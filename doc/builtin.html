<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<![endif]-->
<title>VIM 中文帮助: 内建函数</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css" />
<link rel="canonical" href="https://yianwillis.github.io/vimcdoc/doc/builtin.html" />
<script type="text/javascript" src="vimcdoc.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
<nav id=banner>
<form action=tags.html target="tag_iframe">
  <input type="text" name="tag" id="tag" placeholder="标签搜索">
</form>
<iframe name="tag_iframe" src=""></iframe>
<a href="help.html">帮助总览</a> &middot;
<hr/>
<a href="quickref.html">快速参考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="eval.html#functions">函数列表</a> &middot;
<a href="quickref.html#option-list">选项列表</a> &middot;
<hr/>
<a href="usr_toc.html">用户手册</a> &middot;
<a href="help.html#reference_toc">参考手册</a> &middot;
</nav>

<header>
<h2>builtin</h2>
</header>
<article id=outer>
<section class=inner>
<b class="vimtag"> <a name="builtin.txt">builtin.txt</a> </b>      适用于 Vim 9.1 版本。        最近更新: 2025年10月

内建函数                                        <b class="vimtag"> <a name="builtin-functions">builtin-functions</a> </b>

<code class="note">注意</code>: 表达式求值可以在编译时关闭。此时内建函数不复存在。见  <a href="various.html#+eval">+eval</a>  和
 <a href="eval.html#no-eval-feature">no-eval-feature</a> 。

1. 概览                                  <a href="builtin.html#builtin-function-list">builtin-function-list</a> 
2. 详细                                  <a href="builtin.html#builtin-function-details">builtin-function-details</a> 
3. 特性列表                              <a href="builtin.html#feature-list">feature-list</a> 
4. 字符串里的模式匹配                    <a href="builtin.html#string-match">string-match</a> 

</section><hr class="doubleline" /><section class=inner>
<h4>1. 概览                                         <b class="vimtag"> <a name="builtin-function-list">builtin-function-list</a> </b></h4>
在函数名上使用 <code class="keystroke">CTRL-]</code> 跳转到完整的功能说明。

<code class="section">用法                            结果    描述    </code>

abs(<code class="special">{expr}</code>)                     浮点或数值  <code class="special">{expr}</code> 的绝对值
acos(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的反余弦值
add(<code class="special">{object}</code>, <code class="special">{item}</code>)           列表或 blob   在 <code class="special">{object}</code> 最后附加 <code class="special">{item}</code>
and(<code class="special">{expr}</code>, <code class="special">{expr}</code>)             数值    按位与
append(<code class="special">{lnum}</code>, <code class="special">{text}</code>)          数值    在第 <code class="special">{lnum}</code> 行下附加 <code class="special">{text}</code>
appendbufline(<code class="special">{buf}</code>, <code class="special">{lnum}</code>, <code class="special">{text}</code>)
                                数值    在缓冲区 <code class="special">{buf}</code> 第 <code class="special">{lnum}</code> 行下附加
                                        <code class="special">{text}</code>
argc([<code class="special">{winid}</code>])                 数值    参数列表的文件数目
argidx()                        数值    参数列表的当前索引
arglistid([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]]) 数值   参数列表的 id
argv(<code class="special">{nr}</code> [, <code class="special">{winid}</code>])          字符串  参数列表第 <code class="special">{nr}</code> 个参数
asin(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的反正弦值
argv([-1, <code class="special">{winid}</code>])             列表    参数列表
assert_beeps(<code class="special">{cmd}</code>)             数值    断言 <code class="special">{cmd}</code> 产生铃声
assert_equal(<code class="special">{exp}</code>, <code class="special">{act}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{exp}</code> 等于 <code class="special">{act}</code>
assert_equalfile(<code class="special">{fname-one}</code>, <code class="special">{fname-two}</code> [, <code class="special">{msg}</code>])
                                数值    断言文件内容相同
assert_exception(<code class="special">{error}</code> [, <code class="special">{msg}</code>])
                                数值    断言 v:exception 中有 <code class="special">{error}</code>
assert_fails(<code class="special">{cmd}</code> [, <code class="special">{error}</code> [, <code class="special">{msg}</code> [, <code class="special">{lnum}</code> [, <code class="special">{context}</code>]]]])
                                数值    断言 <code class="special">{cmd}</code> 失败
assert_false(<code class="special">{actual}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{actual}</code> 为假
assert_inrange(<code class="special">{lower}</code>, <code class="special">{upper}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{actual}</code> 在指定范围内
assert_match(<code class="special">{pat}</code>, <code class="special">{text}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{pat}</code> 匹配 <code class="special">{text}</code>
assert_nobeep(<code class="special">{cmd}</code>)            数值    断言 <code class="special">{cmd}</code> 不导致响铃
assert_notequal(<code class="special">{exp}</code>, <code class="special">{act}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{exp}</code> 不等于 <code class="special">{act}</code>
assert_notmatch(<code class="special">{pat}</code>, <code class="special">{text}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{pat}</code> 不匹配 <code class="special">{text}</code>
assert_report(<code class="special">{msg}</code>)            数值    报告一个测试失败
assert_true(<code class="special">{actual}</code> [, <code class="special">{msg}</code>]) 数值    断言 <code class="special">{actual}</code> 为真
atan(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的反正切值
atan2(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)         浮点    <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的反正切值
autocmd_add(<code class="special">{acmds}</code>)            布尔型  新增一组自动命令及组
autocmd_delete(<code class="special">{acmds}</code>)         布尔型  删除一组自动命令及组
autocmd_get([<code class="special">{opts}</code>])           列表    返回自动命令的列表
balloon_gettext()               字符串  气泡的当前文本
balloon_show(<code class="special">{expr}</code>)            无      在气泡内显示<code class="special">{expr}</code>
balloon_split(<code class="special">{msg}</code>)            列表    分割用于的 <code class="special">{msg}</code>
base64_decode(<code class="special">{string}</code>)         blob    base64 解码 <code class="special">{string}</code> 里的字符
base64_encode(<code class="special">{blob}</code>)           字符串  base64 编码 <code class="special">{blob}</code> 里的字节
bindtextdomain(<code class="special">{package}</code>, <code class="special">{path}</code>)
                                布尔型  绑定文本域到特定路径
blob2list(<code class="special">{blob}</code>)               列表    把 <code class="special">{blob}</code> 转换为数值列表
blob2str(<code class="special">{blob}</code> [, <code class="special">{options}</code>])  列表    把 <code class="special">{blob}</code> 转换为字符串列表
browse(<code class="special">{save}</code>, <code class="special">{title}</code>, <code class="special">{initdir}</code>, <code class="special">{default}</code>)
                                字符串  启动文件请求窗口
browsedir(<code class="special">{title}</code>, <code class="special">{initdir}</code>)   字符串  启动目录请求窗口
bufadd(<code class="special">{name}</code>)                  数值    在缓冲区列表里加入缓冲区
bufexists(<code class="special">{buf}</code>)                数值    如果缓冲区 <code class="special">{buf}</code> 存在则为  <a href="eval.html#TRUE">TRUE</a> 
buflisted(<code class="special">{buf}</code>)                数值    如果缓冲区 <code class="special">{buf}</code> 在列表内则为  <a href="eval.html#TRUE">TRUE</a> 
bufload(<code class="special">{buf}</code>)                  数值    如果还未载入，载入缓冲区 <code class="special">{buf}</code>
bufloaded(<code class="special">{buf}</code>)                数值    如果缓冲区 <code class="special">{buf}</code> 被载入则为  <a href="eval.html#TRUE">TRUE</a> 
bufname([<code class="special">{buf}</code>])                字符串  缓冲区 <code class="special">{buf}</code> 的名字
bufnr([<code class="special">{buf}</code> [, <code class="special">{create}</code>]])     数值    缓冲区 <code class="special">{buf}</code> 的编号
bufwinid(<code class="special">{buf}</code>)                 数值    缓冲区 <code class="special">{buf}</code> 的窗口 ID
bufwinnr(<code class="special">{buf}</code>)                 数值    缓冲区 <code class="special">{buf}</code> 的窗口号
byte2line(<code class="special">{byte}</code>)               数值    第 <code class="special">{byte}</code> 个字节所在的行号
byteidx(<code class="special">{expr}</code>, <code class="special">{nr}</code> [, <code class="special">{utf16}</code>])
                                数值    <code class="special">{expr}</code> 里第 <code class="special">{nr}</code> 个字符的字节位置
byteidxcomp(<code class="special">{expr}</code>, <code class="special">{nr}</code> [, <code class="special">{utf16}</code>])
                                数值    <code class="special">{expr}</code> 里第 <code class="special">{nr}</code> 个字符的字节位置
call(<code class="special">{func}</code>, <code class="special">{arglist}</code> [, <code class="special">{dict}</code>])
                                可变    调用函数 <code class="special">{func}</code>，使用参数 <code class="special">{arglist}</code>
ceil(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 向上取整
ch_canread(<code class="special">{handle}</code>)            数值    检查是否有可读的内容
ch_close(<code class="special">{handle}</code>)              无      关闭 <code class="special">{handle}</code>
ch_close_in(<code class="special">{handle}</code>)           无      关闭 <code class="special">{handle}</code> 的 in 部分
ch_evalexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])
                                可变    在 JSON <code class="special">{handle}</code> 上执行 <code class="special">{expr}</code>
ch_evalraw(<code class="special">{handle}</code>, <code class="special">{string}</code> [, <code class="special">{options}</code>])
                                可变    在原始 <code class="special">{handle}</code> 上执行 <code class="special">{string}</code>
ch_getbufnr(<code class="special">{handle}</code>, <code class="special">{what}</code>)   数值    获得 <code class="special">{handle}</code>/<code class="special">{what}</code> 的缓冲区号
ch_getjob(<code class="special">{channel}</code>)            作业    获得 <code class="special">{channel}</code> 的相关作业
ch_info(<code class="special">{handle}</code>)               字符串  有关通道 <code class="special">{handle}</code> 的信息
ch_log(<code class="special">{msg}</code> [, <code class="special">{handle}</code>])      无      在通道日志文件中写入 <code class="special">{msg}</code>
ch_logfile(<code class="special">{fname}</code> [, <code class="special">{mode}</code>])  无      开始记录通道活动
ch_open(<code class="special">{address}</code> [, <code class="special">{options}</code>])
                                通道    打开到 <code class="special">{address}</code> 的通道
ch_read(<code class="special">{handle}</code> [, <code class="special">{options}</code>]) 字符串  从 <code class="special">{handle}</code> 读取
ch_readblob(<code class="special">{handle}</code> [, <code class="special">{options}</code>])
                                blob    从 <code class="special">{handle}</code> 读取 blob
ch_readraw(<code class="special">{handle}</code> [, <code class="special">{options}</code>])
                                字符串  从 <code class="special">{handle}</code> 读取原始格式
ch_sendexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])
                                可变    在 JSON <code class="special">{handle}</code> 上发送 <code class="special">{expr}</code>
ch_sendraw(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])
                                可变    在原始 <code class="special">{handle}</code> 上发送 <code class="special">{expr}</code>
ch_setoptions(<code class="special">{handle}</code>, <code class="special">{options}</code>)
                                无      设置 <code class="special">{handle}</code> 的选项
ch_status(<code class="special">{handle}</code> [, <code class="special">{options}</code>])
                                字符串  通道 <code class="special">{handle}</code> 的状态
changenr()                      数值    当前改变号
char2nr(<code class="special">{expr}</code> [, <code class="special">{utf8}</code>])      数值    <code class="special">{expr}</code> 里第一个字符串的 ASCII/UTF-8 值
charclass(<code class="special">{string}</code>)             数值    <code class="special">{string}</code> 的字符类
charcol(<code class="special">{expr}</code> [, <code class="special">{winid}</code>])     数值    光标或位置标记的列号
charidx(<code class="special">{string}</code>, <code class="special">{idx}</code> [, <code class="special">{countcc}</code> [, <code class="special">{utf16}</code>]])
                                数值    <code class="special">{string}</code> 中字节 <code class="special">{idx}</code> 对应的字符索引
chdir(<code class="special">{dir}</code>)                    数值    改变当前目录
cindent(<code class="special">{lnum}</code>)                 数值    第 <code class="special">{lnum}</code> 行的 C 缩进
clearmatches([<code class="special">{win}</code>])           无      清除所有的匹配
cmdcomplete_info()              字典    获得当前命令行补全信息
col(<code class="special">{expr}</code> [, <code class="special">{winid}</code>])         数值    光标或位置标记的列字节索引
complete(<code class="special">{startcol}</code>, <code class="special">{matches}</code>) 无      设置插入模式补全
complete_add(<code class="special">{expr}</code>)            数值    增加补全匹配
complete_check()                数值    补全时检查输入的键
complete_info([<code class="special">{what}</code>])         字典    获得当前补全信息
complete_match([<code class="special">{lnum}</code>, <code class="special">{col}</code>]) 列表    获得补全列和触发文本
confirm(<code class="special">{msg}</code> [, <code class="special">{choices}</code> [, <code class="special">{default}</code> [, <code class="special">{type}</code>]]])
                                数值    用户选择的序号
copy(<code class="special">{expr}</code>)                    可变    提供 <code class="special">{expr}</code> 的浅备份
cos(<code class="special">{expr}</code>)                     浮点    <code class="special">{expr}</code> 的余弦值
cosh(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的双曲余弦值
count(<code class="special">{comp}</code>, <code class="special">{expr}</code> [, <code class="special">{ic}</code> [, <code class="special">{start}</code>]])
                                数值    计算 <code class="special">{comp}</code> 里有多少个 <code class="special">{expr}</code>
cscope_connection([<code class="special">{num}</code> , <code class="special">{dbpath}</code> [, <code class="special">{prepend}</code>]])
                                数值    检查 cscope 连接是否存在
cursor(<code class="special">{lnum}</code>, <code class="special">{col}</code> [, <code class="special">{off}</code>])
                                数值    移动光标到 <code class="special">{lnum}</code>，<code class="special">{col}</code>，<code class="special">{off}</code>
debugbreak(<code class="special">{pid}</code>)               数值    中断待调试的进程
cursor(<code class="special">{list}</code>)                  数值    移动光标到 <code class="special">{list}</code> 里的位置
deepcopy(<code class="special">{expr}</code> [, <code class="special">{noref}</code>])    可变    提供 <code class="special">{expr}</code> 的完整备份
delete(<code class="special">{fname}</code> [, <code class="special">{flags}</code>])     数值    删除文件或目录 <code class="special">{fname}</code>
deletebufline(<code class="special">{buf}</code>, <code class="special">{first}</code> [, <code class="special">{last}</code>])
                                数值    删除缓冲区 <code class="special">{buf}</code> 的多行
did_filetype()                  数值    用过 FileType 自动命令事件则为  <a href="eval.html#TRUE">TRUE</a> 
diff(<code class="special">{fromlist}</code>, <code class="special">{tolist}</code> [, <code class="special">{options}</code>])
                                列表    比较两个字符串列表
diff_filler(<code class="special">{lnum}</code>)             数值    <code class="special">{lnum}</code> 行之上的 diff 填充行数
diff_hlID(<code class="special">{lnum}</code>, <code class="special">{col}</code>)        数值    <code class="special">{lnum}</code>/<code class="special">{col}</code> 位置的 diff 高亮
digraph_get(<code class="special">{chars}</code>)            字符串  得到 <code class="special">{chars}</code> 的  <a href="digraph.html#digraph">digraph</a> 
digraph_getlist([<code class="special">{listall}</code>])    列表    得到所有的  <a href="digraph.html#digraph">digraph</a> 
digraph_set(<code class="special">{chars}</code>, <code class="special">{digraph}</code>) 布尔型  注册  <a href="digraph.html#digraph">digraph</a> 
digraph_setlist(<code class="special">{digraphlist}</code>)  布尔型  注册多个  <a href="digraph.html#digraph">digraph</a> 
echoraw(<code class="special">{expr}</code>)                 无      照原样输出 <code class="special">{expr}</code>
empty(<code class="special">{expr}</code>)                   数值    如果 <code class="special">{expr}</code> 为空则为  <a href="eval.html#TRUE">TRUE</a> 
environ()                       字典    返回所有环境变量
err_teapot([<code class="special">{expr}</code>])            无      <code class="special">{expr}</code> 为  <a href="eval.html#TRUE">TRUE</a>  时给出 E418 或 E503
escape(<code class="special">{string}</code>, <code class="special">{chars}</code>)       字符串  在 <code class="special">{string}</code> 里用 '\' 转义 <code class="special">{chars}</code>
eval(<code class="special">{string}</code>)                  可变    计算 <code class="special">{string}</code>，返回结果
eventhandler()                  数值    如果在事件处理中则为  <a href="eval.html#TRUE">TRUE</a> 
executable(<code class="special">{expr}</code>)              数值    如果可执行文件 <code class="special">{expr}</code> 存在则为 1
execute(<code class="special">{command}</code>)              字符串  执行 <code class="special">{command}</code> 并取得输出结果
exepath(<code class="special">{expr}</code>)                 字符串  命令 <code class="special">{expr}</code> 的完整路径
exists(<code class="special">{expr}</code>)                  数值    如果 <code class="special">{expr}</code> 存在则为  <a href="eval.html#TRUE">TRUE</a> 
exists_compiled(<code class="special">{expr}</code>)         数值    如果 <code class="special">{expr}</code> 编译时存在则为  <a href="eval.html#TRUE">TRUE</a> 
exp(<code class="special">{expr}</code>)                     浮点    <code class="special">{expr}</code> 的指数函数值
                                        (<code class="vim">译者注</code>: 以 e 为底)
expand(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code>]])
                                可变    扩展 <code class="special">{expr}</code> 里的特殊关键字
expandcmd(<code class="special">{string}</code> [, <code class="special">{options}</code>])
                                字符串  像  <a href="editing.html#:edit">:edit</a>  那样扩展 <code class="special">{string}</code>
extend(<code class="special">{expr1}</code>, <code class="special">{expr2}</code> [, <code class="special">{expr3}</code>])
                                列表/字典 把 <code class="special">{expr2}</code> 里的项目插入 <code class="special">{expr1}</code>
extendnew(<code class="special">{expr1}</code>, <code class="special">{expr2}</code> [, <code class="special">{expr3}</code>])
                                列表/字典 和  <a href="builtin.html#extend()">extend()</a>  类似，但建立新列表或字
                                        典
feedkeys(<code class="special">{string}</code> [, <code class="special">{mode}</code>])   数值    给预输入缓冲区加入键序列
filecopy(<code class="special">{from}</code>, <code class="special">{to}</code>)          数值    如果复制 <code class="special">{from}</code> 文件到 <code class="special">{to}</code> 成功则为
                                         <a href="eval.html#TRUE">TRUE</a> 
filereadable(<code class="special">{file}</code>)            数值    如果 <code class="special">{file}</code> 是个可读文件则为  <a href="eval.html#TRUE">TRUE</a> 
filewritable(<code class="special">{file}</code>)            数值    如果 <code class="special">{file}</code> 是个可写文件则为  <a href="eval.html#TRUE">TRUE</a> 
filter(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)        列表/字典/blob/字符串
                                        删除 <code class="special">{expr1}</code> 里 <code class="special">{expr2}</code> 为 0 的项目
finddir(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{count}</code>]])
                                字符串  在 <code class="special">{path}</code> 里寻找目录 <code class="special">{name}</code>
findfile(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{count}</code>]])
                                字符串/列表 在 <code class="special">{path}</code> 里寻找文件 <code class="special">{name}</code>
flatten(<code class="special">{list}</code> [, <code class="special">{maxdepth}</code>])  列表    展平 <code class="special">{list}</code>，最多到 <code class="special">{maxdepth}</code> 层
flattennew(<code class="special">{list}</code> [, <code class="special">{maxdepth}</code>])
                                列表    展平 <code class="special">{list}</code> 的一个备份
float2nr(<code class="special">{expr}</code>)                数值    转换浮点数 <code class="special">{expr}</code> 为数值
floor(<code class="special">{expr}</code>)                   浮点    <code class="special">{expr}</code> 向下取整
fmod(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)          浮点    <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的浮点余数
fnameescape(<code class="special">{fname}</code>)            字符串  转义 <code class="special">{fname}</code> 中的特殊字符
fnamemodify(<code class="special">{fname}</code>, <code class="special">{mods}</code>)    字符串  修改文件名
foldclosed(<code class="special">{lnum}</code>)              数值    <code class="special">{lnum}</code> 所在折叠的首行，如果是关闭的话
foldclosedend(<code class="special">{lnum}</code>)           数值    <code class="special">{lnum}</code> 所在折叠的末行，如果是关闭的话
foldlevel(<code class="special">{lnum}</code>)               数值    <code class="special">{lnum}</code> 的折叠级别
foldtext()                      字符串  关闭的折叠显示的行
foldtextresult(<code class="special">{lnum}</code>)          字符串  <code class="special">{lnum}</code> 所在的关闭的折叠的文本
foreach(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)       列表/元组/字典/blob/字符串
                                        对 <code class="special">{expr1}</code> 里的每个项目，调用 <code class="special">{expr2}</code>
foreground()                    数值    把 Vim 窗口带到前台
fullcommand(<code class="special">{name}</code> [, <code class="special">{vim9}</code>])  字符串  得到 <code class="special">{name}</code> 的完整命令
funcref(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
                                函数引用  函数 <code class="special">{name}</code> 的引用
function(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
                                函数引用  函数 <code class="special">{name}</code> 的命名引用
garbagecollect([<code class="special">{atexit}</code>])      无      释放内存，打破循环引用
get(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{def}</code>])    可变    得到 <code class="special">{list}</code> 或 <code class="special">{def}</code> 的项目 <code class="special">{idx}</code>
get(<code class="special">{dict}</code>, <code class="special">{key}</code> [, <code class="special">{def}</code>])    可变    得到 <code class="special">{dict}</code> 或 <code class="special">{def}</code> 的项目 <code class="special">{idx}</code>
get(<code class="special">{func}</code>, <code class="special">{what}</code>)             可变    得到函数引用/偏函数 <code class="special">{func}</code> 的属性
getbufinfo([<code class="special">{buf}</code>])             列表    缓冲区信息
getbufline(<code class="special">{buf}</code>, <code class="special">{lnum}</code> [, <code class="special">{end}</code>])
                                列表    缓冲区 <code class="special">{buf}</code> 第 <code class="special">{lnum}</code> 到 <code class="special">{end}</code> 行
getbufoneline(<code class="special">{buf}</code>, <code class="special">{lnum}</code>)    字符串  缓冲区 <code class="special">{buf}</code> 的第 <code class="special">{lnum}</code> 行
getbufvar(<code class="special">{buf}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
                                可变    缓冲区 <code class="special">{buf}</code> 的变量 <code class="special">{varname}</code>
getcellpixels()                 列表    得到字符单元的像素尺寸
getcellwidths()                 列表    得到字符单元的宽度覆盖
getchangelist([<code class="special">{buf}</code>])          列表    改变列表项目的列表
getchar([<code class="special">{expr}</code> [, <code class="special">{opts}</code>]])    数值或字符串
                                        让用户输入一个字符
getcharmod()                    数值    最近输入字符的修饰符
getcharpos(<code class="special">{expr}</code>)              列表    光标、位置标记等的位置
getcharsearch()                 字典    最近字符搜索选项
getcharstr([<code class="special">{expr}</code> [, <code class="special">{opts}</code>]]) 字符串  从用户处得到一个字符
getcmdcomplpat()                字符串  返回当前命令行补全的补全模式
getcmdcompltype()               字符串  返回当前命令行补全的类型
getcmdline()                    字符串  返回当前命令行输入
getcmdpos()                     数值    返回命令行的光标位置
getcmdprompt()                  字符串  返回当前命令行提示
getcmdscreenpos()               数值    返回命令行的光标屏幕位置
getcmdtype()                    字符串  返回当前命令行类型
getcmdwintype()                 字符串  返回当前命令行窗口类型
getcompletion(<code class="special">{pat}</code>, <code class="special">{type}</code> [, <code class="special">{filtered}</code>])
                                列表    命令行补全匹配列表
getcompletiontype(<code class="special">{pat}</code>)        字符串  返回用 <code class="special">{pat}</code> 时命令行补全的类型
getcurpos([<code class="special">{winnr}</code>])            列表    光标位置
getcursorcharpos([<code class="special">{winnr}</code>])     列表    光标的字符位置
getcwd([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])   字符串  当前工作目录
getenv(<code class="special">{name}</code>)                  字符串  返回环境变量
getfontname([<code class="special">{name}</code>])           字符串  使用的字体名
getfperm(<code class="special">{fname}</code>)               字符串  文件 <code class="special">{fname}</code> 的文件权限
getfsize(<code class="special">{fname}</code>)               数值    字节计算的文件 <code class="special">{fname}</code> 大小
getftime(<code class="special">{fname}</code>)               数值    文件的最新修改时间
getftype(<code class="special">{fname}</code>)               字符串  文件 <code class="special">{fname}</code> 类型的描述
getimstatus()                   数值    如果 IME 处于激活状态则为  <a href="eval.html#TRUE">TRUE</a> 
getjumplist([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
                                列表    跳转列表项目的列表
getline(<code class="special">{lnum}</code>)                 字符串  当前缓冲区的第 <code class="special">{lnum}</code> 行
getline(<code class="special">{lnum}</code>, <code class="special">{end}</code>)          列表    当前缓冲区第 <code class="special">{lnum}</code> 到 <code class="special">{end}</code> 行
getloclist(<code class="special">{nr}</code>)                列表    位置列表项目的列表
getloclist(<code class="special">{nr}</code>, <code class="special">{what}</code>)        字典    获取指定的位置列表项目
getmarklist([<code class="special">{buf}</code>])            列表    全局/局部位置标记的列表
getmatches([<code class="special">{win}</code>])             列表    当前匹配的列表
getmousepos()                   字典    最近已知的鼠标位置
getmouseshape()                 字符串  当前鼠标外型名
getpid()                        数值    Vim 的进程号
getpos(<code class="special">{expr}</code>)                  列表    光标、位置标记等的位置
getqflist()                     列表    快速修复项目的列表
getqflist([<code class="special">{what}</code>])             字典    获取指定快速修复列表的项目
getreg([<code class="special">{regname}</code> [, 1 [, <code class="special">{list}</code>]]])
                                字符串/列表     某寄存器内容
getreginfo([<code class="special">{regname}</code>])         字典    关于某寄存器的信息
getregion(<code class="special">{pos1}</code>, <code class="special">{pos2}</code> [, <code class="special">{opts}</code>])
                                列表    获取从 <code class="special">{pos1}</code> 到 <code class="special">{pos2}</code> 的文本
getregionpos(<code class="special">{pos1}</code>, <code class="special">{pos2}</code> [, <code class="special">{opts}</code>])
                                列表    获取指定区域的位置列表
getregtype([<code class="special">{regname}</code>])         字符串  某寄存器的类型
getscriptinfo([<code class="special">{opts}</code>])         列表    已执行脚本的列表
getstacktrace()                 列表    获取 Vim 脚本的当前栈追踪
gettabinfo([<code class="special">{expr}</code>])            列表    标签页列表
gettabvar(<code class="special">{nr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
                                可变    <code class="special">{tabnr}</code> 标签页的 <code class="special">{varname}</code> 变量
gettabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{name}</code> [, <code class="special">{def}</code>])
                                可变    <code class="special">{tabnr}</code> 标签页 <code class="special">{winnr}</code> 窗口的 <code class="special">{name}</code>
gettagstack([<code class="special">{nr}</code>])             字典    获取窗口 <code class="special">{nr}</code> 的标签栈
gettext(<code class="special">{text}</code> [, <code class="special">{package}</code>])   字符串  查找 <code class="special">{text}</code> 的翻译
getwininfo([<code class="special">{winid}</code>])           列表    每个窗口信息的列表
getwinpos([<code class="special">{timeout}</code>])          列表    Vim 窗口以像素计的 X 和 Y 坐标
getwinposx()                    数值    Vim 窗口以像素计的 X 坐标
getwinposy()                    数值    Vim 窗口以像素计的 Y 坐标
getwinvar(<code class="special">{nr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
                                可变    窗口 <code class="special">{expr}</code> 的变量 <code class="special">{varname}</code>
glob(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
                                可变    扩展 <code class="special">{expr}</code> 里的文件通配符
glob2regpat(<code class="special">{expr}</code>)             字符串  转化 glob 模式为搜索模式
globpath(<code class="special">{path}</code>, <code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
                                字符串  在 <code class="special">{path}</code> 所有目录下执行 glob(<code class="special">{expr}</code>)
has(<code class="special">{feature}</code> [, <code class="special">{check}</code>])      数值    如果支持特性 <code class="special">{feature}</code> 则为  <a href="eval.html#TRUE">TRUE</a> 
has_key(<code class="special">{dict}</code>, <code class="special">{key}</code>)          数值    如果 <code class="special">{dict}</code> 有项目 <code class="special">{key}</code> 则为  <a href="eval.html#TRUE">TRUE</a> 
haslocaldir([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
                                数值    如果当前窗口执行过  <a href="editing.html#:lcd">:lcd</a>  则为  <a href="eval.html#TRUE">TRUE</a> 
hasmapto(<code class="special">{what}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])
                                数值    如果 <code class="special">{what}</code> 的映射存在则为  <a href="eval.html#TRUE">TRUE</a> 
histadd(<code class="special">{history}</code>,<code class="special">{item}</code>)       数值    在历史里增加项目
histdel(<code class="special">{history}</code> [, <code class="special">{item}</code>])   数值    从历史里删除项目
histget(<code class="special">{history}</code> [, <code class="special">{index}</code>])  字符串  得到历史的第 <code class="special">{index}</code> 项
histnr(<code class="special">{history}</code>)               数值    历史里最高的项目号
hlID(<code class="special">{name}</code>)                    数值    高亮组 <code class="special">{name}</code> 的语法 ID
hlexists(<code class="special">{name}</code>)                数值    如果高亮组 <code class="special">{name}</code> 存在则为  <a href="eval.html#TRUE">TRUE</a> 
hlget([<code class="special">{name}</code> [, <code class="special">{resolve}</code>]])   列表    得到高亮组属性
hlset(<code class="special">{list}</code>)                   数值    设置高亮组属性
hostname()                      字符串  Vim 运行的机器名字
iconv(<code class="special">{expr}</code>, <code class="special">{from}</code>, <code class="special">{to}</code>)     字符串  转换 <code class="special">{expr}</code> 的编码
id(<code class="special">{item}</code>)                      字符串  获取项目的唯一标识字符串
indent(<code class="special">{lnum}</code>)                  数值    第 <code class="special">{lnum}</code> 行的缩进
index(<code class="special">{object}</code>, <code class="special">{expr}</code> [, <code class="special">{start}</code> [, <code class="special">{ic}</code>]])
                                数值    <code class="special">{object}</code> 里出现 <code class="special">{expr}</code> 的项目的索引
indexof(<code class="special">{object}</code>, <code class="special">{expr}</code> [, <code class="special">{opts}</code>]])
                                数值    <code class="special">{object}</code> 里 <code class="special">{expr}</code> 为真的项目的索引
input(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{completion}</code>]])
                                字符串  从用户得到输入
inputdialog(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{cancelreturn}</code>]])
                                字符串  类似于 input()，但使用 GUI 对话框
inputlist(<code class="special">{textlist}</code>)           数值    让用户从选择列表里挑选
inputrestore()                  数值    恢复预输入
inputsave()                     数值    保存和清除预输入
inputsecret(<code class="special">{prompt}</code> [, <code class="special">{text}</code>]) 字符串  类似于 input()，但隐藏文本
insert(<code class="special">{object}</code>, <code class="special">{item}</code> [, <code class="special">{idx}</code>]) 列表 在 <code class="special">{object}</code> 里插入 <code class="special">{item}</code> [<code class="special">{idx}</code> 之前]
instanceof(<code class="special">{object}</code>, <code class="special">{class}</code>)   数值    如果 <code class="special">{object}</code> 是 <code class="special">{class}</code> 的实例则为
                                         <a href="eval.html#TRUE">TRUE</a> 
interrupt()                     无      中断脚本执行
invert(<code class="special">{expr}</code>)                  数值    按位取反
isabsolutepath(<code class="special">{path}</code>)          数值    如果 <code class="special">{directory}</code> 是绝对路径则为  <a href="eval.html#TRUE">TRUE</a> 
isdirectory(<code class="special">{directory}</code>)        数值    如果 <code class="special">{directory}</code> 是目录则为  <a href="eval.html#TRUE">TRUE</a> 
islocked(<code class="special">{expr}</code>)                数值    如果 <code class="special">{expr}</code> 被锁住则为  <a href="eval.html#TRUE">TRUE</a> 
isinf(<code class="special">{expr}</code>)                   数值    决定 <code class="special">{expr}</code> 是否为无限大 (正或负)
isnan(<code class="special">{expr}</code>)                   数值    如果 <code class="special">{expr}</code> 为 NaN 则为  <a href="eval.html#TRUE">TRUE</a> 
items(<code class="special">{expr}</code>)                   列表    <code class="special">{expr}</code> 里的键/索引-值组对
job_getchannel(<code class="special">{job}</code>)           通道    获取 <code class="special">{job}</code> 的通道句柄
job_info([<code class="special">{job}</code>])               字典    获取 <code class="special">{job}</code> 的信息
job_setoptions(<code class="special">{job}</code>, <code class="special">{options}</code>) 无     设置 <code class="special">{job}</code> 选项
job_start(<code class="special">{command}</code> [, <code class="special">{options}</code>])
                                作业    启动作业
job_status(<code class="special">{job}</code>)               字符串  获取 <code class="special">{job}</code> 的状态
job_stop(<code class="special">{job}</code> [, <code class="special">{how}</code>])       数值    停止 <code class="special">{job}</code>
join(<code class="special">{expr}</code> [, <code class="special">{sep}</code>])          字符串  连接 <code class="special">{expr}</code> 的项目成为一个字符串
js_decode(<code class="special">{string}</code>)             可变    解码 JS 风格的 JSON
js_encode(<code class="special">{expr}</code>)               字符串  编码 JS 风格的 JSON
json_decode(<code class="special">{string}</code>)           可变    解码 JSON
json_encode(<code class="special">{expr}</code>)             字符串  编码 JSON
keys(<code class="special">{dict}</code>)                    列表    <code class="special">{dict}</code> 的所有键
keytrans(<code class="special">{string}</code>)              字符串  把内部键值翻译为  <a href="map.html#:map">:map</a>  可接受的形式
len(<code class="special">{expr}</code>)                     数值    <code class="special">{expr}</code> 的长度
libcall(<code class="special">{lib}</code>, <code class="special">{func}</code>, <code class="special">{arg}</code>)   字符串  调用库 <code class="special">{lib}</code> 的函数 <code class="special">{func}</code>，使用参数
                                        <code class="special">{arg}</code>
libcallnr(<code class="special">{lib}</code>, <code class="special">{func}</code>, <code class="special">{arg}</code>) 数值    同上，但返回数值
line(<code class="special">{expr}</code> [, <code class="special">{winid}</code>])        数值    光标所在、末行或者位置标记所在的行号
line2byte(<code class="special">{lnum}</code>)               数值    行 <code class="special">{lnum}</code> 的字节位置
lispindent(<code class="special">{lnum}</code>)              数值    行 <code class="special">{lnum}</code> 的 Lisp 缩进
list2blob(<code class="special">{list}</code>)               blob    把数值的 <code class="special">{list}</code> 转成 blob
list2str(<code class="special">{list}</code> [, <code class="special">{utf8}</code>])     字符串  把数值的 <code class="special">{list}</code> 转成字符串
list2tuple(<code class="special">{list}</code>)              元组    把 <code class="special">{list}</code> 里的项目转为元组
listener_add(<code class="special">{callback}</code> [, <code class="special">{buf}</code> [, <code class="special">{unbuffered}</code>]])
                                数值    增加监听改动的回调
listener_flush([<code class="special">{buf}</code>])         无      激活监听器回调
listener_remove(<code class="special">{id}</code>)           无      删除监听器回调
localtime()                     数值    当前时间
log(<code class="special">{expr}</code>)                     浮点    <code class="special">{expr}</code> 的自然对数 (以 e 为底)
log10(<code class="special">{expr}</code>)                   浮点    <code class="special">{expr}</code> 以 10 为底的对数
luaeval(<code class="special">{expr}</code> [, <code class="special">{expr}</code>])      可变    执行  <a href="if_lua.html#Lua">Lua</a>  表达式
map(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)           列表/字典/blob/字符串
                                        <code class="special">{expr1}</code> 的每个项目改变为 <code class="special">{expr2}</code>
maparg(<code class="special">{name}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code> [, <code class="special">{dict}</code>]]])
                                字符串/字典
                                        模式 <code class="special">{mode}</code> 的映射 <code class="special">{name}</code> 的右手边
mapcheck(<code class="special">{name}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])
                                字符串  检查匹配 <code class="special">{name}</code> 的映射
maplist([<code class="special">{abbr}</code>])               列表    所有映射的列表，每个映射对应一个字典
mapnew(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)        列表/字典/blob/字符串
                                        类似于  <a href="builtin.html#map()">map()</a>  但创建新列表或字典
mapset(<code class="special">{mode}</code>, <code class="special">{abbr}</code>, <code class="special">{dict}</code>)  无      从  <a href="builtin.html#maparg()">maparg()</a>  返回值恢复映射
match(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])
                                数值    <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 的匹配位置
matchadd(<code class="special">{group}</code>, <code class="special">{pattern}</code> [, <code class="special">{priority}</code> [, <code class="special">{id}</code> [, <code class="special">{dict}</code>]]])
                                数值    用 <code class="special">{group}</code> 高亮 <code class="special">{pattern}</code>
matchaddpos(<code class="special">{group}</code>, <code class="special">{pos}</code> [, <code class="special">{priority}</code> [, <code class="special">{id}</code> [, <code class="special">{dict}</code>]]])
                                数值    <code class="special">{group}</code> 的高亮位置
matcharg(<code class="special">{nr}</code>)                  列表     <a href="pattern.html#:match">:match</a>  的参数
matchbufline(<code class="special">{buf}</code>, <code class="special">{pat}</code>, <code class="special">{lnum}</code>, <code class="special">{end}</code>, [, <code class="special">{dict}</code>)
                                列表    缓冲区 <code class="special">{buf}</code> 里的所有 <code class="special">{pat}</code> 匹配
matchdelete(<code class="special">{id}</code> [, <code class="special">{win}</code>])     数值    删除 <code class="special">{id}</code> 指定的匹配
matchend(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])
                                数值    <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 的结束位置
matchfuzzy(<code class="special">{list}</code>, <code class="special">{str}</code> [, <code class="special">{dict}</code>])
                                列表    在 <code class="special">{list}</code> 中模糊匹配 <code class="special">{str}</code>
matchfuzzypos(<code class="special">{list}</code>, <code class="special">{str}</code> [, <code class="special">{dict}</code>])
                                列表    在 <code class="special">{list}</code> 中模糊匹配 <code class="special">{str}</code>
matchlist(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])
                                列表    <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 的匹配和子匹配
matchstr(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])
                                字符串  <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 的第 <code class="special">{count}</code> 个匹配文
                                        本
matchstrlist(<code class="special">{list}</code>, <code class="special">{pat}</code> [, <code class="special">{dict}</code>)
                                列表    <code class="special">{list}</code> 里所有的 <code class="special">{pat}</code> 匹配
matchstrpos(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])
                                列表    <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 的第 <code class="special">{count}</code> 个匹配
max(<code class="special">{expr}</code>)                     数值    <code class="special">{expr}</code> 的项目的最大值
menu_info(<code class="special">{name}</code> [, <code class="special">{mode}</code>])    字典    获取菜单项目信息
min(<code class="special">{expr}</code>)                     数值    <code class="special">{expr}</code> 的项目的最小值
mkdir(<code class="special">{name}</code> [, <code class="special">{flags}</code> [, <code class="special">{prot}</code>]])
                                数值    建立目录 <code class="special">{name}</code>
mode([<code class="special">{expr}</code>])                  字符串  当前编辑模式
mzeval(<code class="special">{expr}</code>)                  可变    计算  <a href="if_mzsch.html#MzScheme">MzScheme</a>  表达式
nextnonblank(<code class="special">{lnum}</code>)            数值    第一个 &gt;= <code class="special">{lnum}</code> 的非空白行的行号
ngettext(<code class="special">{single}</code>, <code class="special">{plural}</code>, <code class="special">{number}</code>[, <code class="special">{domain}</code>])
                                字符串  根据 <code class="special">{number}</code> 翻译文本
nr2char(<code class="special">{expr}</code> [, <code class="special">{utf8}</code>])      字符串  ASCII/UTF-8 值为 <code class="special">{expr}</code> 的单个字符
or(<code class="special">{expr}</code>, <code class="special">{expr}</code>)              数值    按位或
pathshorten(<code class="special">{expr}</code> [, <code class="special">{len}</code>])   字符串  缩短路径里的目录名
perleval(<code class="special">{expr}</code>)                可变    计算  <a href="if_perl.html#Perl">Perl</a>  表达式
popup_atcursor(<code class="special">{what}</code>, <code class="special">{options}</code>) 数值  在光标附近创建弹出窗口
popup_beval(<code class="special">{what}</code>, <code class="special">{options}</code>)  数值    为 <a href="options.html#'ballooneval'">'ballooneval'</a> 创建弹出窗口
popup_clear()                   无      关闭所有弹出窗口
popup_close(<code class="special">{id}</code> [, <code class="special">{result}</code>])  无      关闭弹出窗口 <code class="special">{id}</code>
popup_create(<code class="special">{what}</code>, <code class="special">{options}</code>) 数值    创建弹出窗口
popup_dialog(<code class="special">{what}</code>, <code class="special">{options}</code>) 数值    创建弹出窗口用作对话框
popup_filter_menu(<code class="special">{id}</code>, <code class="special">{key}</code>)  数值    菜单弹出窗口的过滤
popup_filter_yesno(<code class="special">{id}</code>, <code class="special">{key}</code>) 数值    对话框弹出窗口的过滤
popup_findecho()                数值    获取  <a href="eval.html#:echowin">:echowin</a>  的弹出窗口 ID
popup_findinfo()                数值    获取信息弹出窗口的窗口 ID
popup_findpreview()             数值    获取预览弹出窗口的窗口 ID
popup_getoptions(<code class="special">{id}</code>)          字典    获取弹出窗口 <code class="special">{id}</code> 的选项
popup_getpos(<code class="special">{id}</code>)              字典    获取弹出窗口 <code class="special">{id}</code> 的位置
popup_hide(<code class="special">{id}</code>)                无      隐藏弹出窗口 <code class="special">{id}</code>
popup_list()                    列表    获取所有弹出的窗口 ID 列表
popup_locate(<code class="special">{row}</code>, <code class="special">{col}</code>)      数值    获取在给出位置的弹出窗口 ID
popup_menu(<code class="special">{what}</code>, <code class="special">{options}</code>)   数值    创建弹出窗口用作菜单
popup_move(<code class="special">{id}</code>, <code class="special">{options}</code>)     无      设置弹出窗口 <code class="special">{id}</code> 的位置
popup_notification(<code class="special">{what}</code>, <code class="special">{options}</code>)
                                数值    创建通知弹出窗口
popup_setbuf(<code class="special">{id}</code>, <code class="special">{buf}</code>)       布尔型  设置弹出窗口 <code class="special">{id}</code> 的缓冲区
popup_setoptions(<code class="special">{id}</code>, <code class="special">{options}</code>)
                                无      设置弹出窗口 <code class="special">{id}</code> 的选项
popup_settext(<code class="special">{id}</code>, <code class="special">{text}</code>)     无      设置弹出窗口 <code class="special">{id}</code> 的文本
popup_show(<code class="special">{id}</code>)                数值    撤销弹出窗口 <code class="special">{id}</code> 的隐藏
pow(<code class="special">{x}</code>, <code class="special">{y}</code>)                   浮点    <code class="special">{x}</code> 的 <code class="special">{y}</code> 次方
preinserted()                   数值    文本是否插入在光标后方
prevnonblank(<code class="special">{lnum}</code>)            数值    最后一个 &lt;= <code class="special">{lnum}</code> 的非空白行的行号
printf(<code class="special">{fmt}</code>, <code class="special">{expr1}</code>...)       字符串  排版文本
prompt_getprompt(<code class="special">{buf}</code>)         字符串  获取提示文本
prompt_setcallback(<code class="special">{buf}</code>, <code class="special">{expr}</code>) 无    设置提示回调函数
prompt_setinterrupt(<code class="special">{buf}</code>, <code class="special">{text}</code>) 无   设置提示中断函数
prompt_setprompt(<code class="special">{buf}</code>, <code class="special">{text}</code>) 无      设置提示文本
prop_add(<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{props}</code>)  无    新增一项文本属性
prop_add_list(<code class="special">{props}</code>, [[<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{end-lnum}</code>, <code class="special">{end-col}</code>], ...])
                                无      新增多项文本属性
prop_clear(<code class="special">{lnum}</code> [, <code class="special">{lnum-end}</code> [, <code class="special">{props}</code>]])
                                无      删除所有文本属性
prop_find(<code class="special">{props}</code> [, <code class="special">{direction}</code>])
                                字典    查找文本属性
prop_list(<code class="special">{lnum}</code> [, <code class="special">{props}</code>])   列表    <code class="special">{lnum}</code> 的文本属性
prop_remove(<code class="special">{props}</code> [, <code class="special">{lnum}</code> [, <code class="special">{lnum-end}</code>]])
                                数值    删除一个文本属性
prop_type_add(<code class="special">{name}</code>, <code class="special">{props}</code>)  无      定义新的文本属性类型
prop_type_change(<code class="special">{name}</code>, <code class="special">{props}</code>)
                                无      改变已有的文本属性类型
prop_type_delete(<code class="special">{name}</code> [, <code class="special">{props}</code>])
                                无      删除文本属性类型
prop_type_get(<code class="special">{name}</code> [, <code class="special">{props}</code>])
                                字典    获取文本属性类型的值
prop_type_list([<code class="special">{props}</code>])       列表    获取文本属性类型的列表
pum_getpos()                    字典    如果可见，pum 的位置和大小
pumvisible()                    数值    弹出窗口是否可见
py3eval(<code class="special">{expr}</code> [, <code class="special">{locals}</code>])    可变    计算  <a href="if_pyth.html#python3">python3</a>  表达式
pyeval(<code class="special">{expr}</code> [, <code class="special">{locals}</code>])     可变    计算  <a href="if_pyth.html#Python">Python</a>  表达式
pyxeval(<code class="special">{expr}</code> [, <code class="special">{locals}</code>])    可变    计算  <a href="if_pyth.html#python_x">python_x</a>  表达式
rand([<code class="special">{expr}</code>])                  数值    得到伪随机数
range(<code class="special">{expr}</code> [, <code class="special">{max}</code> [, <code class="special">{stride}</code>]])
                                列表    从 <code class="special">{expr}</code> 到 <code class="special">{max}</code> 的序列
readblob(<code class="special">{fname}</code> [, <code class="special">{offset}</code> [, <code class="special">{size}</code>]])
                                blob    从 <code class="special">{fname}</code> 读取  <a href="eval.html#Blob">Blob</a> 
readdir(<code class="special">{dir}</code> [, <code class="special">{expr}</code> [, <code class="special">{dict}</code>]])
                                列表    <code class="special">{dir}</code> 中 <code class="special">{expr}</code> 所选择的文件名
readdirex(<code class="special">{dir}</code> [, <code class="special">{expr}</code> [, <code class="special">{dict}</code>]])
                                列表    <code class="special">{dir}</code> 中 <code class="special">{expr}</code> 所选择的文件信息
readfile(<code class="special">{fname}</code> [, <code class="special">{type}</code> [, <code class="special">{max}</code>]])
                                列表    得到文件 <code class="special">{fname}</code> 的行列表
reduce(<code class="special">{object}</code>, <code class="special">{func}</code> [, <code class="special">{initial}</code>])
                                可变    用 <code class="special">{func}</code> 缩减 <code class="special">{object}</code>
reg_executing()                 字符串  得到执行中的寄存器名
reg_recording()                 字符串  得到记录中寄存器名
reltime([<code class="special">{start}</code> [, <code class="special">{end}</code>]])    列表    得到时间值
reltimefloat(<code class="special">{time}</code>)            浮点数  把时间值转化为浮点数
reltimestr(<code class="special">{time}</code>)              字符串  把时间值转化为字符串
remote_expr(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code> [, <code class="special">{timeout}</code>]])
                                字符串  发送表达式
remote_foreground(<code class="special">{server}</code>)     数值    把 Vim 服务器带到前台
remote_peek(<code class="special">{serverid}</code> [, <code class="special">{retvar}</code>])
                                数值    检查应答字符串
remote_read(<code class="special">{serverid}</code> [, <code class="special">{timeout}</code>])
                                字符串  读入应答字符串
remote_send(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code>])
                                字符串  发送键序列
remote_startserver(<code class="special">{name}</code>)      无      成为服务器 <code class="special">{name}</code>
remove(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{end}</code>]) 可变/列表
                                        从 <code class="special">{list}</code> 里删除项目 <code class="special">{idx}</code>-<code class="special">{end}</code>
remove(<code class="special">{blob}</code>, <code class="special">{idx}</code> [, <code class="special">{end}</code>]) 可变/blob
                                        从 <code class="special">{blob}</code> 里删除字节 <code class="special">{idx}</code>-<code class="special">{end}</code>
remove(<code class="special">{dict}</code>, <code class="special">{key}</code>)           可变    从 <code class="special">{dict}</code> 里删除项目 <code class="special">{key}</code>
rename(<code class="special">{from}</code>, <code class="special">{to}</code>)            数值    换名 (移动) 文件，从 <code class="special">{from}</code> 到 <code class="special">{to}</code>
repeat(<code class="special">{expr}</code>, <code class="special">{count}</code>)         列表/元组/Blob/字符串
                                        重复 <code class="special">{expr}</code> <code class="special">{count}</code> 次
resolve(<code class="special">{filename}</code>)             字符串  解析快捷方式对应的文件名
reverse(<code class="special">{obj}</code>)                  列表/元组/Blob/字符串
                                        反转 <code class="special">{obj}</code>
round(<code class="special">{expr}</code>)                   浮点    <code class="special">{expr}</code> 四舍五入
rubyeval(<code class="special">{expr}</code>)                可变    计算  <a href="if_ruby.html#Ruby">Ruby</a>  表达式
screenattr(<code class="special">{row}</code>, <code class="special">{col}</code>)        数值    当前光标所在的属性
screenchar(<code class="special">{row}</code>, <code class="special">{col}</code>)        数值    当前光标所在的字符
screenchars(<code class="special">{row}</code>, <code class="special">{col}</code>)       列表    当前光标所在的字符列表
screencol()                     数值    当前光标列
screenpos(<code class="special">{winid}</code>, <code class="special">{lnum}</code>, <code class="special">{col}</code>) 字典  文本字符的屏幕行与列
screenrow()                     数值    当前光标行
screenstring(<code class="special">{row}</code>, <code class="special">{col}</code>)      字符串  当前光标所在的字符串
search(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code> [, <code class="special">{skip}</code>]]]])
                                数值    搜索 <code class="special">{pattern}</code>
searchcount([<code class="special">{options}</code>])        字典    获取或更新搜索统计数据
searchdecl(<code class="special">{name}</code> [, <code class="special">{global}</code> [, <code class="special">{thisblock}</code>]])
                                数值    搜索变量声明
searchpair(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code> [...]]])
                                数值    搜索 start/end 对的另一侧
searchpairpos(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code> [...]]])
                                列表    搜索 start/end 队的另一侧
searchpos(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code> [, <code class="special">{skip}</code>]]]])
                                列表    搜索 <code class="special">{pattern}</code>
server2client(<code class="special">{clientid}</code>, <code class="special">{string}</code>)
                                数值    发送应答字符串
serverlist()                    字符串  得到可用的服务器列表
setbufline(<code class="special">{buf}</code>, <code class="special">{lnum}</code>, <code class="special">{text}</code>)
                                数值    设置缓冲区 <code class="special">{buf}</code> 第 <code class="special">{lnum}</code> 行为 <code class="special">{text}</code>
setbufvar(<code class="special">{buf}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)
                                无      设置缓冲区 <code class="special">{buf}</code> 的 <code class="special">{varname}</code> 为 <code class="special">{val}</code>
setcellwidths(<code class="special">{list}</code>)           无      设置字符单元宽度覆盖
setcharpos(<code class="special">{expr}</code>, <code class="special">{list}</code>)      数值    设置 <code class="special">{expr}</code> 的位置为 <code class="special">{list}</code>
setcharsearch(<code class="special">{dict}</code>)           字典    从 <code class="special">{dict}</code> 设置字符搜索选项
setcmdline(<code class="special">{str}</code> [, <code class="special">{pos}</code>])     数值    设置命令行
setcmdpos(<code class="special">{pos}</code>)                数值    设置命令行的光标位置
setcursorcharpos(<code class="special">{list}</code>)        数值    移动光标到 <code class="special">{list}</code> 指定的位置
setenv(<code class="special">{name}</code>, <code class="special">{val}</code>)           无      设置环境变量
setfperm(<code class="special">{fname}</code>, <code class="special">{mode}</code>)       数值    设置 <code class="special">{fname}</code> 文件权限为 <code class="special">{mode}</code>
setline(<code class="special">{lnum}</code>, <code class="special">{line}</code>)         数值    设置第 <code class="special">{lnum}</code> 行的内容为 <code class="special">{line}</code>
setloclist(<code class="special">{nr}</code>, <code class="special">{list}</code> [, <code class="special">{action}</code>])
                                数值    用 <code class="special">{list}</code> 修改位置列表
setloclist(<code class="special">{nr}</code>, <code class="special">{list}</code> [, <code class="special">{action}</code> [, <code class="special">{what}</code>]])
                                数值    修改指定的位置列表项目
setmatches(<code class="special">{list}</code> [, <code class="special">{win}</code>])    数值    还原匹配列表
setpos(<code class="special">{expr}</code>, <code class="special">{list}</code>)          数值    设置 <code class="special">{expr}</code> 的位置为 <code class="special">{list}</code>
setqflist(<code class="special">{list}</code> [, <code class="special">{action}</code>])  数值    用 <code class="special">{list}</code> 修改快速修复列表
setqflist(<code class="special">{list}</code> [, <code class="special">{action}</code> [, <code class="special">{what}</code>]])
                                数值    修改指定的快速修复列表项目
setreg(<code class="special">{n}</code>, <code class="special">{v}</code> [, <code class="special">{opt}</code>])      数值    设置寄存器的值和类型
settabvar(<code class="special">{nr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>) 无    设置标签页 <code class="special">{nr}</code> 的 <code class="special">{varname}</code> 变量为
                                        <code class="special">{val}</code>
settabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)
                                无      设置标签页 <code class="special">{tabnr}</code> 窗口 <code class="special">{winnr}</code> 的
                                        <code class="special">{varname}</code> 变量为 <code class="special">{val}</code>
settagstack(<code class="special">{nr}</code>, <code class="special">{dict}</code> [, <code class="special">{action}</code>])
                                数值    用 <code class="special">{dict}</code> 修改标签栈
setwinvar(<code class="special">{nr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>) 无    设置窗口 <code class="special">{expr}</code> 的 <code class="special">{varname}</code> 为 <code class="special">{val}</code>
sha256(<code class="special">{expr}</code>)                  字符串  字符串或 blob 的 SHA256 校验码
shellescape(<code class="special">{string}</code> [, <code class="special">{special}</code>])
                                字符串  转义 <code class="special">{string}</code> 以便用作外壳命令的参数
shiftwidth([<code class="special">{col}</code>])             数值    <a href="options.html#'shiftwidth'">'shiftwidth'</a> 的有效值
sign_define(<code class="special">{name}</code> [, <code class="special">{dict}</code>])  数值    定义或更新标号
sign_define(<code class="special">{list}</code>)             列表    定义或更新一列标号
sign_getdefined([<code class="special">{name}</code>])       列表    得到已定义的标号的列表
sign_getplaced([<code class="special">{buf}</code> [, <code class="special">{dict}</code>]])
                                列表    得到已放置的标号的列表
sign_jump(<code class="special">{id}</code>, <code class="special">{group}</code>, <code class="special">{buf}</code>)
                                数值    跳转到标号
sign_place(<code class="special">{id}</code>, <code class="special">{group}</code>, <code class="special">{name}</code>, <code class="special">{buf}</code> [, <code class="special">{dict}</code>])
                                数值    放置标号
sign_placelist(<code class="special">{list}</code>)          列表    放置一列标号
sign_undefine([<code class="special">{name}</code>])         数值    撤销标号的定义
sign_undefine(<code class="special">{list}</code>)           列表    撤销一列标号的定义
sign_unplace(<code class="special">{group}</code> [, <code class="special">{dict}</code>])
                                数值    撤销标号的放置
sign_unplacelist(<code class="special">{list}</code>)        列表    撤销一列标号的放置
simplify(<code class="special">{filename}</code>)            字符串  尽可能简化文件名
sin(<code class="special">{expr}</code>)                     浮点    <code class="special">{expr}</code> 的正弦值
sinh(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的双曲正弦值
slice(<code class="special">{expr}</code>, <code class="special">{start}</code> [, <code class="special">{end}</code>])  字符串、列表或 blob
                                        字符串、列表或 blob 的切片
sort(<code class="special">{list}</code> [, <code class="special">{how}</code> [, <code class="special">{dict}</code>]])
                                列表    排序 <code class="special">{list}</code>，<code class="special">{how}</code> 决定比较方式
sound_clear()                   无      停止播放所有声音
sound_playevent(<code class="special">{name}</code> [, <code class="special">{callback}</code>])
                                数值    播放事件声音
sound_playfile(<code class="special">{path}</code> [, <code class="special">{callback}</code>])
                                数值    播放声音文件 <code class="special">{path}</code>
sound_stop(<code class="special">{id}</code>)                无      停止播放声音 <code class="special">{id}</code>
soundfold(<code class="special">{word}</code>)               字符串  按发音折叠 <code class="special">{word}</code>
spellbadword()                  字符串  光标所在的拼写错误的单词
spellsuggest(<code class="special">{word}</code> [, <code class="special">{max}</code> [, <code class="special">{capital}</code>]])
                                列表    拼写建议
split(<code class="special">{expr}</code> [, <code class="special">{pat}</code> [, <code class="special">{keepempty}</code>]])
                                列表    从 <code class="special">{pat}</code> 分割的 <code class="special">{expr}</code> 里构造  <a href="eval.html#List">List</a> 
sqrt(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的平方根
srand([<code class="special">{expr}</code>])                 列表    取得  <a href="builtin.html#rand()">rand()</a>  的种子
state([<code class="special">{what}</code>])                 字符串  Vim 的当前状态
str2blob(<code class="special">{list}</code> [, <code class="special">{options}</code>])  blob    转换字符串列表为 blob
str2float(<code class="special">{expr}</code> [, <code class="special">{quoted}</code>])  浮点    转换字符串为浮点数
str2list(<code class="special">{expr}</code> [, <code class="special">{utf8}</code>])     列表    把 <code class="special">{expr}</code> 的每个字符转换为 ASCII/UTF-8
                                        值
str2nr(<code class="special">{expr}</code> [, <code class="special">{base}</code> [, <code class="special">{quoted}</code>]])
                                数值    把字符串转换为数值
strcharlen(<code class="special">{expr}</code>)              数值    字符串 <code class="special">{expr}</code> 的字符长度
strcharpart(<code class="special">{str}</code>, <code class="special">{start}</code> [, <code class="special">{len}</code> [, <code class="special">{skipcc}</code>]])
                                字符串  <code class="special">{str}</code> 从第 <code class="special">{start}</code> 字符开始的 <code class="special">{len}</code> 个
                                        字符
strchars(<code class="special">{expr}</code> [, <code class="special">{skipcc}</code>])   数值    <code class="special">{expr}</code> 字符串的字符计数
strdisplaywidth(<code class="special">{expr}</code> [, <code class="special">{col}</code>]) 数值  <code class="special">{expr}</code> 字符串的显示长度
strftime(<code class="special">{format}</code> [, <code class="special">{time}</code>])   字符串  使用指定格式排版时间
strgetchar(<code class="special">{str}</code>, <code class="special">{index}</code>)      数值    从 <code class="special">{str}</code> 取得字符 <code class="special">{index}</code>
stridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])
                                数值    <code class="special">{haystack}</code> 里 <code class="special">{needle}</code> 的位置
string(<code class="special">{expr}</code>)                  字符串  <code class="special">{expr}</code> 值得字符串表示
strlen(<code class="special">{expr}</code>)                  数值    字符串 <code class="special">{expr}</code> 的长度
strpart(<code class="special">{str}</code>, <code class="special">{start}</code> [, <code class="special">{len}</code> [, <code class="special">{chars}</code>]])
                                字符串  <code class="special">{str}</code> 从 <code class="special">{start}</code> 字节开始的 <code class="special">{len}</code> 个字
                                        节/字符
strptime(<code class="special">{format}</code>, <code class="special">{timestring}</code>)
                                数值    把 <code class="special">{timestring}</code> 转换为 unix 时间戳
strridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])
                                数值    <code class="special">{haystack}</code> 里最后一个 <code class="special">{needle}</code> 的位置
strtrans(<code class="special">{expr}</code>)                字符串  翻译字符串，使之可以显示
strutf16len(<code class="special">{string}</code> [, <code class="special">{countcc}</code>])
                                数值    <code class="special">{string}</code> 里的 UTF-16 代码单元数
strwidth(<code class="special">{expr}</code>)                数值    <code class="special">{expr}</code> 字符串的显示单元长度
submatch(<code class="special">{nr}</code> [, <code class="special">{list}</code>])       字符串/列表
                                        ":s" 或 substitute() 的特定匹配
substitute(<code class="special">{expr}</code>, <code class="special">{pat}</code>, <code class="special">{sub}</code>, <code class="special">{flags}</code>)
                                字符串  <code class="special">{expr}</code> 里的所有 <code class="special">{pat}</code> 被 <code class="special">{sub}</code> 替代
swapfilelist()                  列表    <a href="options.html#'directory'">'directory'</a> 找到的交换文件列表
swapinfo(<code class="special">{fname}</code>)               字典    关于交换文件 <code class="special">{fname}</code> 的信息
swapname(<code class="special">{buf}</code>)                 字符串  缓冲区 <code class="special">{buf}</code> 的交换文件
synID(<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{trans}</code>)   数值    <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列所在的语法 ID
synIDattr(<code class="special">{synID}</code>, <code class="special">{what}</code> [, <code class="special">{mode}</code>])
                                字符串  syntax ID <code class="special">{synID}</code> 的 <code class="special">{what}</code> 属性
synIDtrans(<code class="special">{synID}</code>)             数值    <code class="special">{synID}</code> 经过翻译的语法 ID
synconcealed(<code class="special">{lnum}</code>, <code class="special">{col}</code>)     列表    关于隐藏的信息
synstack(<code class="special">{lnum}</code>, <code class="special">{col}</code>)         列表    <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列所在的语法 ID 堆栈
system(<code class="special">{expr}</code> [, <code class="special">{input}</code>])      字符串  外壳命令/过滤 <code class="special">{expr}</code> 的输出
systemlist(<code class="special">{expr}</code> [, <code class="special">{input}</code>])  列表    外壳命令/过滤 <code class="special">{expr}</code> 的输出
tabpagebuflist([<code class="special">{arg}</code>])         列表    标签页里的缓冲区号列表
tabpagenr([<code class="special">{arg}</code>])              数值    当前或最后标签页的编号
tabpagewinnr(<code class="special">{tabarg}</code> [, <code class="special">{arg}</code>]) 数值   标签页里当前窗口的编号
tagfiles()                      列表    使用的标签文件
taglist(<code class="special">{expr}</code> [, <code class="special">{filename}</code>])  列表    匹配 <code class="special">{expr}</code> 的标签列表
tan(<code class="special">{expr}</code>)                     浮点    <code class="special">{expr}</code> 的正切值
tanh(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的双曲正切值
tempname()                      字符串  临时文件的文件名
term_dumpdiff(<code class="special">{filename}</code>, <code class="special">{filename}</code> [, <code class="special">{options}</code>])
                                数值    显示两份截图的差异
term_dumpload(<code class="special">{filename}</code> [, <code class="special">{options}</code>])
                                数值    显示一份屏幕截图
term_dumpwrite(<code class="special">{buf}</code>, <code class="special">{filename}</code> [, <code class="special">{options}</code>])
                                无      为终端窗口的内容进行截图
term_getaltscreen(<code class="special">{buf}</code>)        数值    取得备用屏幕标志位
term_getansicolors(<code class="special">{buf}</code>)       列表    取得 GUI 色彩模式的 ANSI 调色板
term_getattr(<code class="special">{attr}</code>, <code class="special">{what}</code>)    数值    取得 <code class="special">{what}</code> 属性的值
term_getcursor(<code class="special">{buf}</code>)           列表    取得终端光标位置
term_getjob(<code class="special">{buf}</code>)              作业    取得终端关联的作业
term_getline(<code class="special">{buf}</code>, <code class="special">{row}</code>)      字符串  从终端取得一行文本行
term_getscrolled(<code class="special">{buf}</code>)         数值    取得终端的滚动数目
term_getsize(<code class="special">{buf}</code>)             列表    取得终端的大小
term_getstatus(<code class="special">{buf}</code>)           字符串  取得终端的状态
term_gettitle(<code class="special">{buf}</code>)            字符串  取得终端的标题
term_gettty(<code class="special">{buf}</code>, [<code class="special">{input}</code>])   字符串  取得终端的 tty 名
term_list()                     列表    取得终端缓冲区的列表
term_scrape(<code class="special">{buf}</code>, <code class="special">{row}</code>)       列表    取得终端屏幕的某行
term_sendkeys(<code class="special">{buf}</code>, <code class="special">{keys}</code>)    无      给终端发送键序列
term_setansicolors(<code class="special">{buf}</code>, <code class="special">{colors}</code>)
                                无      设置 GUI 色彩模式的 ANSI 调色板
term_setapi(<code class="special">{buf}</code>, <code class="special">{expr}</code>)      无      设置  <a href="terminal.html#terminal-api">terminal-api</a>  函数名前缀
term_setkill(<code class="special">{buf}</code>, <code class="special">{how}</code>)      无      设置停止终端作业的信号值
term_setrestore(<code class="special">{buf}</code>, <code class="special">{command}</code>) 无    设置恢复终端的命令
term_setsize(<code class="special">{buf}</code>, <code class="special">{rows}</code>, <code class="special">{cols}</code>)
                                无      设置终端的大小
term_start(<code class="special">{cmd}</code> [, <code class="special">{options}</code>]) 数值    打开终端窗口并执行作业
term_wait(<code class="special">{buf}</code> [, <code class="special">{time}</code>])     数值    等待屏幕刷新
terminalprops()                 字典    终端属性
test_alloc_fail(<code class="special">{id}</code>, <code class="special">{countdown}</code>, <code class="special">{repeat}</code>)
                                无      使内存分配失败
test_autochdir()                无      系统启动中启动 <a href="options.html#'autochdir'">'autochdir'</a>
test_feedinput(<code class="special">{string}</code>)        无      给输入缓冲区增加键序列
test_garbagecollect_now()       无      为测试用，立即释放内存
test_garbagecollect_soon()      无      为测试用，尽快释放内存
test_getvalue(<code class="special">{string}</code>)         可变    得到内部变量的值
test_gui_event(<code class="special">{event}</code>, <code class="special">{args}</code>) 布尔型  为测试用，生成 GUI 事件
test_ignore_error(<code class="special">{expr}</code>)       无      忽略特定的错误
test_mswin_event(<code class="special">{event}</code>, <code class="special">{args}</code>)
                                布尔型  为测试用，生成 MS-Windows 事件
test_null_blob()                blob    用作测试的空值 (null)
test_null_channel()             通道    用作测试的空值 (null)
test_null_dict()                字典    用作测试的空值 (null)
test_null_function()            函数引用        用作测试的空值 (null)
test_null_job()                 作业    用作测试的空值 (null)
test_null_list()                列表    用作测试的空值 (null)
test_null_partial()             函数引用        用作测试的空值 (null)
test_null_string()              字符串  用作测试的空值 (null)
test_null_tuple()               元组    用途测试的空元组
test_option_not_set(<code class="special">{name}</code>)     无      复位指示选项已设置的标志位
test_override(<code class="special">{expr}</code>, <code class="special">{val}</code>)    无      Vim 内部覆盖用作测试
test_refcount(<code class="special">{expr}</code>)           数值    得到 <code class="special">{expr}</code> 的引用计数
test_setmouse(<code class="special">{row}</code>, <code class="special">{col}</code>)     无      为测试用，设置鼠标位置
test_settime(<code class="special">{expr}</code>)            无      用作测试的当前时间
test_srand_seed([<code class="special">{seed}</code>])       无      为 srand() 测试用，设置种子
test_unknown()                  可变    用作测试的未知值
test_void()                     可变    且作测试的无值 (void)
timer_info([<code class="special">{id}</code>])              列表    定时器信息
timer_pause(<code class="special">{id}</code>, <code class="special">{pause}</code>)      无      暂停或继续定时器
timer_start(<code class="special">{time}</code>, <code class="special">{callback}</code> [, <code class="special">{options}</code>])
                                数值    新建定时器
timer_stop(<code class="special">{timer}</code>)             无      停止定时器
timer_stopall()                 无      停止所有定时器
tolower(<code class="special">{expr}</code>)                 字符串  字符串 <code class="special">{expr}</code> 变为小写
toupper(<code class="special">{expr}</code>)                 字符串  字符串 <code class="special">{expr}</code> 变为大写
tr(<code class="special">{src}</code>, <code class="special">{fromstr}</code>, <code class="special">{tostr}</code>)   字符串  把 <code class="special">{src}</code> 里的 <code class="special">{fromstr}</code> 字符翻译为
                                        <code class="special">{tostr}</code> 字符
trim(<code class="special">{text}</code> [, <code class="special">{mask}</code> [, <code class="special">{dir}</code>]])
                                字符串  从 <code class="special">{text}</code> 中删除 <code class="special">{mask}</code> 中的字符
trunc(<code class="special">{expr}</code>)                   浮点    浮点数 <code class="special">{expr}</code> 截断小数点
tuple2list(<code class="special">{tuple}</code>)             列表    把 <code class="special">{tuple}</code> 里的项目转为为列表
type(<code class="special">{expr}</code>)                    数值    值 <code class="special">{expr}</code> 的类型
typename(<code class="special">{expr}</code>)                字符串  <code class="special">{expr}</code> 类型的描述
undofile(<code class="special">{name}</code>)                字符串  对应 <code class="special">{name}</code> 的撤销文件名
undotree([<code class="special">{buf}</code>])               列表    撤销缓冲区 <code class="special">{buf}</code> 的文件树
uniq(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])
                                列表    从列表中删除相邻的重复项
uri_decode(<code class="special">{string}</code>)            字符串  URI-解码字符串
uri_encode(<code class="special">{string}</code>)            字符串  URI-编码字符串
utf16idx(<code class="special">{string}</code>, <code class="special">{idx}</code> [, <code class="special">{countcc}</code> [, <code class="special">{charidx}</code>]])
                                数值    <code class="special">{string}</code> 里 <code class="special">{idx}</code> 字节的 UTF-16 索引
values(<code class="special">{dict}</code>)                  列表    <code class="special">{dict}</code> 的所有值
virtcol(<code class="special">{expr}</code> [, <code class="special">{list}</code> [, <code class="special">{winid}</code>])
                                数值或列表
                                        光标或位置标记的屏幕列
virtcol2col(<code class="special">{winid}</code>, <code class="special">{lnum}</code>, <code class="special">{col}</code>)
                                数值    屏幕上字符的字节索引
visualmode([<code class="special">{expr}</code>])            字符串  最近使用的可视模式
wildmenumode()                  数值    <a href="options.html#'wildmenu'">'wildmenu'</a> 模式是否激活
wildtrigger()                   数值    开始通配扩展
win_execute(<code class="special">{id}</code>, <code class="special">{command}</code> [, <code class="special">{silent}</code>])
                                字符串  在窗口 <code class="special">{id}</code> 执行 <code class="special">{command}</code>
win_findbuf(<code class="special">{bufnr}</code>)            列表    寻找包含 <code class="special">{bufnr}</code> 的窗口
win_getid([<code class="special">{win}</code> [, <code class="special">{tab}</code>]])    数值    得到 <code class="special">{tab}</code> 中 <code class="special">{win}</code> 的窗口 ID
win_gettype([<code class="special">{nr}</code>])             字符串  窗口 <code class="special">{nr}</code> 的类型
win_gotoid(<code class="special">{expr}</code>)              数值    转到 ID 为 <code class="special">{expr}</code> 的窗口
win_id2tabwin(<code class="special">{expr}</code>)           列表    从窗口 ID 获得标签页与窗口
win_id2win(<code class="special">{expr}</code>)              数值    从窗口 ID 获得窗口号
win_move_separator(<code class="special">{nr}</code>)        数值    移动窗口的垂直分割符
win_move_statusline(<code class="special">{nr}</code>)       数值    移动窗口的状态行
win_screenpos(<code class="special">{nr}</code>)             列表    得到窗口 <code class="special">{nr}</code> 的屏幕位置
win_splitmove(<code class="special">{nr}</code>, <code class="special">{target}</code> [, <code class="special">{options}</code>])
                                数值    移动窗口 <code class="special">{nr}</code> 成为 <code class="special">{target}</code> 的分割窗口
winbufnr(<code class="special">{nr}</code>)                  数值    窗口 <code class="special">{nr}</code> 的缓冲区号
wincol()                        数值    光标所在的窗口列
windowsversion()                字符串  MS-Windows 操作系统版本
winheight(<code class="special">{nr}</code>)                 数值    窗口 <code class="special">{nr}</code> 的高度
winlayout([<code class="special">{tabnr}</code>])            列表    标签页 <code class="special">{tabnr}</code> 的窗口布局
winline()                       数值    光标所在的窗口行
winnr([<code class="special">{expr}</code>])                 数值    当前窗口的编号
winrestcmd()                    字符串  返回恢复窗口大小的命令
winrestview(<code class="special">{dict}</code>)             无      恢复当前窗口的视图
winsaveview()                   字典    保存当前窗口的视图
winwidth(<code class="special">{nr}</code>)                  数值    窗口 <code class="special">{nr}</code> 的宽度
wordcount()                     字典    字节/字符/单词统计
writefile(<code class="special">{object}</code>, <code class="special">{fname}</code> [, <code class="special">{flags}</code>])
                                数值    把行的  <a href="eval.html#Blob">Blob</a>  或  <a href="eval.html#List">List</a>  写到文件
                                        <code class="special">{fname}</code>
xor(<code class="special">{expr}</code>, <code class="special">{expr}</code>)             数值    按位异或

</section><hr class="doubleline" /><section class=inner>
<h4>2. 详细                                         <b class="vimtag"> <a name="builtin-function-details">builtin-function-details</a> </b></h4>
此处并不包含所有函数，有些函数移到了包含特定功能的单独帮助文件里。
返回类型指定  <a href="vim9.html#Vim9-script">Vim9-script</a>  使用的类型，见  <a href="vim9.html#vim9-types">vim9-types</a> 

abs(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="abs()">abs()</a> </b>
                返回 <code class="special">{expr}</code> 的绝对值。如果 <code class="special">{expr}</code> 计算结果为  <a href="eval.html#Float">Float</a> ，abs() 返
                回  <a href="eval.html#Float">Float</a> 。如果 <code class="special">{expr}</code> 可以转换为  <a href="eval.html#Number">Number</a> ，abs() 返回
                 <a href="eval.html#Number">Number</a> 。否则报错并返回 -1。
                示例: 
<code class="example">                        echo abs(1.456)</code>
                        1.456  
<code class="example">                        echo abs(-5.456)</code>
                        5.456  
<code class="example">                        echo abs(-4)</code>
                        4

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;abs()</code>

                返回类型:  <a href="eval.html#Number">Number</a>  或  <a href="eval.html#Float">Float</a> ，取决于 <code class="special">{expr}</code>


acos(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="acos()">acos()</a> </b>
                返回以弧度表示的 <code class="special">{expr}</code> 的反余弦值，返回值为 [0, pi] 区间内的
                 <a href="eval.html#Float">Float</a> 。
                <code class="special">{expr}</code> 的计算结果必须是 [-1, 1] 区间内的  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。
                否则 acos() 返回 "nan"。
                示例: 
<code class="example">                        :echo acos(0)</code>
                        1.570796 
<code class="example">                        :echo acos(-0.5)</code>
                        2.094395

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;acos()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


add(<code class="special">{object}</code>, <code class="special">{expr}</code>)                                   <b class="vimtag"> <a name="add()">add()</a> </b>
                在  <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a>  <code class="special">{object}</code> 最后附加项目 <code class="special">{expr}</code>。返回新产生的
                 <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a> 。例如: 
<code class="example">                        :let alist = add([1, 2, 3], item)</code>
<code class="example">                        :call add(mylist, "woodstock")</code>
                <code class="note">注意</code> 如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，它被作为单个项目附加进去。
                 <a href="builtin.html#extend()">extend()</a>  可以用来连接  <a href="eval.html#List">List</a> 。
                如果 <code class="special">{object}</code> 是  <a href="eval.html#Blob">Blob</a> ，<code class="special">{expr}</code> 必须是个数值。
                 <a href="builtin.html#insert()">insert()</a>  可以用来把一个项目加到其它的位置上。
                如果 <code class="special">{object}</code> 不是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a> ，返回 1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;add(val1)-&gt;add(val2)</code>

                返回类型: list&lt;<code class="special">{type}</code>&gt; (取决于输入的  <a href="eval.html#List">List</a> ) 或  <a href="eval.html#Blob">Blob</a> 


and(<code class="special">{expr}</code>, <code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="and()">and()</a> </b>
                对两个参数进行按位与。参数须转换为数值。列表、字典或浮点数参数
                会报错。
                另见  <a href="builtin.html#or()">or()</a>  和  <a href="builtin.html#xor()">xor()</a> 。
                示例: 
<code class="example">                        :let flag = and(bits, 0x80)</code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :let flag = bits-&gt;and(0x80)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


append(<code class="special">{lnum}</code>, <code class="special">{text}</code>)                                  <b class="vimtag"> <a name="append()">append()</a> </b>
                当 <code class="special">{text}</code> 为  <a href="eval.html#List">List</a> : 把每个  <a href="eval.html#List">List</a>  项目作为文本行，附加到当前
                缓冲区第 <code class="special">{lnum}</code> 行之下。
                否则，把 <code class="special">{text}</code> 作为单个文本行，附加于当前缓冲区第 <code class="special">{lnum}</code> 行之
                下。
                接受任何项目，并转换为字符串。
                <code class="special">{lnum}</code> 可以为零，用于在第一行前插入一行。
                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。
                如果失败 (<code class="special">{lnum}</code> 越界或内存溢出)，返回 1，成功则返回 0。<code class="special">{text}</code>
                为空列表时，不管 <code class="special">{lnum}</code> 为何，总返回零。
                 <a href="vim9.html#Vim9">Vim9</a>  脚本中非法参数或负数会报错。例如: 
<code class="example">                        :let failed = append(line('$'), "# THE END")</code>
<code class="example">                        :let failed = append(0, ["Chapter 1", "the beginning"])</code>
<code class="example"></code>
                也可用作列表的  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        mylist-&gt;append(lnum)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


appendbufline(<code class="special">{buf}</code>, <code class="special">{lnum}</code>, <code class="special">{text}</code>)                    <b class="vimtag"> <a name="appendbufline()">appendbufline()</a> </b>
                类似于  <a href="builtin.html#append()">append()</a> ，但在缓冲区 <code class="special">{buf}</code> 中附加文本。

                此函数只能用于已载入的缓冲区。有必要的话先调用  <a href="builtin.html#bufload()">bufload()</a> 。

                <code class="special">{buf}</code> 的用法可见  <a href="builtin.html#bufname()">bufname()</a> 。

                <code class="special">{lnum}</code> 是行号，在其下附加文本。<code class="note">注意</code> 使用  <a href="builtin.html#line()">line()</a>  会用到当前缓
                冲区而不是正在进行附加的那个。"$" 用来附加于缓冲区的末尾。不支
                持其他字符串值。

                成功时返回 0，失败则返回 1。
                 <a href="vim9.html#Vim9">Vim9</a>  脚本中非法 <code class="special">{lnum}</code> 会报错。

                如果 <code class="special">{buf}</code> 不是合法的缓冲区或 <code class="special">{lnum}</code> 不合法，报错。例如: 
<code class="example">                        :let failed = appendbufline(13, 0, "# THE START")</code>
                不过，<code class="special">{text}</code> 为空列表时，非法的 <code class="special">{lnum}</code> 也不会报错，因为并不实
                际使用 <code class="special">{lnum}</code>。

                也可用作列表的  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        mylist-&gt;appendbufline(buf, lnum)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


argc([<code class="special">{winid}</code>])                                         <b class="vimtag"> <a name="argc()">argc()</a> </b>
                返回参数列表的文件数目。见  <a href="editing.html#arglist">arglist</a> 。
                如果 <code class="special">{winid}</code> 未给出，使用当前窗口的参数列表。
                如果 <code class="special">{winid}</code> 是 -1，使用全局参数列表。
                否则，<code class="special">{winid}</code> 指定参数列表所在的窗口: 窗口号或窗口 ID 均可。
                如果 <code class="special">{winid}</code> 参数不合法，返回 -1。

                返回类型:  <a href="eval.html#Number">Number</a> 


argidx()                                                <b class="vimtag"> <a name="argidx()">argidx()</a> </b>
                返回参数列表的当前索引。0 是第一个文件。argc() - 1 是最后一
                个。见  <a href="editing.html#arglist">arglist</a> 。

                返回类型:  <a href="eval.html#Number">Number</a> 


arglistid([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])                        <b class="vimtag"> <a name="arglistid()">arglistid()</a> </b>
                返回参数列表 ID，这是一个用来标识正在使用的参数列表的数值。零
                代表全局参数列表。见  <a href="editing.html#arglist">arglist</a> 。
                参数非法时返回 -1。

                无参数时，使用当前窗口。
                只提供 <code class="special">{winnr}</code> 时，使用当前标签页的指定窗口。
                同时提供 <code class="special">{winnr}</code> 和 <code class="special">{tabnr}</code> 时，使用指定标签页的指定窗口。
                <code class="special">{winnr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。

                返回类型:  <a href="eval.html#Number">Number</a> 


argv([<code class="special">{nr}</code> [, <code class="special">{winid}</code>]])                                <b class="vimtag"> <a name="argv()">argv()</a> </b>
                返回参数列表第 <code class="special">{nr}</code> 个参数。见  <a href="editing.html#arglist">arglist</a> 。"argv(0)" 是第一个参
                数。例如: 
<code class="example">        :let i = 0</code>
<code class="example">        :while i &lt; argc()</code>
<code class="example">        :  let f = escape(fnameescape(argv(i)), '. ')</code>
<code class="example">        :  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '&lt;CR&gt;'</code>
<code class="example">        :  let i = i + 1</code>
<code class="example">        :endwhile</code>
                如果没有 <code class="special">{nr}</code> 参数或 <code class="special">{nr}</code> 为 -1，返回完整的 <code class="special">{arglist}</code> 的
                 <a href="eval.html#List">List</a> 。

                <code class="special">{winid}</code> 参数指定窗口 ID，见  <a href="builtin.html#argc()">argc()</a> 。
                关于 Vim 的命令行参数，可见  <a href="eval.html#v:argv">v:argv</a> 。

                如果参数列表中不存在第 <code class="special">{nr}</code> 个参数，返回空串。如果 <code class="special">{winid}</code> 参
                数非法，则返回空列表。

                返回类型:  <a href="eval.html#String">String</a> 


asin(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="asin()">asin()</a> </b>
                返回以弧度表示的 <code class="special">{expr}</code> 的反正弦值，返回值为 [-pi/2, pi/2] 区
                间内的浮点数。
                <code class="special">{expr}</code> 的计算结果必须是 [-1, 1] 区间内的  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。
                如果 <code class="special">{expr}</code> 越出 [-1, 1] 区间，返回 "nan"。如果 <code class="special">{expr}</code> 不是
                 <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> ，返回 0.0。
                示例: 
<code class="example">                        :echo asin(0.8)</code>
                        0.927295 
<code class="example">                        :echo asin(-0.5)</code>
                        -0.523599

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;asin()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 

assert_ 函数文档在这里:  <a href="testing.html#assert-functions-details">assert-functions-details</a> 


atan(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="atan()">atan()</a> </b>
                返回 <code class="special">{expr}</code> 反正切的主值，返回值为 [-pi/2, +pi/2] 区间内的弧度
                值浮点数。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回 0.0。
                示例: 
<code class="example">                        :echo atan(100)</code>
                        1.560797 
<code class="example">                        :echo atan(-4.01)</code>
                        -1.326405

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;atan()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


atan2(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                 <b class="vimtag"> <a name="atan2()">atan2()</a> </b>
                返回 <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的反正切值，以弧度计算，返回值为 [-pi,
                +pi] 区间内的浮点数。
                <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则
                返回 0.0。
                示例: 
<code class="example">                        :echo atan2(-1, 1)</code>
                        -0.785398 
<code class="example">                        :echo atan2(1, -1)</code>
                        2.356194

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;atan2(1)</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


autocmd_add(<code class="special">{acmds}</code>)                                    <b class="vimtag"> <a name="autocmd_add()">autocmd_add()</a> </b>
                新增一组自动命令和自动命令组。

                <code class="special">{acmds}</code> 参数是列表，每个项目为包含以下可选项目的字典:
                    bufnr       新增局部于缓冲区的自动命令的缓冲区号。如果指
                                定，忽略 "pattern" 项目。
                    cmd         此自动命令事件要执行的 Ex 命令
                    event       自动命令事件名。参见  <a href="autocmd.html#autocmd-events">autocmd-events</a> 。
                                可以是包含单个事件名的字符串，也可以是事件名的
                                列表。
                    group       自动命令组名。参见  <a href="autocmd.html#autocmd-groups">autocmd-groups</a> 。
                                如此组尚未存在则创建之。如果不指定或为空，使用
                                缺省组。
                    nested      布尔型标志位，要新增嵌套自动命令时设为
                                v:true。参见  <a href="autocmd.html#autocmd-nested">autocmd-nested</a> 。
                    once        布尔型标志位，要新增只执行一次的自动命令时设为
                                v:true。参见  <a href="autocmd.html#autocmd-once">autocmd-once</a> 。
                    pattern     自动命令的模式串。参见  <a href="autocmd.html#autocmd-patterns">autocmd-patterns</a> 。如
                                果指定 "bufnr" 项目，忽略本项目。可以是包含单
                                个模式的字符串，也可以是模式的列表。
                    replace     布尔型标志位，设为 v:true 时，先删除和指定自动
                                命令事件和组相关的所有命令，再加入 <code class="special">{cmd}</code>。这可
                                用于避免为组里的一个自动命令事件重复加入相同的
                                命令。

                成功返回 v:true，失败返回 v:failure。
                示例: 
<code class="example">                        " 为 5 号缓冲区创建局部于缓冲区的自动命令</code>
<code class="example">                        let acmd = {}</code>
<code class="example">                        let acmd.group = 'MyGroup'</code>
<code class="example">                        let acmd.event = 'BufEnter'</code>
<code class="example">                        let acmd.bufnr = 5</code>
<code class="example">                        let acmd.cmd = 'call BufEnterFunc()'</code>
<code class="example">                        call autocmd_add([acmd])</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetAutocmdList()-&gt;autocmd_add()</code>

                返回类型:  <a href="vim9.html#vim9-boolean">vim9-boolean</a> 


autocmd_delete(<code class="special">{acmds}</code>)                                 <b class="vimtag"> <a name="autocmd_delete()">autocmd_delete()</a> </b>
                删除一组自动命令和自动命令组。

                <code class="special">{acmds}</code> 参数是列表，每个项目为包含以下可选项目的字典:
                    bufnr       待删除的局部于缓冲区的自动命令的缓冲区号。如果
                                指定，忽略 "pattern" 项目。
                    cmd         此自动命令事件要执行的 Ex 命令
                    event       自动命令事件名。参见  <a href="autocmd.html#autocmd-events">autocmd-events</a> 。
                                如果为 '*'，删除此组中的所有自动命令事件。
                    group       自动命令组名。参见  <a href="autocmd.html#autocmd-groups">autocmd-groups</a> 。
                                如果不指定或为空，使用缺省组。
                    nested      布尔型标志位，要指定嵌套自动命令时设为
                                v:true。参见  <a href="autocmd.html#autocmd-nested">autocmd-nested</a> 。
                    once        布尔型标志位，要指定只执行一次的自动命令时设为
                                v:true。参见  <a href="autocmd.html#autocmd-once">autocmd-once</a> 。
                    pattern     自动命令的模式串。参见  <a href="autocmd.html#autocmd-patterns">autocmd-patterns</a> 。如
                                果指定 "bufnr" 项目，忽略本项目。

                如果 <code class="special">{acmds}</code> 字典只指定了 <code class="special">{group}</code>，而未指定 <code class="special">{event}</code>、<code class="special">{pattern}</code>
                和 <code class="special">{cmd}</code>，删除整个自动命令组。

                成功返回 v:true，失败返回 v:failure。
                示例: 
<code class="example">                        " :autocmd! BufLeave *.vim</code>
<code class="example">                        let acmd = #{event: 'BufLeave', pattern: '*.vim'}</code>
<code class="example">                        call autocmd_delete([acmd]})</code>
<code class="example">                        " :autocmd! MyGroup1 BufLeave</code>
<code class="example">                        let acmd = #{group: 'MyGroup1', event: 'BufLeave'}</code>
<code class="example">                        call autocmd_delete([acmd])</code>
<code class="example">                        " :autocmd! MyGroup2 BufEnter *.c</code>
<code class="example">                        let acmd = #{group: 'MyGroup2', event: 'BufEnter',</code>
<code class="example">                                                        \ pattern: '*.c'}</code>
<code class="example">                        " :autocmd! MyGroup2 * *.c</code>
<code class="example">                        let acmd = #{group: 'MyGroup2', event: '*',</code>
<code class="example">                                                        \ pattern: '*.c'}</code>
<code class="example">                        call autocmd_delete([acmd])</code>
<code class="example">                        " :autocmd! MyGroup3</code>
<code class="example">                        let acmd = #{group: 'MyGroup3'}</code>
<code class="example">                        call autocmd_delete([acmd])</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetAutocmdList()-&gt;autocmd_delete()</code>

                返回类型:  <a href="vim9.html#vim9-boolean">vim9-boolean</a> 


autocmd_get([<code class="special">{opts}</code>])                                   <b class="vimtag"> <a name="autocmd_get()">autocmd_get()</a> </b>
                返回自动命令的  <a href="eval.html#List">List</a> 。如果不提供 <code class="special">{opts}</code>，返回所有组里所有事件
                的自动命令。

                可选的 <code class="special">{opts}</code> 字典参数支持以下项目:
                    group       自动命令组名。如果指定，只返回此组中定义的自动
                                命令。如果给出的组不存在，返回错误信息。如果设
                                为空串，使用缺省自动命令组。
                    event       自动命令事件名。如果指定，只返回为此事件定义的
                                自动命令。如为 "*"，返回所有事件的自动命令。如
                                果给出的事件不存在，返回错误信息。
                    pattern     自动命令模式。如果指定，只返回为此模式定义的自
                                动命令。
                <code class="special">{opts}</code> 接受以上三者的组合。

                返回列表的每个项目为字典，包含以下项目:
                    bufnr       对局部于缓冲区的自动命令而言，此自动命令定义所
                                在的缓冲区号。
                    cmd         此自动命令执行的命令。
                    event       自动命令事件名。
                    group       自动命令组名。
                    nested      布尔型标志位，嵌套自动命令设为 v:true。见
                                 <a href="autocmd.html#autocmd-nested">autocmd-nested</a> 。
                    once        布尔型标志位，只执行一次的自动命令时设为
                                v:true。参见  <a href="autocmd.html#autocmd-once">autocmd-once</a> 。
                    pattern     自动命令模式。对局部于缓冲区的自动命令而言，
                                有以下形式 "&lt;buffer=n&gt;"。
                如果组里的一个自动命令事件有多个命令，每个命令会分别返回单独的
                项目。

                如果指定组、事件或模式的自动命令不存在，返回空列表。

                示例: 
<code class="example">                        " :autocmd MyGroup</code>
<code class="example">                        echo autocmd_get(#{group: 'Mygroup'})</code>
<code class="example">                        " :autocmd G BufUnload</code>
<code class="example">                        echo autocmd_get(#{group: 'G', event: 'BufUnload'})</code>
<code class="example">                        " :autocmd G * *.ts</code>
<code class="example">                        let acmd = #{group: 'G', event: '*', pattern: '*.ts'}</code>
<code class="example">                        echo autocmd_get(acmd)</code>
<code class="example">                        " :autocmd Syntax</code>
<code class="example">                        echo autocmd_get(#{event: 'Syntax'})</code>
<code class="example">                        " :autocmd G BufEnter *.ts</code>
<code class="example">                        let acmd = #{group: 'G', event: 'BufEnter',</code>
<code class="example">                                                        \ pattern: '*.ts'}</code>
<code class="example">                        echo autocmd_get(acmd)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Getopts()-&gt;autocmd_get()</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt;


balloon_gettext()                                       <b class="vimtag"> <a name="balloon_gettext()">balloon_gettext()</a> </b>
                返回气泡的当前文本。只用于字符串，不用于列表。如果气泡不存在，
                返回空串。

                返回类型:  <a href="eval.html#String">String</a> 


balloon_show(<code class="special">{expr}</code>)                                    <b class="vimtag"> <a name="balloon_show()">balloon_show()</a> </b>
                在气泡中显示 <code class="special">{expr}</code>。GUI 上 <code class="special">{expr}</code> 用作字符串。而终端上 <code class="special">{expr}</code>
                可以是多行的列表。如果 <code class="special">{expr}</code> 不是列表，会用  <a href="builtin.html#balloon_split()">balloon_split()</a> 
                进行分割。
                如果 <code class="special">{expr}</code> 为空，删除任何已存在的气泡。

                示例: 
<code class="example">                        func GetBalloonContent()</code>
<code class="example">                           " ... 启动内容的获取过程</code>
<code class="example">                           return ''</code>
<code class="example">                        endfunc</code>
<code class="example">                        set balloonexpr=GetBalloonContent()</code>
<code class="example"></code>
<code class="example">                        func BalloonCallback(result)</code>
<code class="example">                          call balloon_show(a:result)</code>
<code class="example">                        endfunc</code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;balloon_show()</code>

                期待的用法是从 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 启动气泡内容的获取过程。它应调用
                异步方法，然后在其回调中执行 balloon_show()。<a href="options.html#'balloonexpr'">'balloonexpr'</a> 自
                身可返回空字符串或任何占位符，例如 "载入中..."。

                如果不能显示气泡，不做任何事，不会报错。
                {仅当编译时加入  <a href="various.html#+balloon_eval">+balloon_eval</a>  或  <code class="badlink">balloon_eval_term</code>  特性才
                有效}

                返回类型:  <a href="eval.html#Number">Number</a> 


balloon_split(<code class="special">{msg}</code>)                                    <b class="vimtag"> <a name="balloon_split()">balloon_split()</a> </b>
                把字符串 <code class="special">{msg}</code> 分割为用于气泡中显示的多行。分割依据的是当前窗
                口大小，并进行优化以显示调试器的输出。
                返回分割后行的  <a href="eval.html#List">List</a> 。出错时返回空列表。
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;balloon_split()-&gt;balloon_show()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <code class="badlink">balloon_eval_term</code>  特性才有效}</code>

                返回类型: list<code class="special">&lt;any&gt;</code> 或 list<code class="special">&lt;string&gt;</code>


base64_decode(<code class="special">{string}</code>)                                 <b class="vimtag"> <a name="base64_decode()">base64_decode()</a> </b>
                返回 blob，包含对 base64 编码的 <code class="special">{string}</code> 的字符进行解码后的字
                节。

                <code class="special">{string}</code> 参数只能包含 base64-编码的字符，长度必须为 4 的倍数。

                出错时返回空 blob。

                示例: 
<code class="example">                    " 把解码内容写到二进制文件</code>
<code class="example">                    call writefile(base64_decode(s), 'tools.bmp')</code>
<code class="example">                    " 解码 base64-编码的字符串</code>
<code class="example">                    echo blob2str(base64_decode(encodedstr))</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetEncodedString()-&gt;base64_decode()</code>

                返回类型:  <a href="eval.html#Blob">Blob</a> 


base64_encode(<code class="special">{blob}</code>)                                   <b class="vimtag"> <a name="base64_encode()">base64_encode()</a> </b>
                返回将 <code class="special">{blob}</code> 包含的字节进行 base64 编码后的字符串。使用 RFC
                4648 定义的 base64 字母表。

                示例: 
<code class="example">                    " 对二进制文件内容进行编码</code>
<code class="example">                    echo base64_encode(readblob('somefile.bin'))</code>
<code class="example">                    " 对字符串进行编码</code>
<code class="example">                    echo base64_encode(str2blob(somestr-&gt;split("\n")))</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBinaryData()-&gt;base64_encode()</code>

                返回类型:  <a href="eval.html#String">String</a> 


bindtextdomain(<code class="special">{package}</code>, <code class="special">{path}</code>)                       <b class="vimtag"> <a name="bindtextdomain()">bindtextdomain()</a> </b>
                将指定的 <code class="special">{package}</code> 和 <code class="special">{path}</code> 进行绑定，使得
                 <a href="builtin.html#gettext()">gettext()</a>  函数可用于得到一个包的语言特定的翻译。<code class="special">{path}</code> 为包
                含翻译的目录。见  <a href="repeat.html#package-translation">package-translation</a> 。

                成功时返回 v:true，失败时返回 v:false (内存溢出)。

                返回类型:  <a href="vim9.html#vim9-boolean">vim9-boolean</a> 


blob2list(<code class="special">{blob}</code>)                                       <b class="vimtag"> <a name="blob2list()">blob2list()</a> </b>
                返回 <code class="special">{blob}</code> 中每个字节对应的数值的列表。示例: 
<code class="example">                        blob2list(0z0102.0304)  返回 [1, 2, 3, 4]</code>
<code class="example">                        blob2list(0z)           返回 []</code>
                出错时返回空列表。 <a href="builtin.html#list2blob()">list2blob()</a>  为其逆操作。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBlob()-&gt;blob2list()</code>

                返回类型: list<code class="special">&lt;any&gt;</code> 或 list<code class="special">&lt;number&gt;</code>


blob2str(<code class="special">{blob}</code> [, <code class="special">{options}</code>])                          <b class="vimtag"> <a name="blob2str()">blob2str()</a> </b>
                返回 <code class="special">{blob}</code> 中字节序列使用当前 <a href="options.html#'encoding'">'encoding'</a> 转换而成的字符构成的
                字符串列表。

                blob 里的每个 <code class="special">&lt;NL&gt;</code> 字节视作字符串结束，并添加新列表项目。blob
                里的每个 <code class="special">&lt;NUL&gt;</code> 字节则被转换为 <code class="special">&lt;NL&gt;</code> 字符。

                如果 <code class="special">{options}</code> 未提供，使用当前 <a href="options.html#'encoding'">'encoding'</a> 值来解码 <code class="special">{blob}</code> 里
                的字节序列。

                参数 <code class="special">{options}</code> 为  <a href="eval.html#Dict">Dict</a> ，支持以下项目:
                    encoding    使用此编码来解码 <code class="special">{blob}</code> 里的字节序列。 <a href="eval.html#String">String</a> 
                                值。支持的值可见  <a href="mbyte.html#encoding-names">encoding-names</a>  (加上特殊值
                                "none")。
                                                        <b class="vimtag"> <a name="E1515">E1515</a> </b> <b class="vimtag"> <a name="E1516">E1516</a> </b>
                当前 <a href="options.html#'encoding'">'encoding'</a> 如为 "utf-8"，<code class="special">{blob}</code> 发现非法字节序列时报错并
                返回空列表。要抑制此种检验而不介意得到可能非法的字符串，将
                <code class="special">{options}</code> 里的 "encoding" 设为 "none"。

                blob 为空时返回空列表。

                另见  <a href="builtin.html#str2blob()">str2blob()</a> 

                示例: 
<code class="example">                    blob2str(0z6162)            返回 ['ab']</code>
<code class="example">                    blob2str(0zC2ABC2BB)        返回 ['«»']</code>
<code class="example">                    blob2str(0z610A62)          返回 ['a', 'b']</code>
<code class="example">                    blob2str(0z610062)          返回 ['a\nb']</code>
<code class="example">                    blob2str(0zABBB, {'encoding': 'latin1'}) 返回 ['«»']</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBlob()-&gt;blob2str()</code>

                返回类型: list<code class="special">&lt;string&gt;</code>


browse(<code class="special">{save}</code>, <code class="special">{title}</code>, <code class="special">{initdir}</code>, <code class="special">{default}</code>)           <b class="vimtag"> <a name="browse()">browse()</a> </b>
                启动文件请求窗口。只有在 "has("browse")" 返回  <a href="eval.html#TRUE">TRUE</a>  时 (只有
                在一些 GUI 版本里) 才可以。
                输入的字段包括:
                    <code class="special">{save}</code>       <a href="eval.html#TRUE">TRUE</a>  时，选择要写入的文件
                    <code class="special">{title}</code>     请求窗口的标题
                    <code class="special">{initdir}</code>   开始浏览的目录
                    <code class="special">{default}</code>   缺省文件名
                如果按了 "Cancel" 按钮、出错、或者无法浏览，返回空字符串。

                返回类型:  <a href="eval.html#String">String</a> 


browsedir(<code class="special">{title}</code>, <code class="special">{initdir}</code>)                           <b class="vimtag"> <a name="browsedir()">browsedir()</a> </b>
                启动目录请求窗口。只有在 "has("browse")" 返回  <a href="eval.html#TRUE">TRUE</a>  时 (只有
                在一些 GUI 版本里) 才能工作。
                有的系统上不支持目录浏览器，这时使用文件浏览器。此时: 选择要用
                的目录里的文件。
                输入的字段包括:
                    <code class="special">{title}</code>     请求窗口的标题
                    <code class="special">{initdir}</code>   开始浏览的目录
                如果按了 "Cancel" 按钮、出错、或者无法浏览，返回空字符串。

                返回类型:  <a href="eval.html#String">String</a> 


bufadd(<code class="special">{name}</code>)                                          <b class="vimtag"> <a name="bufadd()">bufadd()</a> </b>
                在缓冲区列表中加入名为 <code class="special">{name}</code> (须为字符串) 的缓冲区。
                如果对应文件 <code class="special">{name}</code> 的缓冲区已经存在，返回该缓冲区号。否则返回
                新建缓冲区的号。<code class="special">{name}</code> 为空串时，总是建立新缓冲区。
                该缓冲区不置位 <a href="options.html#'buflisted'">'buflisted'</a> 也还未载入。要在缓冲区中增加文件: 
<code class="example">                        let bufnr = bufadd('someName')</code>
<code class="example">                        call bufload(bufnr)</code>
<code class="example">                        call setbufline(bufnr, 1, ['some', 'text'])</code>
                出错时返回 0。
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        let bufnr = 'somename'-&gt;bufadd()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


bufexists(<code class="special">{buf}</code>)                                        <b class="vimtag"> <a name="bufexists()">bufexists()</a> </b>
                返回数值，如果名为 <code class="special">{buf}</code> 的缓冲区存在的话，返回  <a href="eval.html#TRUE">TRUE</a> 。
                <code class="special">{buf}</code> 参数是数值时，指定缓冲区号。数值零指定当前窗口的轮换缓
                冲区。

                <code class="special">{buf}</code> 参数是字符串时，必须完全匹配指定缓冲区名。该名可以是:
                - 相对于当前目录。
                - 完整路径。
                - <a href="options.html#'buftype'">'buftype'</a> 设为 "nofile" 的缓冲区名。
                - URL 名。
                列表外缓冲区也会被找到。
                <code class="note">注意</code> 帮助文件在  <a href="windows.html#:buffers">:buffers</a>  里列出的是它们的短名字。但
                bufexists() 需要它们的长名字才能找到它们。
                bufexists() 可能报告缓冲区存在，但要使其名字可用于  <a href="windows.html#:buffer">:buffer</a> 
                命令，可能需用到  <a href="builtin.html#expand()">expand()</a> 。尤其 MS-Windows 8.3 名字可能形
                如 "c:\DOCUME~1"。
                使用 "bufexists(0)" 可以测试是否存在轮换文件名。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        let exists = 'somename'-&gt;bufexists()</code>

&lt;
                返回类型:  <a href="eval.html#Number">Number</a> 

                已废弃的名字: buffer_exists()。         <b class="vimtag"> <a name="buffer_exists()">buffer_exists()</a> </b>

buflisted(<code class="special">{buf}</code>)                                        <b class="vimtag"> <a name="buflisted()">buflisted()</a> </b>
                返回数值，如果名为 <code class="special">{buf}</code> 的缓冲区在列表内的话 (置位了
                <a href="options.html#'buflisted'">'buflisted'</a> 选项)，返回  <a href="eval.html#TRUE">TRUE</a> 。
                <code class="special">{buf}</code> 参数用法同  <a href="builtin.html#bufexists()">bufexists()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        let listed = 'somename'-&gt;buflisted()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


bufload(<code class="special">{buf}</code>)                                          <b class="vimtag"> <a name="bufload()">bufload()</a> </b>
                确保缓冲区 <code class="special">{buf}</code> 已载入。如果缓冲区名指向已存在的文件，读入该
                文件。否则缓冲区会为空。如果缓冲区已载入，则没有改变。如果缓冲
                区不和文件相关 (如 <a href="options.html#'buftype'">'buftype'</a> 为 "nofile" 时)，不读入任何文件。
                如果缓冲区的文件已有交换文件，不会弹出对话框，还是会载入缓冲
                区。
                <code class="special">{buf}</code> 参数的用法可见  <a href="builtin.html#bufexists()">bufexists()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        eval 'somename'-&gt;bufload()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


bufloaded(<code class="special">{buf}</code>)                                        <b class="vimtag"> <a name="bufloaded()">bufloaded()</a> </b>
                返回数值，如果名为 <code class="special">{buf}</code> 的缓冲区存在且已载入的话 (在窗口显
                示，或者至少被隐藏)，返回  <a href="eval.html#TRUE">TRUE</a> 。
                <code class="special">{buf}</code> 参数用法同  <a href="builtin.html#bufexists()">bufexists()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        let loaded = 'somename'-&gt;bufloaded()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


bufname([<code class="special">{buf}</code>])                                        <b class="vimtag"> <a name="bufname()">bufname()</a> </b>
                返回缓冲区的名字，多数情况如同 ":ls" 命令显示的那样，但不使用
                如 "[未命名]" 那样的特别名字。
                如果 <code class="special">{buf}</code> 省略使用当前缓冲区。
                如果 <code class="special">{buf}</code> 参数是数值，指定缓冲区号。数值零代表当前窗口的轮换
                缓冲区。
                如果 <code class="special">{buf}</code> 参数是字符串，它用作  <a href="autocmd.html#file-pattern">file-pattern</a>  来匹配缓冲区名
                字。这里总假设置位 <a href="options.html#'magic'">'magic'</a> 而 <a href="options.html#'cpoptions'">'cpoptions'</a> 为空。如果有超过一个
                匹配，返回空字符串。
                "" 或 "%" 可用来指定当前缓冲区，"#" 指定轮换缓冲区。
                完整的匹配优先，如果没有，也接受在缓冲区名的开始，结束和中间的
                匹配。如果你只愿意接受完整的匹配，在模式的开始放上 "^"，在结尾
                放上 "$"。
                先查找列表内缓冲区。如果列出缓冲区有唯一的匹配，返回之。不然，
                再查找列表外的缓冲区。
                如果 <code class="special">{buf}</code> 是字符串，但你想用作缓冲区号，给它加零可以强制转化
                为数值型: 
<code class="example">                        :echo bufname("3" + 0)</code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        echo bufnr-&gt;bufname()</code>
<code class="example"></code>
                如果缓冲区不存在，或者没有名字，返回空字符串。 
<code class="example">        bufname("#")            轮换缓冲区名</code>
<code class="example">        bufname(3)              缓冲区 3 的名字</code>
<code class="example">        bufname("%")            当前缓冲区名</code>
<code class="example">        bufname("file2")        匹配 "file2" 的缓冲区名。</code>

                返回类型:  <a href="eval.html#String">String</a> 
                                                        <b class="vimtag"> <a name="buffer_name()">buffer_name()</a> </b>
                已废弃的名字: buffer_name()。


bufnr([<code class="special">{buf}</code> [, <code class="special">{create}</code>]])                             <b class="vimtag"> <a name="bufnr()">bufnr()</a> </b>
                返回缓冲区的编号，如同 ":ls" 命令显示的那样。关于 <code class="special">{buf}</code> 的使
                用，见上  <a href="builtin.html#bufname()">bufname()</a> 。
                如果不存在符合的缓冲区，返回 -1。或者，如果提供了 <code class="special">{create}</code> 参
                数而且为 TRUE，建立一个新的列表外缓冲区，并返回其编号。例如: 
<code class="example">                        let newbuf = bufnr('Scratch001', 1)</code>
                这里空名会使用当前缓冲区。要创建新缓冲区可用  <a href="builtin.html#bufadd()">bufadd()</a>  带空
                名。

                bufnr("$") 是最后一个缓冲区: 
<code class="example">                        :let last_buffer = bufnr("$")</code>
                返回数值，即最大的已有的缓冲区的编号。<code class="note">注意</code> 较小的编号不一定都
                对应存在的缓冲区，因为 ":bwipeout" 可能永久地删除了部分的缓冲
                区。用 bufexists() 可以测试缓冲区是否存在。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        echo bufref-&gt;bufnr()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                已废弃的名字: buffer_number()。         <b class="vimtag"> <a name="buffer_number()">buffer_number()</a> </b>
                                                        <b class="vimtag"> <a name="last_buffer_nr()">last_buffer_nr()</a> </b>
                bufnr("$") 已废弃的名字: last_buffer_nr()。

bufwinid(<code class="special">{buf}</code>)                                         <b class="vimtag"> <a name="bufwinid()">bufwinid()</a> </b>
                返回数值，带缓冲区 <code class="special">{buf}</code> 相关的第一个窗口的  <a href="windows.html#window-ID">window-ID</a> 。
                <code class="special">{buf}</code> 的用法见上述  <a href="builtin.html#bufname()">bufname()</a> 。 如果缓冲区 <code class="special">{buf}</code> 不存在或没有
                对应窗口，返回 -1。示例: 
<code class="example"></code>
<code class="example">        echo "包含缓冲区 1 的窗口是 " .. (bufwinid(1))</code>

                只处理当前标签页。 <a href="builtin.html#win_findbuf()">win_findbuf()</a>  给出更多说明。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        FindBuffer()-&gt;bufwinid()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


bufwinnr(<code class="special">{buf}</code>)                                         <b class="vimtag"> <a name="bufwinnr()">bufwinnr()</a> </b>
                和  <a href="builtin.html#bufwinid()">bufwinid()</a>  类似，但返回窗口号而不是  <a href="windows.html#window-ID">window-ID</a> 。
                如果缓冲区 <code class="special">{buf}</code> 不存在或者没有对应的窗口，返回 -1。例如: 
<code class="example"></code>
<code class="example">        echo "包含缓冲区 1 的窗口是 " .. (bufwinnr(1))</code>
<code class="example"></code>
                该编号可用于  <a href="windows.html#CTRL-W_w">CTRL-W_w</a>  和 ":wincmd w"  <a href="windows.html#:wincmd">:wincmd</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        FindBuffer()-&gt;bufwinnr()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


byte2line(<code class="special">{byte}</code>)                                       <b class="vimtag"> <a name="byte2line()">byte2line()</a> </b>
                返回当前缓冲区第 <code class="special">{byte}</code> 个字节所在的行号。取决于当前缓冲区的
                <a href="options.html#'fileformat'">'fileformat'</a> 选项，这可以包括不同的换行符。第一个字符的字节编
                号为 1。
                另见  <a href="builtin.html#line2byte()">line2byte()</a> 、 <a href="motion.html#go">go</a>  和  <a href="motion.html#:goto">:goto</a> 。

                <code class="special">{byte}</code> 值非法时返回 -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetOffset()-&gt;byte2line()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+byte_offset">+byte_offset</a>  特性才有效}</code>


byteidx(<code class="special">{expr}</code>, <code class="special">{nr}</code> [, <code class="special">{utf16}</code>])                       <b class="vimtag"> <a name="byteidx()">byteidx()</a> </b>
                返回字符串 <code class="special">{expr}</code> 里第 <code class="special">{nr}</code> 个字符的字节位置。零代表第一个字
                符，此时返回零。
                如果没有多字节字符，返回值总是等于 <code class="special">{nr}</code>。
                组合字符不单独计数，其字节长度加到其前导的基础字符上。要将组合
                字符分别计数，见下  <a href="builtin.html#byteidxcomp()">byteidxcomp()</a> 。
                如果给出 <code class="special">{utf16}</code> 且为 TRUE，<code class="special">{nr}</code> 用作字符串 <code class="special">{expr}</code> 的 UTF-16
                索引，而不是字符索引。UTF-16 索引是字符串以 16 位单词编码时的
                索引。如果指定的 UTF-16 索引在某字符 (如 4-字节字符) 的内部，
                返回该字符首个字节的字节索引。详见  <a href="eval.html#string-offset-encoding">string-offset-encoding</a> 。
                例如: 
<code class="example">                        echo matchstr(str, ".", byteidx(str, 3))</code>
                显示第四个字符。另一个方法也能达到相同的效果: 
<code class="example">                        let s = strpart(str, byteidx(str, 3))</code>
<code class="example">                        echo strpart(s, 0, byteidx(s, 1))</code>
                另见  <a href="builtin.html#strgetchar()">strgetchar()</a>  和  <a href="builtin.html#strcharpart()">strcharpart()</a> 。

                如果字符数不足 <code class="special">{nr}</code>，返回 -1。
                如果刚好 <code class="special">{nr}</code> 个字符，返回字符串的字节长度。
                要从字节索引相应地获取字符索引和 UTF-16 索引，见  <a href="builtin.html#charidx()">charidx()</a> 
                和  <a href="builtin.html#utf16idx()">utf16idx()</a> 。
                示例: 
<code class="example">                        echo byteidx('a😊😊', 2)        返回 5</code>
<code class="example">                        echo byteidx('a😊😊', 2, 1)     返回 1</code>
<code class="example">                        echo byteidx('a😊😊', 3, 1)     返回 5</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;byteidx(idx)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


byteidxcomp(<code class="special">{expr}</code>, <code class="special">{nr}</code> [, <code class="special">{utf16}</code>])                   <b class="vimtag"> <a name="byteidxcomp()">byteidxcomp()</a> </b>
                类似于  <a href="builtin.html#byteidx()">byteidx()</a> ，但组合字符作为一个单独的字符计算。示例: 
<code class="example">                        let s = 'e' .. nr2char(0x301)</code>
<code class="example">                        echo byteidx(s, 1)</code>
<code class="example">                        echo byteidxcomp(s, 1)</code>
<code class="example">                        echo byteidxcomp(s, 2)</code>
                第一个和第三个 echo 返回 3 ('e' 加上组合字符是 3 个字节)，第二
                个 echo 返回 1 ('e' 是一个字节)。
                仅当 <a href="options.html#'encoding'">'encoding'</a> 为某种 Unicode 编码时，才和  <a href="builtin.html#byteidx()">byteidx()</a>  有所不
                同。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;byteidxcomp(idx)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


call(<code class="special">{func}</code>, <code class="special">{arglist}</code> [, <code class="special">{dict}</code>])                      <b class="vimtag"> <a name="call()">call()</a> </b> <b class="vimtag"> <a name="E699">E699</a> </b>
                调用函数 <code class="special">{func}</code>，使用  <a href="eval.html#List">List</a>  <code class="special">{arglist}</code> 项目作为参数。
                <code class="special">{func}</code> 可以是  <a href="eval.html#Funcref">Funcref</a>  或函数名。
                a:firstline 和 a:lastline 设为当前行。
                返回调用的函数的结果。
                <code class="special">{dict}</code> 用于为函数指定 "dict" 属性。其目的是设置局部变量
                "self"。 <a href="eval.html#Dictionary-function">Dictionary-function</a> 

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFunc()-&gt;call([arg, arg], dict)</code>

                返回类型: any，取决于 <code class="special">{func}</code>


ceil(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="ceil()">ceil()</a> </b>
                返回浮点数，即大于等于 <code class="special">{expr}</code> 的最小整数 (向上取整)。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        echo ceil(1.456)</code>
                        2.0  
<code class="example">                        echo ceil(-5.456)</code>
                        -5.0  
<code class="example">                        echo ceil(4.0)</code>
                        4.0

                如果 <code class="special">{expr}</code> 不是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> ，返回 0.0。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;ceil()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


ch_ 函数文档在这里:  <a href="channel.html#channel-functions-details">channel-functions-details</a> 


changenr()                                              <b class="vimtag"> <a name="changenr()">changenr()</a> </b>
                返回最近改变的编号。这和  <a href="undo.html#:undolist">:undolist</a>  显示的编号相同，可用于
                 <a href="undo.html#:undo">:undo</a>  命令。
                如果发生了改变，返回的是此改变的编号。在重做以后，返回的是重做
                的改变的编号。在撤销以后，返回撤销的改变的编号减一。
                如果撤销列表为空，返回 0。

                返回类型:  <a href="eval.html#Number">Number</a> 


char2nr(<code class="special">{string}</code> [, <code class="special">{utf8}</code>])                            <b class="vimtag"> <a name="char2nr()">char2nr()</a> </b>
                返回 <code class="special">{string}</code> 第一个字符的数值结果。例如: 
<code class="example">                        char2nr(" ")            返回 32</code>
<code class="example">                        char2nr("ABC")          返回 65</code>
                如果 <code class="special">{utf8}</code> 省略或为零，使用当前的 <a href="options.html#'encoding'">'encoding'</a>。比如对 "utf-8"
                来说: 
<code class="example">                        char2nr("á")            返回 225</code>
<code class="example">                        char2nr("á"[0])         返回 195</code>
                如果 <code class="special">{utf8}</code> 为 TRUE，则总视为 UTF-8 字符。
                组合字符是一个单独的字符。
                 <a href="builtin.html#nr2char()">nr2char()</a>  是它的逆操作。
                要把字符串转换为字符数值的列表: 
<code class="example">                    let str = "ABC"</code>
<code class="example">                    let list = map(split(str, '\zs'), {_, val -&gt; char2nr(val)})</code>
                结果是: [65, 66, 67]

                如果 <code class="special">{string}</code> 不是字符串型，返回 0。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetChar()-&gt;char2nr()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


charclass(<code class="special">{string}</code>)                                     <b class="vimtag"> <a name="charclass()">charclass()</a> </b>
                返回 <code class="special">{string}</code> 首个字符的字符类。
                字符类为以下之一:
                        0       空白
                        1       标点
                        2       单词字符 (取决于 <a href="options.html#'iskeyword'">'iskeyword'</a>)
                        3       表情符号
                        其它    特定 Unicode 类
                此类用于模式匹配和单词动作。
                如果 <code class="special">{string}</code> 不是字符串型，返回 0。

                返回类型:  <a href="eval.html#Number">Number</a> 


charcol(<code class="special">{expr}</code> [, <code class="special">{winid}</code>])                             <b class="vimtag"> <a name="charcol()">charcol()</a> </b>
                同  <a href="builtin.html#col()">col()</a> ，但返回 <code class="special">{expr}</code> 给出列的位置字符索引而不是字节索引。

                示例:
                如果光标在第五行文本 "여보세요" 的 '세' 时: 
<code class="example">                        charcol('.')            返回 3</code>
<code class="example">                        col('.')                返回 7</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPos()-&gt;col()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


charidx(<code class="special">{string}</code>, <code class="special">{idx}</code> [, <code class="special">{countcc}</code> [, <code class="special">{utf16}</code>]])      <b class="vimtag"> <a name="charidx()">charidx()</a> </b>
                返回 <code class="special">{string}</code> <code class="special">{idx}</code> 字节对应的字符索引。首个字符的索引为零。
                如果没有多字节字符，返回值自然等于 <code class="special">{idx}</code>。

                如果 <code class="special">{countcc}</code> 省略或  <a href="eval.html#FALSE">FALSE</a> ，组合字符不单独计算，它们的字节
                长度被加入前导的基本字符。
                如果 <code class="special">{countcc}</code> 为  <a href="eval.html#TRUE">TRUE</a> ，组合字符算作单独的字符。

                如果给出 <code class="special">{utf16}</code> 且为 TRUE，<code class="special">{nr}</code> 用作字符串 <code class="special">{expr}</code> 的 UTF-16
                索引，而不是字符索引。

                参数非法或不足 <code class="special">{idx}</code> 字节时，返回 -1。如果正好有 <code class="special">{idx}</code> 字节，
                返回字符串以字符计的长度。

                如果首个参数不是字符串、第二个参数不是数值或第三个参数存在且非
                零或一，报错。

                关于如何从字符索引来获取字节索引，可见  <a href="builtin.html#byteidx()">byteidx()</a>  和
                 <a href="builtin.html#byteidxcomp()">byteidxcomp()</a> ，而要从字符索引获取 UTF-16 索引，可见
                 <code class="badlink">utf16idx</code> 。
                详见  <a href="eval.html#string-offset-encoding">string-offset-encoding</a> 。
                示例: 
<code class="example">                        echo charidx('áb́ć', 3)            返回 1</code>
<code class="example">                        echo charidx('áb́ć', 6, 1) 返回 4</code>
<code class="example">                        echo charidx('áb́ć', 16)           返回 -1</code>
<code class="example">                        echo charidx('a😊😊', 4, 0, 1)  返回 2</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;charidx(idx)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


chdir(<code class="special">{dir}</code> [, <code class="special">{scope}</code>])                                <b class="vimtag"> <a name="chdir()">chdir()</a> </b>
                切换当前工作目录为 <code class="special">{dir}</code>。目录改变的作用域见下:
                如果没给出 <code class="special">{scope}</code>，在当前目录的作用域里切换当前工作目录:
                    - 如果设置了局部于窗口的目录 ( <a href="editing.html#:lcd">:lcd</a> )，则在该作用域里改变
                      当前工作目录。
                    - 否则，如果设置了局部于标签页的目录 ( <a href="editing.html#:tcd">:tcd</a> )，则在该作用
                      域里改变当前工作目录。
                    - 否则，改变全局目录。

                如果给出 <code class="special">{scope}</code>，为下面指定的作用域改变当前工作目录:
                    "window"    改变窗口局部目录。 <a href="editing.html#:lcd">:lcd</a> 
                    "tabpage"   改变标签页局部目录。 <a href="editing.html#:tcd">:tcd</a> 
                    "global"    改变全局目录。 <a href="editing.html#:cd">:cd</a> 

                <code class="special">{dir}</code> 必须为字符串。
                如果成功，返回上次的工作目录。把它传给另一个 chdir() 会恢复上
                次目录。
                如果失败，返回空串。

                示例: 
<code class="example">                        let save_dir = chdir(newdir)</code>
<code class="example">                        if save_dir != ""</code>
<code class="example">                           " ... 做点事</code>
<code class="example">                           call chdir(save_dir)</code>
<code class="example">                        endif</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetDir()-&gt;chdir()</code>

                返回类型:  <a href="eval.html#String">String</a> 


cindent(<code class="special">{lnum}</code>)                                         <b class="vimtag"> <a name="cindent()">cindent()</a> </b>
                得到第 <code class="special">{lnum}</code> 行根据 C 缩进规则应有的缩进距离，见 <a href="options.html#'cindent'">'cindent'</a>。
                缩进的计算以空格计，因而和 <a href="options.html#'tabstop'">'tabstop'</a> 的值是有关系的。<code class="special">{lnum}</code> 的
                使用方式和  <a href="builtin.html#getline()">getline()</a>  相同。
                <code class="special">{lnum}</code> 非法时返回 -1。
                见  <a href="indent.html#C-indenting">C-indenting</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;cindent()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


clearmatches([<code class="special">{win}</code>])                                   <b class="vimtag"> <a name="clearmatches()">clearmatches()</a> </b>
                清除之前  <a href="builtin.html#matchadd()">matchadd()</a>  和  <a href="pattern.html#:match">:match</a>  命令为当前窗口定义的匹配。
                如果给出 <code class="special">{win}</code>，使用指定窗口号或窗口 ID 的窗口而不是当前窗口。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWin()-&gt;clearmatches()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


cmdcomplete_info()                                      <b class="vimtag"> <a name="cmdcomplete_info()">cmdcomplete_info()</a> </b>
                返回  <a href="eval.html#Dictionary">Dictionary</a> ，即命令行补全信息。见  <a href="cmdline.html#cmdline-completion">cmdline-completion</a> 。
                项目是:
                   cmdline_orig 补全开始前原始的命令行字符串。
                   pum_visible  如果弹出菜单可见则为  <a href="eval.html#TRUE">TRUE</a> 。
                                见  <a href="builtin.html#pumvisible()">pumvisible()</a> 。
                   matches      所有补全候选的列表。每个项目是字符串。
                   selected     选中项目的索引。首个索引值为零。如果没项目选
                                中，索引值为 -1 (只显示输入的文本，而按了 <code class="special">&lt;Up&gt;</code>
                                或 <code class="special">&lt;Down&gt;</code> 键时如果没有选中项目则是最近的补全)

                如果没有尝试补全、只有一个候选且已完整提供、或者出错的时候，返
                回空  <a href="eval.html#Dictionary">Dictionary</a> 。

                返回类型: dict<code class="special">&lt;any&gt;</code>


col(<code class="special">{expr}</code> [, <code class="special">{winid}</code>])                                 <b class="vimtag"> <a name="col()">col()</a> </b>
                返回数值，即 <code class="special">{expr}</code> 给定的列位置的字节索引。
                可接受的位置参见  <a href="builtin.html#getpos()">getpos()</a> 。
                <code class="special">{expr}</code> 为 "$" 代表光标行的行尾，即返回光标行的字节数加 1。
                另外，<code class="special">{expr}</code> 可以是 [lnum, col]: 包含行号和列号的  <a href="eval.html#List">List</a> 。常用
                于指定列号为 "$" 以得到特定行的末列列号。如果 "lnum" 或 "col"
                超出范围，col() 返回零。
                可选的 <code class="special">{winid}</code> 参数从该窗口而不是当前窗口中取值。
                要得到行号用  <a href="builtin.html#line()">line()</a> 。两者都要用  <a href="builtin.html#getpos()">getpos()</a> 。
                要得到屏幕列的位置，用  <a href="builtin.html#virtcol()">virtcol()</a> 。要得到字符位置，用
                 <a href="builtin.html#charcol()">charcol()</a> 。
                <code class="note">注意</code> 只能使用当前文件的位置标记。
                例如: 
<code class="example">                        col(".")                光标所在列</code>
<code class="example">                        col("$")                光标行的长度加 1</code>
<code class="example">                        col("'t")               位置标记 t 的列号</code>
<code class="example">                        col("'" .. markname)    等于 markname 的位置标记的列号</code>

                第一列为 1。<code class="special">{expr}</code> 非法或找不到 ID 对应 <code class="special">{winid}</code> 的窗口时返回
                0。
                大写位置标记的对应列可能在另一个缓冲区中。
                如果激活了 <a href="options.html#'virtualedit'">'virtualedit'</a> 并且如果光标在行尾之后的话，计算光标
                位置得到的列号比实际的多 1。另外，使用 <code class="special">&lt;Cmd&gt;</code> 映射时光标不移
                动，可用此特性来取得插入模式下的列号: 
<code class="example">                        :imap &lt;F2&gt; &lt;Cmd&gt;echowin col(".")&lt;CR&gt;</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPos()-&gt;col()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


complete(<code class="special">{startcol}</code>, <code class="special">{matches}</code>)                         <b class="vimtag"> <a name="complete()">complete()</a> </b> <b class="vimtag"> <a name="E785">E785</a> </b>
                设置插入模式补全的匹配。只能用于插入模式。通常从 <code class="keystroke">CTRL-R</code> = 的映
                射里调用 (见  <a href="insert.html#i_CTRL-R">i_CTRL-R</a> )，但也可从  <a href="map.html#%3CCmd%3E">&lt;Cmd&gt;</a>  或  <code class="badlink">&lt;ScriptCmd</code>  映
                射里调用。不能在 <code class="keystroke">CTRL-O</code> 之后或者在表达式映射里使用。
                <code class="special">{startcol}</code> 是行内待补全文本开始的字节偏移。直到光标为止的文本
                就是原始的文本，它将要被匹配所替代。用 col('.') 会得到空串。而
                "col('.') - 1" 将用匹配替换单个字符。
                <code class="special">{matches}</code> 必须是  <a href="eval.html#List">List</a> 。每个  <a href="eval.html#List">List</a>  项目是一个匹配。
                 <a href="insert.html#complete-items">complete-items</a>  说明可能的项目类型。
                忽略 <a href="options.html#'completeopt'">'completeopt'</a> 里的 "longest"。
                <code class="note">注意</code> 调用此函数后，你不应插入任何使补全停止的内容。
                用 <code class="keystroke">CTRL-N</code> 和 <code class="keystroke">CTRL-P</code> 选择匹配，就像普通的插入模式补全那样。如果
                指定，会出现弹出菜单，见  <a href="insert.html#ins-completion-menu">ins-completion-menu</a> 。

                示例 (使用老式 Vim 脚本): 
<code class="example"></code>
<code class="example">                inoremap &lt;F5&gt; &lt;C-R&gt;=ListMonths()&lt;CR&gt;</code>
<code class="example"></code>
<code class="example">                func ListMonths()</code>
<code class="example">                  call complete(col('.'), ['January', 'February', 'March',</code>
<code class="example">                        \ 'April', 'May', 'June', 'July', 'August',</code>
<code class="example">                        \ 'September', 'October', 'November', 'December'])</code>
<code class="example">                  return ''</code>
<code class="example">                endfunc</code>

                示例 (使用 Vim9 脚本): 
<code class="example"></code>
<code class="example">                vim9script</code>
<code class="example">                def ListMonths(): string</code>
<code class="example">                  const months = [ 'January', 'February', 'March', 'April',</code>
<code class="example">                        'May', 'June', 'July', 'September', 'October',</code>
<code class="example">                        'November', 'December']</code>
<code class="example">                  complete(col('.'), months)</code>
<code class="example">                  return ''</code>
<code class="example">                enddef</code>
<code class="example"></code>
<code class="example">                inoremap &lt;F5&gt; &lt;ScriptCmd&gt;ListMonths()&lt;CR&gt;</code>
<code class="example"></code>
                此例并不很有用，但可以说明功能。<code class="note">注意</code>这里返回空串，以免插入零。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetMatches()-&gt;complete(col('.'))</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


complete_add(<code class="special">{expr}</code>)                                    <b class="vimtag"> <a name="complete_add()">complete_add()</a> </b>
                把 <code class="special">{expr}</code> 加到匹配的列表里。只能用于 <a href="options.html#'completefunc'">'completefunc'</a> 选项指定的
                函数里。
                返回 0 代表失败 (空字符串或者内存不足)，1 代表加入了匹配，2 代
                表匹配已经在列表里。
                 <a href="insert.html#complete-functions">complete-functions</a>  解释 <code class="special">{expr}</code>。它和 <a href="options.html#'omnifunc'">'omnifunc'</a> 应该返回的列
                表中单个项目相同。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMoreMatches()-&gt;complete_add()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


complete_check()                                        <b class="vimtag"> <a name="complete_check()">complete_check()</a> </b>
                寻找补全匹配时，检查输入的键。如果寻找匹配需要一定时间时有用。
                如果匹配的搜索被中止，返回  <a href="eval.html#TRUE">TRUE</a> 。否则返回零。
                只能用于 <a href="options.html#'completefunc'">'completefunc'</a> 选项指定的函数里。

                返回类型:  <a href="eval.html#Number">Number</a> 


complete_info([<code class="special">{what}</code>])                                 <b class="vimtag"> <a name="complete_info()">complete_info()</a> </b>
                返回关于插入模式补全信息的  <a href="eval.html#Dictionary">Dictionary</a> 。见  <a href="insert.html#ins-completion">ins-completion</a> 。
                项目是:
                   mode         当前补全模式名的字符串。
                                可用值见  <a href="builtin.html#complete_info_mode">complete_info_mode</a> 。
                   pum_visible  如果弹出菜单可见则为  <a href="eval.html#TRUE">TRUE</a> 。
                                见  <a href="builtin.html#pumvisible()">pumvisible()</a> 。
                   items        包含补全所有备选的列表。每个项目是包含项目
                                "word"、"abbr"、"menu"、"kind"、"info" 和
                                "user_data" 的字典。
                                见  <a href="insert.html#complete-items">complete-items</a> 。
                   matches      类似于 "items"，但只返回匹配当前查询的项目。如
                                果 "what" 里同时要求 "matches" 和 "items"，返
                                回列表仍然会叫做 "items"，但每个项目有一个额外
                                的 "match" 字段。
                   selected     选中项目的索引。首个索引为零。如果没有选中的项
                                目则索引为 -1 (只显示输入的文本，或者在无选择
                                的情况下使用 <code class="special">&lt;Up&gt;</code> 或 <code class="special">&lt;Down&gt;</code> 键则为最后一项补
                                全)
                   completed    返回当前选中索引对应项目的包含 "items" 里描述
                                的所有项目的字典。

                                                        <b class="vimtag"> <a name="complete_info_mode">complete_info_mode</a> </b>
                mode 值是:
                   ""                不在补全模式中
                   "keyword"         关键字补全  <a href="insert.html#i_CTRL-X_CTRL-N">i_CTRL-X_CTRL-N</a> 
                   "ctrl_x"          刚按了 <code class="keystroke">CTRL-X</code>  <a href="insert.html#i_CTRL-X">i_CTRL-X</a> 
                   "scroll"           <a href="insert.html#i_CTRL-X_CTRL-E">i_CTRL-X_CTRL-E</a>  或  <a href="insert.html#i_CTRL-X_CTRL-Y">i_CTRL-X_CTRL-Y</a>  滚
                                     动
                   "whole_line"      整行  <a href="insert.html#i_CTRL-X_CTRL-L">i_CTRL-X_CTRL-L</a> 
                   "files"           文件名  <a href="insert.html#i_CTRL-X_CTRL-F">i_CTRL-X_CTRL-F</a> 
                   "tags"            标签  <a href="insert.html#i_CTRL-X_CTRL-]">i_CTRL-X_CTRL-]</a> 
                   "path_defines"    定义补全  <a href="insert.html#i_CTRL-X_CTRL-D">i_CTRL-X_CTRL-D</a> 
                   "path_patterns"   头文件补全  <a href="insert.html#i_CTRL-X_CTRL-I">i_CTRL-X_CTRL-I</a> 
                   "dictionary"      字典  <a href="insert.html#i_CTRL-X_CTRL-K">i_CTRL-X_CTRL-K</a> 
                   "thesaurus"       同义词词典  <a href="insert.html#i_CTRL-X_CTRL-T">i_CTRL-X_CTRL-T</a> 
                   "cmdline"         Vim 命令行  <a href="insert.html#i_CTRL-X_CTRL-V">i_CTRL-X_CTRL-V</a> 
                   "function"        用户定义补全  <a href="insert.html#i_CTRL-X_CTRL-U">i_CTRL-X_CTRL-U</a> 
                   "omni"            全能补全  <a href="insert.html#i_CTRL-X_CTRL-O">i_CTRL-X_CTRL-O</a> 
                   "spell"           拼写建议  <a href="insert.html#i_CTRL-X_s">i_CTRL-X_s</a> 
                   "eval"             <a href="builtin.html#complete()">complete()</a>  补全
                   "register"        寄存器里的单词  <a href="insert.html#i_CTRL-X_CTRL-R">i_CTRL-X_CTRL-R</a> 
                   "unknown"         其它内部模式

                如果提供可选的 <code class="special">{what}</code> 列表参数，只返回 <code class="special">{what}</code> 中列出的项目。
                <code class="special">{what}</code> 中不支持的项目被安静地跳过。

                要得到弹出菜单的位置和大小，可见  <a href="builtin.html#pum_getpos()">pum_getpos()</a> 。也可通过
                 <a href="autocmd.html#CompleteChanged">CompleteChanged</a>  事件中的  <a href="eval.html#v:event">v:event</a>  得到。

                出错时返回空  <a href="eval.html#Dictionary">Dictionary</a> 。

                示例: 
<code class="example">                        " 取得所有项目</code>
<code class="example">                        call complete_info()</code>
<code class="example">                        " 只要 'mode'</code>
<code class="example">                        call complete_info(['mode'])</code>
<code class="example">                        " 只要 'mode' 和 'pum_visible'</code>
<code class="example">                        call complete_info(['mode', 'pum_visible'])</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetItems()-&gt;complete_info()</code>

                返回类型: dict<code class="special">&lt;any&gt;</code>


complete_match([<code class="special">{lnum}</code>, <code class="special">{col}</code>])                         <b class="vimtag"> <a name="complete_match()">complete_match()</a> </b>
                从给定位置开始反向查找，返回根据 <a href="options.html#'isexpand'">'isexpand'</a> 选项找到的匹配列
                表。没有提供参数时，使用当前光标位置。

                每个匹配用 [startcol, trigger_text] 列表表示，其中:
                - startcol: 补全应开始的列号，如果没有触发器位置则为 -1。对多
                  字符触发器，返回首个字符的列号。
                - trigger_text: 匹配 <a href="options.html#'isexpand'">'isexpand'</a> 的触发器字符串，如果没找到匹配
                  或使用了缺省 <a href="options.html#'iskeyword'">'iskeyword'</a> 模式时则为空串。

                <a href="options.html#'isexpand'">'isexpand'</a> 如为空，使用 <a href="options.html#'iskeyword'">'iskeyword'</a> 模式 "\k\+$" 以查找当前关
                键字的开始位置。

                示例: 
<code class="example">        set isexpand=.,-&gt;,/,/*,abc</code>
<code class="example">        func CustomComplete()</code>
<code class="example">          let res = complete_match()</code>
<code class="example">          if res-&gt;len() == 0 | return | endif</code>
<code class="example">          let [col, trigger] = res[0]</code>
<code class="example">          let items = []</code>
<code class="example">          if trigger == '/*'</code>
<code class="example">            let items = ['/** */']</code>
<code class="example">          elseif trigger == '/'</code>
<code class="example">            let items = ['/*! */', '// TODO:', '// fixme:']</code>
<code class="example">          elseif trigger == '.'</code>
<code class="example">            let items = ['length()']</code>
<code class="example">          elseif trigger =~ '^\-&gt;'</code>
<code class="example">            let items = ['map()', 'reduce()']</code>
<code class="example">          elseif trigger =~ '^\abc'</code>
<code class="example">            let items = ['def', 'ghk']</code>
<code class="example">          endif</code>
<code class="example">          if items-&gt;len() &gt; 0</code>
<code class="example">            let startcol = trigger =~ '^/' ? col : col + len(trigger)</code>
<code class="example">            call complete(startcol, items)</code>
<code class="example">          endif</code>
<code class="example">        endfunc</code>
<code class="example">        inoremap &lt;Tab&gt; &lt;Cmd&gt;call CustomComplete()&lt;CR&gt;</code>

                返回类型: list&lt;list<code class="special">&lt;any&gt;</code>&gt;


confirm(<code class="special">{msg}</code> [, <code class="special">{choices}</code> [, <code class="special">{default}</code> [, <code class="special">{type}</code>]]])   <b class="vimtag"> <a name="confirm()">confirm()</a> </b>
                confirm() 提供用户一个对话框，从中可以作出选择。返回选择的序
                号。第一个选择为 1。
                <code class="note">注意</code>: confirm() 只有在编译时加入对话框支持才存在，见
                 <a href="various.html#+dialog_con">+dialog_con</a> 、 <a href="various.html#+dialog_con_gui">+dialog_con_gui</a>  和  <a href="various.html#+dialog_gui">+dialog_gui</a> 。
                在  <a href="gui_w32.html#dialog">dialog</a>  里显示 <code class="special">{msg}</code> 消息，并提供可能的选择 <code class="special">{choices}</code>。如
                果 <code class="special">{choices}</code> 不存在或者为空，使用 "&amp;OK" (经过翻译)。
                <code class="special">{msg}</code> 是字符串，'\n' 用来包含换行符。在有些系统上该字符串在放
                不下时被回绕，但并非所有系统都如此。
                <code class="special">{choices}</code> 是一个字符串，用 '\n' 分隔各个选择，例如 
<code class="example">                        confirm("Save changes?", "&amp;Yes\n&amp;No\n&amp;Cancel")</code>
                '&amp;' 之后的字符提供该选择的快捷键。这样，你可以输入 'c' 来选择
                "Cancel"。快捷键不一定是第一个字符: 
<code class="example">                        confirm("file has been modified", "&amp;Save\nSave &amp;All")</code>
                控制台里，每个选择的第一个字符用作缺省的快捷键。忽略大小写。

                可选的 <code class="special">{default}</code> 参数是用户按 <code class="special">&lt;CR&gt;</code> 使用的选择号。设定 1 使得第
                一个选项成为缺省，如果是 0，则不设定任何缺省。如果不提供
                <code class="special">{default}</code>，假设为 1。

                可选的 <code class="special">{type}</code> 字符串参数指定对话框的类型。只有在 GTK、Mac、
                Motif 和 Win32 GUI 上才用得上，它用以指定图标。可以取的值是:
                "Error"、"Question"、"Info"、"Warning" 或 "Generic"。只有第一
                个字符是重要的。如果忽略 <code class="special">{type}</code>，使用 "Generic"。

                如果用户用 <code class="special">&lt;Esc&gt;</code>、<code class="keystroke">CTRL-C</code> 或者别的合法的中断键中止对话框，
                confirm() 返回 0。

                一个例子: 
<code class="example">                   let choice = confirm("你要吃什么？",</code>
<code class="example">                                        \ "&amp;苹果\n&amp;桔子\n&amp;香蕉", 2)</code>
<code class="example">                   if choice == 0</code>
<code class="example">                        echo "快下定决心！"</code>
<code class="example">                   elseif choice == 3</code>
<code class="example">                        echo "好吃"</code>
<code class="example">                   else</code>
<code class="example">                        echo "我本人喜欢香蕉。"</code>
<code class="example">                   endif</code>
                GUI 的对话框使用按钮。按钮的排放方式取决于 <a href="options.html#'guioptions'">'guioptions'</a> 里的
                'v' 标志位。如果包含该标志位，按钮总是竖排的。不然，confirm()
                试图把按钮放在一行里。如果放不下，那么还是使用竖排的方式。在有
                的系统上，无论如何总是使用横排。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        BuildMessage()-&gt;confirm("&amp;Yes\n&amp;No")</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


copy(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="copy()">copy()</a> </b>
                构造 <code class="special">{expr}</code> 的备份。对数值和字符串而言，这和直接使用 <code class="special">{expr}</code>
                并无不同。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，建立一个浅备份。这意味着，原来的  <a href="eval.html#List">List</a> 
                可以被改变，而不会影响新建的备份。反之亦然。不过，其中的项目只
                有一份，所以修改项目同时修改两个  <a href="eval.html#List">List</a>  的内容。
                 <a href="eval.html#Tuple">Tuple</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  的复制和  <a href="eval.html#List">List</a>  类似。
                另见  <a href="builtin.html#deepcopy()">deepcopy()</a> 。
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;copy()</code>

                返回类型: any，取决于 <code class="special">{expr}</code>


cos(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="cos()">cos()</a> </b>
                返回浮点数，即以弧度测量的 <code class="special">{expr}</code> 的余弦值。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回 0.0。
                示例: 
<code class="example">                        :echo cos(100)</code>
                        0.862319 
<code class="example">                        :echo cos(-4.01)</code>
                        -0.646043

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;cos()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


cosh(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="cosh()">cosh()</a> </b>
                返回 <code class="special">{expr}</code> 的双曲余弦值，返回值为 [1, inf] 区间内的浮点数。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回 0.0。
                示例: 
<code class="example">                        :echo cosh(0.5)</code>
                        1.127626 
<code class="example">                        :echo cosh(-0.5)</code>
                        -1.127626

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;cosh()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


count(<code class="special">{comp}</code>, <code class="special">{expr}</code> [, <code class="special">{ic}</code> [, <code class="special">{start}</code>]])              <b class="vimtag"> <a name="count()">count()</a> </b> <b class="vimtag"> <a name="E706">E706</a> </b>
                返回  <a href="eval.html#String">String</a> 、 <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  <code class="special">{comp}</code> 里值为
                <code class="special">{expr}</code> 的项目出现的次数。

                如果给出 <code class="special">{start}</code>，从该索引指定的项目开始。<code class="special">{start}</code> 只能用于
                 <a href="eval.html#List">List</a>  或  <a href="eval.html#Tuple">Tuple</a> 。

                如果给出 <code class="special">{ic}</code> 并且为  <a href="eval.html#TRUE">TRUE</a> ，忽略大小写。

                <code class="special">{comp}</code> 为字符串时返回 <code class="special">{expr}</code> 不重叠的出现次数。<code class="special">{expr}</code> 为空串时
                返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;count(val)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


cscope_connection([<code class="special">{num}</code> , <code class="special">{dbpath}</code> [, <code class="special">{prepend}</code>]])     <b class="vimtag"> <a name="cscope_connection()">cscope_connection()</a> </b>
                检查  <a href="if_cscop.html#cscope">cscope</a>  连接是否存在。如果没有参数，则函数返回:
                        0，如果 cscope 不存在 (编译没有带该特性)，或者不存在
                           cscope 连接；
                        1，如果至少有一个 cscope 连接。

                如果指定了参数，那么 <code class="special">{num}</code> 的值指定如何检查 cscope 连接存在与
                否的方式:

<code class="section">                <code class="special">{num}</code>   存在检查的方式描述 </code>
                -----   ------------------------------
                0       等同于无参数 (例如，"cscope_connection()")。
                1       忽略 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 的字符串部分匹配。
                2       忽略 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 的字符串完整匹配。
                3       使用 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 和 <code class="special">{prepend}</code> 的字符串部
                        分匹配。
                4       使用 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 和 <code class="special">{prepend}</code> 的字符串完
                        整匹配。

                <code class="note">注意</code>: 所有的字符串比较都对大小写敏感！

                示例。假定我们有如下设置 (":cs show" 的输出): 
<code class="example"></code>
<code class="example">  # pid    database name                        prepend path</code>
<code class="example">  0 27664  cscope.out                           /usr/local</code>

<code class="section">                启动方式                                           返回值 </code>
                ----------                                      ---------- 
<code class="example">                cscope_connection()                                     1</code>
<code class="example">                cscope_connection(1, "out")                             1</code>
<code class="example">                cscope_connection(2, "out")                             0</code>
<code class="example">                cscope_connection(3, "out")                             0</code>
<code class="example">                cscope_connection(3, "out", "local")                    1</code>
<code class="example">                cscope_connection(4, "out")                             0</code>
<code class="example">                cscope_connection(4, "out", "local")                    0</code>
<code class="example">                cscope_connection(4, "cscope.out", "/usr/local")        1</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


cursor(<code class="special">{lnum}</code>, <code class="special">{col}</code> [, <code class="special">{off}</code>])                         <b class="vimtag"> <a name="cursor()">cursor()</a> </b>
cursor(<code class="special">{list}</code>)
                把光标定位在第 <code class="special">{lnum}</code> 行的第 <code class="special">{col}</code> 列 (字节计数)。第一列为 1。

                如果只有一个参数 <code class="special">{list}</code>，它被看作带两个、三个或四个参数的
                 <a href="eval.html#List">List</a> :
                        [<code class="special">{lnum}</code>, <code class="special">{col}</code>]
                        [<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{off}</code>]
                        [<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{off}</code>, <code class="special">{curswant}</code>]
                和  <a href="builtin.html#getpos()">getpos()</a>  和  <a href="builtin.html#getcurpos()">getcurpos()</a>  的返回值类似，但没有第一项。

                要用 <code class="special">{col}</code> 作为字符计数来定位光标，用  <a href="builtin.html#setcursorcharpos()">setcursorcharpos()</a> 。

                不改变跳转表。
                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> ，但 <code class="special">{lnum}</code> 为零时除外，此时光标
                留在当前行。
                如果 <code class="special">{lnum}</code> 超过缓冲区的行数，光标定位在缓冲区的末行。
                如果 <code class="special">{lnum}</code> 为零，光标留在当前行。
                如果 <code class="special">{col}</code> 超过该行的字节数，光标定位在该行的最后一个字符上。
                如果 <code class="special">{col}</code> 为零，光标留在当前列。
                如果 <code class="special">{curswant}</code> 给出，它被用于设置垂直移动的首选列，否则使用
                <code class="special">{col}</code>。

                如果使用 <a href="options.html#'virtualedit'">'virtualedit'</a>，<code class="special">{off}</code> 指定从该字符开始以屏幕列计算的偏
                移。例如，在制表里或者在最后一个字符之后的某个位置。
                如果定位成功，返回 0，否则返回 -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCursorPos()-&gt;cursor()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


debugbreak(<code class="special">{pid}</code>)                                       <b class="vimtag"> <a name="debugbreak()">debugbreak()</a> </b>
                专用于中断待调试的程序。给进程 <code class="special">{uid}</code> 发送 SIGTRAP。其它进程的
                行为未指定。见  <a href="terminal.html#terminal-debugger">terminal-debugger</a> 。
                <code class="notvi">{仅适用于 MS-Windows}</code>

                如果成功中断了程序返回  <a href="eval.html#TRUE">TRUE</a> 。否则返回  <a href="eval.html#FALSE">FALSE</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPid()-&gt;debugbreak()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


deepcopy(<code class="special">{expr}</code> [, <code class="special">{noref}</code>])                            <b class="vimtag"> <a name="deepcopy()">deepcopy()</a> </b> <b class="vimtag"> <a name="E698">E698</a> </b>
                构造 <code class="special">{expr}</code> 的备份。对数值和字符串而言，这和直接使用 <code class="special">{expr}</code>
                并无不同。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，建立一个完整的备份。这意味着，原来的
                 <a href="eval.html#List">List</a>  可以被改变，而不会影响新建的备份。反之亦然。如果某个项
                目是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> ，递归地建立它的备份。这样，备份里
                项目的修改也不会影响到原来  <a href="eval.html#List">List</a>  的内容。
                 <a href="eval.html#Tuple">Tuple</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  的复制和  <a href="eval.html#List">List</a>  类似。

                如果省略 <code class="special">{noref}</code> 或为零，包含的  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  只复制
                一次。所有指向它的引用指向此一备份。如果 <code class="special">{noref}</code> 设为 1，每次
                 <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  的出现会导致建立一个新的备份。这意味着
                循环引用会使得 deepcopy() 失败。
                                                        <b class="vimtag"> <a name="E724">E724</a> </b>
                嵌套可达 100 层。如果有指向较高层的引用，<code class="special">{noref}</code> 为 1 的深备份
                会失败。
                另见  <a href="builtin.html#copy()">copy()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetObject()-&gt;deepcopy()</code>

                返回类型: any，取决于 <code class="special">{expr}</code>


delete(<code class="special">{fname}</code> [, <code class="special">{flags}</code>])                             <b class="vimtag"> <a name="delete()">delete()</a> </b>
                无 <code class="special">{flags}</code> 或 <code class="special">{flags}</code> 为空: 删除名为 <code class="special">{fname}</code> 的文件。

                <code class="special">{fname}</code> 可以是符号链接。符号链接本身被删除，而不是它链接到的文
                件。

                如果 <code class="special">{flags}</code> 是 "d": 删除名为 <code class="special">{fname}</code> 的目录。如果目录 <code class="special">{fname}</code>
                非空会失败。

                如果 <code class="special">{flags}</code> 是 "rf": 递归删除名为 <code class="special">{fname}</code> 的目录和其下的所有
                文件。 <code class="emphasis">要小心</code> ！
                <code class="note">备注</code>: 在 MS-Windows 上不能删除正在使用的目录。

                返回类型为数值。如果成功删除文件，返回 0/false，如果删除失败或
                部分失败，返回 -1/御前。

                从  <a href="eval.html#List">List</a>  里删除项目请用  <a href="builtin.html#remove()">remove()</a> 。
                要删除缓冲区的行用  <a href="change.html#:delete">:delete</a>  或  <a href="builtin.html#deletebufline()">deletebufline()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;delete()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


deletebufline(<code class="special">{buf}</code>, <code class="special">{first}</code> [, <code class="special">{last}</code>])                <b class="vimtag"> <a name="deletebufline()">deletebufline()</a> </b>
                删除缓冲区 <code class="special">{buf}</code> 中 <code class="special">{first}</code> 到 <code class="special">{last}</code> (闭区间) 的文本行。
                如果省略 <code class="special">{last}</code>，只删除第 <code class="special">{first}</code> 行。
                成功时返回 0，失败时返回 1。

                此函数只能用于已载入的缓冲区。有必要的话先调用  <a href="builtin.html#bufload()">bufload()</a> 。

                <code class="special">{buf}</code> 的用法见上述的  <a href="builtin.html#bufname()">bufname()</a> 。

                <code class="special">{first}</code> 和 <code class="special">{last}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。<code class="note">注意</code>  <a href="builtin.html#line()">line()</a>  指定当
                前缓冲区。"$" 指定缓冲区 <code class="special">{buf}</code> 的末行。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;deletebufline(1)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


did_filetype()                                          <b class="vimtag"> <a name="did_filetype()">did_filetype()</a> </b>
                如果执行自动命令时，激活 FileType 事件至少一次，则返回
                 <a href="eval.html#TRUE">TRUE</a> 。可以用于防止在检测文件类型的脚本里再次激活 FileType 事
                件。 <a href="autocmd.html#FileType">FileType</a> 
                如果用过 ":setf FALLBACK"，返回  <a href="eval.html#FALSE">FALSE</a> 。
                如果编辑另外一个文件，该计数被复位，因而这只能检查 FileType 事
                件是否在当前缓冲区里激活过。它允许开始编辑另一个缓冲区的自动命
                令设置 <a href="options.html#'filetype'">'filetype'</a> 并载入语法文件。

                返回类型:  <a href="eval.html#Number">Number</a> 


diff(<code class="special">{fromlist}</code>, <code class="special">{tolist}</code> [, <code class="special">{options}</code>])                <b class="vimtag"> <a name="diff()">diff()</a> </b>
                返回包含 <code class="special">{fromlist}</code> 和 <code class="special">{tolist}</code> 里字符串的差异的字符串或列
                表。使用 Vim 内部 diff 库来计算差异。

                                                        <b class="vimtag"> <a name="E106">E106</a> </b>
                <code class="special">{options}</code> 里可选的 "output" 项目指定返回的 diff 格式。支持以下
                值:
                    indices     返回每个差异块的起始与结束索引还有字符串计数的
                                列表。
                    unified     返回合并风格的 (unified) diff 输出字符串。这是
                                缺省。

                如果 <code class="special">{options}</code> 里的 "output" 项目为 "indices"，返回列表。每个
                列表项目包含对应一个差异块的带以下字段的字典:
                    from_idx    此差异块在 <code class="special">{fromlist}</code> 里的开始索引。
                    from_count  此差异块在 <code class="special">{fromlist}</code> 里被新增/删除/修改的字符
                                串数目。
                    to_idx      此差异块在 <code class="special">{tolist}</code> 里的开始索引。
                    to_count    此差异块在 <code class="special">{tolist}</code> 里被新增/删除/修改的字符串
                                数目。

                <code class="special">{options}</code> 字典参数也能指定比较选项 (类似于 <a href="options.html#'diffopt'">'diffopt'</a>)，支持以
                下项目:
                    algorithm           指定使用的比较算法的字典。支持的布尔
                                        项目为 "myers"、"minimal"、"patience"
                                        和 "histogram"。
                    context             差异文上下文行数。缺省为 0。
                    iblank              忽略全空白行的改动。
                    icase               忽略文本大小写的更改。
                    indent-heuristic    内部比较库使用缩进启发。
                    iwhite              忽略空白字符数目的更改。
                    iwhiteall           忽略所有空白字符的更改。
                    iwhiteeol           忽略行尾空白字符的更改。
                这些选项的更多信息详见 <a href="options.html#'diffopt'">'diffopt'</a>。

                为了计算合并风格的 diff，用换行符连接 <code class="special">{fromlist}</code> 里的所有项
                目，然后对 <code class="special">{tolist}</code> 同样处理。合并风格的 diff 输出使用行号。

                如果 <code class="special">{fromlist}</code> 和 <code class="special">{tolist}</code> 等同，返回空列表或空串。

                示例: 
<code class="example">                    :echo diff(['abc'], ['xxx'])</code>
<code class="example">                     @@ -1 +1 @@</code>
<code class="example">                     -abc</code>
<code class="example">                     +xxx</code>
<code class="example"></code>
<code class="example">                    :echo diff(['abc'], ['xxx'], {'output': 'indices'})</code>
<code class="example">                     [{'from_idx': 0, 'from_count': 1, 'to_idx': 0, 'to_count': 1}]</code>
<code class="example">                    :echo diff(readfile('oldfile'), readfile('newfile'))</code>
<code class="example">                    :echo diff(getbufline(5, 1, '$'), getbufline(6, 1, '$'))</code>

                更多例子可见  <a href="diff.html#diff-func-examples">diff-func-examples</a> 

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFromList-&gt;diff(to_list)</code>

                返回类型:  <a href="eval.html#String">String</a>  或 list&lt;dict<code class="special">&lt;number&gt;</code>&gt; 或 list<code class="special">&lt;any&gt;</code>
                取决于 <code class="special">{options}</code>


diff_filler(<code class="special">{lnum}</code>)                                     <b class="vimtag"> <a name="diff_filler()">diff_filler()</a> </b>
                返回第 <code class="special">{lnum}</code> 行之上的填充行的数目。
                这些是在另一个进行比较的窗口里在此位置插入的行。这些填充行在屏
                幕上显示，但缓冲区里并不存在。
                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。所以 "." 是当前行，"'m" 是位置
                标记 m，等等。
                如果当前窗口不处于比较模式，返回 0。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;diff_filler()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


diff_hlID(<code class="special">{lnum}</code>, <code class="special">{col}</code>)                                <b class="vimtag"> <a name="diff_hlID()">diff_hlID()</a> </b>
                返回比较模式下行 <code class="special">{lnum}</code> 和列 <code class="special">{col}</code> (字节位置) 所在的高亮 ID。
                如果当前行没有差异，返回零。
                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。所以 "." 是当前行，"'m" 是位置
                标记 m，等等。
                最左列的 <code class="special">{col}</code> 为 1，第一行的 <code class="special">{lnum}</code> 为 1。
                高亮 ID 可以用于  <a href="builtin.html#synIDattr()">synIDattr()</a> ，以得到高亮对应的语法信息。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;diff_hlID(col)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


digraph_get(<code class="special">{chars}</code>)                                    <b class="vimtag"> <a name="digraph_get()">digraph_get()</a> </b> <b class="vimtag"> <a name="E1214">E1214</a> </b>
                返回 <code class="special">{chars}</code> 对应的二合字母。必须是包含两个字符的字符串。如果
                <code class="special">{chars}</code> 不是两个字符或者 <code class="special">{chars}</code> 对应的二合字母不存在，报错并
                返回空串。

                如有需要，字符会从 Unicode 转化为 <a href="options.html#'encoding'">'encoding'</a>。此种转换必须可
                行，有时可能会失败。

                另见  <a href="builtin.html#digraph_getlist()">digraph_getlist()</a> 。

                示例: 
<code class="example">                " 得到内建的二合字母</code>
<code class="example">                :echo digraph_get('00')         " 返回 '∞'</code>
<code class="example"></code>
<code class="example">                " 得到用户定义的二合字母</code>
<code class="example">                :call digraph_set('aa', 'あ')</code>
<code class="example">                :echo digraph_get('aa')         " 返回 'あ'</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetChars()-&gt;digraph_get()</code>

                返回类型:  <a href="eval.html#String">String</a> 

                仅当编译时加入  <a href="various.html#+digraphs">+digraphs</a>  特性才有效。如果此特性被关闭，此函
                数会报错。


digraph_getlist([<code class="special">{listall}</code>])                            <b class="vimtag"> <a name="digraph_getlist()">digraph_getlist()</a> </b>
                返回二合字母的列表。如果给出 <code class="special">{listall}</code> 参数且为 TRUE，返回所有
                二合字母，包括缺省的二合字母。不然，只返回用户定义的二合字母。

                如有需要，字符会从 Unicode 转化为 <a href="options.html#'encoding'">'encoding'</a>。此种转换必须可
                行，有时可能会失败。

                另见  <a href="builtin.html#digraph_get()">digraph_get()</a> 。

                示例: 
<code class="example">                " 得到用户定义的二合字母</code>
<code class="example">                :echo digraph_getlist()</code>
<code class="example"></code>
<code class="example">                " 得到所有的二合字母，包括缺省的二合字母</code>
<code class="example">                :echo digraph_getlist(1)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetNumber()-&gt;digraph_getlist()</code>

                返回类型: list&lt;list<code class="special">&lt;string&gt;</code>&gt;

                仅当编译时加入  <a href="various.html#+digraphs">+digraphs</a>  特性才有效。如果此特性被关闭，此函
                数会报错。


digraph_set(<code class="special">{chars}</code>, <code class="special">{digraph}</code>)                         <b class="vimtag"> <a name="digraph_set()">digraph_set()</a> </b>
                把二合字母 <code class="special">{chars}</code> 加到列表。<code class="special">{chars}</code> 必须是包含两个字符的字符
                串。<code class="special">{digraph}</code> 为包含单个 UTF-8 编码字符的字符串。 <b class="vimtag"> <a name="E1215">E1215</a> </b>
                小心， <code class="emphasis">不</code> 忽略组合字符。此函数和  <a href="digraph.html#:digraphs">:digraphs</a>  命令类似，但对加
                入由空白开始的二合字母有用。

                如果  <a href="digraph.html#digraph">digraph</a>  已注册，函数返回 v:true。如果失败，报错并返回
                v:false。

                要同时定义多个二合字母，可用  <a href="builtin.html#digraph_setlist()">digraph_setlist()</a> 。

                示例: 
<code class="example">                        call digraph_set('  ', 'あ')</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;digraph_set('あ')</code>

                返回类型:  <a href="vim9.html#vim9-boolean">vim9-boolean</a> 

                仅当编译时加入  <a href="various.html#+digraphs">+digraphs</a>  特性才有效。如果此特性被关闭，此函
                数会报错。


digraph_setlist(<code class="special">{digraphlist}</code>)                          <b class="vimtag"> <a name="digraph_setlist()">digraph_setlist()</a> </b>
                类似于  <a href="builtin.html#digraph_set()">digraph_set()</a> ，但此函数一次加入多个二合字母。
                <code class="special">{digraphlist}</code> 为列表组成的列表，每个列表包含两个字符串，即
                 <a href="builtin.html#digraph_set()">digraph_set()</a>  里描述的 <code class="special">{chars}</code> 和 <code class="special">{digraph}</code>。 <b class="vimtag"> <a name="E1216">E1216</a> </b>
                示例: 
<code class="example">                    call digraph_setlist([['aa', 'あ'], ['ii', 'い']])</code>

                功能相当于: 
<code class="example">                    for [chars, digraph] in [['aa', 'あ'], ['ii', 'い']]</code>
<code class="example">                          call digraph_set(chars, digraph)</code>
<code class="example">                    endfor</code>
                区别在于，如果出现第一个错误，函数立即返回，后续的二合字母不再
                加入。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                    GetList()-&gt;digraph_setlist()</code>

                返回类型:  <a href="vim9.html#vim9-boolean">vim9-boolean</a> 

                仅当编译时加入  <a href="various.html#+digraphs">+digraphs</a>  特性才有效。如果此特性被关闭，此函
                数会报错。


echoraw(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="echoraw()">echoraw()</a> </b>
                照原样输出 <code class="special">{expr}</code>，包括非显示字符。可用于输出终端代码。例如，
                要关闭 modifyOtherKeys: 
<code class="example">                        call echoraw(&amp;t_TE)</code>
                要再次打开之: 
<code class="example">                        call echoraw(&amp;t_TI)</code>
                使用时要小心，容易把终端搞乱。

                返回类型:  <a href="eval.html#Number">Number</a> 


empty(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="empty()">empty()</a> </b>
                如果 <code class="special">{expr}</code> 为空，返回数值 1，否则返回 0。
                -  <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  没有项目时为空。
                -  <a href="eval.html#String">String</a>  的长度为零时为空。
                -  <a href="eval.html#Number">Number</a>  或  <a href="eval.html#Float">Float</a>  的值为零时为空。
                -  <a href="eval.html#v:false">v:false</a> 、 <a href="eval.html#v:none">v:none</a>  和  <a href="eval.html#v:null">v:null</a>  为空， <a href="eval.html#v:true">v:true</a>  不是。
                - 启动失败的  <a href="eval.html#Job">Job</a>  为空。
                - 己关闭的  <a href="eval.html#Channel">Channel</a>  为空。
                -  <a href="eval.html#Blob">Blob</a>  的长度为零时为空。
                -  <a href="vim9class.html#Object">Object</a>  (如果对象存在) 的 empty() 方法返回真值时为空

                如果  <a href="eval.html#List">List</a>  很大，这比把长度和零比较要快得多。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;empty()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


environ()                                               <b class="vimtag"> <a name="environ()">environ()</a> </b>
                返回所有的环境变量构成的字典。可以这样检查某个环境变量是否存
                在: 
<code class="example">                        :echo has_key(environ(), 'HOME')</code>
                <code class="note">注意</code> 变量名可以是驼峰式 (CamelCase) 的，要忽略大小写，可以这
                样: 
<code class="example">                        :echo index(keys(environ()), 'HOME', 0, 1) != -1</code>

                返回类型: dict<code class="special">&lt;string&gt;</code>


err_teapot([<code class="special">{expr}</code>])                                    <b class="vimtag"> <a name="err_teapot()">err_teapot()</a> </b>
                生成编号为 418 的错误，为实现 RFC 2324 而设计。
                如果 <code class="special">{expr}</code> 存在且为 TRUE，给出 503 错误，指示咖啡暂未准备好。
                <code class="special">{expr}</code> 存在时必须为字符串 (<code class="vim">译者注</code>: 原文如此)。

                返回类型:  <a href="eval.html#Number">Number</a> 


escape(<code class="special">{string}</code>, <code class="special">{chars}</code>)                               <b class="vimtag"> <a name="escape()">escape()</a> </b>
                在 <code class="special">{string}</code> 里用反斜杠转义 <code class="special">{chars}</code> 里的字符。例如: 
<code class="example">                        :echo escape('c:\program files\vim', ' \')</code>
                返回: 
<code class="example">                        c:\\program\ files\\vim</code>
                另见  <a href="builtin.html#shellescape()">shellescape()</a>  和  <a href="builtin.html#fnameescape()">fnameescape()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;escape(' \')</code>

                返回类型:  <a href="eval.html#String">String</a> 


eval(<code class="special">{string}</code>)                                          <b class="vimtag"> <a name="eval()">eval()</a> </b>
                计算 <code class="special">{string}</code> 并返回其结果。这对把  <a href="builtin.html#string()">string()</a>  的结果转换为原来
                的值尤其有用。适用于数值、浮点数、字符串、blob 和它们的复合类
                型。也可用于指向已有函数的  <a href="eval.html#Funcref">Funcref</a> 。 <a href="vim9.html#Vim9">Vim9</a>  脚本里，可用于从
                 <a href="vim9class.html#enum">enum</a>  的完全限定名获取对应的值。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        argv-&gt;join()-&gt;eval()</code>

                返回类型: any，取决于 <code class="special">{string}</code>


eventhandler()                                          <b class="vimtag"> <a name="eventhandler()">eventhandler()</a> </b>
                如果在事件处理中则返回 1。此时，Vim 在等待用户输入一个字符的时
                候被中断，比如，在 Vim 上拖放了一个文件。这也意味着此时不能使
                用交互的命令。如果不是，返回零。

                返回类型:  <a href="eval.html#Number">Number</a> 


executable(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="executable()">executable()</a> </b>
                本函数检查名字由 <code class="special">{expr}</code> 指定的可执行文件存在与否。<code class="special">{expr}</code> 必须
                是程序不带任何参数的名字。

                executable() 使用 $PATH 的值和/或程序的普通的搜索路径。
                                                        <b class="vimtag"> <a name="PATHEXT">PATHEXT</a> </b>
                MS-Windows 上，可以可选地包含 ".exe"、".bat" 等。为此，
                $PATHEXT 里的扩展名会被尝试。这样，如果 "foo.exe" 不存在，可能
                会找到 "foo.exe.bat"。如果没有设置 $PATHEXT，使用的是
                ".com;.exe;.bat;.cmd"。$PATHEXT 里可以使用单独的句号，以尝试没
                有扩展名的名字。如果 <a href="options.html#'shell'">'shell'</a> 看起来像 Unix 外壳，那么也尝试没
                有扩展名的名字。
                MS-Windows 上，只检查是否文件存在且不是目录，并不检查它是否真
                的可以执行。
                MS-Windows 上，和 Vim 程序在同一目录的可执行文件通常能找到。因
                为这个目录加到了 $PATH 里，执行应该也没有问题  <a href="os_win32.html#win32-PATH">win32-PATH</a> 。
                                        <b class="vimtag"> <a name="NoDefaultCurrentDirectoryInExePath">NoDefaultCurrentDirectoryInExePath</a> </b>
                MS-Windows 上，Vim 当前工作目录下的可执行文件通常也能找到，但
                此行为可通过设置 $NoDefaultCurrentDirectoryInExePath 环境变量
                来关闭。

                返回数值:
                        1       存在
                        0       不存在
                        -1      此系统中没有实现
                 <a href="builtin.html#exepath()">exepath()</a>  可用于获取可执行文件的完整路径。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCommand()-&gt;executable()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


execute(<code class="special">{command}</code> [, <code class="special">{silent}</code>])                         <b class="vimtag"> <a name="execute()">execute()</a> </b>
                执行 Ex 命令或命令序列，返回结果为字符串。
                <code class="special">{command}</code> 可以是字符串或列表。如果是列表，逐行执行命令。
                这或多或少等价于: 
<code class="example">                        redir =&gt; var</code>
<code class="example">                        {command}</code>
<code class="example">                        redir END</code>
                但不识别 <code class="special">{command}</code> 里的续行。

                可选的 <code class="special">{silent}</code> 参数可取以下的值:
                        ""              不用  <a href="various.html#:silent">:silent</a> 
                        "silent"        用  <a href="various.html#:silent">:silent</a> 
                        "silent!"       用  <a href="various.html#:silent!">:silent!</a> 
                缺省是 "silent"。<code class="note">注意</code> 用 "silent!" 时，和  <a href="various.html#:redir">:redir</a>  不同，错误
                被忽略。使用外部命令时，屏幕可能会搞乱，可用  <a href="builtin.html#system()">system()</a>  代替。
                                                        <b class="vimtag"> <a name="E930">E930</a> </b>
                <code class="special">{command}</code> 里不可用  <a href="various.html#:redir">:redir</a> 。

                要得到行的列表，在结果上用  <a href="builtin.html#split()">split()</a> : 
<code class="example">                        execute('args')-&gt;split("\n")</code>
<code class="example"></code>
                要在非当前窗口的其它窗口中执行命令，用  <a href="builtin.html#win_execute()">win_execute()</a> 。

                递归调用时，内层的输出结果不包含在外层的结果里。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCommand()-&gt;execute()</code>

                返回类型:  <a href="eval.html#String">String</a> 


exepath(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="exepath()">exepath()</a> </b>
                如果 <code class="special">{expr}</code> 是可执行文件并且是绝对路径、相对路径或可在 $PATH
                是找到，返回完整路径。
                <code class="note">注意</code> 如果 <code class="special">{expr}</code> 以 "./" 开始，使用当前路径，这对 Vim 可能是个
                问题: 
<code class="example">                        echo exepath(v:progpath)</code>
                如果 <code class="special">{expr}</code> 在 $PATH 里找不到，或者不可执行，返回空字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCommand()-&gt;exepath()</code>

                返回类型:  <a href="eval.html#String">String</a> 


exists(<code class="special">{expr}</code>)                                          <b class="vimtag"> <a name="exists()">exists()</a> </b>
                返回数值，如果 <code class="special">{expr}</code> 被定义，返回  <a href="eval.html#TRUE">TRUE</a> ，不然返回零。

                <code class="note">备注</code>: 在编译过的  <a href="vim9.html#:def">:def</a>  函数里，计算在运行时完成。要在编译时计
                算表达式，可用  <a href="builtin.html#exists_compiled()">exists_compiled()</a> 。

                要检查某特性是否支持，用  <a href="builtin.html#has()">has()</a> 。
                要检查文件是否存在，用  <a href="builtin.html#filereadable()">filereadable()</a> 。

                <code class="special">{expr}</code> 参数是字符串，可以使用以下选择之一:
                        varname         内部变量 (见  <a href="eval.html#internal-variables">internal-variables</a> )。也
                        dict.key        适用于  <a href="eval.html#curly-braces-names">curly-braces-names</a> 、
                        list[i]          <a href="eval.html#Dictionary">Dictionary</a>  项目、 <a href="eval.html#List">List</a>  项目、类和对
                        import.Func     象方法、导入项目等等。
                        class.Func      不适用于编译过的  <a href="vim9.html#:def">:def</a>  函数里的局部变
                        object.Func     量。
                        class.varname   也可用于  <a href="vim9.html#Vim9">Vim9</a>  脚本里的函数，因为它被
                        object.varname  视作函数引用。
                                        小心计算索引时可能会因为非法的表达式产
                                        生错误信息。例如: 
<code class="example">                                           :let l = [1, 2, 3]</code>
<code class="example">                                           :echo exists("l[5]")</code>
                                           0 
<code class="example">                                           :echo exists("l[xx]")</code>
                                           E121: Undefined variable: xx
                                           0
                        &amp;option-name    Vim 选项 (只检查是否存在，而不是是否工
                                        作)
                        +option-name    能工作的 Vim 选项。
                        $ENVNAME        环境变量 (也可以通过和空字符串比较完
                                        成)
                        *funcname       已实现的内建函数 (见  <a href="eval.html#functions">functions</a> ) 或者
                                        用户定义的函数 (见  <a href="eval.html#user-functions">user-functions</a> )。
                                        也可用于指向函数引用的变量。
                        ?funcname       可实现的内建函数；用于检查 "funcname"
                                        是否合法
                        :cmdname        Ex 命令: 内建命令、用户命令或者命令修
                                        饰符  <a href="map.html#:command">:command</a> 。
                                        返回:
                                        1  匹配命令的开始
                                        2  完整匹配命令
                                        3  匹配多个用户命令
                                        要检查命令是否支持，检查返回值是否为
                                        2。
                        :2match          <a href="pattern.html#:2match">:2match</a>  命令。
                        :3match          <a href="pattern.html#:3match">:3match</a>  命令 (你可能用不上，这是为内
                                        部保留的)。
                        #event          符合此事件的自动命令
                        #event#pattern  符合此事件和此模式的自动命令 (模式按本
                                        义出现，和自动命令的模式逐字符比较)
                        #group          存在自动命令组
                        #group#event    在该组里定义并符合此事件的自动命令。
                        #group#event#pattern
                                        为该组定义、符合事件和模式的自动命令。
                        ##event         支持此事件的自动命令。

                例如: 
<code class="example">                        exists("&amp;shortname")</code>
<code class="example">                        exists("$HOSTNAME")</code>
<code class="example">                        exists("*strftime")</code>
<code class="example">                        exists("*s:MyFunc")     " 只适用于老式脚本</code>
<code class="example">                        exists("*MyFunc")</code>
<code class="example">                        exists("bufcount")</code>
<code class="example">                        exists(":Make")</code>
<code class="example">                        exists("#CursorHold")</code>
<code class="example">                        exists("#BufReadPre#*.gz")</code>
<code class="example">                        exists("#filetypeindent")</code>
<code class="example">                        exists("#filetypeindent#FileType")</code>
<code class="example">                        exists("#filetypeindent#FileType#*")</code>
<code class="example">                        exists("##ColorScheme")</code>
                符号 (&amp;/$/*/#) 和名字之间不能有空格。
                名字之后不能有附加字符，虽然现在有一些情况下会忽略这些字符，但
                将来的检查可能更严格。所以不要依赖此行为！
                可以通过的例子: 
<code class="example">                        exists(":make")</code>
                 <code class="emphasis">不</code> 能通过的例子: 
<code class="example">                        exists(":make install")</code>
<code class="example"></code>
                <code class="note">注意</code> 参数必须是字符串，不是变量的名字本身。例如: 
<code class="example">                        exists(bufcount)</code>
                不检查 "bufcount" 变量是否存在，而是提取 "bufcount" 的值，并检
                查其 (根据此处的语法) 是否存在。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Varname()-&gt;exists()</code>

                返回类型:  <a href="eval.html#String">String</a> 


exists_compiled(<code class="special">{expr}</code>)                                 <b class="vimtag"> <a name="exists_compiled()">exists_compiled()</a> </b>
                类似于  <a href="builtin.html#exists()">exists()</a>  但在编译时计算。可用于跳过函数未定义时会报错
                的程序块: 
<code class="example">                        if exists_compiled('*ThatFunction')</code>
<code class="example">                           ThatFunction('works')</code>
<code class="example">                        endif</code>
                如果用  <a href="builtin.html#exists()">exists()</a> ，ThatFunction() 未定义时会报告编译错误。

                <code class="special">{expr}</code> 必须是按本义出现的字符串。 <b class="vimtag"> <a name="E1232">E1232</a> </b>
                只可用于  <a href="vim9.html#:def">:def</a>  函数中。 <b class="vimtag"> <a name="E1233">E1233</a> </b>
                不能用于检查参数或局部变量。

                返回类型:  <a href="eval.html#String">String</a> 


exp(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="exp()">exp()</a> </b>
                返回 <code class="special">{expr}</code> 的指数函数值，返回值为 [0, inf] 区间内的浮点数。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或者  <a href="eval.html#Number">Number</a> 。否则返回 0.0。
                示例: 
<code class="example">                        :echo exp(2)</code>
                        7.389056 
<code class="example">                        :echo exp(-1)</code>
                        0.367879

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;exp()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


expand(<code class="special">{string}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code>]])                 <b class="vimtag"> <a name="expand()">expand()</a> </b>
                扩展 <code class="special">{string}</code> 里的通配符和下列特殊关键字。
                <a href="options.html#'wildignorecase'">'wildignorecase'</a> 此处适用。

                如果给出 <code class="special">{list}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，返回列表。否则返回的是字符串，且
                如果返回多个匹配，以 <code class="special">&lt;NL&gt;</code> 字符分隔 [<code class="note">备注</code>: 5.0 版本使用空格。但
                是文件名如果也包含空格就会有问题]。

                如果扩展失败，返回空字符串。如果 <code class="special">{string}</code> 以 '%'，'#' 或 '&lt;'
                开始，不返回不存在的文件名。详见下。

                 <a href="terminal.html#:terminal">:terminal</a>  窗口里 '%' 扩展为 '!' 后跟运行中的命令或外壳。
                 <a href="terminal.html#terminal-bufname">terminal-bufname</a> 

                如果 <code class="special">{string}</code> 以 '%'、'#' 或 '&lt;' 开始，以类似于
                 <a href="cmdline.html#cmdline-special">cmdline-special</a>  变量的方式扩展，包括相关的修饰符。这里是一个
                简短的小结:

                        %               当前文件名
                        #               轮换文件名
                        #n              轮换文件名 n
                        <code class="special">&lt;cfile&gt;</code>         光标所在的文件名
                        <code class="special">&lt;afile&gt;</code>         自动命令文件名
                        <code class="special">&lt;abuf&gt;</code>          自动命令缓冲区号 (以字符串形式出现！)
                        <code class="special">&lt;amatch&gt;</code>        自动命令匹配的名字
                        <code class="special">&lt;cexpr&gt;</code>         光标所在的 C 表达式
                        <code class="special">&lt;sfile&gt;</code>         载入的脚本文件或函数名
                        <code class="special">&lt;slnum&gt;</code>         载入脚本文件行号或函数行号
                        <code class="special">&lt;sflnum&gt;</code>        脚本文件行号，即使在函数中亦然
                        <code class="special">&lt;SID&gt;</code>           "<code class="special">&lt;SNR&gt;</code>123_"  其中 "123" 是当前脚本 ID
                                         <a href="map.html#%3CSID%3E">&lt;SID&gt;</a> 
                        <code class="special">&lt;script&gt;</code>        执行中的脚本文件，或当前函数定义所在的
                                        脚本文件
                        <code class="special">&lt;stack&gt;</code>         调用栈
                        <code class="special">&lt;cword&gt;</code>         光标所在的单词
                        <code class="special">&lt;cWORD&gt;</code>         光标所在的字串 (WORD)
                        <code class="special">&lt;client&gt;</code>        最近收到的消息的 <code class="special">{clientid}</code>
                                         <a href="builtin.html#server2client()">server2client()</a> 
                修饰符:
                        :p              扩展为完整的路径
                        :h              头部 (去掉最后一个部分)
                        :t              尾部 (只保留最后一个部分)
                        :r              根部 (去掉一个扩展名)
                        :e              只有扩展名

                还支持其它修饰符，完整列表见  <a href="cmdline.html#filename-modifiers">filename-modifiers</a> 。

                例如: 
<code class="example">                        :let &amp;tags = expand("%:p:h") .. "/tags"</code>
                <code class="note">注意</code> 扩展 '%'、'#' 或者 '&lt;' 开头的字符串的时候，其后的文本被忽
                略。这样 <code class="emphasis">不</code> 行: 
<code class="example">                        :let doesntwork = expand("%:h.bak")</code>
                应该这样: 
<code class="example">                        :let doeswork = expand("%:h") .. ".bak"</code>
                还要 <code class="note">注意</code> 扩展 "<code class="special">&lt;cfile&gt;</code>" 和其它形式只能返回被引用的文件名，而
                不会进一步扩展。如果 "<code class="special">&lt;cfile&gt;</code>" 是 "~/.cshrc"，你需要执行另一个
                expand() 把 "~/" 扩展为主目录的路径: 
<code class="example">                        :echo expand(expand("&lt;cfile&gt;"))</code>

                变量名和其后的修饰符之间不能有空白。 <a href="builtin.html#fnamemodify()">fnamemodify()</a>  函数可以用
                来修改普通的文件名。

                使用 '%' 或 '#' 但当前或轮换文件名没有定义的时候，使用空字符
                串。在无名缓冲区使用 "%:p"  生成当前目录，后加一个 '/'。
                如果设置了 <a href="options.html#'verbose'">'verbose'</a>，'%'、'#' 和 <code class="special">&lt;&gt;</code> 项目的扩展如果失败会报
                错。

                如果 <code class="special">{string}</code> 不以 '%'、'#' 或 '&lt;' 开始，它以命令行上的文件名
                那样被扩展。使用 <a href="options.html#'suffixes'">'suffixes'</a> 和 <a href="options.html#'wildignore'">'wildignore'</a>，除非给出可选的
                <code class="special">{nosuf}</code> 参数而且为  <a href="eval.html#TRUE">TRUE</a> 。
                这里可以有不存在的文件的名字。"**" 项目可以用来在目录树里查
                找。例如，要寻找当前目录及其下目录的所有的 "README": 
<code class="example">                        :echo expand("**/README")</code>

                expand() 也可用来扩展变量和只有外壳知道的环境变量。但这会很
                慢，因为需要使用外壳才能进行扩展。见  <a href="eval.html#expr-env-expand">expr-env-expand</a> 。
                扩展后的变量还是被当作文件名的列表处理。如果不能扩展环境变量，
                保留其不变。这样，":echo expand('$FOOBAR')" 返回的还是
                "$FOOBAR"。

                 <a href="builtin.html#glob()">glob()</a>  说明如何找到存在的文件。 <a href="builtin.html#system()">system()</a>  说明如何得到外部命
                令的原始输出。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Getpattern()-&gt;expand()</code>

                返回类型:  <a href="eval.html#String">String</a>  或 list<code class="special">&lt;string&gt;</code>，取决于 <code class="special">{list}</code>


expandcmd(<code class="special">{string}</code> [, <code class="special">{options}</code>])                       <b class="vimtag"> <a name="expandcmd()">expandcmd()</a> </b>
                像  <a href="editing.html#:edit">:edit</a>  这样的 Ex 命令那样扩展字符串 <code class="special">{string}</code> 里的特殊项
                目。在 <code class="special">{string}</code> 的所有位置像  <a href="builtin.html#expand()">expand()</a>  那样扩展特殊关键字，也
                扩展环境变量。"~user" 和 "~/path" 只在开始处被扩展。

                <code class="special">{option}</code> 字典参数支持以下项目:
                    errmsg      设为 TRUE 时，报告扩展时出现的错误。缺省不回显
                                错误信息。

                返回扩展后的字符串。如果扩展时出错，返回未修改的 <code class="special">{string}</code>。

                示例: 
<code class="example">                        :echo expandcmd('make %&lt;.o')</code>
<code class="example">                        make /path/runtime/doc/builtin.o</code>
<code class="example">                        :echo expandcmd('make %&lt;.o', {'errmsg': v:true})</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCommand()-&gt;expandcmd()</code>

                返回类型:  <a href="eval.html#String">String</a>  或 list<code class="special">&lt;string&gt;</code>，取决于 <code class="special">{list}</code>


extend(<code class="special">{expr1}</code>, <code class="special">{expr2}</code> [, <code class="special">{expr3}</code>])                    <b class="vimtag"> <a name="extend()">extend()</a> </b>
                <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 必须都是  <a href="eval.html#List">List</a>  或者都是  <a href="eval.html#Dictionary">Dictionary</a> 。

                如果都是  <a href="eval.html#List">List</a> : 把 <code class="special">{expr2}</code> 附加到 <code class="special">{expr1}</code> 之后。
                如果给出 <code class="special">{expr3}</code>，把 <code class="special">{expr2}</code> 里的项目加到 <code class="special">{expr1}</code> 中索引为
                <code class="special">{expr3}</code> 的项目之前。如果 <code class="special">{expr3}</code> 为零，插在第一个项目之前。如
                果 <code class="special">{expr3}</code> 等于 len(<code class="special">{expr1}</code>)，那么 <code class="special">{expr2}</code> 会附加在最后。
                例如: 
<code class="example">                        :echo sort(extend(mylist, [7, 5]))</code>
<code class="example">                        :call extend(mylist, [2, 3], 1)</code>
                如果 <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 是同一个列表，复制的项目数等于列表原来
                的长度。例如，如果 <code class="special">{expr}</code> 为 1，则复制列表首值 N 次 (N 是列表
                原来的长度)。
                用  <a href="builtin.html#add()">add()</a>  把一个项目加入列表。要连接两个列表成为一个新列表，
                用 + 操作符: 
<code class="example">                        :let newlist = [1, 2, 3] + [4, 5]</code>

                如果都是  <a href="eval.html#Dictionary">Dictionary</a> : 把 <code class="special">{expr2}</code> 里的所有项目加入 <code class="special">{expr1}</code>。
                如果 <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 包含相同的键，那么 <code class="special">{expr3}</code> 决定应该怎
                么做:
                <code class="special">{expr3}</code> = "keep": 保持 <code class="special">{expr1}</code> 的值
                <code class="special">{expr3}</code> = "force": 使用 <code class="special">{expr2}</code> 的值
                <code class="special">{expr3}</code> = "error": 给出错误信息                         <b class="vimtag"> <a name="E737">E737</a> </b>
                如果省略 <code class="special">{expr3}</code>，假设使用 "force"。

                只要 <code class="special">{expr2}</code> 非空，<code class="special">{expr1}</code> 就被改变。如果需要，给 <code class="special">{expr1}</code> 先做
                个备份，或者用  <a href="builtin.html#extendnew()">extendnew()</a>  返回新的列表/字典。
                <code class="special">{expr2}</code> 保持不变。
                如果 <code class="special">{expr1}</code> 被锁住且 <code class="special">{expr2}</code> 非空，操作失败。
                返回 <code class="special">{expr1}</code>。出错时返回 0。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;extend(otherlist)</code>

                返回类型: list&lt;<code class="special">{type}</code>&gt; 或 dict&lt;<code class="special">{type}</code>&gt;，取决于 <code class="special">{expr1}</code> 和
                <code class="special">{expr2}</code>，出错时:  <a href="eval.html#Number">Number</a> 


extendnew(<code class="special">{expr1}</code>, <code class="special">{expr2}</code> [, <code class="special">{expr3}</code>])                 <b class="vimtag"> <a name="extendnew()">extendnew()</a> </b>
                和  <a href="builtin.html#extend()">extend()</a>  类似，但不是新增项目到 <code class="special">{expr1}</code>，而是创建并返回新
                列表或字典。<code class="special">{expr1}</code> 保持不变。

                返回类型: list&lt;<code class="special">{type}</code>&gt; 或 dict&lt;<code class="special">{type}</code>&gt;，取决于 <code class="special">{expr1}</code> 和
                <code class="special">{expr2}</code>，出错时:  <a href="eval.html#Number">Number</a> 


feedkeys(<code class="special">{string}</code> [, <code class="special">{mode}</code>])                           <b class="vimtag"> <a name="feedkeys()">feedkeys()</a> </b>
                将 <code class="special">{string}</code> 里的字符放在队列里等候处理，就像它们来自映射或者用
                户输入一样。

                缺省它们加在预输入 (typeahead) 缓冲区的尾端，所以如果
                仍然在执行映射，这些字符会出现在映射内容之后。用 'i' 标志位则
                插入位置在其它字符之前，这样，它们在映射其它字符之前就会执行。

                该函数不会等待 <code class="special">{string}</code> 包含的键处理完毕。

                <code class="special">{string}</code> 如果要包含特殊键，可以使用双引号和 "\..." 记法
                 <a href="eval.html#expr-quote">expr-quote</a> 。例如，feedkeys("\<code class="special">&lt;CR&gt;</code>") 会模拟 <code class="special">&lt;Enter&gt;</code> 键击。但
                feedkeys('\<code class="special">&lt;CR&gt;</code>') 却实际压入五个字符。
                一个可能有用的特殊代码是 <code class="special">&lt;Ignore&gt;</code>，它会结束等待字符输入而不做
                任何事。                                <b class="vimtag"> <a name="%3CIgnore%3E">&lt;Ignore&gt;</a> </b>

                <code class="special">{mode}</code> 是字符串，包含以下字符标志位:
                'm'     对键重映射。缺省。如果不给出 <code class="special">{mode}</code>，键会经过重映射。
                'n'     不对键重映射。
                't'     像用户输入那样处理键；如果不包含，像来自映射一样处理。
                        这会影响撤销、打开折叠等行为。
                'L'     底层输入。只用于 Unix 或 GUI。键的使用就像来自终端那
                        样。不使用其它标志位。          <b class="vimtag"> <a name="E980">E980</a> </b>
                        <code class="keystroke">CTRL-C</code> 中断且包含 't' 标志位时，设置内部 "got_int" 标
                        志位。
                'i'     插入字符串而不是附加 (见上)。
                'x'     执行命令，直至预输入为空为止。和 ":normal!" 类似。可以
                        不带 'x' 执行 feedkeys() 数次，然后一次性执行带 'x' 的
                        (可以只带空 <code class="special">{string}</code>) 来执行所有的输入。<code class="note">注意</code> Vim 退出
                        插入模式时行为就如同按了 <code class="special">&lt;Esc&gt;</code> 那样，以避免在脚本可以
                        继续前等待字符键入的阻塞情况。
                        <code class="note">注意</code> 你执行命令时调用了 feedkeys()，会导致递归调用，而
                        所有的预输入会被最后的那个调用消耗。
                'c'     执行时移除脚本上下文，以便应用老式的脚本语法，不适用
                        "s:var" 等等。<code class="note">注意</code> 如果放入队列的字符串是用于设置脚本
                        上下文的，这依然有效。
                '!'     使用 'x' 时不停止插入模式。可用于使定时器稍晚点才退出
                        插入状态的测试环境。对测试 CursorHoldI 有用。

                返回值总为 0。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetInput()-&gt;feedkeys()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


filecopy(<code class="special">{from}</code>, <code class="special">{to}</code>)                                  <b class="vimtag"> <a name="filecopy()">filecopy()</a> </b>
                复制文件 <code class="special">{from}</code> 到 <code class="special">{to}</code>。返回值为数值，文件复制成功为  <a href="eval.html#TRUE">TRUE</a> ，
                失败则为  <a href="eval.html#FALSE">FALSE</a> 。
                如果名为 <code class="special">{to}</code> 的文件已存在，此函数会失败。
                <code class="note">注意</code> 此函数 (尚) 不处理目录。

                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetOldName()-&gt;filecopy(newname)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


filereadable(<code class="special">{file}</code>)                                    <b class="vimtag"> <a name="filereadable()">filereadable()</a> </b>
                返回数值，如果名为 <code class="special">{file}</code> 的文件存在且可读，则为  <a href="eval.html#TRUE">TRUE</a> 。如果
                <code class="special">{file}</code> 不存在，或者是一个目录，返回  <a href="eval.html#FALSE">FALSE</a> 。<code class="special">{file}</code> 可以是任何
                返回字符串的表达式。
                如果你不关心文件是否可读，可用  <a href="builtin.html#glob()">glob()</a> 。
                按本义使用 <code class="special">{file}</code>，你可能需要先扩展通配符: 
<code class="example">                        echo filereadable('~/.vimrc')</code>
<code class="example">                        0</code>
<code class="example">                        echo filereadable(expand('~/.vimrc'))</code>
<code class="example">                        1</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;filereadable()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                                                        <b class="vimtag"> <a name="file_readable()">file_readable()</a> </b>
                已废弃的名字: file_readable()。


filewritable(<code class="special">{file}</code>)                                    <b class="vimtag"> <a name="filewritable()">filewritable()</a> </b>
                返回数值，如果名为 <code class="special">{file}</code> 的文件存在且可写，则为 1。如果
                <code class="special">{file}</code> 不存在，或者不可写，返回 0。如果 <code class="special">{file}</code> 是一个目录但是
                可写，返回 2。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;filewritable()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


filter(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                <b class="vimtag"> <a name="filter()">filter()</a> </b>
                <code class="special">{expr1}</code> 必须是  <a href="eval.html#List">List</a>  、 <a href="eval.html#String">String</a> 、 <a href="eval.html#Blob">Blob</a>  或者  <a href="eval.html#Dictionary">Dictionary</a> 。
                对 <code class="special">{expr1}</code> 里的每个项目计算 <code class="special">{expr2}</code>，如果结果为零或假值，从该
                 <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  里删除该项目。类似方法用于检视  <a href="eval.html#Blob">Blob</a> 
                里的每个字节和  <a href="eval.html#String">String</a>  里的每个字符。

                <code class="special">{expr2}</code> 必须是  <a href="eval.html#string">string</a>  或  <a href="eval.html#Funcref">Funcref</a> 。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#string">string</a> ，<code class="special">{expr2}</code> 内的  <a href="eval.html#v:val">v:val</a>  包含当前项目的
                值。 <a href="eval.html#Dictionary">Dictionary</a>  中  <a href="eval.html#v:key">v:key</a>  包含当前项目的键。 <a href="eval.html#List">List</a>  中
                 <a href="eval.html#v:key">v:key</a>  包含当前项目的索引。 <a href="eval.html#Blob">Blob</a>  中  <a href="eval.html#v:key">v:key</a>  包含当前字节的索
                引。 <a href="eval.html#String">String</a>  中  <a href="eval.html#v:key">v:key</a>  包含当前字符的索引。
                例如: 
<code class="example">                        call filter(mylist, 'v:val !~ "OLD"')</code>
                删除所有出现 "OLD" 的项目。 
<code class="example">                        call filter(mydict, 'v:key &gt;= 8')</code>
                删除所有键小于 8 的值。 
<code class="example">                        call filter(var, 0)</code>
                删除所有的值，从而清除该  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#Funcref">Funcref</a> ，它必须接受两个参数:
                        1. 当前项目的键或索引。
                        2. 当前项目的值。
                如果该项目应保留，此函数必须返回  <a href="eval.html#TRUE">TRUE</a> 。
                例如要保留列表中奇数项目: 
<code class="example">                        func Odd(idx, val)</code>
<code class="example">                          return a:idx % 2 == 1</code>
<code class="example">                        endfunc</code>
<code class="example">                        call filter(mylist, function('Odd'))</code>
                使用  <a href="eval.html#lambda">lambda</a>  会更短。 <a href="vim9.html#Vim9">Vim9</a>  语法: 
<code class="example">                        call filter(myList, (idx, val) =&gt; idx * val &lt;= 42)</code>
                老式脚本语法: 
<code class="example">                        call filter(myList, {idx, val -&gt; idx * val &lt;= 42})</code>
                如果不用 "val"，可以不写: 
<code class="example">                        call filter(myList, {idx -&gt; idx % 2 == 1})</code>

                 <a href="vim9.html#Vim9">Vim9</a>  脚本中，计算结果必须为真值、假值、零或一。其他值会报告
                类型错误。

                对  <a href="eval.html#List">List</a>  和  <a href="eval.html#Dictionary">Dictionary</a>  而言，该操作是原位操作 (直接在输入上
                修改)。要想不更动，先建立备份: 
<code class="example">                        :let l = filter(copy(mylist), 'v:val =~ "KEEP"')</code>
<code class="example"></code>
                返回 <code class="special">{expr1}</code>，即经过过滤的  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> ，或者新的
                 <a href="eval.html#Blob">Blob</a>  或  <a href="eval.html#String">String</a> 。
                如果执行 <code class="special">{expr2}</code> 有错，不再处理 <code class="special">{expr1}</code> 的其余项目。<code class="special">{expr2}</code> 是
                函数引用时，忽略函数里的错误，除非该函数用 "abort" 标志位定
                义。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;filter(expr2)</code>

                返回类型:  <a href="eval.html#String">String</a> 、 <a href="eval.html#Blob">Blob</a> 、list&lt;<code class="special">{type}</code>&gt; 或 dict&lt;<code class="special">{type}</code>&gt;，
                取决于 <code class="special">{expr1}</code>


finddir(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{count}</code>]])                  <b class="vimtag"> <a name="finddir()">finddir()</a> </b>
                在 <code class="special">{path}</code> 里查找目录 <code class="special">{name}</code>。支持向下和向上的递归目录搜索。
                <code class="special">{path}</code> 的语法参见  <a href="editing.html#file-searching">file-searching</a> 。

                返回第一个找到的路径。如果找到的路径在当前目录之下，返回相对路
                径。否则，返回完整路径。
                如果省略 <code class="special">{path}</code>，使用 <a href="options.html#'path'">'path'</a>。

                如果给出可选的 <code class="special">{count}</code>，寻找 <code class="special">{path}</code> 里 <code class="special">{name}</code> 第 <code class="special">{count}</code> 次出
                现，而不是第一次。
                如果 <code class="special">{count}</code> 为负，返回所有的匹配的列表。

                如果目录没找到，返回空串。

                这和 ex 命令  <a href="editing.html#:find">:find</a>  非常类似。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;finddir()</code>

                返回类型: <code class="special">{count}</code> 为负时是 list<code class="special">&lt;string&gt;</code>，否则是  <a href="eval.html#String">String</a> 


findfile(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{count}</code>]])                 <b class="vimtag"> <a name="findfile()">findfile()</a> </b>
                类似于  <a href="builtin.html#finddir()">finddir()</a> ，不过寻找文件而不是目录。
                使用 <a href="options.html#'suffixesadd'">'suffixesadd'</a>。
                例如: 
<code class="example">                        :echo findfile("tags.vim", ".;")</code>
                从当前文件所在的目录开始往上搜索，直到找到文件 "tags.vim" 为
                止。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;findfile()</code>

                返回类型: <code class="special">{count}</code> 为负时是 list<code class="special">&lt;string&gt;</code>，否则是  <a href="eval.html#String">String</a> 


flatten(<code class="special">{list}</code> [, <code class="special">{maxdepth}</code>])                          <b class="vimtag"> <a name="flatten()">flatten()</a> </b>
                展平 <code class="special">{list}</code>，最多到 <code class="special">{maxdepth}</code> 层。不给出 <code class="special">{maxdepth}</code> 时返回完
                全无嵌套的  <a href="eval.html#List">List</a> ，如同 <code class="special">{maxdepth}</code> 为非常大的数值。
                <code class="special">{list}</code> 在原位被修改，如果不想如此，可用  <a href="builtin.html#flattennew()">flattennew()</a> 。
                Vim9 脚本中不能用 flatten()，必须使用  <a href="builtin.html#flattennew()">flattennew()</a> 。
                                                        <b class="vimtag"> <a name="E900">E900</a> </b>
                <code class="special">{maxdepth}</code> 代表展平嵌套列表的最深层数。
                <code class="special">{maxdepth}</code> 为零时，不修改 <code class="special">{list}</code>。
                <code class="special">{maxdepth}</code> 必须为正数。

                如果有错，返回数值零。

                示例: 
<code class="example">                        :echo flatten([1, [2, [3, 4]], 5])</code>
                        [1, 2, 3, 4, 5] 
<code class="example">                        :echo flatten([1, [2, [3, 4]], 5], 1)</code>
                        [1, 2, [3, 4], 5]

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;flatten()</code>

                返回类型: list&lt;<code class="special">{type}</code>&gt;


flattennew(<code class="special">{list}</code> [, <code class="special">{maxdepth}</code>])                       <b class="vimtag"> <a name="flattennew()">flattennew()</a> </b>
                同  <a href="builtin.html#flatten()">flatten()</a> ，但先创建 <code class="special">{list}</code> 的备份。

                返回类型: list&lt;<code class="special">{type}</code>&gt;


float2nr(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="float2nr()">float2nr()</a> </b>
                返回数值，即 <code class="special">{expr}</code> 省略小数点部分的结果。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回 0。
                如果 <code class="special">{expr}</code> 的值超出  <a href="eval.html#Number">Number</a>  的范围，结果为 0x7fffffff 或
                -0x7fffffff (有 64-位 数值支持时，则为 0x7fffffffffffffff 或
                -0x7fffffffffffffff)。而 NaN 转换为 -0x80000000 (有64-位数
                值支持时，则为 -0x8000000000000000)。
                示例: 
<code class="example">                        echo float2nr(3.95)</code>
                        3  
<code class="example">                        echo float2nr(-23.45)</code>
                        -23  
<code class="example">                        echo float2nr(1.0e100)</code>
                        2147483647  (或 9223372036854775807) 
<code class="example">                        echo float2nr(-1.0e150)</code>
                        -2147483647 (或 -9223372036854775807) 
<code class="example">                        echo float2nr(1.0e-100)</code>
                        0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;float2nr()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


floor(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="floor()">floor()</a> </b>
                返回浮点数，即小于等于 <code class="special">{expr}</code> 的最大整数 (向下取整)。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回 0。
                示例: 
<code class="example">                        echo floor(1.856)</code>
                        1.0  
<code class="example">                        echo floor(-5.456)</code>
                        -6.0  
<code class="example">                        echo floor(4.0)</code>
                        4.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;floor()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


fmod(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                  <b class="vimtag"> <a name="fmod()">fmod()</a> </b>
                返回 <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的余数，该除法可能实际无法表达出来。选
                择某整数 i，返回 <code class="special">{expr1}</code> - i * <code class="special">{expr2}</code>，使得如果 <code class="special">{expr2}</code> 非
                零，结果和 <code class="special">{expr1}</code> 同号而绝对值小于 <code class="special">{expr2}</code> 的绝对值。如果
                <code class="special">{expr2}</code> 为零，返回零。返回值为  <a href="eval.html#Float">Float</a> 。
                <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。
                否则返回 0.0。
                示例: 
<code class="example">                        :echo fmod(12.33, 1.22)</code>
                        0.13 
<code class="example">                        :echo fmod(-12.33, 1.22)</code>
                        -0.13

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;fmod(1.22)</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


fnameescape(<code class="special">{string}</code>)                                   <b class="vimtag"> <a name="fnameescape()">fnameescape()</a> </b>
                转义 <code class="special">{string}</code> 以便用作命令的文件名参数。有特殊意义的字符，如
                '%' 和 '|'，会用反斜杠转义。
                多数系统上，会转义的字符是 " \t\n*?[{`$\\%#'\"|!&lt;"。在反斜杠可
                以出现在文件名中的系统上，此字符集取决于 <a href="options.html#'isfname'">'isfname'</a>。
                也转义出现在开头的 '+' 和 '&gt;' 字符 ( <a href="editing.html#:edit">:edit</a>  和  <a href="editing.html#:write">:write</a>  之后有
                特殊意义)，还有单个出现的 "-" ( <a href="editing.html#:cd">:cd</a>  之后有特殊意义)。
                出错时返回空串。
                示例: 
<code class="example">                        :let fname = '+some str%nge|name'</code>
<code class="example">                        :exe "edit " .. fnameescape(fname)</code>
                则会执行: 
<code class="example">                        edit \+some\ str\%nge\|name</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;fnameescape()</code>

                返回类型:  <a href="eval.html#String">String</a> 


fnamemodify(<code class="special">{fname}</code>, <code class="special">{mods}</code>)                            <b class="vimtag"> <a name="fnamemodify()">fnamemodify()</a> </b>
                根据 <code class="special">{mods}</code> 修改文件名 <code class="special">{fname}</code>。<code class="special">{mods}</code> 是一个字符序列组成的字
                符串，就像命令行上使用的文件名那样。见  <a href="cmdline.html#filename-modifiers">filename-modifiers</a> 。
                例如: 
<code class="example">                        :echo fnamemodify("main.c", ":p:h")</code>
                返回: 
<code class="example">                        /home/user/vim/vim/src</code>
                如果 <code class="special">{mods}</code> 为空或使用了不支持的修饰符，返回 <code class="special">{fname}</code>。
                如果 <code class="special">{fname}</code> 为空，<code class="special">{mods}</code> ":h" 返回 "."，以便  <a href="editing.html#:cd">:cd</a>  所用。这不
                同于不带缓冲区名的 expand('%:h')，后者返回空串。
                <code class="note">注意</code>: 环境变量不能用于 <code class="special">{fname}</code>，需要先用  <a href="builtin.html#expand()">expand()</a>  扩展。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;fnamemodify(':p:h')</code>

                返回类型:  <a href="eval.html#String">String</a> 


foldclosed(<code class="special">{lnum}</code>)                                      <b class="vimtag"> <a name="foldclosed()">foldclosed()</a> </b>
                返回数值，如果行 <code class="special">{lnum}</code> 在关闭的折叠中，返回该折叠开始的行号。
                如果行 <code class="special">{lnum}</code> 不在关闭的折叠中，返回 -1。
                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。因而 "." 是当前行，"'m" 是位置
                标记 m，等等。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;foldclosed()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


foldclosedend(<code class="special">{lnum}</code>)                                   <b class="vimtag"> <a name="foldclosedend()">foldclosedend()</a> </b>
                返回数值，如果行 <code class="special">{lnum}</code> 在关闭的折叠中，返回该折叠结束的行号。
                如果行 <code class="special">{lnum}</code> 不在关闭的折叠中，返回 -1。
                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。因而 "." 是当前行，"'m" 是位置
                标记 m，等等。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;foldclosedend()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


foldlevel(<code class="special">{lnum}</code>)                                       <b class="vimtag"> <a name="foldlevel()">foldlevel()</a> </b>
                返回数值，当前缓冲区第 <code class="special">{lnum}</code> 行的折叠级别。如果在嵌套的折叠
                里，返回最深的那层。如果行 <code class="special">{lnum}</code> 没有折叠，返回零。这和折叠是
                打开还是关闭无关。在更新折叠时 (在 <a href="options.html#'foldexpr'">'foldexpr'</a> 里)，如果折叠还
                在更新而相应的折叠级别未知，返回 -1。一个特例是前一行的级别通
                常总是知道的。
                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。因而 "." 是当前行，"'m" 是位置
                标记 m，等等。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;foldlevel()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


foldtext()                                              <b class="vimtag"> <a name="foldtext()">foldtext()</a> </b>
                返回关闭的折叠所显示的行。这是 <a href="options.html#'foldtext'">'foldtext'</a> 选项使用的缺省函数，
                而且也只应该在计算 <a href="options.html#'foldtext'">'foldtext'</a> 时使用。它使用  <a href="eval.html#v:foldstart">v:foldstart</a> 、
                 <a href="eval.html#v:foldend">v:foldend</a>  和  <a href="eval.html#v:folddashes">v:folddashes</a>  变量。
                返回的字符串看起来像: 
<code class="example">                        +-- 45 lines: abcdef</code>
                开头的连字符的数目取决于折叠级别。"45" 是折叠的行数。"abcdef"
                是折叠第一个非空白行的文本。开头的空白、"//" 和 "/*" 还有
                <a href="options.html#'foldmarker'">'foldmarker'</a> 和 <a href="options.html#'commentstring'">'commentstring'</a> 选项的文本都被去除。
                用于描绘实际的折叠文本时，行的其余部分用 <a href="options.html#'fillchars'">'fillchars'</a> 设置的
                fold 字符来填充。
                如果没有折叠，返回空串。

                返回类型:  <a href="eval.html#String">String</a> 
                <code class="notvi">{仅当编译时加入  <a href="various.html#+folding">+folding</a>  特性才有效}</code>


foldtextresult(<code class="special">{lnum}</code>)                                  <b class="vimtag"> <a name="foldtextresult()">foldtextresult()</a> </b>
                返回行 <code class="special">{lnum}</code> 所在的关闭的折叠显示的文本。在合适的上下文里计算
                <a href="options.html#'foldtext'">'foldtext'</a>。
                如果 <code class="special">{lnum}</code> 没有关闭的折叠，返回空字符串。
                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。所以 "." 是当前行，"'m" 是位置
                标记 m，等等。
                可用于输出折叠文本，例如，到 HTML 格式。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+folding">+folding</a>  特性才有效}</code>


                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;foldtextresult()</code>

                返回类型:  <a href="eval.html#String">String</a> 


foreach(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                               <b class="vimtag"> <a name="foreach()">foreach()</a> </b> <b class="vimtag"> <a name="E1525">E1525</a> </b>
                <code class="special">{expr1}</code> 必须为  <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a> 、 <a href="eval.html#String">String</a> 、 <a href="eval.html#Blob">Blob</a>  或
                 <a href="eval.html#Dictionary">Dictionary</a> 。
                对 <code class="special">{expr1}</code> 的每个项目执行 <code class="special">{expr2}</code>。<code class="special">{expr1}</code> 不能被修改；但其值
                可以，行为等同于  <a href="eval.html#:lockvar">:lockvar</a>  深度 1。 <a href="eval.html#E741">E741</a> 
                要修改 <code class="special">{expr1}</code>，参见  <a href="builtin.html#map()">map()</a>  和  <a href="builtin.html#filter()">filter()</a> 。

                <code class="special">{expr2}</code> 必须为  <a href="eval.html#string">string</a>  或  <a href="eval.html#Funcref">Funcref</a> 。

                当 <code class="special">{expr2}</code> 是  <a href="eval.html#string">string</a>  时，在 <code class="special">{expr2}</code> 里  <a href="eval.html#v:val">v:val</a>  是当前项目的
                值。对  <a href="eval.html#Dictionary">Dictionary</a>  而言， <a href="eval.html#v:key">v:key</a>  是当前项目的键值，对  <a href="eval.html#List">List</a> 
                或  <a href="eval.html#Tuple">Tuple</a>  而言， <a href="eval.html#v:key">v:key</a>  是当前项目的索引。对  <a href="eval.html#Blob">Blob</a>  而言，
                 <a href="eval.html#v:key">v:key</a>  是当前字节的索引。对  <a href="eval.html#String">String</a>  而言， <a href="eval.html#v:key">v:key</a>  是当前字符
                的索引。
                示例: 
<code class="example">                        call foreach(mylist, 'used[v:val] = true')</code>
                这会记录在 <code class="special">{expr1}</code> 列表里的所有项目。

                <code class="note">注意</code> <code class="special">{expr2}</code> 是表达式的计算结果但用作命令。这里往往
                 <a href="eval.html#literal-string">literal-string</a>  比较好用，因为可以避免双重反斜杠转义。

                当 <code class="special">{expr2}</code> 是  <a href="eval.html#Funcref">Funcref</a>  时，其应接受两个参数:
                        1. 当前项目的键值或索引。
                        2. 当前项目的值。
                如果只接受一个参数，老式匿名函数不会报错，但 Vim9 匿名函数会报
                错 "E1106: One argument too many"，参数数目必须匹配。
                函数如果有返回值，会被忽略。

                所有情况下，返回 <code class="special">{expr1}</code>。
                执行 <code class="special">{expr2}</code> 遇错时，不再处理 <code class="special">{expr1}</code> 的其余项目。
                <code class="special">{expr2}</code> 是 Funcref 时，忽略函数内的错误，除非使用了 "abort" 标
                志位。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;foreach(expr2)</code>

                返回类型:  <a href="eval.html#String">String</a> 、 <a href="eval.html#Blob">Blob</a> 、list&lt;<code class="special">{type}</code>&gt;、tuple&lt;<code class="special">{type}</code>&gt; 或
                dict&lt;<code class="special">{type}</code>&gt;，取决于 <code class="special">{expr1}</code>


foreground()                                            <b class="vimtag"> <a name="foreground()">foreground()</a> </b>
                把 Vim 窗口带到前台。用于从客户发送到 Vim 服务器的时候。
                 <a href="builtin.html#remote_send()">remote_send()</a> 
                在 Win32 系统上，可能不行，操作系统并不总能允许窗口把自己带到
                前台。这时应使用  <a href="builtin.html#remote_foreground()">remote_foreground()</a> 。

                返回类型:  <a href="eval.html#Number">Number</a> 
                {仅当使用 Win32、Motif 和 GTK GUI 版本和 Win32 控制台版本时才
                有效}

fullcommand(<code class="special">{name}</code> [, <code class="special">{vim9}</code>])                          <b class="vimtag"> <a name="fullcommand()">fullcommand()</a> </b>
                获取简短缩写命令的完整命令名；关于命令缩写，详见  <a href="usr_20.html#20.2">20.2</a> 。

                字符串参数 <code class="special">{name}</code> 可以  <a href="cmdline.html#:">:</a>  开始，也可以包含 <code class="special">[range]</code>，这些部分
                被跳过，且不会返回。
                如果命令不存在、有二义性 (出现于用户定义命令) 或不能缩短
                 <a href="vim9.html#vim9-no-shorten">vim9-no-shorten</a> ，返回空串。

                无 <code class="special">{vim9}</code> 参数时使用当前脚本版本。<code class="special">{vim9}</code> 存在且为 FALSE 时使用
                老式脚本规则。<code class="special">{vim9}</code> 存在且为 TRUE 时使用 Vim9 规则，例如 "en"
                不能用作 "endif" 的缩写。

                例如  <code class="badlink">fullcommand('s')</code> 、`fullcommand(<code class="badlink">'sub'</code>)`、
                 <code class="badlink">fullcommand(':%substitute')</code>  都返回 "substitute"。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;fullcommand()</code>

                返回类型:  <a href="eval.html#String">String</a> 


funcref(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])                <b class="vimtag"> <a name="funcref()">funcref()</a> </b>
                类似于  <a href="builtin.html#function()">function()</a> ，但返回的函数引用通过引用来查找函数，而不
                是名字。如果函数 <code class="special">{name}</code> 之后被重定义，这很有意义。

                和  <a href="builtin.html#function()">function()</a>  不同，<code class="special">{name}</code> 必须是已经定义的用户函数。自动载
                入函数也可以，但必须已经载入 (以避免因为只是引用函数名而不小心
                载入自动载入脚本，可用  <a href="builtin.html#function()">function()</a>  代替)。<code class="special">{name}</code> 不能是内建函
                数。
                出错时返回 0。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFuncname()-&gt;funcref([arg])</code>

                返回类型: func(...): any 或出错时  <a href="eval.html#Number">Number</a> 


function(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])               <b class="vimtag"> <a name="function()">function()</a> </b> <b class="vimtag"> <a name="partial">partial</a> </b> <b class="vimtag"> <a name="E700">E700</a> </b> <b class="vimtag"> <a name="E923">E923</a> </b>
                返回指向函数 <code class="special">{name}</code> 的  <a href="eval.html#Funcref">Funcref</a>  变量。<code class="special">{name}</code> 可以是用户定义的
                函数或者内部函数的名字。

                <code class="special">{name}</code> 可以是函数引用或偏函数。如果是偏函数，会使用其保存的字
                典，而不接受 <code class="special">{dict}</code> 参数。例如: 
<code class="example">                        let FuncWithArg = function(dict.Func, [arg])</code>
<code class="example">                        let Broken = function(dict.Func, [arg], dict)</code>

                使用函数引用时，通过 <code class="special">{name}</code> 查找函数，即使以后被重定义了亦然。
                要保留相同的函数，用  <a href="builtin.html#funcref()">funcref()</a> 。

                提供 <code class="special">{arglist}</code> 或 <code class="special">{dict}</code> 则会建立偏函数。这意味着参数列表和/或
                字典会存放在函数引用里，并在调用函数引用时使用。

                参数被传递到函数里，在其它参数之前，但在来自  <a href="eval.html#method">method</a>  的参数之
                后。例如: 
<code class="example">                        func Callback(arg1, arg2, name)</code>
<code class="example">                        ...</code>
<code class="example">                        let Partial = function('Callback', ['one', 'two'])</code>
<code class="example">                        ...</code>
<code class="example">                        call Partial('name')</code>
                函数的调用就类似于: 
<code class="example">                        call Callback('one', 'two', 'name')</code>
<code class="example"></code>
                用  <a href="eval.html#method">method</a>  的话: 
<code class="example">                        func Callback(one, two, three)</code>
<code class="example">                        ...</code>
<code class="example">                        let Partial = function('Callback', ['two'])</code>
<code class="example">                        ...</code>
<code class="example">                        eval 'one'-&gt;Partial('three')</code>
                函数的调用就类似于: 
<code class="example">                        call Callback('one', 'two', 'three')</code>
<code class="example"></code>
                function() 调用可以嵌套，来给函数引用加入更多的参数。额外的参
                数附加于参数列表之后。如: 
<code class="example">                        func Callback(arg1, arg2, name)</code>
<code class="example">                        "...</code>
<code class="example">                        let Func = function('Callback', ['one'])</code>
<code class="example">                        let Func2 = function(Func, ['two'])</code>
<code class="example">                        "...</code>
<code class="example">                        call Func2('name')</code>
                函数的调用就类似于: 
<code class="example">                        call Callback('one', 'two', 'name')</code>
<code class="example"></code>
                字典只对 "dict" 函数的调用有用。该情况下，<code class="special">{dict}</code> 作为 "self"
                传入。例如: 
<code class="example">                        function Callback() dict</code>
<code class="example">                           echo "called for " .. self.name</code>
<code class="example">                        endfunction</code>
<code class="example">                        "...</code>
<code class="example">                        let context = {"name": "example"}</code>
<code class="example">                        let Func = function('Callback', context)</code>
<code class="example">                        "...</code>
<code class="example">                        call Func()     " 会回显: called for example</code>
                如果不需额外参数，function() 是没有必要的。这两者等价: 
<code class="example">                        let Func = function('Callback', context)</code>
<code class="example">                        let Func = context.Callback</code>
<code class="example"></code>
                可以合并参数列表和字典: 
<code class="example">                        function Callback(arg1, count) dict</code>
<code class="example">                        "...</code>
<code class="example">                        let context = {"name": "example"}</code>
<code class="example">                        let Func = function('Callback', ['one'], context)</code>
<code class="example">                        "...</code>
<code class="example">                        call Func(500)</code>
                函数的调用就类似于: 
<code class="example">                        call context.Callback('one', 500)</code>

                出错时返回 0。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFuncname()-&gt;function([arg])</code>
<code class="example"></code>

                返回类型: func(...): any 或出错时  <a href="eval.html#Number">Number</a> 


garbagecollect([<code class="special">{atexit}</code>])                              <b class="vimtag"> <a name="garbagecollect()">garbagecollect()</a> </b>
                清理不再使用但有循环引用的  <a href="eval.html#List">List</a>  、 <a href="eval.html#Dictionary">Dictionary</a> 、 <a href="eval.html#Channel">Channel</a>  和
                 <a href="eval.html#Job">Job</a> 。

                几乎没有需要调用这个函数，因为 Vim 内存不足或者 <a href="options.html#'updatetime'">'updatetime'</a>
                之后等待用户按键时会自动执行此功能。没有循环引用的项目总是在不
                再使用的时候就被立即释放了。
                可用于删除很大的  <a href="eval.html#List">List</a>  和/或  <a href="eval.html#Dictionary">Dictionary</a>  而且有循环引用的时
                候，尤其是在要运行很长时间的脚本里。

                如果可选的 <code class="special">{atexit}</code> 参数为一，并且之前还没做过的话，Vim 即使在
                退出时也会执行垃圾回收。可用于检查内存泄漏。

                垃圾清理不是立即进行的，它会等待安全的时机，就是等待用户输入字
                符的时候。要强制立即进行垃圾清理，可用
                 <a href="testing.html#test_garbagecollect_now()">test_garbagecollect_now()</a> 。

                返回类型:  <a href="eval.html#String">String</a> 


get(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{default}</code>])                        <b class="vimtag"> <a name="get()">get()</a> </b> <b class="vimtag"> <a name="get()-list">get()-list</a> </b>
                获取  <a href="eval.html#List">List</a>  <code class="special">{list}</code> 的第 <code class="special">{idx}</code> 个项目。如果不存在此项目，返回
                <code class="special">{default}</code>。如果省略 <code class="special">{default}</code>，返回零。
                建议用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;get(idx)</code>

                返回类型: any，取决于 <code class="special">{list}</code>


get(<code class="special">{tuple}</code>, <code class="special">{idx}</code> [, <code class="special">{default}</code>])                       <b class="vimtag"> <a name="get()-tuple">get()-tuple</a> </b>
                获取  <a href="eval.html#Tuple">Tuple</a>  <code class="special">{tuple}</code> 的第 <code class="special">{idx}</code> 个项目。如果不存在此项目，返回
                <code class="special">{default}</code>。如果省略 <code class="special">{default}</code>，返回零。
                建议用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mytuple-&gt;get(idx)</code>

                返回类型: any，取决于 <code class="special">{tuple}</code>


get(<code class="special">{blob}</code>, <code class="special">{idx}</code> [, <code class="special">{default}</code>])                        <b class="vimtag"> <a name="get()-blob">get()-blob</a> </b>
                获取  <a href="eval.html#Blob">Blob</a>  <code class="special">{blob}</code> 的第 <code class="special">{idx}</code> 个字节。如果不存在此字节，返回
                <code class="special">{default}</code>。如果省略 <code class="special">{default}</code>，返回 -1。
                建议用作  <a href="eval.html#method">method</a> : 
<code class="example">                        myblob-&gt;get(idx)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


get(<code class="special">{dict}</code>, <code class="special">{key}</code> [, <code class="special">{default}</code>])                        <b class="vimtag"> <a name="get()-dict">get()-dict</a> </b>
                获取  <a href="eval.html#Dictionary">Dictionary</a>  <code class="special">{dict}</code> 键为 <code class="special">{key}</code> 的项目。如果不存在此项目，
                返回 <code class="special">{default}</code>。如果省略 <code class="special">{default}</code>，返回零。有用的例子: 
<code class="example">                        let val = get(g:, 'var_name', 'default')</code>
                如果 g:var_name 存在，返回它的值，如果不存在返回 <code class="badlink">'default'</code>。
                建议用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mydict-&gt;get(key)</code>

                返回类型: any，取决于 <code class="special">{dict}</code>


get(<code class="special">{func}</code>, <code class="special">{what}</code>)                                     <b class="vimtag"> <a name="get()-func">get()-func</a> </b>
                获取函数引用 <code class="special">{func}</code> 的项目 <code class="special">{what}</code>。<code class="special">{what}</code> 的可能值是:
                  "name"    函数名
                  "func"    函数
                  "dict"    字典
                  "args"    参数列表
                  "arity"   包含函数接受的参数数目 (不包括 <code class="special">{arglist}</code>) 相关信息
                            的字典，有以下字段:
                                required    位置参数的数目
                                optional    必选参数之外的可选参数的数目
                                varargs     如果此函数接受可变参数数目 ... 则
                                            为  <a href="eval.html#TRUE">TRUE</a> 

                                <code class="note">注意</code>: 如果函数引用的 <code class="special">{arglist}</code> 包含了参数个数
                                多于函数引用本身期待的数目，不会报错，这里不检
                                查。

                出错时返回零。

                建议用作  <a href="eval.html#method">method</a> : 
<code class="example">                        myfunc-&gt;get(what)</code>

                返回类型: any，取决于 <code class="special">{func}</code> 和 <code class="special">{what}</code>


getbufinfo([<code class="special">{buf}</code>])                                     <b class="vimtag"> <a name="getbufinfo()">getbufinfo()</a> </b>
getbufinfo([<code class="special">{dict}</code>])
                获取字典列表形式的缓冲区信息。

                不带参数则返回关于所有缓冲区的信息。

                只给出  <a href="eval.html#Dictionary">Dictionary</a>  参数时，返回匹配相关条件的缓冲区。<code class="special">{dict}</code>
                中可指定以下键值:
                        buflisted       只包含在列表内的缓冲区。
                        bufloaded       只包含已载入的缓冲区。
                        bufmodified     只包含修改过的缓冲区。

                否则，<code class="special">{buf}</code> 指定特定的单个缓冲区并返回其信息。<code class="special">{buf}</code> 的用法见上
                述  <a href="builtin.html#bufname()">bufname()</a> 。如果找到缓冲区，返回的列表有一个项目。不然返回
                空列表。

                每个返回的列表项目是带有以下项目的字典:
                        bufnr           缓冲区号。
                        changed         若缓冲区已修改则为 TRUE。
                        changedtick     缓冲区作过的改动次数。
                        hidden          若缓冲区隐藏则为 TRUE。
                        lastused        缓冲区最近修改时间， <a href="builtin.html#localtime()">localtime()</a>  那样
                                        的以秒计的时间戳。
                                        <code class="notvi">{仅当编译时加入  <a href="various.html#+viminfo">+viminfo</a>  特性才有效}</code>
                        listed          若缓冲区在列表内，则为 TRUE。
                        lnum            在当前窗口里打开本缓冲区时所用的行号。
                                        仅当该缓冲区在此窗口中曾经显示过才有
                                        效。
                                        如果要某个窗口最近已知的光标位置的行
                                        号，可用  <a href="builtin.html#line()">line()</a> : 
<code class="example">                                                :echo line('.', {winid})</code>

                        linecount       缓冲区行数 (仅当缓冲区载入后才有效)
                        loaded          若缓冲区已载入则为 TRUE。
                        name            缓冲区文件的完整列表。
                        signs           缓冲区内放置的标号的列表。
                                        每个列表项目是以下项目的字典:
                                            id    标号的识别符
                                            lnum  行号
                                            name  标号名
                        variables       缓冲区局部变量的字典的引用。
                        windows         显示此缓冲区的所有  <a href="windows.html#window-ID">window-ID</a>  的列表
                        popups          显示此缓冲区的弹出窗口  <a href="windows.html#window-ID">window-ID</a>  的
                                        列表

                示例: 
<code class="example">                        for buf in getbufinfo()</code>
<code class="example">                            echo buf.name</code>
<code class="example">                        endfor</code>
<code class="example">                        for buf in getbufinfo({'buflisted':1})</code>
<code class="example">                            if buf.changed</code>
<code class="example">                                ....</code>
<code class="example">                            endif</code>
<code class="example">                        endfor</code>

                要获取缓冲区局部选项，可用: 
<code class="example">                        getbufvar({bufnr}, '&amp;option_name')</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufnr()-&gt;getbufinfo()</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt;


getbufline(<code class="special">{buf}</code>, <code class="special">{lnum}</code> [, <code class="special">{end}</code>])                     <b class="vimtag"> <a name="getbufline()">getbufline()</a> </b>
                返回 <code class="special">{buf}</code> 缓冲区的第 <code class="special">{lnum}</code> 到 <code class="special">{end}</code> (包含) 行的  <a href="eval.html#List">List</a> 。如果
                省略 <code class="special">{end}</code>，返回只有一行 <code class="special">{lnum}</code> 的  <a href="eval.html#List">List</a> 。如果只要该行，可用
                 <a href="builtin.html#getbufoneline()">getbufoneline()</a> 。

                <code class="special">{buf}</code> 的用法见上述  <a href="builtin.html#bufname()">bufname()</a> 。

                <code class="special">{lnum}</code> 和 <code class="special">{end}</code> 可以使用 "$" 来表示缓冲区的最后一行。除此以
                外，必须用数值。

                如果 <code class="special">{lnum}</code> 小于 1 或大于缓冲区的行数，返回空  <a href="eval.html#List">List</a> 。

                如果 <code class="special">{end}</code> 大于缓冲区的行数，就把它当成缓冲区的行数。如果
                <code class="special">{end}</code> 在 <code class="special">{lnum}</code> 之前，返回空  <a href="eval.html#List">List</a> 。

                此函数只能用于已经载入的缓冲区。未载入或不存在的缓冲区总是返回
                空  <a href="eval.html#List">List</a> 。

                例如: 
<code class="example">                        :let lines = getbufline(bufnr("myfile"), 1, "$")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufnr()-&gt;getbufline(lnum)</code>

                返回类型: list<code class="special">&lt;string&gt;</code>


getbufoneline(<code class="special">{buf}</code>, <code class="special">{lnum}</code>)                            <b class="vimtag"> <a name="getbufoneline()">getbufoneline()</a> </b>
                类似于  <a href="builtin.html#getbufline()">getbufline()</a> ，但只获取一行且以字符串形式返回。

                返回类型:  <a href="eval.html#String">String</a> 


getbufvar(<code class="special">{buf}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])                   <b class="vimtag"> <a name="getbufvar()">getbufvar()</a> </b>
                返回缓冲区 <code class="special">{buf}</code> 里的选项或者局部变量 <code class="special">{varname}</code> 的值。<code class="note">注意</code> 必
                须使用不带 "b:" 的名字。
                <code class="special">{varname}</code> 参数为字符串。
                如果 <code class="special">{varname}</code> 为空，返回包含所有缓冲区局部变量的
                 <a href="eval.html#Dictionary">Dictionary</a> 。
                如果 <code class="special">{varname}</code> 为 "&amp;"，返回包含所有缓冲区局部选项的
                 <a href="eval.html#Dictionary">Dictionary</a> 。
                否则，如果 <code class="special">{varname}</code> 以 "&amp;" 开始，返回单个缓冲区局部选项值。
                也可用于全局或者局部于缓冲区的选项，但不能用于全局或者局部于窗
                口的变量，还有局部于窗口的选项。
                <code class="special">{buf}</code> 的用法见上述  <a href="builtin.html#bufname()">bufname()</a> 。
                如果缓冲区或者变量不存在，返回 <code class="special">{def}</code> 或空字符串。不会有错误消
                息。
                示例: 
<code class="example">                        :let bufmodified = getbufvar(1, "&amp;mod")</code>
<code class="example">                        :echo "todo myvar = " .. getbufvar("todo", "myvar")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufnr()-&gt;getbufvar(varname)</code>

                返回类型: any，取决于 <code class="special">{varname}</code>


getcellpixels()                                         <b class="vimtag"> <a name="getcellpixels()">getcellpixels()</a> </b>
                返回终端单元的像素尺寸  <a href="eval.html#List">List</a> 。
                列表格式是 [xpixel, ypixel]。

                仅对 Unix (终端和 gVim) 和 Windows (仅 gVim) 有效。
                其他系统返回 [] 或报错。
                <code class="note">注意</code> 不同终端可能会有变种。macOS 上系统的 Terminal.app 返回的
                尺寸以点 (point) 计 (在视网膜缩放之前)，而第三方终端返回原始像
                素尺寸 (在视网膜缩放之后)。

                返回类型: list<code class="special">&lt;any&gt;</code>


getcellwidths()                                         <b class="vimtag"> <a name="getcellwidths()">getcellwidths()</a> </b>
                返回  <a href="builtin.html#setcellwidths()">setcellwidths()</a>  覆盖的字符范围的单元宽度的  <a href="eval.html#List">List</a> 。
                其格式和  <a href="builtin.html#setcellwidths()">setcellwidths()</a>  的参数相同。如果没有单元宽度被覆盖
                的字符范围，返回空列表。

                返回类型: list<code class="special">&lt;any&gt;</code>


getchangelist([<code class="special">{buf}</code>])                                  <b class="vimtag"> <a name="getchangelist()">getchangelist()</a> </b>
                返回缓冲区 <code class="special">{buf}</code> 里的  <a href="motion.html#changelist">changelist</a> 。<code class="special">{buf}</code> 的用法可见上述
                 <a href="builtin.html#bufname()">bufname()</a> 。缓冲区 <code class="special">{buf}</code> 不存在时返回空列表。

                返回列表包含两个项目: 包含改变位置的列表以及在该列表中的当前位
                置。改变位置列表的每个项目是包含以下内容的字典:
                        col             列号
                        coladd          用于 <a href="options.html#'virtualedit'">'virtualedit'</a> 的列偏移
                        lnum            行号
                如果缓冲区 <code class="special">{buf}</code> 是当前缓冲区，当前位置指的是在列表中的位置。
                如果是其它缓冲区，它设为列表的长度。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufnr()-&gt;getchangelist()</code>

                返回类型: list<code class="special">&lt;any&gt;</code>


getchar([<code class="special">{expr}</code> [, <code class="special">{opts}</code>]])                            <b class="vimtag"> <a name="getchar()">getchar()</a> </b>
                从用户或输入流中提取单个字符。
                如果忽略 <code class="special">{expr}</code> 为 -1，等待直到有字符输入为止。
                如果 <code class="special">{expr}</code> 为 0，只有在有字符可用时才取得字符，否则返回零。
                如果 <code class="special">{expr}</code> 为 1，只检查是否有字符可用，并不消耗该字符。如果没
                                  有字符，返回零。
                如果希望返回总是字符串形式，用  <a href="builtin.html#getcharstr()">getcharstr()</a>  或 <code class="special">{opts}</code> 里的
                "number" 设为  <a href="eval.html#FALSE">FALSE</a> 。

                如果省略 <code class="special">{expr}</code> 或者 <code class="special">{expr}</code> 为零，返回整个字符或者特殊键。如果
                是单个字符，以数值形式返回。用  <a href="builtin.html#nr2char()">nr2char()</a>  把它转化成字符串。
                否则返回经过编码的字符构成的字符串。如果是特殊键，返回以 0x80
                (十进制: 128) 开始的一串字节构成的字符串。它和字符串 "\<code class="special">&lt;Key&gt;</code>"
                等值，例如 "\<code class="special">&lt;Left&gt;</code>"。如果用带修饰符 (Shift，Control， Alt) 的
                字符而字符本身不包含该修饰符时，返回值也用字符串类型。也可以用
                 <a href="builtin.html#keytrans()">keytrans()</a>  把返回的字符串转为可读的形式。

                如果 <code class="special">{expr}</code> 为 0 并已键入 Esc，会有短暂的延迟，以便 Vim 有机会
                判断是否是转义序序列的开始。

                如果 <code class="special">{expr}</code> 为 1，只返回第一个字节。如果是单字节字符，返回的就
                是该字符自身的数值形式。用  <a href="builtin.html#nr2char()">nr2char()</a>  把它转化为字符串。

                 <a href="builtin.html#getcharmod()">getcharmod()</a>  可用于得到附加的修饰符。

                可选参数 <code class="special">{opts}</code> 是支持以下项目的字典:

                        cursor          指定等待字符时光标行为的字符串。
                                        "hide": 隐藏光标。
                                        "keep": 保持当前光标不变。
                                        "msg": 移动光标到消息区。
                                        (缺省: "msg")

                        number          如为  <a href="eval.html#TRUE">TRUE</a> ，提取到单个字符时返回数
                                        值。
                                        如为  <a href="eval.html#FALSE">FALSE</a> ，总把返回值转换为字符串，
                                        无字符可用时返回空串 (而非 0)。
                                        (缺省:  <a href="eval.html#TRUE">TRUE</a> )

                        simplify        如为  <a href="eval.html#TRUE">TRUE</a> ，字符包含修饰符 (如有)。例
                                        如 <code class="keystroke">CTRL-I</code> 和 <code class="special">&lt;Tab&gt;</code> 返回相同值。
                                        如为  <a href="eval.html#FALSE">FALSE</a> ，字符不包含修饰符。
                                        (缺省:  <a href="eval.html#TRUE">TRUE</a> )

                用户点击鼠标时，返回鼠标事件。所在的位置可以在  <a href="eval.html#v:mouse_col">v:mouse_col</a> 、
                 <a href="eval.html#v:mouse_lnum">v:mouse_lnum</a>  、 <code class="badlink">v:mosue_winid</code>  和  <a href="eval.html#v:mouse_win">v:mouse_win</a>  里找到。也可
                用  <a href="builtin.html#getmousepos()">getmousepos()</a> 。鼠标移动事件被忽略。
                下例用通常的处理方法定位鼠标: 
<code class="example">                        let c = getchar()</code>
<code class="example">                        if c == "\&lt;LeftMouse&gt;" &amp;&amp; v:mouse_win &gt; 0</code>
<code class="example">                          exe v:mouse_win .. "wincmd w"</code>
<code class="example">                          exe v:mouse_lnum</code>
<code class="example">                          exe "normal " .. v:mouse_col .. "|"</code>
<code class="example">                        endif</code>

                使用括号内粘贴模式时，只返回首个字符。粘贴文本其余部分被丢弃。
                 <a href="term.html#xterm-bracketed-paste">xterm-bracketed-paste</a> 。

                这里没有提示，你需要想办法告诉用户，需要输入一个字符。屏幕不重
                画，例如在窗口改变大小时也是如此。使用弹出窗口时，最好使用
                 <a href="popup.html#popup-filter">popup-filter</a> 。

                字符不通过映射。
                键码被替换。因而，用户输入 <code class="special">&lt;Del&gt;</code> 键时，你得到 <code class="special">&lt;Del&gt;</code> 的键码，而
                不是原始的字符序列。比如: 
<code class="example">                        getchar() == "\&lt;Del&gt;"</code>
<code class="example">                        getchar() == "\&lt;S-Left&gt;"</code>
                下例重新定义 "f"，使它忽略大小写: 
<code class="example">                        :nmap f :call FindChar()&lt;CR&gt;</code>
<code class="example">                        :function FindChar()</code>
<code class="example">                        :  let c = nr2char(getchar())</code>
<code class="example">                        :  while col('.') &lt; col('$') - 1</code>
<code class="example">                        :    normal l</code>
<code class="example">                        :    if getline('.')[col('.') - 1] ==? c</code>
<code class="example">                        :      break</code>
<code class="example">                        :    endif</code>
<code class="example">                        :  endwhile</code>
<code class="example">                        :endfunction</code>

                也可能收到模拟字符，例如  <a href="autocmd.html#%3CCursorHold%3E">&lt;CursorHold&gt;</a> 。通常你想忽略之跳到下
                个字符: 
<code class="example">                        :function GetKey()</code>
<code class="example">                        :  let c = getchar()</code>
<code class="example">                        :  while c == "\&lt;CursorHold&gt;"</code>
<code class="example">                        :    let c = getchar()</code>
<code class="example">                        :  endwhile</code>
<code class="example">                        :  return c</code>
<code class="example">                        :endfunction</code>

                返回类型:  <a href="eval.html#Number">Number</a>  或  <a href="eval.html#String">String</a> 


getcharmod()                                            <b class="vimtag"> <a name="getcharmod()">getcharmod()</a> </b>
                返回数值，反映最近用  <a href="builtin.html#getchar()">getchar()</a>  或其它方式输入字符的修饰符状
                态。这些值可以相加:
                        2       Shift
                        4       Control
                        8       Alt (Meta)
                        16      Meta (当和 ALT 不同时)
                        32      鼠标双击
                        64      鼠标三击
                        96      鼠标四击 (== 32 + 64)
                        128     Command (Mac) 或 Super (GTK)
                只有没有包含字符本身的修饰符被返回。因而，Shift-a 产生没有修饰
                符的 "A"。如果没有使用修饰符，返回 0。

                返回类型:  <a href="eval.html#Number">Number</a> 


getcharpos(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="getcharpos()">getcharpos()</a> </b>
                得到字符串 <code class="special">{expr}</code> 的位置。和  <a href="builtin.html#getpos()">getpos()</a>  相同，但返回列表的列号
                是字符索引而不是字节索引。
                如果  <a href="builtin.html#getpos()">getpos()</a>  返回等于 v:maxcol 的很大列号，那么
                getcharpos() 会返回末字符的字符索引。

                示例:
                如果光标在第五行文本 "여보세요" 的 '세' 时: 
<code class="example">                        getcharpos('.')         返回 [0, 5, 3, 0]</code>
<code class="example">                        getpos('.')             返回 [0, 5, 7, 0]</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMark()-&gt;getcharpos()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


getcharsearch()                                         <b class="vimtag"> <a name="getcharsearch()">getcharsearch()</a> </b>
                以 <code class="special">{dict}</code> 形式返回当前字符搜索信息，带有以下项目:

                    char        上次字符搜索 ( <a href="motion.html#t">t</a> 、 <a href="motion.html#f">f</a> 、 <a href="motion.html#T">T</a>  或  <a href="motion.html#F">F</a> ) 使用的字
                                符；空字符串代表没有字符搜索进行过
                    forward     字符搜索的方向；1 为正向，0 为反向
                    until       字符搜索的类型；1 为  <a href="motion.html#t">t</a>  为  <a href="motion.html#T">T</a>  字符搜索，0 为
                                 <a href="motion.html#f">f</a>  或  <a href="motion.html#F">F</a>  字符搜索

                可用于使  <a href="motion.html#;">;</a>  和  <a href="motion.html#,">,</a>  永远进行正向/反向搜索而不管上次字符搜索的
                方向: 
<code class="example">                        :nnoremap &lt;expr&gt; ; getcharsearch().forward ? ';' : ','</code>
<code class="example">                        :nnoremap &lt;expr&gt; , getcharsearch().forward ? ',' : ';'</code>
                另见  <a href="builtin.html#setcharsearch()">setcharsearch()</a> 。

                返回类型: dict<code class="special">&lt;any&gt;</code>


getcharstr([<code class="special">{expr}</code> [, <code class="special">{opts}</code>]])                         <b class="vimtag"> <a name="getcharstr()">getcharstr()</a> </b>
                和  <a href="builtin.html#getchar()">getchar()</a>  相同，但总是返回字符串形式，且 <code class="special">{opts}</code> 里不允许
                设置 "number"。

                返回类型:  <a href="eval.html#String">String</a> 


getcmdcomplpat()                                        <b class="vimtag"> <a name="getcmdcomplpat()">getcmdcomplpat()</a> </b>
                返回当前命令行的补全模式。
                只有在编辑命令行时有效，所以必须在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或
                 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  里使用。
                另见  <a href="builtin.html#getcmdtype()">getcmdtype()</a> 、 <a href="builtin.html#setcmdpos()">setcmdpos()</a> 、 <a href="builtin.html#getcmdline()">getcmdline()</a> 、
                 <a href="builtin.html#getcmdprompt()">getcmdprompt()</a> 、 <a href="builtin.html#getcmdcompltype()">getcmdcompltype()</a>  和  <a href="builtin.html#setcmdline()">setcmdline()</a> 。
                补全没有定义时，返回空串。

                返回类型:  <a href="eval.html#String">String</a> 


getcmdcompltype()                                       <b class="vimtag"> <a name="getcmdcompltype()">getcmdcompltype()</a> </b>
                返回当前命令行补全的类型。只有在编辑命令行时有效，所以必须在
                 <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或  <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  里使用。
                返回字符串可见  <a href="map.html#:command-completion">:command-completion</a> 。
                另见  <a href="builtin.html#getcmdtype()">getcmdtype()</a> 、 <a href="builtin.html#setcmdpos()">setcmdpos()</a>  、 <a href="builtin.html#getcmdline()">getcmdline()</a> 、
                 <a href="builtin.html#getcmdprompt()">getcmdprompt()</a> 、 <a href="builtin.html#getcmdcomplpat()">getcmdcomplpat()</a>  或  <a href="builtin.html#setcmdline()">setcmdline()</a> 。
                如果没有定义补全，返回空串。

                要获取为指定字符串所使用的命令行补全的类型，可用
                 <a href="builtin.html#getcompletiontype()">getcompletiontype()</a> 。

                返回类型:  <a href="eval.html#String">String</a> 


getcmdline()                                            <b class="vimtag"> <a name="getcmdline()">getcmdline()</a> </b>
                返回当前命令行输入。只有在编辑命令行时有效，所以必须在
                 <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或  <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  里使用。
                例如: 
<code class="example">                        :cmap &lt;F7&gt; &lt;C-\&gt;eescape(getcmdline(), ' \')&lt;CR&gt;</code>
                另见  <a href="builtin.html#getcmdtype()">getcmdtype()</a> 、 <a href="builtin.html#getcmdpos()">getcmdpos()</a> 、 <a href="builtin.html#setcmdpos()">setcmdpos()</a> 、
                 <a href="builtin.html#getcmdprompt()">getcmdprompt()</a>  和  <a href="builtin.html#setcmdline()">setcmdline()</a> 。
                输入密码或用  <a href="builtin.html#inputsecret()">inputsecret()</a>  时返回空串。

                返回类型:  <a href="eval.html#String">String</a> 


getcmdpos()                                             <b class="vimtag"> <a name="getcmdpos()">getcmdpos()</a> </b>
                返回命令行的字节计算的光标位置。第一列为 1。
                只有在编辑命令行时有效，所以必须在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或
                 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  或表达式映射里使用。
                不然，返回 0。
                另见  <a href="builtin.html#getcmdtype()">getcmdtype()</a> 、 <a href="builtin.html#setcmdpos()">setcmdpos()</a> 、 <a href="builtin.html#getcmdline()">getcmdline()</a> 、
                 <a href="builtin.html#getcmdprompt()">getcmdprompt()</a>  和  <a href="builtin.html#setcmdline()">setcmdline()</a> 。

                返回类型:  <a href="eval.html#Number">Number</a> 


getcmdprompt()                                          <b class="vimtag"> <a name="getcmdprompt()">getcmdprompt()</a> </b>
                返回当前命令行在使用  <a href="builtin.html#input()">input()</a>  或  <a href="builtin.html#confirm()">confirm()</a>  之类的函数时的提
                示。
                只有在编辑命令行时有效，所以必须在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或
                 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  或表达式映射里使用。
                另见  <a href="builtin.html#getcmdtype()">getcmdtype()</a> 、 <a href="builtin.html#getcmdline()">getcmdline()</a> 、 <a href="builtin.html#getcmdpos()">getcmdpos()</a> 、
                 <a href="builtin.html#setcmdpos()">setcmdpos()</a>  和  <a href="builtin.html#setcmdline()">setcmdline()</a> 。

                返回类型:  <a href="eval.html#String">String</a> 


getcmdscreenpos()                                       <b class="vimtag"> <a name="getcmdscreenpos()">getcmdscreenpos()</a> </b>
                返回命令行的字节计算的光标屏幕位置。第一列为 1。
                和  <a href="builtin.html#getcmdpos()">getcmdpos()</a>  不同，它把提示位置也加入在内。
                只有在编辑命令行时有效，所以必须在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或
                 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  或表达式映射里使用。
                不然，返回 0。
                另见  <a href="builtin.html#getcmdpos()">getcmdpos()</a> 、 <a href="builtin.html#setcmdpos()">setcmdpos()</a> 、 <a href="builtin.html#getcmdline()">getcmdline()</a>  和
                 <a href="builtin.html#setcmdline()">setcmdline()</a> 。

                返回类型:  <a href="eval.html#Number">Number</a> 


getcmdtype()                                            <b class="vimtag"> <a name="getcmdtype()">getcmdtype()</a> </b>
                返回当前命令行类型。可能的返回值是:
                    :   普通 Ex 命令
                    &gt;   调试模式命令  <a href="repeat.html#debug-mode">debug-mode</a> 
                    /   正向搜索命令
                    ?   反向搜索命令
                    @    <a href="builtin.html#input()">input()</a>  命令
                    -    <a href="insert.html#:insert">:insert</a>  或  <a href="insert.html#:append">:append</a>  命令
                    =    <a href="insert.html#i_CTRL-R_%20">i_CTRL-R_=</a> 
                只能在编辑命令行时调用，因而必须在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或
                 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  或表达式映射里使用。
                否则，返回空字符串。
                另见  <a href="builtin.html#getcmdpos()">getcmdpos()</a> 、 <a href="builtin.html#setcmdpos()">setcmdpos()</a>  和  <a href="builtin.html#getcmdline()">getcmdline()</a> 。

                返回类型:  <a href="eval.html#String">String</a> 


getcmdwintype()                                         <b class="vimtag"> <a name="getcmdwintype()">getcmdwintype()</a> </b>
                返回当前  <a href="cmdline.html#command-line-window">command-line-window</a>  类型。可能的返回值和
                 <a href="builtin.html#getcmdtype()">getcmdtype()</a>  相同。如果不在命令行窗口内，返回空字符串。

                返回类型:  <a href="eval.html#String">String</a> 


getcompletion(<code class="special">{pat}</code>, <code class="special">{type}</code> [, <code class="special">{filtered}</code>])             <b class="vimtag"> <a name="getcompletion()">getcompletion()</a> </b>
                返回命令行补全匹配列表。字符串 <code class="special">{type}</code> 指定类型。支持以下的匹配
                类型:

                arglist         参数列表中的文件名
                augroup         自动命令组
                buffer          缓冲区名
                behave           <a href="gui.html#:behave">:behave</a>  子选项
                breakpoint       <a href="repeat.html#:breakadd">:breakadd</a>  和  <a href="repeat.html#:breakdel">:breakdel</a>  子选项
                color           色彩方案
                command         Ex 命令
                cmdline          <a href="cmdline.html#cmdline-completion">cmdline-completion</a>  结果
                compiler        编译器
                cscope           <a href="if_cscop.html#:cscope">:cscope</a>  子选项
                custom,<code class="special">{func}</code>   <code class="special">{func}</code> 定义的定制补全
                customlist,<code class="special">{func}</code> <code class="special">{func}</code> 定义的定制补全
                diff_buffer      <a href="diff.html#:diffget">:diffget</a>  和  <a href="diff.html#:diffput">:diffput</a>  补全
                dir             目录名
                dir_in_path     <a href="options.html#'cdpath'">'cdpath'</a> 里的目录名
                environment     环境变量名
                event           自动命令事件
                expression      Vim 表达式
                file            文件和目录名
                file_in_path    <a href="options.html#'path'">'path'</a> 中的文件和目录名
                filetype        文件类型名 <a href="options.html#'filetype'">'filetype'</a>
                filetypecmd      <a href="filetype.html#:filetype">:filetype</a>  子选项
                function        函数名
                help            帮助主题
                highlight       高亮组
                history          <a href="cmdline.html#:history">:history</a>  子选项
                keymap          键盘映射
                locale          locale 名 (可见 locale -a 的输出)
                mapclear        缓冲区参数
                mapping         映射名
                menu            菜单
                messages         <a href="message.html#:messages">:messages</a>  子选项
                option          选项
                packadd         可选包  <a href="repeat.html#pack-add">pack-add</a>  名
                retab            <a href="change.html#:retab">:retab</a>  子选项
                scriptnames     执行过的脚本名  <a href="repeat.html#:scriptnames">:scriptnames</a> 
                shellcmd        外壳命令
                shellcmdline    带文件名参数的外壳命令行
                sign             <a href="sign.html#:sign">:sign</a>  子选项
                syntax          语法文件名 <a href="options.html#'syntax'">'syntax'</a>
                syntime          <a href="syntax.html#:syntime">:syntime</a>  子选项
                tag             标签
                tag_listfiles   标签、文件名
                user            用户名
                var             用户变量

                如果 <code class="special">{pat}</code> 为空串，返回所有匹配。否则只返回匹配 <code class="special">{pat}</code> 的项目。
                关于 <code class="special">{pat}</code> 中特殊字符的使用，见  <a href="editing.html#wildcards">wildcards</a> 。

                如果可选的 <code class="special">{filtered}</code> 标志位设为 1，应用 <a href="options.html#'wildignore'">'wildignore'</a> 来过滤结
                果。否则返回所有匹配。<a href="options.html#'wildignorecase'">'wildignorecase'</a> 选项则总是有效。

                如果 <a href="options.html#'wildoptions'">'wildoptions'</a> 选项包含 <code class="badlink">'fuzzy'</code>，补全匹配使用模糊匹配，否
                则使用正则表达式匹配。因此，此函数和用户在命令行的偏好保持一
                致。如果不想如此，可在调用 getcompletion() 前清空
                <a href="options.html#'wildoptions'">'wildoptions'</a>，之后再复原。

                如果 <code class="special">{type}</code> 为 "cmdline"，返回  <a href="cmdline.html#cmdline-completion">cmdline-completion</a>  的结果。例
                如，要补全 ":call" 命令之后可能的取值: 
<code class="example">                        echo getcompletion('call ', 'cmdline')</code>

                如果没有匹配，返回空列表。如果 <code class="special">{type}</code> 为非法值，报错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPattern()-&gt;getcompletion('color')</code>

                返回类型: list<code class="special">&lt;string&gt;</code>


getcompletiontype(<code class="special">{pat}</code>)                                <b class="vimtag"> <a name="getcompletiontype()">getcompletiontype()</a> </b>
                返回 <code class="special">{pat}</code> 使用的命令补全的类型。如果找不到对应的补全类型，返
                回空串。
                要得到当前命令行补全类型，可用  <a href="builtin.html#getcmdcompltype()">getcmdcompltype()</a> 。

                返回类型: list<code class="special">&lt;string&gt;</code>


getcurpos([<code class="special">{winid}</code>])                                    <b class="vimtag"> <a name="getcurpos()">getcurpos()</a> </b>
                返回光标位置。类似于 getpos('.')，但返回列表中包含一个额外的
                "curswant" 项目:
<code class="section">                    [0, lnum, col, off, curswant] </code>
                "curswant" 数值是垂直移动光标时的首选列。 <a href="motion.html#$">$</a>  命令后，它将是等
                同于  <a href="eval.html#v:maxcol">v:maxcol</a>  的一个很大的值。另见  <a href="builtin.html#getcursorcharpos()">getcursorcharpos()</a>  和
                 <a href="builtin.html#getpos()">getpos()</a> 。
                首个 "bufnum" 项目总是为零。<code class="badlink">'col'</code> 返回的是光标的字节位置。要得
                到字符位置，用  <a href="builtin.html#getcursorcharpos()">getcursorcharpos()</a> 。

                可选的 <code class="special">{winid}</code> 参数可指定窗口。可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。返
                回最近已知的光标位置，如果缓冲区的当前值不是当前窗口，可能会非
                法。<code class="special">{winid}</code> 非法时返回零组成的列表。

                可用于保存和恢复光标位置: 
<code class="example">                        let save_cursor = getcurpos()</code>
<code class="example">                        移动光标</code>
<code class="example">                        call setpos('.', save_cursor)</code>
                <code class="note">注意</code> 这只适用于同一窗口内的移动。要恢复更多状态，见
                 <a href="builtin.html#winrestview()">winrestview()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;getcurpos()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


getcursorcharpos([<code class="special">{winid}</code>])                             <b class="vimtag"> <a name="getcursorcharpos()">getcursorcharpos()</a> </b>
                同  <a href="builtin.html#getcurpos()">getcurpos()</a> ，但返回列表中的列号是字符索引而不是字节索引。

                示例:
                如果光标在第三行文本 "여보세요" 的 '보' 时: 
<code class="example">                        getcursorcharpos()      返回 [0, 3, 2, 0, 3]</code>
<code class="example">                        getcurpos()             返回 [0, 3, 4, 0, 3]</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;getcursorcharpos()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


getcwd([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])                           <b class="vimtag"> <a name="getcwd()">getcwd()</a> </b>
                返回字符串，当前工作目录的名字。忽略 <a href="options.html#'autochdir'">'autochdir'</a>。

                有 <code class="special">{winr}</code> 则返回当前标签页的该窗口的本地当前目录。<code class="special">{winr}</code> 可以
                是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                <code class="special">{winr}</code> 为 -1 时返回全局工作目录名。另见  <a href="builtin.html#haslocaldir()">haslocaldir()</a> 。

                有 <code class="special">{winr}</code> 和 <code class="special">{tabnr}</code> 则返回指定标签页和窗口的本地当前目录。如
                果 <code class="special">{winnr}</code> 为 -1，返回指定标签页的当前目录。
                如果 <code class="special">{winr}</code> 为零使用当前窗口。如果 <code class="special">{tabnr}</code> 为零使用当前标签
                页。
                无参数时，返回当前窗口的实际工作目录。
                参数非法时返回空串。

                示例: 
<code class="example">                        " 返回当前窗口的工作目录</code>
<code class="example">                        :echo getcwd()</code>
<code class="example">                        :echo getcwd(0)</code>
<code class="example">                        :echo getcwd(0, 0)</code>
<code class="example">                        " 返回标签页 2 中的窗口 3 的工作目录</code>
<code class="example">                        :echo getcwd(3, 2)</code>
<code class="example">                        " 返回全局工作目录</code>
<code class="example">                        :echo getcwd(-1)</code>
<code class="example">                        " 返回标签页 3 的工作目录</code>
<code class="example">                        :echo getcwd(-1, 3)</code>
<code class="example">                        " 返回当前标签页的工作目录</code>
<code class="example">                        :echo getcwd(-1, 0)</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;getcwd()</code>

                返回类型:  <a href="eval.html#String">String</a> 


getenv(<code class="special">{name}</code>)                                          <b class="vimtag"> <a name="getenv()">getenv()</a> </b>
                返回环境变量 <code class="special">{name}</code> 的值。<code class="special">{name}</code> 参数为不带前导 '$' 的字符串。
                例如: 
<code class="example">                        myHome = getenv('HOME')</code>
<code class="example"></code>
                如果该变量不存在返回  <a href="eval.html#v:null">v:null</a> 。这和变量设为空串时不同，不过有
                的系统把空值解读为删除了的变量。另见  <a href="eval.html#expr-env">expr-env</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetVarname()-&gt;getenv()</code>

                返回类型:  <a href="eval.html#String">String</a>  或  <a href="eval.html#Number">Number</a> 


getfontname([<code class="special">{name}</code>])                                   <b class="vimtag"> <a name="getfontname()">getfontname()</a> </b>
                如果没有参数，返回使用的正常字体的名字，也就是 Normal 高亮组
                 <a href="syntax.html#hl-Normal">hl-Normal</a>  使用的。
                如果带了参数，检查字符串 <code class="special">{name}</code> 是否合法的字体名。如果不是，返
                回空字符串。否则，返回实际的字体名，或者如果 GUI 不支持取得真
                正的名字，返回 <code class="special">{name}</code>。
                只有在 GUI 运行的时候才能用，所以不能用于你的 vimrc 和 gvimrc
                文件。用  <a href="autocmd.html#GUIEnter">GUIEnter</a>  自动命令可以在 GUI 刚开始之后使用此函数。
                <code class="note">注意</code> GTK GUI 接受任何字体名，所以不会检查名字是否合法。

                返回类型:  <a href="eval.html#String">String</a> 


getfperm(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getfperm()">getfperm()</a> </b>
                返回字符串，给定文件 <code class="special">{fname}</code> 的读、写、执行权限。
                如果 <code class="special">{fname}</code> 不存在或者它所在的目录无法读取，返回空字符串。
                返回值的形式是 "rwxrwxrwx"，其中每组 "rwx" 标志位分别代表文件
                所有者、文件所属组和其它用户的权限。如果用户没有某权限，相应的
                标志位被字符串 "-" 代替。例如: 
<code class="example">                        :echo getfperm("/etc/passwd")</code>
<code class="example">                        :echo getfperm(expand("~/.vimrc"))</code>
                希望它会 (从安全角度而言) 显示字符串 "rw-r--r--" 或者甚至
                "rw-------"。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;getfperm()</code>

                返回类型:  <a href="eval.html#String">String</a> 

                要设置权限，可用  <a href="builtin.html#setfperm()">setfperm()</a> 。


getfsize(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getfsize()">getfsize()</a> </b>
                返回数值，文件 <code class="special">{fname}</code> 以字节数计算的大小。
                如果 <code class="special">{fname}</code> 是目录，返回 0。
                如果找不到文件 <code class="special">{fname}</code>，返回 -1。
                如果 <code class="special">{fname}</code> 文件过大，超出了 Vim 的数值的范围，返回 -2。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;getfsize()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


getftime(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getftime()">getftime()</a> </b>
                返回数值，给定文件 <code class="special">{fname}</code> 的最新修改时间。该时间为 1970 年 1
                月 1 日开始计算的秒数，可以传给  <a href="builtin.html#strftime()">strftime()</a> 。
                另见  <a href="builtin.html#localtime()">localtime()</a>  和  <a href="builtin.html#strftime()">strftime()</a> 。
                如果找不到文件 <code class="special">{fname}</code>，返回 -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;getftime()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


getftype(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getftype()">getftype()</a> </b>
                返回字符串，给定文件 <code class="special">{fname}</code> 的文件类型的描述。
                如果 <code class="special">{fname}</code> 不存在，返回空字符串。
                下表列出各种不同文件类型的返回值:
                        普通文件                "file"
                        目录                    "dir"
                        符号链接                "link"
                        块设备                  "bdev"
                        字符设备                "cdev"
                        套接字                  "socket"
                        FIFO                    "fifo"
                        其它                    "other"
                例如: 
<code class="example">                        getftype("/home")</code>
                <code class="note">注意</code> 只有在能支持的系统上才会返回 "link" 这样的类型。有的系统
                只支持 "dir" 和 "file"。MS-Windows 上目录的符号链接返回 "dir"
                而不是 "link"。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;getftype()</code>

                返回类型:  <a href="eval.html#String">String</a> 


getimstatus()                                           <b class="vimtag"> <a name="getimstatus()">getimstatus()</a> </b>
                返回数值，IME 状态激活时为  <a href="eval.html#TRUE">TRUE</a> ，否则为  <a href="eval.html#FALSE">FALSE</a> 。
                见 <a href="options.html#'imstatusfunc'">'imstatusfunc'</a>。

                返回类型:  <a href="eval.html#Number">Number</a> 


getjumplist([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])                      <b class="vimtag"> <a name="getjumplist()">getjumplist()</a> </b>
                返回指定窗口的  <a href="motion.html#jumplist">jumplist</a> 。

                无参数时使用当前窗口。
                如果只带 <code class="special">{winnr}</code>，使用当前标签页的指定窗口。
                <code class="special">{winnr}</code> 也可以是  <a href="windows.html#window-ID">window-ID</a> 。
                有 <code class="special">{winr}</code> 和 <code class="special">{tabnr}</code> 则返回指定标签页的指定窗口。如果 <code class="special">{winnr}</code>
                或 <code class="special">{tabnr}</code> 非法，返回空列表。

                返回列表包含两个项目: 包含跳转位置的列表以及在该列表中的最近使
                用的跳转位置号。跳转位置列表的每个项目是包含以下内容的字典:
                        bufnr           缓冲区号
                        col             列号
                        coladd          用于 <a href="options.html#'virtualedit'">'virtualedit'</a> 的列偏移
                        filename        文件名，如有的话
                        lnum            行号

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;getjumplist()</code>

                返回类型: list<code class="special">&lt;any&gt;</code>


getline(<code class="special">{lnum}</code> [, <code class="special">{end}</code>])                               <b class="vimtag"> <a name="getline()">getline()</a> </b>
                如果没有 <code class="special">{end}</code>，返回字符串，即当前缓冲区第 <code class="special">{lnum}</code> 行文本。
                例如: 
<code class="example">                        getline(1)</code>
                如果 <code class="special">{lnum}</code> 是不以数字开始的字符串，调用  <a href="builtin.html#line()">line()</a>  来把该字符串
                转化成数值。要得到光标所在的行: 
<code class="example">                        getline(".")</code>
                如果 <code class="special">{lnum}</code> 是小于 1 或者大于缓冲区的总行数的数值，返回空串。

                如果给出 <code class="special">{end}</code>，返回  <a href="eval.html#List">List</a> ，其中每个项目是当前缓冲区从 <code class="special">{lnum}</code>
                到 <code class="special">{end}</code> (包含) 范围的一行。
                <code class="special">{end}</code> 的用法同 <code class="special">{lnum}</code>。
                安静地忽略不存在的行。
                如果 <code class="special">{end}</code> 在 <code class="special">{lnum}</code> 之前，返回空  <a href="eval.html#List">List</a> 。
                例如: 
<code class="example">                        :let start = line('.')</code>
<code class="example">                        :let end = search("^$") - 1</code>
<code class="example">                        :let lines = getline(start, end)</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ComputeLnum()-&gt;getline()</code>

                返回类型: list<code class="special">&lt;string&gt;</code> 或  <a href="eval.html#String">String</a> ，取决于 <code class="special">{end}</code>

                要获取其它缓冲区的文本行，见  <a href="builtin.html#getbufline()">getbufline()</a>  和
                 <a href="builtin.html#getbufoneline()">getbufoneline()</a> 。

getloclist(<code class="special">{nr}</code> [, <code class="special">{what}</code>])                             <b class="vimtag"> <a name="getloclist()">getloclist()</a> </b>
                返回  <a href="eval.html#List">List</a> ，包含窗口 <code class="special">{nr}</code> 的位置列表的所有项目。<code class="special">{nr}</code> 可以是窗
                口号或  <a href="windows.html#window-ID">window-ID</a> 。如果 <code class="special">{nr}</code> 为 0，使用当前窗口。

                如果是位置列表窗口，返回其显示的位置列表。如果窗口号 <code class="special">{nr}</code> 非
                法，返回空列表。其它的情况和  <a href="builtin.html#getqflist()">getqflist()</a>  相同。

                如果提供了可选的 <code class="special">{what}</code> 字典参数，以字典形式返回 <code class="special">{what}</code> 列出的
                项目。关于 <code class="special">{what}</code> 支持的项目，可参考  <a href="builtin.html#getqflist()">getqflist()</a> 。

                除了  <a href="builtin.html#getqflist()">getqflist()</a>  的 <code class="special">{what}</code> 支持的项目以外， <a href="builtin.html#getloclist()">getloclist()</a>  还
                支持以下项目:

                        filewinid       用于显示来自位置列表的文件的窗口的
                                        id。只有当调用来自位置列表窗口时此域才
                                        可用。详见
                                         <a href="quickfix.html#location-list-file-window">location-list-file-window</a> 。

                如果窗口 <code class="special">{nr}</code> 没有位置列表，返回带缺省值的  <a href="eval.html#Dictionary">Dictionary</a> 。
                如果窗口 <code class="special">{nr}</code> 不存在，返回空字典。

                示例 (另见  <a href="quickfix.html#getqflist-examples">getqflist-examples</a> ): 
<code class="example">                        :echo getloclist(3, {'all': 0})</code>
<code class="example">                        :echo getloclist(5, {'filewinid': 0})</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt; 或 list<code class="special">&lt;any&gt;</code>


getmarklist([<code class="special">{buf}</code>])                                    <b class="vimtag"> <a name="getmarklist()">getmarklist()</a> </b>
                无 <code class="special">{buf}</code> 参数时，返回  <a href="eval.html#List">List</a> ，给出所有全局位置标记的信息。
                 <a href="motion.html#mark">mark</a> 

                给出可选的 <code class="special">{buf}</code> 参数时，返回缓冲区 <code class="special">{buf}</code> 中定义的局部位置标
                记。<code class="special">{buf}</code> 的用法可见  <a href="builtin.html#bufname()">bufname()</a> 。<code class="special">{buf}</code> 非法时返回空列表。

                返回列表的每个项目是包含以下内容的  <a href="eval.html#Dict">Dict</a> :
                    mark   带 "'" 前缀的位置标记名
                    pos    位置标记所在位置的  <a href="eval.html#List">List</a> :
                                [bufnum, lnum, col, off]
                           详情请参考  <a href="builtin.html#getpos()">getpos()</a> 。
                    file   文件名

                要获取特定位置标记的信息，参见  <a href="builtin.html#getpos()">getpos()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufnr()-&gt;getmarklist()</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt; 或 list<code class="special">&lt;any&gt;</code>


getmatches([<code class="special">{win}</code>])                                     <b class="vimtag"> <a name="getmatches()">getmatches()</a> </b>
                返回之前  <a href="builtin.html#matchadd()">matchadd()</a>  和  <a href="pattern.html#:match">:match</a>  命令为当前窗口定义的所有匹配
                组成的列表  <a href="eval.html#List">List</a> 。 <a href="builtin.html#getmatches()">getmatches()</a>  常和  <a href="builtin.html#setmatches()">setmatches()</a>  组合使
                用，因为  <a href="builtin.html#setmatches()">setmatches()</a>  可以恢复  <a href="builtin.html#getmatches()">getmatches()</a>  保存的匹配列
                表。
                如果指定 <code class="special">{win}</code>，使用对应此窗口号或窗口 ID 的窗口，而不是当前窗
                口。<code class="special">{win}</code> 非法时返回空列表。
                示例: 
<code class="example">                        :echo getmatches()</code>
                        [{<code class="badlink">'group'</code>: 'MyGroup1', <code class="badlink">'pattern'</code>: 'TODO',
                        <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 1}, {<code class="badlink">'group'</code>: 'MyGroup2',
                        <code class="badlink">'pattern'</code>: 'FIXME', <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 2}] 
<code class="example">                        :let m = getmatches()</code>
<code class="example">                        :call clearmatches()</code>
<code class="example">                        :echo getmatches()</code>
                        [] 
<code class="example">                        :call setmatches(m)</code>
<code class="example">                        :echo getmatches()</code>
                        [{<code class="badlink">'group'</code>: 'MyGroup1', <code class="badlink">'pattern'</code>: 'TODO',
                        <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 1}, {<code class="badlink">'group'</code>: 'MyGroup2',
                        <code class="badlink">'pattern'</code>: 'FIXME', <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 2}] 
<code class="example">                        :unlet m</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt; 或 list<code class="special">&lt;any&gt;</code>


getmousepos()                                           <b class="vimtag"> <a name="getmousepos()">getmousepos()</a> </b>
                返回鼠标最近已知位置的  <a href="eval.html#Dictionary">Dictionary</a> 。可用于鼠标点击的映射或弹
                出窗口的过滤。项目是:
                        screenrow       屏幕行
                        screencol       屏幕列
                        winid           点击所在的窗口 ID
                        winrow          "winid" 里的行
                        wincol          "winid" 里的列
                        line            "winid" 里的文本内容行
                        column          "winid" 里的文本列
                        coladd          点击所在字符开始处的 (以屏幕列计) 偏移
                所有的数值从 1 开始。

                如果鼠标不在窗口上，比如在命令行或  <a href="tabpage.html#tabpanel">tabpanel</a>  里，则只有
                "screenrow" 和 "screencol" 是合法的，其它的值均为零。

                如果鼠标在窗口底下的状态行上或窗口右侧的垂直分割线上，"line"
                和 "column" 的值为零。

                如果位置在文本之后，那么 "column" 是文本以字节计的长度加一。

                如果鼠标在弹出窗口上，使用该窗口。

                使用  <a href="builtin.html#getchar()">getchar()</a>  时，Vim 变量  <a href="eval.html#v:mouse_lnum">v:mouse_lnum</a> 、 <a href="eval.html#v:mouse_col">v:mouse_col</a>  和
                 <a href="eval.html#v:mouse_winid">v:mouse_winid</a>  也能提供相应的这些值。

                返回类型: dict<code class="special">&lt;number&gt;</code>


getmouseshape()                                         <b class="vimtag"> <a name="getmouseshape()">getmouseshape()</a> </b>
                返回当前显示的鼠标指针的外型名。如果不支持  <a href="various.html#+mouseshape">+mouseshape</a>  特性
                或外型未知，返回空串。
                本函数主要用于测试。

                返回类型:  <a href="eval.html#String">String</a> 


getpid()                                                <b class="vimtag"> <a name="getpid()">getpid()</a> </b>
                返回数值，即 Vim 进程的进程号。Unix 和 MS-Windows 上这是个唯一
                的数值，直到 Vim 退出为止。

                返回类型:  <a href="eval.html#Number">Number</a> 


getpos(<code class="special">{expr}</code>)                                          <b class="vimtag"> <a name="getpos()">getpos()</a> </b>
                得到字符串 <code class="special">{expr}</code> 的位置。
                可接受的位置是:                          <b class="vimtag"> <a name="E1209">E1209</a> </b>
                    .       光标位置。
                    $       当前缓冲区的最后一行。
                    'x      位置标记 x 的位置 (如果该位置标记没有设置，所有值
                            返回 0)。
                    w0      当前窗口可见部分的首行 (如果显示不刷新，如安静 Ex
                            模式下，则为一)。
                    w$      当前窗口可见部分的末行 (如果无行可见，返回比 w0 小
                            一的值)。
                    v       不在可视模式下，返回光标位置。可视模式下，返回可视
                            区域另一端。一个容易理解的方法是记住在可视模式下，
                            "v" 和 ".": 总是互补。"." 指向光标位置，而 "v" 指
                            向  <a href="visual.html#v_o">v_o</a>  会移动光标到的地方。所以，可用 "v" 和 "."
                            组合进行面向字符的可视模式的各种选择。如果光标在面
                            向字符的可视模式的结尾，"v" 指向相同可视区域的开始
                            处。而如果光标在面向字符的可视模式的开始处，"v" 指
                            向相同可视区域的结尾。"v" 和  <a href="motion.html#'%3C">'&lt;</a>  及  <a href="motion.html#'%3E">'&gt;</a>  不同，因
                            为它会立即更新。
                <code class="note">注意</code> 可以使用其它文件的位置标记。此时行号应用于那个缓冲区。

                返回  <a href="eval.html#List">List</a> ，包含四个数值:
                    [bufnum, lnum, col, off]
                "bufnum" 为零，除非使用了 '0 或 'A 这样的位置标记，这时它是此
                位置标记所在的缓冲区号。
                "lnum" 和 "col" 是缓冲区里的位置。第一列为 1。
                除非使用了 <a href="options.html#'virtualedit'">'virtualedit'</a>。"off" 值为零，这是从对应字符开始位置
                的以屏幕列计的位移。例如，在制表之中或最后一个字符之后的某个位
                置。

                要得到光标位置，见  <a href="builtin.html#getcurpos()">getcurpos()</a> 。
                返回列表中的列号是行内的字节位置。要得行内的字符位置，用
                 <a href="builtin.html#getcharpos()">getcharpos()</a> 。

                <code class="note">注意</code> '&lt; 和 '&gt; 和可视模式有关: "V" (可视行模式) 时 '&lt; 的列为
                零，'&gt; 的列是等于  <a href="eval.html#v:maxcol">v:maxcol</a>  的一个大数。
                可返回等于  <a href="eval.html#v:maxcol">v:maxcol</a>  的大列号，这种情况代表 "在行尾之后"。
                <code class="special">{expr}</code> 如非法，返回全零组成的列表。

                可以用来保存和恢复光标位置: 
<code class="example">                        let save_a_mark = getpos("'a")</code>
<code class="example">                        ...</code>
<code class="example">                        call setpos("'a", save_a_mark)</code>

                另见  <a href="builtin.html#getcharpos()">getcharpos()</a> 、 <a href="builtin.html#getcurpos()">getcurpos()</a>  和  <a href="builtin.html#setpos()">setpos()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMark()-&gt;getpos()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


getqflist([<code class="special">{what}</code>])                                     <b class="vimtag"> <a name="getqflist()">getqflist()</a> </b>
                返回  <a href="eval.html#List">List</a> ，包含所有当前快速修复错误。列表的每个项目是包含以
                下项目的字典:
                        bufnr   有此文件名的缓冲区号， <a href="builtin.html#bufname()">bufname()</a>  得到缓冲区名
                        module  模块名
                        lnum    缓冲区里的行号 (第一行是 1)
                        end_lnum
                                如果项目为多行，末行的行号
                        col     列号 (第一列是 1)
                        end_col 如果项目有范围，末列的列号
                        vcol     <a href="eval.html#TRUE">TRUE</a> : "col" 是可视列
                                 <a href="eval.html#FALSE">FALSE</a> : "col" 是字节位置
                        nr      错误号
                        pattern 用于定位错误的搜索模式
                        text    错误描述
                        type    错误类型，'E'、'1' 等。
                        valid    <a href="eval.html#TRUE">TRUE</a> : 能识别该错误信息
                        user_data
                                和项目关联的定制数据，可为任何类型。

                如果没有错误列表或者它为空，返回空列表。快速修复列表项目如果包
                含不存在的缓冲区号，返回的 "bufnr" 置为零 (<code class="note">注意</code> 有些函数接受缓
                冲区号零，代表轮换缓冲区，为此，可能需要显式检查零值)。

                应用: 在多个文件里寻找模式的匹配，并对之进行处理: 
<code class="example">                        :vimgrep /theword/jg *.c</code>
<code class="example">                        :for d in getqflist()</code>
<code class="example">                        :   echo bufname(d.bufnr) ':' d.lnum '=' d.text</code>
<code class="example">                        :endfor</code>

                如果提供了可选的 <code class="special">{what}</code> 字典参数，以字典形式返回 <code class="special">{what}</code> 列出的
                项目。<code class="special">{what}</code> 支持以下字符串项目:
                        changedtick      <a href="quickfix.html#quickfix-changedtick">quickfix-changedtick</a>  列表改变的总数
                        context 获取  <a href="quickfix.html#quickfix-context">quickfix-context</a> 
                        efm     解析 "lines" 时使用的 errorformat。如果没有给
                                出，使用 <a href="options.html#'errorformat'">'errorformat'</a> 选项值。
                        id      获取快速修复列表  <a href="quickfix.html#quickfix-ID">quickfix-ID</a>  说明的信息。
                                零代表当前列表或 "nr" 指定的列表
                        idx     获取由 <code class="badlink">'id'</code> 或 <code class="badlink">'nr'</code> 指定的快速修复列表中在此索
                                引的项目信息。
                                如果设为零，使用当前项目。
                                见  <a href="quickfix.html#quickfix-index">quickfix-index</a> 
                        items   获取快速修复列表的项目
                        lines   用 <a href="options.html#'efm'">'efm'</a> 解析文本行列表并返回其结果项目。只支
                                持  <a href="eval.html#List">List</a>  类型。不修改当前快速修复列表。见
                                 <a href="quickfix.html#quickfix-parse">quickfix-parse</a> 。
                        nr      获取关于指定快速修复列表的信息；零代表当前快速
                                修复列表，"$" 代表最后的快速修复列表
                        qfbufnr 快速修复窗口显示的缓冲区号。快速修复缓冲区不存
                                在时返回 0。见  <a href="quickfix.html#quickfix-buffer">quickfix-buffer</a> 。
                        size    快速修复列表的项目总数
                        title   获取列表标题  <a href="quickfix.html#quickfix-title">quickfix-title</a> 
                        winid   获取快速修复  <a href="windows.html#window-ID">window-ID</a> 
                        all     上述所有的快速修复属性
                忽略 <code class="special">{what}</code> 中非字符串项。要获取某个特定项之值，先设为零。
                如果不给出 "nr"，使用当前快速修复列表。
                同时给出 "nr" 和非零 "id" 时，使用 "id" 指定的列表。
                要取得快速修复栈的列表数目，在 <code class="special">{what}</code> 中设置 <code class="badlink">'nr'</code> 为 "$"。返回
                字典中的 "nr" 值会告诉你快速修复的栈大小。
                如果给出 "lines"，忽略除 "efm" 外的所有其它项。返回的字典包
                含 "items" 项，给出所有项目的列表。

                返回字典包含以下项目:
                        changedtick      <a href="quickfix.html#quickfix-changedtick">quickfix-changedtick</a>  列表改变的总数
                        context 快速修复列表的上下文，见  <a href="quickfix.html#quickfix-context">quickfix-context</a> 
                                如果不存在，设为 ""。
                        id      快速修复列表 ID  <a href="quickfix.html#quickfix-ID">quickfix-ID</a> 。如果不存在，设
                                为 0。
                        idx     列表中快速修复项目的索引。如果不存在，设为 0。
                        items   快速修复列表的项目。如果不存在，设为空列表。
                        nr      快速修复列表号。如果不存在，设为 0
                        qfbufnr 快速修复窗口显示的缓冲区号。如果不存在，设为
                                0。
                        size    快速修复列表的项数。如果不存在，设为 0。
                        title   快速修复列表标题文本。如果不存在，设为 ""。
                        winid   快速修复  <a href="windows.html#window-ID">window-ID</a> 。如果不存在，设为 0

                示例 (另见  <a href="quickfix.html#getqflist-examples">getqflist-examples</a> ): 
<code class="example">                        :echo getqflist({'all': 1})</code>
<code class="example">                        :echo getqflist({'nr': 2, 'title': 1})</code>
<code class="example">                        :echo getqflist({'lines' : ["F1:10:L10"]})</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt; 或 list<code class="special">&lt;any&gt;</code>


getreg([<code class="special">{regname}</code> [, 1 [, <code class="special">{list}</code>]]])                    <b class="vimtag"> <a name="getreg()">getreg()</a> </b>
                返回字符串，寄存器 <code class="special">{regname}</code> 的内容。例如: 
<code class="example">                        :let cliptext = getreg('*')</code>
                如果 <code class="special">{regname}</code> 对应的寄存器没有设过，返回空串。
                <code class="special">{regname}</code> 参数必须为字符串。 <b class="vimtag"> <a name="E1162">E1162</a> </b>

                getreg('=') 返回最近一次表达式寄存器计算的返回值 (用于映射)。
                getreg('=', 1) 返回表达式自身，以便用  <a href="builtin.html#setreg()">setreg()</a>  恢复。对于其
                它寄存器，这个额外的参数被忽略，所以给出此参数总是无妨。

                如果 <code class="special">{list}</code> 给出且为  <a href="eval.html#TRUE">TRUE</a> ，改变返回值为列表。每个列表项是一
                个文本行。如果你在意寄存器内可能存在的零字节，可以用这种形式:
                不用第三个参数时 NL 和零字节都用 NL 表示 (见
                 <a href="pattern.html#NL-used-for-Nul">NL-used-for-Nul</a> )。
                如果 <code class="special">{regname}</code> 对应的寄存器没有设过，返回空列表。

                如果 <code class="special">{regname}</code> 为 ""，使用无名寄存器 '"'。
                如果没有指定 <code class="special">{regname}</code>，使用  <a href="eval.html#v:register">v:register</a> 。
                 <a href="vim9.html#Vim9-script">Vim9-script</a>  中 <code class="special">{regname}</code> 必须为单个字符。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRegname()-&gt;getreg()</code>

                返回类型:  <a href="eval.html#String">String</a>  或 list<code class="special">&lt;string&gt;</code>，取决于 <code class="special">{list}</code>


getreginfo([<code class="special">{regname}</code>])                                 <b class="vimtag"> <a name="getreginfo()">getreginfo()</a> </b>
                返回寄存器 <code class="special">{regname}</code> 的详细信息，即带下列项目的字典:
                        regcontents     寄存器 <code class="special">{regname}</code> 包含的行列表，相当于
                                         <code class="badlink">getreg</code> (<code class="special">{regname}</code>, 1, 1)。
                        regtype         寄存器 <code class="special">{regname}</code> 的类型，见
                                         <a href="builtin.html#getregtype()">getregtype()</a> 。
                        isunnamed       布尔标志位，如果无名寄存器当前指向此寄
                                        存器，返回 v:true。
                        points_to       用于无名寄存器，给出当前指向的寄存器的
                                        单字母名 (见  <a href="change.html#quotequote">quotequote</a> )。例如，用
                                         <a href="change.html#dd">dd</a>  删除一行后，此字段设为 "1"，这是
                                        包含被删除文本的寄存器。

                <code class="special">{regname}</code> 参数为字符串。<code class="special">{regname}</code> 非法或对应的寄存器没有设过
                时，返回空列表。
                如果 <code class="special">{regname}</code> 为 "" 或 "@"，使用无名寄存器 '"'。
                如果没有指定 <code class="special">{regname}</code>，使用  <a href="eval.html#v:register">v:register</a> 。
                返回的字典可传递给  <a href="builtin.html#setreg()">setreg()</a> 。
                 <a href="vim9.html#Vim9-script">Vim9-script</a>  中 <code class="special">{regname}</code> 必须为单个字符。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRegname()-&gt;getreginfo()</code>

                返回类型: dict<code class="special">&lt;any&gt;</code>


getregion(<code class="special">{pos1}</code>, <code class="special">{pos2}</code> [, <code class="special">{opts}</code>])                    <b class="vimtag"> <a name="getregion()">getregion()</a> </b>
                返回缓冲区从 <code class="special">{pos1}</code> 到 <code class="special">{pos2}</code> 的字符串列表。

                <code class="special">{pos1}</code> 和 <code class="special">{pos2}</code> 必须为带四个数值的  <a href="eval.html#List">List</a> 。列表的格式见
                 <a href="builtin.html#getpos()">getpos()</a> 。可以指定另一缓冲区的位置，但请先看一下
                 <a href="builtin.html#getregion-notes">getregion-notes</a>  的限制说明。

                可选参数 <code class="special">{opts}</code> 是支持以下项目的字典:

                        type            指定区域的选择类型。可能值见
                                         <a href="builtin.html#getregtype()">getregtype()</a> ，但宽度可以省略，且不能
                                        用空串。
                                        (缺省: "v")

                        exclusive       如为  <a href="eval.html#TRUE">TRUE</a> ，结束位置为开的。
                                        (缺省: 跟随 <a href="options.html#'selection'">'selection'</a>)

                可用  <a href="builtin.html#visualmode()">visualmode()</a>  得到最近的选择类型。如果可视模式现在激活，
                用  <a href="builtin.html#mode()">mode()</a>  得到可视模式 (如在  <a href="map.html#:vmap">:vmap</a>  里)。
                此函数可用于获取  <a href="visual.html#characterwise-visual">characterwise-visual</a>  这种文本开始和结束处可
                以在不同列的选择方式。

                                                        <b class="vimtag"> <a name="getregion-notes">getregion-notes</a> </b>
                请<code class="note">注意</code>:
                - <code class="special">{pos1}</code> 和 <code class="special">{pos2}</code> 的顺序无关紧要。总是返回从左上角到右下角的
                  内容。
                - <a href="options.html#'virtualedit'">'virtualedit'</a> 打开时，区域会跨越行尾，生成行里以空格填充。
                - 区域面向列块时，如果它的开始或结束处在某多单元字符的中间，不
                  包括此字符，选中的部分以空格代替。
                - <code class="special">{pos1}</code> 和 <code class="special">{pos2}</code> 如不在同一缓冲区，返回空列表。
                - <code class="special">{pos1}</code> 和 <code class="special">{pos2}</code> 必须属于一个  <a href="builtin.html#bufloaded()">bufloaded()</a>  的缓冲区。
                - 在当前窗口上下文下计算，如果缓冲区在带有不同的 <a href="options.html#'virtualedit'">'virtualedit'</a>
                  或 <a href="options.html#'list'">'list'</a> 值的窗口中显示，会导致区别。
                - 指定开的选择区且 <code class="special">{pos1}</code> 和 <code class="special">{pos2}</code> 相同时，返回列表包含单个字
                  符，就像选择的是闭区间那样，这匹配可视模式下空的开选择区的行
                  为。

                示例: 
<code class="example">                        :xnoremap &lt;CR&gt;</code>
<code class="example">                        \ &lt;Cmd&gt;echow getregion(</code>
<code class="example">                        \ getpos('v'), getpos('.'), #{ type: mode() })&lt;CR&gt;</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        getpos('.')-&gt;getregion(getpos("'a"))</code>

                返回类型: list<code class="special">&lt;string&gt;</code>


getregionpos(<code class="special">{pos1}</code>, <code class="special">{pos2}</code> [, <code class="special">{opts}</code>])                 <b class="vimtag"> <a name="getregionpos()">getregionpos()</a> </b>
                同  <a href="builtin.html#getregion()">getregion()</a> ，但返回 <code class="special">{pos1}</code> 和 <code class="special">{pos2}</code> 定界的缓冲区文本片段
                的位置列表。
                片段指的是对应每行上的一对位置: 
<code class="example">                        [[{start_pos}, {end_pos}], ...]</code>

                位置是包含四个数值的  <a href="eval.html#List">List</a> :
                    [bufnum, lnum, col, off]
                "bufnum" 为缓冲区号。
                "lnum" 和 "col" 是缓冲区里的位置。首列的列号为 1。
                如果起始位置的 "off" 值非零，它指定相对于字符开始处以屏幕列计
                的偏移值。如 <code class="special">&lt;Tab&gt;</code> 中间和末字符之后的某个位置。如果结束位置的
                "off" 值非零，它指定该字符的首个不在选择范围的单元偏移值，否则
                该字符的所有单元都被选择。

                除了  <a href="builtin.html#getregion()">getregion()</a>  支持的选项以外，<code class="special">{opts}</code> 也支持下列值:

                        eol             如为  <a href="eval.html#TRUE">TRUE</a> ，"col" 用行长加一来指示行
                                        尾之后的位置。
                                        如为  <a href="eval.html#FALSE">FALSE</a> ，位置被局限在行范围内，如
                                        果行为空或选择区完全在行尾之外，两个位
                                        置的 "col" 都使用 0 值。
                                        (缺省:  <a href="eval.html#FALSE">FALSE</a> )

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        getpos('.')-&gt;getregionpos(getpos("'a"))</code>

                示例可见高亮-抽出插件  <a href="usr_52.html#52.6">52.6</a> 

                返回类型: list&lt;list&lt;list<code class="special">&lt;number&gt;</code>&gt;&gt;


getregtype([<code class="special">{regname}</code>])                                 <b class="vimtag"> <a name="getregtype()">getregtype()</a> </b>
                返回字符串，寄存器 <code class="special">{regname}</code> 的类型。
                该值会是以下可能之一:
                    "v"                  <a href="motion.html#characterwise">characterwise</a>  (面向字符) 的文本
                    "V"                  <a href="motion.html#linewise">linewise</a>  (面向行) 的文本
                    "&lt;<code class="keystroke">CTRL-V</code>&gt;<code class="special">{width}</code>"    <a href="visual.html#blockwise-visual">blockwise-visual</a>  (面向列块) 的文本
                    ""                  空或者未知的寄存器
                &lt;<code class="keystroke">CTRL-V</code>&gt; 是一个字符，其值为 0x16。
                <code class="special">{regname}</code> 参数为字符串。如果 <code class="special">{regname}</code> 为 ""，使用无名寄存器
                '"'。
                如果没有指定 <code class="special">{regname}</code>，使用  <a href="eval.html#v:register">v:register</a> 。
                 <a href="vim9.html#Vim9-script">Vim9-script</a>  中 <code class="special">{regname}</code> 必须为单个字符。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRegname()-&gt;getregtype()</code>

                返回类型:  <a href="eval.html#String">String</a> 


getscriptinfo([<code class="special">{opts}</code>])                                 <b class="vimtag"> <a name="getscriptinfo()">getscriptinfo()</a> </b>
                返回  <a href="eval.html#List">List</a> ，包含所有已执行的 Vim 脚本的信息，依执行的顺序排
                列，类似于  <a href="repeat.html#:scriptnames">:scriptnames</a>  显示的结果。

                可选的字典参数 <code class="special">{opts}</code> 支持以下可选项目:
                    name        脚本名匹配模式，如指定此项目而不指定 "sid"，返
                                回名字匹配模式 "name" 的脚本的信息。
                    sid         脚本 ID  <a href="map.html#%3CSID%3E">&lt;SID&gt;</a> 。如果指定，只返回 ID 为 "sid"
                                的脚本的信息，忽略 "name"。

                返回列表的每个项目是包含以下项目的  <a href="eval.html#Dict">Dict</a> :
                    autoload    脚本用 `import autoload` 载入但尚未真正执行时
                                为真 (见  <a href="vim9.html#import-autoload">import-autoload</a> )。
                    functions   脚本中定义的局部于脚本的函数名列表。仅为
                                <code class="special">{opts}</code> 中用 "sid" 项目指定的特定脚本给出。
                    name        Vim 脚本文件名。
                    sid         脚本 ID  <a href="map.html#%3CSID%3E">&lt;SID&gt;</a> 。
                    sourced     如有，此脚本名链接到的实际执行的脚本 ID。否则
                                为零。
                    variables   脚本中定义的局部于脚本的变量列表。仅为 <code class="special">{opts}</code>
                                中用 "sid" 项目指定的特定脚本给出。
                                <code class="note">注意</code> 这是备份，不可用此字典来修改脚本局部变量
                                的值。
                    version     Vim 脚本版本号 ( <a href="eval.html#scriptversion">scriptversion</a> )

                示例: 
<code class="example">                        :echo getscriptinfo({'name': 'myscript'})</code>
<code class="example">                        :echo getscriptinfo({'sid': 15})[0].variables</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt;


getstacktrace()                                         <b class="vimtag"> <a name="getstacktrace()">getstacktrace()</a> </b>
                返回 Vim 脚本的当前栈追踪。
                栈追踪是每个项目为包含以下项目的  <a href="eval.html#Dictionary">Dictionary</a>  的  <a href="eval.html#List">List</a> :
                    funcref     堆栈在函数上时对应的函数引用，否则此项省略。
                    event       堆栈在自动命令事件上时对应的事件描述，否则此项
                                省略。
                    lnum        堆栈在脚本的行号。
                    filepath    堆栈在脚本的文件路径。

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt;


gettabinfo([<code class="special">{tabnr}</code>])                                   <b class="vimtag"> <a name="gettabinfo()">gettabinfo()</a> </b>
                如果没指定 <code class="special">{tabnr}</code>，返回  <a href="eval.html#List">List</a> ，包含所有标签页的信息。每个列
                表项是  <a href="eval.html#Dictionary">Dictionary</a> 。
                否则，<code class="special">{tabnr}</code> 指定标签页号，返回关于该标签页的信息。如果该标志
                页不存在，返回空列表。

                每个列表项是包含以下项目的  <a href="eval.html#Dictionary">Dictionary</a> :
                        tabnr           标签页号
                        variables       包含标签页局部变量的字典的引用
                        windows         标签页中的  <a href="windows.html#window-ID">window-ID</a>  列表。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabnr()-&gt;gettabinfo()</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt;


gettabvar(<code class="special">{tabnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])                 <b class="vimtag"> <a name="gettabvar()">gettabvar()</a> </b>
                得到标签页 <code class="special">{tabnr}</code> 的标签页局部变量 <code class="special">{varname}</code> 的值。 <a href="eval.html#t:var">t:var</a> 
                标签页的编号从一开始。
                <code class="special">{varname}</code> 参数为字符串。如果 <code class="special">{varname}</code> 为空，返回包含所有标签
                页局部变量的字典。
                <code class="note">注意</code> 必须使用不带 "t:" 的名字。
                如果标签页或者变量不存在，返回 <code class="special">{def}</code> 或空字符串。不会有错误消
                息。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabnr()-&gt;gettabvar(varname)</code>

                返回类型: any，取决于 <code class="special">{varname}</code>


gettabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])     <b class="vimtag"> <a name="gettabwinvar()">gettabwinvar()</a> </b>
                得到标签页 <code class="special">{tabnr}</code> 的窗口 <code class="special">{winnr}</code> 的窗口局部变量 <code class="special">{varname}</code> 的
                值。
                <code class="special">{varname}</code> 参数为字符串。如果 <code class="special">{varname}</code> 为空，返回一个包含所有
                窗口局部变量的字典。
                如果 <code class="special">{varname}</code> 为 "&amp;"，返回包含所有窗口局部选项的
                 <a href="eval.html#Dictionary">Dictionary</a> 。
                否则，如果 <code class="special">{varname}</code> 以 "&amp;" 打头，得到窗口局部选项的值。
                <code class="note">注意</code> <code class="special">{varname}</code> 必须为不带 "w:" 的名字。
                标签页的编号从一开始。当前标签页可用  <a href="builtin.html#getwinvar()">getwinvar()</a> 。
                <code class="special">{winnr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{winnr}</code> 为零，使用当前窗口。
                也可用于全局或者局部于缓冲区或局部于窗口的选项，但不能用于全局
                或者局部于缓冲区的变量。
                如果标签页、窗口或者变量不存在，返回 <code class="special">{def}</code> 或空字符串。不会有
                错误消息。
                例如: 
<code class="example">                        :let list_is_on = gettabwinvar(1, 2, '&amp;list')</code>
<code class="example">                        :echo "myvar = " .. gettabwinvar(3, 1, 'myvar')</code>

                要得到所有窗口局部变量，可用: 
<code class="example">                        gettabwinvar({tabnr}, {winnr}, '&amp;')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabnr()-&gt;gettabwinvar(winnr, varname)</code>

                返回类型: any，取决于 <code class="special">{varname}</code>


gettagstack([<code class="special">{winnr}</code>])                                  <b class="vimtag"> <a name="gettagstack()">gettagstack()</a> </b>
                返回字典，窗口 <code class="special">{winnr}</code> 的标签栈。
                <code class="special">{winnr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果没有给出 <code class="special">{winnr}</code>，使用当前窗口。
                如果窗口 <code class="special">{winnr}</code> 不存在，返回空字典。

                返回字典包含如下项目:
                        curidx          栈的当前索引。如果在栈顶，设为
                                        (length + 1)。栈底的索引为 1。
                        items           栈中的项目列表。每个项目是包含下述项的
                                        字典。
                        length          栈中的项目数。

                栈中的每个项目是以下项的字典:
                        bufnr           当前跳转的缓冲区号
                        from            标签跳转之前的光标位置。 <a href="builtin.html#getpos()">getpos()</a>  说
                                        明返回列表的格式。
                        matchnr         当前的匹配标签号。用于同一名字有多个匹
                                        配标签的时候。
                        tagname         标签名

                 <a href="tagsrch.html#tagstack">tagstack</a>  说明标签栈的更多信息。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;gettagstack()</code>

                返回类型: dict<code class="special">&lt;any&gt;</code>


gettext(<code class="special">{text}</code> [, <code class="special">{package}</code>])                           <b class="vimtag"> <a name="gettext()">gettext()</a> </b>
                对字符串 <code class="special">{text}</code> 进行翻译。
                用于 Vim 脚本。要生成消息翻译时，由  <code class="badlink">xgettext</code>  对 <code class="special">{text}</code> 进行
                提取，翻<code class="vim">译者</code>会把翻译后的消息加到 .po 文件，调用 gettext() 时，
                Vim 会依此查找翻译内容。
                <code class="special">{text}</code> 推荐使用双引号括起，因为  <code class="badlink">xgettext</code>  不理解单引号字符串
                里的转义。

                给出 <code class="special">{package}</code> 时，只寻找特定于该包的翻译。主要用于第三方 Vim
                脚本。需要在使用 gettext() 函数前先用  <a href="builtin.html#bindtextdomain()">bindtextdomain()</a>  来指
                定翻译所在的路径。

                返回类型:  <a href="eval.html#String">String</a> 


getwininfo([<code class="special">{winid}</code>])                                   <b class="vimtag"> <a name="getwininfo()">getwininfo()</a> </b>
                返回窗口信息，返回值是字典的  <a href="eval.html#List">List</a> 。

                如果给出 <code class="special">{winid}</code>，返回给定 ID 的窗口的信息，为包含单个项目的
                 <a href="eval.html#List">List</a> 。如果窗口是  <a href="popup.html#popup">popup</a>  窗口，返回该弹出窗口的信息。如果窗
                口不存在，返回空列表。

                如果没有给出 <code class="special">{winid}</code>，返回所有标签页中所有窗口 (但不包括
                 <a href="popup.html#popup">popup</a>  窗口) 的信息。

                每个列表项是包含以下项目的  <a href="eval.html#Dictionary">Dictionary</a> :
                        botline         最近完整显示的缓冲区行
                        bufnr           窗口中的缓冲区号
                        height          窗口高度 (不计窗口工具条 winbar)
                        leftcol         显示的首列；仅用于 <a href="options.html#'wrap'">'wrap'</a> 关闭时
                        loclist         1 如果显示了位置列表
                                        <code class="notvi">{仅当加入  <a href="various.html#+quickfix">+quickfix</a>  特性才有效}</code>
                        quickfix        1 如果是快速修复或位置列表窗口
                                        <code class="notvi">{仅当加入  <a href="various.html#+quickfix">+quickfix</a>  特性才有效}</code>
                        terminal        1 如果是终端窗口
                                        <code class="notvi">{仅当加入  <a href="various.html#+terminal">+terminal</a>  特性才有效}</code>
                        tabnr           标签页号
                        topline         首个显示的缓冲区行
                        variables       包含窗口局部变量的字典的引用
                        width           窗口宽度
                        winbar          1 如果窗口有工具条，0 反之
                        wincol          窗口最左侧屏幕列，
                                         <a href="builtin.html#win_screenpos()">win_screenpos()</a>  中的 "col"
                        textoff         文本前由 <a href="options.html#'foldcolumn'">'foldcolumn'</a>、<a href="options.html#'signcolumn'">'signcolumn'</a> 和
                                        行号所占据的列数
                        winid            <a href="windows.html#window-ID">window-ID</a> 
                        winnr           窗口号
                        winrow          窗口最顶侧屏幕行，
                                         <a href="builtin.html#win_screenpos()">win_screenpos()</a>  中的 "row"

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;getwininfo()</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt;


getwinpos([<code class="special">{timeout}</code>])                                  <b class="vimtag"> <a name="getwinpos()">getwinpos()</a> </b>
                返回两个数值组成的  <a href="eval.html#List">List</a> ，即  <a href="builtin.html#getwinposx()">getwinposx()</a>  和  <a href="builtin.html#getwinposy()">getwinposy()</a> 
                结果的混合:
                        [x-pos, y-pos]
                <code class="special">{timeout}</code> 可用于以毫秒计的等待终端反馈的超时。省略时缺省为 100
                毫秒。远程终端可用更长的超时。
                如果取值小于 10 且在指定时限内没有收到反馈，返回如果有的上次报
                告的位置。可用于轮询位置并在同时并发做其它的事: 
<code class="example">                        while 1</code>
<code class="example">                          let res = getwinpos(1)</code>
<code class="example">                          if res[0] &gt;= 0</code>
<code class="example">                            break</code>
<code class="example">                          endif</code>
<code class="example">                          " 干些话</code>
<code class="example">                        endwhile</code>


                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTimeout()-&gt;getwinpos()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


getwinposx()                                            <b class="vimtag"> <a name="getwinposx()">getwinposx()</a> </b>
                返回数值，即 GUI Vim 窗口以像素计从左起算的 X 坐标。也适用于
                xterm (100 毫秒超时)。
                如果该信息得不到 (如在 Wayland 后台上)，返回 -1。
                返回值可用于 ":winpos"。

                返回类型:  <a href="eval.html#Number">Number</a> 


getwinposy()                                            <b class="vimtag"> <a name="getwinposy()">getwinposy()</a> </b>
                返回数值，即 GUI Vim 窗口以像素计从顶部起算的 Y 坐标。也适用于
                xterm (100 毫秒超时)。
                如果该信息得不到 (如在 Wayland 后台上)，返回 -1。
                返回值可用于 ":winpos"。

                返回类型:  <a href="eval.html#Number">Number</a> 


getwinvar(<code class="special">{winnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])                 <b class="vimtag"> <a name="getwinvar()">getwinvar()</a> </b>
                类似于  <a href="builtin.html#gettabwinvar()">gettabwinvar()</a> ，只用当前标签页。
                例如: 
<code class="example">                        :let list_is_on = getwinvar(2, '&amp;list')</code>
<code class="example">                        :echo "myvar = " .. getwinvar(1, 'myvar')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;getwinvar(varname)</code>

                返回类型: any，取决于 <code class="special">{varname}</code>


glob(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])      <b class="vimtag"> <a name="glob()">glob()</a> </b>
                扩展 <code class="special">{expr}</code> 里的文件通配符。 <a href="editing.html#wildcards">wildcards</a>  说明其中特殊字符的使用
                方法。

                除非给出可选的 <code class="special">{nosuf}</code> 参数且为  <a href="eval.html#TRUE">TRUE</a> ，应用 <a href="options.html#'suffixes'">'suffixes'</a> 和
                <a href="options.html#'wildignore'">'wildignore'</a> 选项: 跳过匹配任何 <a href="options.html#'wildignore'">'wildignore'</a> 模式的名字，而
                <a href="options.html#'suffixes'">'suffixes'</a> 影响匹配结果的排序。
                <a href="options.html#'wildignorecase'">'wildignorecase'</a> 则总是适用。

                如果给出 <code class="special">{list}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，返回  <a href="eval.html#List">List</a> ，包含所有匹配的文件。
                使用列表的优点是可以正确得到包含换行符的文件名。
                否则返回的是字符串，且如果返回多个匹配，以 <code class="special">&lt;NL&gt;</code> 字符分隔。

                如果扩展失败，返回空字符串或空列表。

                扩展结果不包含不存在文件的名字。仅当符号链接指向已存在文件时才
                会包含在扩展结果内。但若给出了 <code class="special">{alllinks}</code> 参数且为  <a href="eval.html#TRUE">TRUE</a> ，则
                包含所有符号链接。

                多数系统上，可以用反引号从外部命令得到文件名。例如: 
<code class="example">                        :let tagfiles = glob("`find . -name tags -print`")</code>
<code class="example">                        :let &amp;tags = substitute(tagfiles, "\n", ",", "g")</code>
                反引号包围的程序的输出结果必须每个项目一行。项目内部可以使用空
                格。

                特殊 Vim 变量的扩展见  <a href="builtin.html#expand()">expand()</a> 。 <a href="builtin.html#system()">system()</a>  说明如何得到外部
                命令的原始输出。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;glob()</code>

                返回类型:  <a href="eval.html#String">String</a>  或 list<code class="special">&lt;string&gt;</code> 或 list<code class="special">&lt;any&gt;</code>，取决于 <code class="special">{list}</code>


glob2regpat(<code class="special">{string}</code>)                                    <b class="vimtag"> <a name="glob2regpat()">glob2regpat()</a> </b>
                转换  <a href="builtin.html#glob()">glob()</a>  所用有文件模式为搜索模式。结果可用来匹配包含文件
                名的字符串。例如 
<code class="example">                        if filename =~ glob2regpat('Make*.mak')</code>
                等价于: 
<code class="example">                        if filename =~ '^Make.*\.mak$'</code>
                如果 <code class="special">{string}</code> 为空串，返回值是 "^$"，匹配空串。
                <code class="note">备注</code> 结果与所用系统有关。MS-Windows 上反斜杠通常用作路径分隔
                符。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;glob2regpat()</code>

                返回类型:  <a href="eval.html#String">String</a> 

                                                        <b class="vimtag"> <a name="globpath()">globpath()</a> </b>
globpath(<code class="special">{path}</code>, <code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
                在 <code class="special">{path}</code> 的所有目录下的字符串 <code class="special">{expr}</code> 执行  <a href="builtin.html#glob()">glob()</a>  并连接所有
                的返回结果。例如: 
<code class="example">                        :echo globpath(&amp;rtp, "syntax/c.vim")</code>

                <code class="special">{path}</code> 是逗号分隔的目录名的列表。每个目录名都附加在 <code class="special">{expr}</code> 之
                前，然后如同  <a href="builtin.html#glob()">glob()</a>  那样被扩展。必要的话，插入路径分隔符。
                要在目录名字里加上逗号，可以使用反斜杠转义。<code class="note">注意</code> 在 MS-Windows
                上目录的最后可能有一个反斜杠。如果你要在后面加上逗号进行分隔，
                先把反斜杠去掉。
                如果某个目录下的扩展失败，不会有错误信息。

                除非给出可选的 <code class="special">{nosuf}</code> 参数且为  <a href="eval.html#TRUE">TRUE</a> ，应用 <a href="options.html#'suffixes'">'suffixes'</a> 和
                <a href="options.html#'wildignore'">'wildignore'</a> 选项: 跳过匹配任何 <a href="options.html#'wildignore'">'wildignore'</a> 模式的名字，而
                <a href="options.html#'suffixes'">'suffixes'</a> 影响匹配结果的排序。

                如果给出 <code class="special">{list}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，返回匹配文件的列表。列表的好处是
                会正确处理包含换行符的文件名，否则返回字符串，有多个匹配时，以
                <code class="special">&lt;NL&gt;</code> 字符分隔。例如: 
<code class="example">                        :echo globpath(&amp;rtp, "syntax/c.vim", 0, 1)</code>

                <code class="special">{alllinks}</code> 的用法可见  <a href="builtin.html#glob()">glob()</a> 。

                可以用 "**" 项目来搜索目录树。例如，寻找在 <a href="options.html#'runtimepath'">'runtimepath'</a> 和它
                之下所有目录里的 "README.txt" 文件: 
<code class="example">                        :echo globpath(&amp;rtp, "**/README.txt")</code>
                不支持向上搜索和 "**" 的深度限制，所以 <a href="options.html#'path'">'path'</a> 的使用不一定总能
                正确工作。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetExpr()-&gt;globpath(&amp;rtp)</code>

                返回类型:  <a href="eval.html#String">String</a>  或 list<code class="special">&lt;string&gt;</code> 或 list<code class="special">&lt;any&gt;</code>，取决于 <code class="special">{list}</code>


has(<code class="special">{feature}</code> [, <code class="special">{check}</code>])                              <b class="vimtag"> <a name="has()">has()</a> </b>
                如果 <code class="special">{check}</code> 省略或为零: 返回数值，如果支持特性 <code class="special">{feature}</code> 则为
                1，不然为零。<code class="special">{feature}</code> 参数是大小写忽略的字符串。见下面的
                 <a href="builtin.html#feature-list">feature-list</a> 。

                如果 <code class="special">{check}</code> 给出且非零: 返回数值，如果特性 <code class="special">{feature}</code> 可以支
                持，则为 1，不然为零。可用于检查 <code class="special">{feature}</code> 是否有拼写错误，也
                可用于检测死代码。要记住旧版本的 Vim 不知道新增的特性，而当前
                版本的 Vim 也不会知道已废弃的特性。

                另见  <a href="builtin.html#exists()">exists()</a>  和  <a href="builtin.html#exists_compiled()">exists_compiled()</a> 。

                <code class="note">注意</code> 特性不可用时，要跳过会有语法错误的代码，Vim 可能会跳过行
                的其余部分，从而丢失其中跟随的  <code class="badlink">endif</code> 。所以， <code class="badlink">endif</code>  请另起一
                行: 
<code class="example">                        if has('feature')</code>
<code class="example">                          let x = this-&gt;breaks-&gt;without-&gt;the-&gt;feature</code>
<code class="example">                        endif</code>
                如果试图把  <code class="badlink">endif</code>  移到第二行成为 "| endif"，它不会被找到。

                返回类型:  <a href="eval.html#Number">Number</a> 


has_key(<code class="special">{dict}</code>, <code class="special">{key}</code>)                                  <b class="vimtag"> <a name="has_key()">has_key()</a> </b>
                返回数值，如果  <a href="eval.html#Dictionary">Dictionary</a>  <code class="special">{dict}</code> 里存在键为 <code class="special">{key}</code> 的项目，则
                为 TRUE，不然为 FALSE。
                <code class="special">{key}</code> 参数是字符串。 <a href="vim9.html#Vim9">Vim9</a>  脚本中也接受数值 (并转换为字符串)，
                但其它类型都不行。
                老式脚本中进行通常的自动转换，转为字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mydict-&gt;has_key(key)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


haslocaldir([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])                      <b class="vimtag"> <a name="haslocaldir()">haslocaldir()</a> </b>
                返回数值:
                    1   如果窗口用  <a href="editing.html#:lcd">:lcd</a>  设置过局部目录
                    2   如果标签页用  <a href="editing.html#:tcd">:tcd</a>  设置过局部目录
                    0   其它。

                无参数时使用当前窗口。
                有 <code class="special">{winr}</code> 则使用当前标签页的该窗口。
                有 <code class="special">{winr}</code> 和 <code class="special">{tabnr}</code> 则使用指定标签页的该窗口。
                <code class="special">{winr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{winnr}</code> 为 -1，它被忽略，只使用标签页。
                参数非法时返回 0。
                示例: 
<code class="example">                        if haslocaldir() == 1</code>
<code class="example">                          " 窗口的局部目录情况</code>
<code class="example">                        elseif haslocaldir() == 2</code>
<code class="example">                          " 标签页的局部目录情况</code>
<code class="example">                        else</code>
<code class="example">                          " 全局目录情况</code>
<code class="example">                        endif</code>
<code class="example"></code>
<code class="example">                        " 当前窗口</code>
<code class="example">                        :echo haslocaldir()</code>
<code class="example">                        :echo haslocaldir(0)</code>
<code class="example">                        :echo haslocaldir(0, 0)</code>
<code class="example">                        " 当前标签页的窗口 n</code>
<code class="example">                        :echo haslocaldir(n)</code>
<code class="example">                        :echo haslocaldir(n, 0)</code>
<code class="example">                        " 标签页 m 的窗口 n</code>
<code class="example">                        :echo haslocaldir(n, m)</code>
<code class="example">                        " 标签页 m</code>
<code class="example">                        :echo haslocaldir(-1, m)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;haslocaldir()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


hasmapto(<code class="special">{what}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])                  <b class="vimtag"> <a name="hasmapto()">hasmapto()</a> </b>
                返回数值，如果存在某映射，其右边的表达式 (被映射到的部分) 的某
                处包含 <code class="special">{what}</code>，并且该映射在 <code class="special">{mode}</code> 指定的模式下存在，返回
                TRUE。
                参数 <code class="special">{what}</code> 和 <code class="special">{mode}</code> 为字符串。
                如果提供 <code class="special">{abbr}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，使用缩写而不是映射。不要忘记指定
                插入和/或命令行模式。
                同时检查全局映射和局部于当前缓冲区的映射以寻找匹配。
                如果没有匹配的映射，返回 FALSE。
                <code class="special">{mode}</code> 识别下列字符:
                        n       普通模式
                        v       可视和选择模式
                        x       可视模式
                        s       选择模式
                        o       操作符等待模式
                        i       插入模式
                        l       Language-Argument ("r"、"f"、"t" 等等) 模式
                        c       命令行模式
                如果没有提供 <code class="special">{mode}</code>，使用 "nvo"。

                该函数可用于检查是否存在映射到 Vim 脚本的某个函数的映射。例
                如: 
<code class="example">                        :if !hasmapto('\ABCdoit')</code>
<code class="example">                        :   map &lt;Leader&gt;d \ABCdoit</code>
<code class="example">                        :endif</code>
                这样，到 "\ABCdoit" 的映射只有在到 "\ABCdoit" 的映射还不存在的
                时候才会进行。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRHS()-&gt;hasmapto()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


histadd(<code class="special">{history}</code>, <code class="special">{item}</code>)                              <b class="vimtag"> <a name="histadd()">histadd()</a> </b>
                把字符串 <code class="special">{item}</code> 加到历史 <code class="special">{history}</code> 里。后者可以是:
                                                        <b class="vimtag"> <a name="hist-names">hist-names</a> </b>
                        "cmd"    或 ":"   命令行历史
                        "search" 或 "/"   搜索模式历史
                        "expr"   或 "="   输入表达式历史
                        "input"  或 "@"   输入行历史
                        "debug"  或 "&gt;"   调试命令历史
                        空                当前或最后使用的历史
                <code class="special">{history}</code> 字符串无须是完整名字，一个字符就够了。
                如果 <code class="special">{item}</code> 已经在历史里存在，它会被调整位置，从而成为最新的一
                项。
                返回结果为数值: 如果操作成功则为 TRUE，不然返回 FALSE。

                例如: 
<code class="example">                        :call histadd("input", strftime("%Y %b %d"))</code>
<code class="example">                        :let date=input("Enter date: ")</code>
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetHistory()-&gt;histadd('search')</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


histdel(<code class="special">{history}</code> [, <code class="special">{item}</code>])                           <b class="vimtag"> <a name="histdel()">histdel()</a> </b>
                清除 <code class="special">{history}</code>，换而言之，删除它所有的项目。 <a href="builtin.html#hist-names">hist-names</a>  解释
                <code class="special">{history}</code> 的所有可能值。

                如果 <code class="special">{item}</code> 计算结果为字符串，它被看作正则表达式。从历史里删除
                所有匹配该模式的项目 (如果有的话)。
                必须匹配大小写，除非使用 "\c"  <a href="pattern.html#%2F\c">/\c</a> 。
                如果 <code class="special">{item}</code> 的计算结果为数值，它被解释为索引值，见
                 <a href="cmdline.html#:history-indexing">:history-indexing</a> 。如果该索引存在，删除相应的项目。

                返回结果为数值: 如果操作成功则为 TRUE，不然返回 FALSE。

                例如:
                清除表达式寄存器历史: 
<code class="example">                        :call histdel("expr")</code>

                删除所有 "*" 开始的搜索历史: 
<code class="example">                        :call histdel("/", '^\*')</code>

                下面三者是等价的: 
<code class="example">                        :call histdel("search", histnr("search"))</code>
<code class="example">                        :call histdel("search", -1)</code>
<code class="example">                        :call histdel("search", '^' .. histget("search", -1) .. '$')</code>

                要删除最后的搜索模式，并在 "n" 命令和 <a href="options.html#'hlsearch'">'hlsearch'</a> 里使用倒数第
                二个模式: 
<code class="example">                        :call histdel("search", -1)</code>
<code class="example">                        :let @/ = histget("search", -1)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetHistory()-&gt;histdel()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


histget(<code class="special">{history}</code> [, <code class="special">{index}</code>])                          <b class="vimtag"> <a name="histget()">histget()</a> </b>
                返回字符串，即 <code class="special">{history}</code> 历史的第 <code class="special">{index}</code> 项。 <a href="builtin.html#hist-names">hist-names</a>  解
                释 <code class="special">{history}</code> 的所有可能值，而  <a href="cmdline.html#:history-indexing">:history-indexing</a>  解释
                <code class="special">{index}</code>。如果没有这个项目，返回空字符串。如果忽略 <code class="special">{index}</code>，返
                回历史里最近使用的项目。

                例如:
                重做历史里的倒数第二个搜索 
<code class="example">                        :execute '/' .. histget("search", -2)</code>
<code class="example"></code>
                定义 Ex 命令 ":H <code class="special">{num}</code>"，以重新执行  <a href="cmdline.html#:history">:history</a>  输出的第 <code class="special">{num}</code>
                项。 
<code class="example">                        :command -nargs=1 H execute histget("cmd", 0+&lt;args&gt;)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetHistory()-&gt;histget()</code>

                返回类型:  <a href="eval.html#String">String</a> 


histnr(<code class="special">{history}</code>)                                       <b class="vimtag"> <a name="histnr()">histnr()</a> </b>
                返回当前项目在 <code class="special">{history}</code> 里的编号。 <a href="builtin.html#hist-names">hist-names</a>  解释 <code class="special">{history}</code>
                的所有可能值。
                如果有错，返回 -1。

                例如: 
<code class="example">                        :let inp_index = histnr("expr")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetHistory()-&gt;histnr()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


hlexists(<code class="special">{name}</code>)                                        <b class="vimtag"> <a name="hlexists()">hlexists()</a> </b>
                返回数值。只要名为 <code class="special">{name}</code> 的高亮组用某种方法定义过，返回
                TRUE。不一定要为该组定义过高亮属性。一些语法项目可能已经使用该
                组。
                                                        <b class="vimtag"> <a name="highlight_exists()">highlight_exists()</a> </b>
                已废弃的名字: highlight_exists()。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;hlexists()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


hlget([<code class="special">{name}</code> [, <code class="special">{resolve}</code>]])                           <b class="vimtag"> <a name="hlget()">hlget()</a> </b>
                返回包含所有高亮组属性的列表。如果给出可选 <code class="special">{name}</code>，只返回指定
                高亮组的属性的列表。如果高亮组 <code class="special">{name}</code> 不存在，返回空列表。

                如果可选的 <code class="special">{resolve}</code> 参数设为 v:true 而且高亮组 <code class="special">{name}</code> 链接到
                另一个组，递归解析链接，并返回最终解析结果的高亮组的属性。

                返回列表的每个项目是包含以下项目的字典:
                        cleared 布尔型标志位，如果高亮组属性被清除或还未指定，
                                设为 v:true。见  <a href="syntax.html#highlight-clear">highlight-clear</a> 。
                        cterm   cterm 属性。见  <a href="syntax.html#highlight-cterm">highlight-cterm</a> 。
                        ctermbg cterm 背景色。见  <a href="syntax.html#highlight-ctermbg">highlight-ctermbg</a> 。
                        ctermfg cterm 前景色。见  <a href="syntax.html#highlight-ctermfg">highlight-ctermfg</a> 。
                        ctermul cterm 下划线颜色。见  <a href="syntax.html#highlight-ctermul">highlight-ctermul</a> 。
                        default 布尔型标志位，如果高亮组链接是缺省链接，设为
                                v:true。见  <a href="syntax.html#highlight-default">highlight-default</a> 。
                        font    高亮组字体。见  <a href="syntax.html#highlight-font">highlight-font</a> 。
                        gui     gui 属性。见  <a href="syntax.html#highlight-gui">highlight-gui</a> 。
                        guibg   gui 背景色。见  <a href="syntax.html#highlight-guibg">highlight-guibg</a> 。
                        guifg   gui 前景色。见  <a href="syntax.html#highlight-guifg">highlight-guifg</a> 。
                        guisp   gui 特殊颜色。见  <a href="syntax.html#highlight-guisp">highlight-guisp</a> 。
                        id      高亮组 ID。
                        linksto 链接目标高亮组名。见  <a href="syntax.html#:highlight-link">:highlight-link</a> 。
                        name    高亮组名。见  <a href="syntax.html#group-name">group-name</a> 。
                        start   start 终端转义码。见  <a href="syntax.html#highlight-start">highlight-start</a> 。
                        stop    stop 终端转义码。见  <a href="syntax.html#highlight-stop">highlight-stop</a> 。
                        term    终端属性。见  <a href="syntax.html#highlight-term">highlight-term</a> 。

                上述字典里的 <a href="options.html#'term'">'term'</a>、<code class="badlink">'cterm'</code> 和 <code class="badlink">'gui'</code> 项目本身为字典，带以下可
                选布尔型项目: <code class="badlink">'bold'</code>、<code class="badlink">'standout'</code>、<code class="badlink">'underline'</code>、<code class="badlink">'undercurl'</code>、
                <code class="badlink">'italic'</code>、<code class="badlink">'reverse'</code>、<code class="badlink">'inverse'</code> 和 <code class="badlink">'strikethrough'</code>。

                示例: 
<code class="example">                        :echo hlget()</code>
<code class="example">                        :echo hlget('ModeMsg')</code>
<code class="example">                        :echo hlget('Number', v:true)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;hlget()</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt;


hlset(<code class="special">{list}</code>)                                           <b class="vimtag"> <a name="hlset()">hlset()</a> </b>
                建立或修改一组高亮组的属性。<code class="special">{list}</code> 中的每项对应一个高亮组的属
                性字典。此字典支持的项目列表见  <code class="badlink">hlget</code> 。

                除了  <a href="builtin.html#hlget()">hlget()</a>  描述的项目以外，字典还支持以下附加项目:

                        force           布尔型标志位，强制建立带属性的已有高亮
                                        组的链接。

                通过 <code class="badlink">'name'</code> 项目指定高亮组，忽略 <code class="badlink">'id'</code> 项目 (如有提供)。如果指
                定名字的高亮组不存在，建立之。否则已有的高亮组的属性将被修改。

                如果 <a href="options.html#'term'">'term'</a>、<code class="badlink">'cterm'</code> 或 <code class="badlink">'gui'</code> 项目指定了空字典，清除对应的属
                性。如果 <code class="badlink">'cleared'</code> 项目设为了 v:true，清除高亮组的所有属性。

                <code class="badlink">'linksto'</code> 项目可用来链接一个高亮组到另一高亮组。见
                 <a href="syntax.html#:highlight-link">:highlight-link</a> 。

                成功返回零，失败返回 -1。

                示例: 
<code class="example">                        " 为 Visual 高亮组加入 bold 属性</code>
<code class="example">                        :call hlset([#{name: 'Visual',</code>
<code class="example">                                        \ term: #{reverse: 1 , bold: 1}}])</code>
<code class="example">                        :call hlset([#{name: 'Type', guifg: 'DarkGreen'}])</code>
<code class="example">                        :let l = hlget()</code>
<code class="example">                        :call hlset(l)</code>
<code class="example">                        " 清除 Search 高亮组</code>
<code class="example">                        :call hlset([#{name: 'Search', cleared: v:true}])</code>
<code class="example">                        " 清除高亮组的 'term' 属性</code>
<code class="example">                        :call hlset([#{name: 'Title', term: {}}])</code>
<code class="example">                        " 建立 MyHlg 组，链接到 DiffAdd</code>
<code class="example">                        :call hlset([#{name: 'MyHlg', linksto: 'DiffAdd'}])</code>
<code class="example">                        " 删除 MyHlg 组的链接</code>
<code class="example">                        :call hlset([#{name: 'MyHlg', linksto: 'NONE'}])</code>
<code class="example">                        " 清除属性和链接</code>
<code class="example">                        :call hlset([#{name: 'MyHlg', cleared: v:true,</code>
<code class="example">                                        \ linksto: 'NONE'}])</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetAttrList()-&gt;hlset()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


hlID(<code class="special">{name}</code>)                                            <b class="vimtag"> <a name="hlID()">hlID()</a> </b>
                返回数值，即名为 <code class="special">{name}</code> 的高亮组的 ID。如果该高亮组不存在，返
                回零。
                可用于提取高亮组的信息。比如，要得到 "Comment" 组的背景颜色: 
<code class="example">        :echo synIDattr(synIDtrans(hlID("Comment")), "bg")</code>
                                                        <b class="vimtag"> <a name="highlightID()">highlightID()</a> </b>
                已废弃的名字: highlightID()。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;hlID()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


hostname()                                              <b class="vimtag"> <a name="hostname()">hostname()</a> </b>
                返回字符串，即 Vim 运行的机器名字。超过 256 字符串长度的机器名
                被截短。

                返回类型:  <a href="eval.html#String">String</a> 


iconv(<code class="special">{string}</code>, <code class="special">{from}</code>, <code class="special">{to}</code>)                           <b class="vimtag"> <a name="iconv()">iconv()</a> </b>
                返回字符串，即文本 <code class="special">{string}</code> 从 <code class="special">{from}</code> 编码转到 <code class="special">{to}</code> 编码以后的
                文本。
                如果转换完全失败，返回空字符串。如果部分字符无法转换，以 "?"
                代替之。
                编码名字可以是任何 iconv() 库函数接受的名字，见
                ":!man 3 iconv"。
                大多数转换需要 Vim 编译时加入  <a href="various.html#+iconv">+iconv</a>  特性。不然，只支持
                UTF-8 和 latin1 的相互转换。
                这可以用来显示包含特殊字符的消息。不管 <a href="options.html#'encoding'">'encoding'</a> 设为何值，总
                可以用 UTF-8 书写消息，然后使用: 
<code class="example">                        echo iconv(utf8_str, "utf-8", &amp;enc)</code>
                <code class="note">注意</code> Vim 使用 UTF-8 进行所有的 Unicode 编码，从/到 UCS-2 的转
                换都自动转为 UTF-8。你不能在字符串里使用 UCS-2，因为那里有 NUL
                字节。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;iconv('latin1', 'utf-8')</code>

                返回类型:  <a href="eval.html#String">String</a> 


id(<code class="special">{item}</code>)                                              <b class="vimtag"> <a name="id()">id()</a> </b>
                返回和 <code class="special">{item}</code> 相关联而不是 <code class="special">{item}</code> 内容绑定的唯一字符串。仅当
                <code class="special">{item}</code> 存在且被引用时才有效，且仅在生成结果的 vim 实例中有效。
                基本想法是  <code class="badlink">id(<code class="special">{item}</code>)</code>  不应随 <code class="special">{item}</code> 内容的改变而改变。这可用
                于给字典作  <code class="badlink">key</code>  时基于身分而不是值的相等。

                此操作不引用 <code class="special">{item}</code>，也没有函数可以把  <code class="badlink">id</code>  转换为 <code class="special">{item}</code>。为
                此，可保有一个  <code class="badlink">id</code>  到 <code class="special">{item}</code> 的映射。下例 
<code class="example">                    var referenceMap: dict&lt;any&gt;</code>
<code class="example">                    var id = item-&gt;id()</code>
<code class="example">                    referenceMap[id] = item</code>
                会防止 <code class="special">{item}</code> 被垃圾回收，同时提供了从  <code class="badlink">id</code>  取得 <code class="special">{item}</code> 的一种
                方法。

                <code class="special">{item}</code> 可为列表、元组、字典、对象、作业、通道或 blob。如果
                item 不是这些可接受的类型之一或为 null 值，返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetItem()-&gt;id()</code>

                返回类型:  <a href="eval.html#String">String</a> 


indent(<code class="special">{lnum}</code>)                                          <b class="vimtag"> <a name="indent()">indent()</a> </b>
                返回数值，第 <code class="special">{lnum}</code> 行的缩进距离。缩进的计算以空格计，因而它和
                <a href="options.html#'tabstop'">'tabstop'</a> 的值是有关系的。<code class="special">{lnum}</code> 的使用方式和  <a href="builtin.html#getline()">getline()</a>  相
                同。
                <code class="special">{lnum}</code> 非法时返回 -1。 <a href="vim9.html#Vim9">Vim9</a>  脚本会报错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;indent()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


index(<code class="special">{object}</code>, <code class="special">{expr}</code> [, <code class="special">{start}</code> [, <code class="special">{ic}</code>]])            <b class="vimtag"> <a name="index()">index()</a> </b>
                寻找 <code class="special">{object}</code> 中的 <code class="special">{expr}</code>，并返回其索引。要通过匿名函数来选择
                项目，可见  <a href="builtin.html#indexof()">indexof()</a> 。

                如果 <code class="special">{object}</code> 为  <a href="eval.html#List">List</a>  或  <a href="eval.html#Tuple">Tuple</a> ，返回值等于 <code class="special">{expr}</code> 的最小项
                目索引。这里不进行自动转换，字符串 "4" 不同于数值 4，数值 4 也
                不等同于浮点数 4.0。<a href="options.html#'ignorecase'">'ignorecase'</a> 的值此处不适用，大小写是否敏
                感由 <code class="special">{ic}</code> 参数决定。

                如果 <code class="special">{object}</code> 为  <a href="eval.html#Blob">Blob</a> ，返回字节值等于 <code class="special">{expr}</code> 的最小索引。

                如果给出 <code class="special">{start}</code>，从索引为 <code class="special">{start}</code> 的项目开始寻找 (可以为负，
                指定相对于尾部的项目)。

                如果给出 <code class="special">{ic}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，忽略大小写。否则，必须匹配大小写。

                如果在 <code class="special">{object}</code> 里找不到 <code class="special">{expr}</code>，返回 -1。
                示例: 
<code class="example">                        :let idx = index(words, "the")</code>
<code class="example">                        :if index(numbers, 123) &gt;= 0</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetObject()-&gt;index(what)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


indexof(<code class="special">{object}</code>, <code class="special">{expr}</code> [, <code class="special">{opts}</code>])                    <b class="vimtag"> <a name="indexof()">indexof()</a> </b>
                返回 <code class="special">{object}</code> 中的 <code class="special">{expr}</code> 为 v:true 的项目的索引。
                <code class="special">{object}</code> 必须为  <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a>  或  <a href="eval.html#Blob">Blob</a> 。

                如果 <code class="special">{object}</code> 为  <a href="eval.html#List">List</a>  或  <a href="eval.html#Tuple">Tuple</a> ，为列表或元组中的每个项目计
                算 <code class="special">{expr}</code>，直到结果结果为 v:true 为止，返回该项目的索引。

                如果 <code class="special">{object}</code> 为  <a href="eval.html#Blob">Blob</a> ，为 Blob 中的每个字节计算 <code class="special">{expr}</code>，直到
                结果结果为 v:true 为止，返回该字节的索引。

                <code class="special">{expr}</code> 必须为  <a href="eval.html#string">string</a>  或  <a href="eval.html#Funcref">Funcref</a> 。

                <code class="special">{expr}</code> 为  <a href="eval.html#string">string</a>  时: 如果 <code class="special">{object}</code> 为  <a href="eval.html#List">List</a>  或  <a href="eval.html#Tuple">Tuple</a> ,
                <code class="special">{expr}</code> 中的  <a href="eval.html#v:key">v:key</a>  包含当前列表或元组项目的索引，而  <a href="eval.html#v:val">v:val</a> 
                为当前项目值。如果 <code class="special">{object}</code> 为  <a href="eval.html#Blob">Blob</a> ，<code class="special">{expr}</code> 中的  <a href="eval.html#v:key">v:key</a>  包
                含当前字节的索引，而  <a href="eval.html#v:val">v:val</a>  为当前字节值。

                <code class="special">{expr}</code> 为  <a href="eval.html#Funcref">Funcref</a>  时，它必须接受两个参数:
                        1. 当前项目的键值或索引。
                        2. 当前项目的值。
                找到项目时函数必须返回  <a href="eval.html#TRUE">TRUE</a> ，此时搜索停止。

                可选参数 <code class="special">{opts}</code> 为字典，包含以下项目:
                    startidx    从带此索引的项目开始计算 <code class="special">{expr}</code>；可为负值，索
                                引值相对于列表尾部
                所有项目上的 <code class="special">{expr}</code> 计算结果均为 v:false 时，返回 -1。
                示例: 
<code class="example">                        :let l = [#{n: 10}, #{n: 20}, #{n: 30}]</code>
<code class="example">                        :echo indexof(l, "v:val.n == 20")</code>
<code class="example">                        :echo indexof(l, {i, v -&gt; v.n == 30})</code>
<code class="example">                        :echo indexof(l, "v:val.n == 20", #{startidx: 1})</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;indexof(expr)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


input(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{completion}</code>]])             <b class="vimtag"> <a name="input()">input()</a> </b>
                返回字符串，即用户在命令行上的输入内容，可以为任何值。参数
                <code class="special">{prompt}</code> 或者是一个提示字符串，或者是一个空白字符串 (没有提
                示)。'\n' 可以在提示里使用，以开始新行。
                该提示使用  <a href="eval.html#:echohl">:echohl</a>  设置的高亮。
                输入方法和命令行相似，也使用相同的编辑命令和映射。但 input()
                输入的行使用另外的历史。
                示例: 
<code class="example">                        :if input("咖啡还是啤酒？") == "啤酒"</code>
<code class="example">                        :  echo "干杯！"</code>
<code class="example">                        :endif</code>

                如果给出可选的 <code class="special">{text}</code> 参数，它被用作缺省的回答，就像是用户输入
                的那样。例如: 
<code class="example">                        :let color = input("Color? ", "white")</code>
<code class="example"></code>
                可选的 <code class="special">{completion}</code> 参数指定输入支持的补全类型。如果不给出，不
                使用补全。支持的补全类型和用户定义命令用 "-complete=" 参数能给
                出的类型相同。详情见  <a href="map.html#:command-completion">:command-completion</a> 。例如: 
<code class="example">                        let fname = input("File: ", "", "file")</code>

                <code class="note">注意</code>: 在只能运行于 GUI 模式的版本里 (比如 Win32 GUI)，此函数不
                能在启动文件里使用。
                <code class="note">注意</code>: input() 在映射里调用时，它会消耗该映射余下的字符，因为映
                射的处理就像那些字符被键盘输入一样。在 input() 前使用
                 <a href="builtin.html#inputsave()">inputsave()</a>  然后在 input() 输入之后  <a href="builtin.html#inputrestore()">inputrestore()</a>  可以避
                免这一点。另一个方法是避免在映射的后面提供任何字符，比如，使用
                 <a href="eval.html#:execute">:execute</a>  或  <a href="various.html#:normal">:normal</a> 。

                使用映射的例子: 
<code class="example">                        :nmap \x :call GetFoo()&lt;CR&gt;:exe "/" .. Foo&lt;CR&gt;</code>
<code class="example">                        :function GetFoo()</code>
<code class="example">                        :  call inputsave()</code>
<code class="example">                        :  let g:Foo = input("enter search pattern: ")</code>
<code class="example">                        :  call inputrestore()</code>
<code class="example">                        :endfunction</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPrompt()-&gt;input()</code>

                返回类型:  <a href="eval.html#String">String</a> 


inputdialog(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{cancelreturn}</code>]])     <b class="vimtag"> <a name="inputdialog()">inputdialog()</a> </b>
                类似于  <a href="builtin.html#input()">input()</a> ，但如果运行 GUI 且支持文本对话框，弹出一个对
                话框窗口来输入文本。
                例如: 
<code class="example">                   :let n = inputdialog("value for shiftwidth", shiftwidth())</code>
<code class="example">                   :if n != ""</code>
<code class="example">                   :  let &amp;sw = n</code>
<code class="example">                   :endif</code>
                如果对话框被取消，返回 <code class="special">{cancelreturn}</code>。如果忽略，返回空字符
                串。
                输入 <code class="special">&lt;Enter&gt;</code> 和按 OK 按钮相同。按 <code class="special">&lt;Esc&gt;</code> 和按 Cancel 按钮相同。
                <code class="note">备注</code>: 不支持命令行补全。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPrompt()-&gt;inputdialog()</code>

                返回类型:  <a href="eval.html#String">String</a> 


inputlist(<code class="special">{textlist}</code>)                                   <b class="vimtag"> <a name="inputlist()">inputlist()</a> </b>
                <code class="special">{textlist}</code> 必须是字符串的  <a href="eval.html#List">List</a> 。显示此  <a href="eval.html#List">List</a> ，每个字符串一
                行。用户得到提示要输入一个数值，返回此值。
                如果命令行上打开鼠标 (<a href="options.html#'mouse'">'mouse'</a> 为 "a" 或包含 "c")，用户也可以用
                鼠标点击项目来进行选择。第一个字符串返回 0。在第一个项目之上点
                击返回负数。在提示行上点击返回 <code class="special">{textlist}</code> 的长度加一。
                确保 <code class="special">{textlist}</code> 不超过 <a href="options.html#'lines'">'lines'</a> 个项目，否则无法使用。建议把项
                目编号放在每个字符串的开始处，并在第一项上加上提示。例如: 
<code class="example">                        let color = inputlist(['Select color:', '1. red',</code>
<code class="example">                                \ '2. green', '3. blue'])</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetChoices()-&gt;inputlist()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


inputrestore()                                          <b class="vimtag"> <a name="inputrestore()">inputrestore()</a> </b>
                恢复前一个  <a href="builtin.html#inputsave()">inputsave()</a>  保存的预输入。应该和  <a href="builtin.html#inputsave()">inputsave()</a>  调
                用的次数相同，不过调用更多次也无妨。
                如果没有可以恢复的，返回 TRUE，不然返回 FALSE。

                返回类型:  <a href="eval.html#Number">Number</a> 


inputsave()                                             <b class="vimtag"> <a name="inputsave()">inputsave()</a> </b>
                保存预输入 (也包括映射的) 并清除之，使得下一个提示能从用户得到
                输入。在提示之后应该跟上配套的  <a href="builtin.html#inputrestore()">inputrestore()</a> 。可以多次使
                用，此时应该有同样多次的  <a href="builtin.html#inputrestore()">inputrestore()</a>  调用。
                如果内存不足，返回 TRUE，不然返回 FALSE。

                返回类型:  <a href="eval.html#Number">Number</a> 


inputsecret(<code class="special">{prompt}</code> [, <code class="special">{text}</code>])                        <b class="vimtag"> <a name="inputsecret()">inputsecret()</a> </b>
                该函数和  <a href="builtin.html#input()">input()</a>  函数类似，但有两个例外:
                a) 用户的应答显示为一串星号 ("*")，从而输入可以保密，还有
                b) 用户的应答不会记录在输入  <a href="cmdline.html#history">history</a>  栈中。
                返回字符串，即用户在命令行上根据提示输入的应答。
                <code class="note">备注</code>: 不支持命令行补全。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPrompt()-&gt;inputsecret()</code>

                返回类型:  <a href="eval.html#String">String</a> 


insert(<code class="special">{object}</code>, <code class="special">{item}</code> [, <code class="special">{idx}</code>])                      <b class="vimtag"> <a name="insert()">insert()</a> </b>
                如果 <code class="special">{object}</code> 为  <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a> ，在开始处插入 <code class="special">{item}</code>。

                如果指定 <code class="special">{idx}</code>，<code class="special">{item}</code> 的插入位置在索引 <code class="special">{idx}</code> 之前。如果
                <code class="special">{idx}</code> 为零，插入在第一个项目之前，和省略 <code class="special">{idx}</code> 效果相同。也可
                用负的 <code class="special">{idx}</code>，见  <a href="eval.html#list-index">list-index</a> 。-1 插入在最后一个项目之前。
                返回新产生的  <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a> 。例如: 
<code class="example">                        :let mylist = insert([2, 3, 5], 1)</code>
<code class="example">                        :call insert(mylist, 4, -1)</code>
<code class="example">                        :call insert(mylist, 6, len(mylist))</code>
                用  <a href="builtin.html#add()">add()</a>  可以更简单的完成最后一个例子。
                <code class="note">注意</code> 如 <code class="special">{item}</code> 是  <a href="eval.html#List">List</a> ，它被作为单个项目来插入。 <a href="builtin.html#extend()">extend()</a> 
                用来连接多个  <a href="eval.html#List">List</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;insert(item)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


instanceof(<code class="special">{object}</code>, <code class="special">{class}</code>)                           <b class="vimtag"> <a name="instanceof()">instanceof()</a> </b> <b class="vimtag"> <a name="E614">E614</a> </b> <b class="vimtag"> <a name="E616">E616</a> </b> <b class="vimtag"> <a name="E693">E693</a> </b>
                返回数值，如果 <code class="special">{object}</code> 参数为 <code class="special">{class}</code> 指定的  <a href="vim9class.html#Class">Class</a> 、
                 <a href="vim9class.html#Interface">Interface</a>  或类  <a href="vim9class.html#:type">:type</a>  别名的直接或间接实例，返回  <a href="eval.html#TRUE">TRUE</a> 。
                <code class="special">{class}</code> 是可变参数时，如果 <code class="special">{object}</code> 为其中指定类之一的实例，返
                回  <a href="eval.html#TRUE">TRUE</a> 。
                示例: 
<code class="example">                        instanceof(animal, Dog, Cat)</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        myobj-&gt;instanceof(mytype)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


interrupt()                                             <b class="vimtag"> <a name="interrupt()">interrupt()</a> </b>
                中断脚本的执行。它或多或少像用户按了 <code class="keystroke">CTRL-C</code> 一样。多数命令不再
                执行，控制权还给用户。可用于中止较底层如自动命令等的执行。
                如: 
<code class="example">                :function s:check_typoname(file)</code>
<code class="example">                :   if fnamemodify(a:file, ':t') == '['</code>
<code class="example">                :       echomsg 'Maybe typo'</code>
<code class="example">                :       call interrupt()</code>
<code class="example">                :   endif</code>
<code class="example">                :endfunction</code>
<code class="example">                :au BufWritePre * call s:check_typoname(expand('&lt;amatch&gt;'))</code>

                返回类型: void


invert(<code class="special">{expr}</code>)                                          <b class="vimtag"> <a name="invert()">invert()</a> </b>
                按位取反。参数须转换为数值。列表、字典或浮点数参数会报错。
                示例: 
<code class="example">                        :let bits = invert(bits)</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :let bits = bits-&gt;invert()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


isabsolutepath(<code class="special">{path}</code>)                                  <b class="vimtag"> <a name="isabsolutepath()">isabsolutepath()</a> </b>
                返回数值，如果 <code class="special">{path}</code> 为绝对路径则为  <a href="eval.html#TRUE">TRUE</a> 。
                Unix 上，绝对路径是指 '/' 开始的路径。
                MS-Windows 上，绝对路径是指由可选的驱动器前缀前导，后跟 '\' 或
                '/' 的路径。UNC 路径总是绝对的。
                示例: 
<code class="example">                        echo isabsolutepath('/usr/share/')      " 1</code>
<code class="example">                        echo isabsolutepath('./foobar')         " 0</code>
<code class="example">                        echo isabsolutepath('C:\Windows')       " 1</code>
<code class="example">                        echo isabsolutepath('foobar')           " 0</code>
<code class="example">                        echo isabsolutepath('\\remote\file')    " 1</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;isabsolutepath()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


isdirectory(<code class="special">{directory}</code>)                                <b class="vimtag"> <a name="isdirectory()">isdirectory()</a> </b>
                返回数值，如果名为 <code class="special">{directory}</code> 的目录存在，返回  <a href="eval.html#TRUE">TRUE</a> 。如果
                <code class="special">{directory}</code> 不存在或者不是目录，返回  <a href="eval.html#FALSE">FALSE</a> 。<code class="special">{directory}</code> 可以
                是任何表达式，最终用作字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;isdirectory()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


isinf(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="isinf()">isinf()</a> </b>
                如果 <code class="special">{expr}</code> 是正无穷大返回 1，负无穷大返回 -1，否则返回 0。 
<code class="example">                        :echo isinf(1.0 / 0.0)</code>
                        1 
<code class="example">                        :echo isinf(-1.0 / 0.0)</code>
                        -1

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;isinf()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


islocked(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="islocked()">islocked()</a> </b> <b class="vimtag"> <a name="E786">E786</a> </b>
                返回数值，如果 <code class="special">{expr}</code> 是某个加锁的变量名，返回  <a href="eval.html#TRUE">TRUE</a> 。
                字符串 <code class="special">{expr}</code> 必须是变量名、 <a href="eval.html#List">List</a>  项目，或  <a href="eval.html#Dictionary">Dictionary</a>  项
                目，不是变量本身！例如: 
<code class="example">                        :let alist = [0, ['a', 'b'], 2, 3]</code>
<code class="example">                        :lockvar 1 alist</code>
<code class="example">                        :echo islocked('alist')         " 1</code>
<code class="example">                        :echo islocked('alist[1]')      " 0</code>
<code class="example"></code>
                如果 <code class="special">{expr}</code> 是不存在的变量，返回 -1。如果 <code class="special">{expr}</code> 使用越界的范
                围、列表或字典索引，报错。用  <a href="builtin.html#exists()">exists()</a>  可以检查变量是否存在。
                Vim9 脚本里，此函数不适用于局部函数变量。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;islocked()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


isnan(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="isnan()">isnan()</a> </b>
                如果 <code class="special">{expr}</code> 是值为 NaN 的浮点数，返回  <a href="eval.html#TRUE">TRUE</a> 。 
<code class="example">                        echo isnan(0.0 / 0.0)</code>
                        1

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;isnan()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


items(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="items()">items()</a> </b>
                返回  <a href="eval.html#List">List</a> ，<code class="special">{expr}</code> 的所有键/索引-值组对。每个  <a href="eval.html#List">List</a>  项目是两
                个项目的列表:
                - 对  <a href="eval.html#Dict">Dict</a>  而言: 键和值
                - 对  <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a> 、 <a href="eval.html#Blob">Blob</a>  和  <a href="eval.html#String">String</a>  而言: 索引和值
                对  <a href="eval.html#Dict">Dict</a>  而言，返回的  <a href="eval.html#List">List</a>  项目的顺序不定。否则，依索引值升
                序排序。

                另见  <a href="builtin.html#keys()">keys()</a>  和  <a href="builtin.html#values()">values()</a> 。

                示例: 
<code class="example">                        let mydict = #{a: 'red', b: 'blue'}</code>
<code class="example">                        for [key, value] in items(mydict)</code>
<code class="example">                           echo $"{key} = {value}"</code>
<code class="example">                        endfor</code>
<code class="example">                        echo items([1, 2, 3])</code>
<code class="example">                        echo items(('a', 'b', 'c'))</code>
<code class="example">                        echo items("foobar")</code>
<code class="example">                        echo items(0z0102)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mydict-&gt;items()</code>

                返回类型: list&lt;list<code class="special">&lt;any&gt;</code>&gt; 或 list<code class="special">&lt;any&gt;</code>


job_ 函数文档在这里:  <a href="channel.html#job-functions-details">job-functions-details</a> 


join(<code class="special">{expr}</code> [, <code class="special">{sep}</code>])                                  <b class="vimtag"> <a name="join()">join()</a> </b>
                连接所有 <code class="special">{expr}</code> 项目成为字符串。<code class="special">{expr}</code> 可以是  <a href="eval.html#List">List</a>  或
                 <a href="eval.html#Tuple">Tuple</a> 。
                如果指定 <code class="special">{sep}</code>，该分隔符出现在项目之间。如果省略 <code class="special">{sep}</code>，用单个
                空格。
                <code class="note">注意</code> 尾部不加 <code class="special">{sep}</code>。如果你坚持要加入: 
<code class="example">                        let lines = join(mylist, "\n") .. "\n"</code>
                字符串项目照原样使用。用类似  <a href="builtin.html#string()">string()</a>  的方式把  <a href="eval.html#List">List</a> 、
                 <a href="eval.html#Tuple">Tuple</a>  和  <a href="eval.html#Dictionary">Dictionary</a>  转化为字符串。逆函数是  <a href="builtin.html#split()">split()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;join()</code>

                返回类型:  <a href="eval.html#String">String</a> 


js_decode(<code class="special">{string}</code>)                                     <b class="vimtag"> <a name="js_decode()">js_decode()</a> </b>
                和  <a href="builtin.html#json_decode()">json_decode()</a>  类似，但有以下区别:
                - 对象键名不需用引号括起。
                - 字符串可以用单引号括起。
                - 接受数组的空项目 (两个逗句之间)，返回 v:none 项目。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ReadObject()-&gt;js_decode()</code>

                返回类型: any，取决于 <code class="special">{varname}</code>


js_encode(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="js_encode()">js_encode()</a> </b>
                和  <a href="builtin.html#json_encode()">json_encode()</a>  类似，但有以下区别:
                - 对象键名不用引号括起。
                - 数组里的 v:none 项目生成逗号之间的空项目。
                例如，Vim 对象:
<code class="section">                        [1,v:none,{"one":1},v:none] </code>
                会被编码为:
<code class="section">                        [1,,<code class="special">{one:1}</code>,,] </code>
                而 json_encode() 会生成:
<code class="section">                        [1,null,{"one":1},null] </code>
                对 Javscript，这种编码也是合法的。但比 JSON 更高效，尤其是使用
                有可选项目的数组时。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetObject()-&gt;js_encode()</code>

                返回类型:  <a href="eval.html#String">String</a> 


json_decode(<code class="special">{string}</code>)                                   <b class="vimtag"> <a name="json_decode()">json_decode()</a> </b> <b class="vimtag"> <a name="E491">E491</a> </b>
                解析 JSON 格式的字符串，返回等价的 Vim 值。见  <a href="builtin.html#json_encode()">json_encode()</a> 
                了解 JSON 和 Vim 值的关系。
                解码是容错的:
                - 忽略数组和对象拖尾的逗号，例如 "[1, 2, ]" 等同 "[1, 2]"。
                - 对象中接受整数键，如 <code class="special">{1:2}</code> 和 {"1":2} 相同。
                - 识别更多浮点数，例如 "1." 相当于 "1.0"，而 "001.2" 相当于
                  "1.2"。接受特殊浮点值 "Infinity"、"-Infinity" 和 "NaN" (大小
                  写无关)。
                - 忽略整数值前导零，例如 "012" 相当于 "12"，而 "-012" 相当于
                  "-12"。
                - 按本义名 null、true 或 false 的大小写无关，例如 "NULL" 相当
                  于 "null"，"True" 相当于 "true"。
                - 接受字符串中不转义的控制字符 U+0000 到 U+001F，例如 " "
                  (字符串中的制表符) 相当于 "\t"。
                - 接受空或只有空白组成的 JSON 表达式，生成 v:none。
                - 忽略非法的两字符转义序列中的反斜杠，例如 "\a" 解码为 "a"。
                - JSON 字符串中正确的代理对正常应是 12 字符的序列，如
                  "\uD834\uDD1E"，但 json_decode() 安静地接受截断的代理对，例
                  如 "\uD834" 或 "\uD834\u"。
                                                        <b class="vimtag"> <a name="E938">E938</a> </b>
                对象里的重复键值，虽然在 rfc7159 中合法，便不被 json_decode()
                接受，因为转换结果必须是合法的 Vim 类型，例如，这样不行:
                {"a":"b", "a":"c"}

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ReadObject()-&gt;json_decode()</code>

                返回类型: any，取决于 <code class="special">{varname}</code>


json_encode(<code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="json_encode()">json_encode()</a> </b>
                对 <code class="special">{expr}</code> 进行 JSON 编码，返回字符串。
                编码格式在此指定:
                <a href="https://tools.ietf.org/html/rfc7159.html">https://tools.ietf.org/html/rfc7159.html</a>
                Vim 值的转换如下:                       <b class="vimtag"> <a name="E1161">E1161</a> </b>
                    <a href="eval.html#Number">Number</a>              十进制数
                    <a href="eval.html#Float">Float</a>               浮点数
                   Float nan            "NaN"
                   Float inf            "Infinity"
                   Float -inf           "-Infinity"
                    <a href="eval.html#String">String</a>              双引号括起 (可为 null)
                    <a href="eval.html#Funcref">Funcref</a>             不接受，报错
                    <a href="eval.html#List">List</a>                作为数组 (可为 null)；若递归使用: []
                    <a href="eval.html#Tuple">Tuple</a>               作为数组 (可为 null)；若递归使用: []
                    <a href="eval.html#Dict">Dict</a>                作为对象 (可为 null)；若递归使用: <code class="special">{}</code>
                    <a href="eval.html#Blob">Blob</a>                作为一个个字节组成的数组
                   v:false              "false"
                   v:true               "true"
                   v:none               "null"
                   v:null               "null"
                <code class="note">备注</code> NaN 和 Infinity 作为值传递。这在 JSON 标准里没有提到，但
                若干实现支持。如果不支持，可能会报错。
                字符串时包含非法字符时，使用字符 0xfffd 替代。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetObject()-&gt;json_encode()</code>

                返回类型:  <a href="eval.html#String">String</a> 


keys(<code class="special">{dict}</code>)                                            <b class="vimtag"> <a name="keys()">keys()</a> </b>
                返回  <a href="eval.html#List">List</a> ，<code class="special">{dict}</code> 的所有键。 <a href="eval.html#List">List</a>  项目的顺序不定。另见
                 <a href="builtin.html#items()">items()</a>  和  <a href="builtin.html#values()">values()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mydict-&gt;keys()</code>

                返回类型: list<code class="special">&lt;string&gt;</code>


keytrans(<code class="special">{string}</code>)                                      <b class="vimtag"> <a name="keytrans()">keytrans()</a> </b>
                把键值的内部字节表示方式转换为  <a href="map.html#:map">:map</a>  可接受的形式。如 
<code class="example">                        :let xx = "\&lt;C-Home&gt;"</code>
<code class="example">                        :echo keytrans(xx)</code>
                        <code class="special">&lt;C-Home&gt;</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        "\&lt;C-Home&gt;"-&gt;keytrans()</code>

                返回类型:  <a href="eval.html#String">String</a> 


len(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="len()">len()</a> </b> <b class="vimtag"> <a name="E701">E701</a> </b>
                返回数值，参数的长度。
                如果 <code class="special">{expr}</code> 为字符串或数值，返回它使用的字节数，和  <a href="builtin.html#strlen()">strlen()</a> 
                相同。
                如果 <code class="special">{expr}</code> 为  <a href="eval.html#List">List</a> ，返回  <a href="eval.html#List">List</a>  的项目数量。
                如果 <code class="special">{expr}</code> 为  <a href="eval.html#Tuple">Tuple</a> ，返回  <a href="eval.html#Tuple">Tuple</a>  的项目数量。
                如果 <code class="special">{expr}</code> 为  <a href="eval.html#Blob">Blob</a> ，返回字节数。
                如果 <code class="special">{expr}</code> 为  <a href="eval.html#Dictionary">Dictionary</a> ，返回  <a href="eval.html#Dictionary">Dictionary</a>  的项目数量。
                如果 <code class="special">{expr}</code> 为 {Object|，调用对象 (如有) 的 len() 方法来取得长
                度值 ( <a href="vim9class.html#object-len()">object-len()</a> )。
                否则报错并返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;len()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


libcall(<code class="special">{libname}</code>, <code class="special">{funcname}</code>, <code class="special">{argument}</code>)              <b class="vimtag"> <a name="libcall()">libcall()</a> </b> <b class="vimtag"> <a name="E364">E364</a> </b> <b class="vimtag"> <a name="E368">E368</a> </b>
                在运行库 <code class="special">{libname}</code> 里调用函数 <code class="special">{funcname}</code> 并给出单个参数
                <code class="special">{argument}</code>。
                这可以用于调用库里的函数，尤其是 Vim 里用到的那些。因为只能使
                用单个参数，所以可以调用的标准库函数相当有限。
                结果是函数返回的字符串。如果函数返回 NULL，在 Vim 里会以空字符
                串 "" 出现。
                如果函数返回数值，请使用  <a href="builtin.html#libcallnr()">libcallnr()</a> ！
                如果 <code class="special">{argument}</code> 是数值，它以 int 类型传给函数；如果 <code class="special">{argument}</code>
                是字符串，它以 null 结尾的字符串类型传入。
                在  <a href="starting.html#restricted-mode">restricted-mode</a>  里，该函数不能运行。

                libcall() 允许你写自己的 Vim '插件' 扩展，而无须重新编译程序。
                它并 <code class="emphasis">不</code> 是用来调用系统函数的一个方法！如果你试图这么做，Vim 很
                有可能会崩溃。

                Win32 上，你写的函数必须在 DLL 里提供，而且必须使用普通的 C 调
                用惯例 ( <code class="emphasis">不是</code>  Windows 系统 DLL 使用的 Pascal 惯例)。函数必须
                只能接受单个参数，或者是字符指针，或者是长整数，而且必须返回字
                符指针或者 NULL。返回的字符指针必须指向在函数返回之后仍然指向
                合法的内存 (比如 DLL 的静态区域)。如果指向分配的区域，那么内存
                会发生泄漏。在函数里使用静态缓冲区应该可以，在 DLL 卸载时会被
                释放。

                警 告: 如果函数返回不合法的指针，Vim 会崩溃！如果函数返回数值
                也会发生同样的问题，因为 Vim 把它当作指针看待。
                Win32 系统上，<code class="special">{libname}</code> 必须是不带 ".DLL" 后缀的 DLL 文件名。
                只有 DLL 不在常见的位置的时候，才需要指定完整的路径名。
                Unix 上: 如果编译你自己的插件，记住目标代码必须生成位置无关代
                码 ('PIC')。
                {仅当使用 Win32 和一些 Unix 版本且带有  <a href="various.html#+libcall">+libcall</a>  特性时才有
                效}
                例如: 
<code class="example">                        :echo libcall("libc.so", "getenv", "HOME")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetValue()-&gt;libcall("libc.so", "getenv")</code>


libcallnr(<code class="special">{libname}</code>, <code class="special">{funcname}</code>, <code class="special">{argument}</code>)            <b class="vimtag"> <a name="libcallnr()">libcallnr()</a> </b>
                和  <a href="builtin.html#libcall()">libcall()</a>  类似，但函数返回 int，而不是字符串。
                {仅当使用 Win32 和一些 Unix 版本且带有  <a href="various.html#+libcall">+libcall</a>  特性时才有
                效}
                例如: 
<code class="example">                        :echo libcallnr("/usr/lib/libc.so", "getpid", "")</code>
<code class="example">                        :call libcallnr("libc.so", "printf", "Hello World!\n")</code>
<code class="example">                        :call libcallnr("libc.so", "sleep", 10)</code>

                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetValue()-&gt;libcallnr("libc.so", "printf")</code>

                返回类型:  <a href="eval.html#String">String</a> 


line(<code class="special">{expr}</code> [, <code class="special">{winid}</code>])                                <b class="vimtag"> <a name="line()">line()</a> </b>
                返回数值，即 <code class="special">{expr}</code> 给定的文件位置行号。<code class="special">{expr}</code> 参数是字符串。
                可接受的位置见  <a href="builtin.html#getpos()">getpos()</a> 。

                要得到列号用  <a href="builtin.html#col()">col()</a> 。两者都要可用  <a href="builtin.html#getpos()">getpos()</a> 。

                给出可选的 <code class="special">{winid}</code> 参数时，从该窗口取值而不是当前窗口。

                <code class="special">{expr}</code> 和 <code class="special">{winid}</code> 有非法值时返回 0。

                例如: 
<code class="example">                        line(".")               光标所在的行号</code>
<code class="example">                        line(".", winid)        同上，但取自窗口 "winid"</code>
<code class="example">                        line("'t")              位置标记 t 的行号</code>
<code class="example">                        line("'" .. marker)     名为 marker 的位置标记的行号</code>

                要在打开文件后跳转到最近已知的位置，见  <a href="usr_05.html#last-position-jump">last-position-jump</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetValue()-&gt;line()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


line2byte(<code class="special">{lnum}</code>)                                       <b class="vimtag"> <a name="line2byte()">line2byte()</a> </b>
                返回当前缓冲区第 <code class="special">{lnum}</code> 行从缓冲区开始计算的字节数。这里包括换
                行符，但它具体的值取决于当前缓冲区的 <a href="options.html#'fileformat'">'fileformat'</a> 选项，第一行
                返回 1。这和 <a href="options.html#'encoding'">'encoding'</a> 有关但忽略 <a href="options.html#'fileencoding'">'fileencoding'</a>。
                这也可以用来得到最后一行之后的 "那行" 的字节计数: 
<code class="example">                        line2byte(line("$") + 1)</code>
                这就等于缓冲区大小加一。如果 <a href="options.html#'fileencoding'">'fileencoding'</a> 为空则等于文件大小
                加一。<code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。<code class="special">{lnum}</code> 非法或者编译时关闭
                了  <a href="various.html#+byte_offset">+byte_offset</a>  特性时返回 -1。
                另见  <a href="builtin.html#byte2line()">byte2line()</a> 、 <a href="motion.html#go">go</a>  和  <a href="motion.html#:goto">:goto</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;line2byte()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


lispindent(<code class="special">{lnum}</code>)                                      <b class="vimtag"> <a name="lispindent()">lispindent()</a> </b>
                得到第 <code class="special">{lnum}</code> 行根据 lisp 缩进规则应有的缩进距离，见 <a href="options.html#'lisp'">'lisp'</a>。
                缩进的计算以空格计，因而和 <a href="options.html#'tabstop'">'tabstop'</a> 的值是有关系的。
                <code class="special">{lnum}</code> 的使用方式和  <a href="builtin.html#getline()">getline()</a>  相同。
                <code class="special">{lnum}</code> 非法时返回 -1。 <a href="vim9.html#Vim9">Vim9</a>  脚本会报错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;lispindent()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


list2blob(<code class="special">{list}</code>)                                       <b class="vimtag"> <a name="list2blob()">list2blob()</a> </b>
                返回连接 <code class="special">{list}</code> 中所有数值的 blob。例如: 
<code class="example">                        list2blob([1, 2, 3, 4]) returns 0z01020304</code>
<code class="example">                        list2blob([])           returns 0z</code>
                出错时返回空 blob。如果有数值为负或大于 255，报错
                <b class="vimtag"> <a name="E1239">E1239</a> </b> 。

                 <a href="builtin.html#blob2list()">blob2list()</a>  是其逆操作。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetList()-&gt;list2blob()</code>

                返回类型:  <a href="eval.html#Blob">Blob</a> 


list2str(<code class="special">{list}</code> [, <code class="special">{utf8}</code>])                             <b class="vimtag"> <a name="list2str()">list2str()</a> </b>
                把 <code class="special">{list}</code> 中的每个数值转换为字符，并连接成字符串。例如: 
<code class="example">                        list2str([32])          返回 " "</code>
<code class="example">                        list2str([65, 66, 67])  返回 "ABC"</code>
                也可以这样实现 (慢): 
<code class="example">                        join(map(list, {nr, val -&gt; nr2char(val)}), '')</code>
                 <a href="builtin.html#str2list()">str2list()</a>  是逆操作。

                <code class="special">{utf8}</code> 省略或为零时，使用当前 <a href="options.html#'encoding'">'encoding'</a>。
                <code class="special">{utf8}</code> 为 TRUE 时，总是返回 UTF-8 字符。
                使用 UTF-8 时，组合字符正常工作: 
<code class="example">                        list2str([97, 769])     返回 "á"</code>

                出错时返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetList()-&gt;list2str()</code>

                返回类型:  <a href="eval.html#String">String</a> 


list2tuple(<code class="special">{list}</code>)                                      <b class="vimtag"> <a name="list2tuple()">list2tuple()</a> </b>
                从列表项目的浅备份建立元组。示例: 
<code class="example">                        list2tuple([1, 2, 3])           返回 (1, 2, 3)</code>
                 <a href="builtin.html#tuple2list()">tuple2list()</a>  是逆操作。

                此函数不会递归转换 <code class="special">{list}</code> 里的所有列表项目为元组。<code class="note">注意</code>列表和元
                组的项目只有一份，所以修改项目会同时修改元组和列表里的内容。

                出错时返回空元组。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetList()-&gt;list2tuple()</code>

                返回类型: tuple&lt;<code class="special">{type}</code>&gt; (取决于给定的  <a href="eval.html#List">List</a> )


listener_add(<code class="special">{callback}</code> [, <code class="special">{buf}</code> [, <code class="special">{unbuffered}</code>]])     <b class="vimtag"> <a name="listener_add()">listener_add()</a> </b>
                添加缓冲区 <code class="special">{buf}</code> 有改动时会被执行的回调函数。
                <code class="special">{buf}</code> 可以是缓冲区名或号。它可接受的值见  <a href="builtin.html#bufname()">bufname()</a> 。省略
                <code class="special">{buf}</code> 时使用当前缓冲区。
                返回唯一的 ID，可传递给  <a href="builtin.html#listener_remove()">listener_remove()</a> 。

                如果 <code class="special">{buf}</code> 已注册过回调，这等价于在增加新回调之前，先调用 
<code class="example">                    listener_flush({buf})</code>
                函数。

                <code class="special">{callback}</code> 调用时带五个参数:
                    bufnr       发生改动的缓冲区
                    start       改动发生的首行行号
                    end         改动区域之下的首行行号
                    added       增加的行数，如果删除行则为负数
                    changes     关于改动细节的项目列表

                示例: 
<code class="example">            func Listener(bufnr, start, end, added, changes)</code>
<code class="example">              echo 'lines ' .. a:start .. ' until ' .. a:end .. ' changed'</code>
<code class="example">            endfunc</code>
<code class="example">            call listener_add('Listener', bufnr)</code>
<code class="example"></code>
                此列表不能修改。"changes" 的每个项目是带以下项的字典:
                    lnum        改动的首行行号
                    end         改动区域之下的首行行号
                    added       增加的行数，如果删除行则为负数
                    col         "lnum" 中受改动影响的首列；如果未知或整行都受
                                影响则为一；这是字节计数，首个字符的值为一。
                插入新行 (不包含分割行，如在插入模式时键入 CR 的情况) 时，值
                为:
                    lnum        在该行之上加入了新行
                    end         等于 "lnum"
                    added       插入的行数
                    col         1
                删除行时，值为:
                    lnum        首个删除行
                    end         删除发生之前首 (<code class="vim">译者注</code>: 应为末？) 个删除行之下
                                的那行
                    added       负数，删除的行数
                    col         1
                行发生改动时:
                    lnum        首个改动行
                    end         最后改动行之下的那行
                    added       0
                    col         改动发生的首列，或 1

                <code class="special">{unbuffered}</code> 为  <a href="eval.html#FALSE">FALSE</a>  或未给出时，调用 <code class="special">{callback}</code> 的时刻为:

                1. 在屏幕刚刚刷新前。
                2. 调用  <a href="builtin.html#listener_flush()">listener_flush()</a>  时。
                3. 发生了影响行计数的改动，以致于修改列表里的某行的行号不再有
                   效。

                依改动发生的次序列出项目，这样最近发生的改动在最后。

                因为上面列出的触发回调的第三个触发的原因，传递给的回调的行号未
                必能保证有效。如果这会导致问题，把 <code class="special">{unbuffered}</code> 设为  <a href="eval.html#TRUE">TRUE</a> 。

                <code class="special">{unbuffered}</code> 为  <a href="eval.html#TRUE">TRUE</a>  时，每一个改动都会触发 <code class="special">{callback}</code>。改动
                列表只保留单一字典，字典里的 "start"、"end" 和 "added" 值和对
                应的回调参数相同。调用回调时的行号一定是合法的，但之后的改动可
                能会使之非法，所以不建议保留其备份为之后使用。

                <code class="special">{callback}</code> 调用时文本被锁定，见  <a href="eval.html#textlock">textlock</a> 。如果需要改动缓冲
                区，使用定时器可以在之后某时进行需要的改动  <a href="builtin.html#timer_start()">timer_start()</a> 。

                <code class="special">{callback}</code> 中不能调用 listener_add()。 <b class="vimtag"> <a name="E1569">E1569</a> </b>

                缓冲区初次载入时不调用 <code class="special">{callback}</code>。 <a href="autocmd.html#BufReadPost">BufReadPost</a>  自动命令事件
                可用来处理缓冲区的初始文本。
                缓冲区被卸载时也不调用 <code class="special">{callback}</code>， <a href="autocmd.html#BufUnload">BufUnload</a>  自动事件可用于
                此。

                <code class="special">{callback}</code> 或 <code class="special">{buf}</code> 非法时返回零。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetBuffer()-&gt;listener_add(callback)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


listener_flush([<code class="special">{buf}</code>])                                 <b class="vimtag"> <a name="listener_flush()">listener_flush()</a> </b>
                调用缓冲区 <code class="special">{buf}</code> 的监听器回调。如果没有待处理的改动则不调用回
                调。

                <code class="special">{buf}</code> 可以是缓冲区名或号。它可接受的值见  <a href="builtin.html#bufname()">bufname()</a> 。省略
                <code class="special">{buf}</code> 时使用当前缓冲区。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;listener_flush()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


listener_remove(<code class="special">{id}</code>)                                   <b class="vimtag"> <a name="listener_remove()">listener_remove()</a> </b>
                删除之前用  <a href="builtin.html#listener_add()">listener_add()</a>  加的监听器。
                如果 <code class="special">{id}</code> 找不到返回 FALSE，<code class="special">{id}</code> 已删除时返回 TRUE。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetListenerId()-&gt;listener_remove()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


localtime()                                             <b class="vimtag"> <a name="localtime()">localtime()</a> </b>
                返回当前时间，以 1970 年 1 月 1 日开始的秒数计算。另见
                 <a href="builtin.html#strftime()">strftime()</a> 、 <a href="builtin.html#strptime()">strptime()</a>  和  <a href="builtin.html#getftime()">getftime()</a> 。

                返回类型:  <a href="eval.html#Number">Number</a> 


log(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="log()">log()</a> </b>
                返回浮点数，即浮点数 <code class="special">{expr}</code> 的自然对数 (即以 e 为底)。
                <code class="special">{expr}</code> 计算结果必须为 (0, inf] 区间内的  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。
                如果 <code class="special">{expr}</code> 不是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> ，返回 0.0。
                示例: 
<code class="example">                        :echo log(10)</code>
                        2.302585 
<code class="example">                        :echo log(exp(5))</code>
                        5.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;log()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


log10(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="log10()">log10()</a> </b>
                返回浮点数，即浮点数 <code class="special">{expr}</code> 以 10 为底的对数。
                <code class="special">{expr}</code> 计算结果必须为  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。
                如果 <code class="special">{expr}</code> 不是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> ，返回 0.0。
                示例: 
<code class="example">                        :echo log10(1000)</code>
                        3.0 
<code class="example">                        :echo log10(0.01)</code>
                        -2.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;log10()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


luaeval(<code class="special">{expr}</code> [, <code class="special">{expr}</code>])                              <b class="vimtag"> <a name="luaeval()">luaeval()</a> </b>
                执行 Lua 表达式 <code class="special">{expr}</code> 并把结果转换为 Vim 数据结构。第二个
                <code class="special">{expr}</code> 指定在第一个 <code class="special">{expr}</code> 里可以使用的额外参数，可以 _A 形式
                访问。
                字符串原样返回。
                布尔值对象转换为数值。
                数值转换为  <a href="eval.html#Float">Float</a> 。
                vim.eval() 得到的字典和列表以原样返回。
                 <a href="if_lua.html#lua-luaeval">lua-luaeval</a>  有更多详情。
                <code class="note">注意</code>  <a href="vim9.html#:def">:def</a>  函数里的局部变量对 <code class="special">{expr}</code> 不可见。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;luaeval()</code>

                返回类型: any，取决于 <code class="special">{expr}</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+lua">+lua</a>  特性才有效}</code>


map(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                   <b class="vimtag"> <a name="map()">map()</a> </b>
                <code class="special">{expr1}</code> 必须是  <a href="eval.html#List">List</a>  、 <a href="eval.html#String">String</a> 、 <a href="eval.html#Blob">Blob</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。
                <code class="special">{expr1}</code> 是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  时，<code class="special">{expr1}</code> 里的每个项目被
                <code class="special">{expr2}</code> 的计算结果替代。
                 <a href="eval.html#Blob">Blob</a>  的每个字节被替代。
                 <a href="eval.html#String">String</a>  的每个字符，包括组合字符，被替代。
                如果项目的类型发生变化，可以考虑用  <a href="builtin.html#mapnew()">mapnew()</a>  来创建新的列表或
                字典。Vim9 脚本里这是必须的。

                <code class="special">{expr2}</code> 必须是  <a href="eval.html#String">String</a>  或  <a href="eval.html#Funcref">Funcref</a> 。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#String">String</a> ，<code class="special">{expr2}</code> 内的  <a href="eval.html#v:val">v:val</a>  包含当前项目的
                值。 <a href="eval.html#Dictionary">Dictionary</a>  中  <a href="eval.html#v:key">v:key</a>  包含当前项目的键。 <a href="eval.html#List">List</a>  中
                 <a href="eval.html#v:key">v:key</a>  包含当前项目的索引。 <a href="eval.html#Blob">Blob</a>  中  <a href="eval.html#v:key">v:key</a>  包含当前字节的索
                引。 <a href="eval.html#String">String</a>  中  <a href="eval.html#v:key">v:key</a>  包含当前字符的索引。
                例如: 
<code class="example">                        :call map(mylist, '"&gt; " .. v:val .. " &lt;"')</code>
                "mylist" 里的每个项目之前放上 "&gt; "，而之后放上 " &lt;"。

                <code class="note">注意</code> <code class="special">{string}</code> 是表达式的计算结果，而它本身又用作表达式。通常，
                最好用  <a href="eval.html#literal-string">literal-string</a>  来避免反斜杠加倍。当然，你仍然需要加倍
                ' 引号。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#Funcref">Funcref</a> ，它必须接受两个参数:
                        1. 当前项目的键或索引。
                        2. 当前项目的值。
                用老式脚本匿名函数时如果它只接受一个参数，不报错。但 Vim9 匿名
                函数会报错 "E1106: One argument too many"，参数数目必须匹配。

                函数必须返回项目的新值。例如要改变每个值为 "键-值": 
<code class="example">                        func KeyValue(key, val)</code>
<code class="example">                          return a:key .. '-' .. a:val</code>
<code class="example">                        endfunc</code>
<code class="example">                        call map(myDict, function('KeyValue'))</code>
                使用  <a href="eval.html#lambda">lambda</a>  会更短: 
<code class="example">                        call map(myDict, {key, val -&gt; key .. '-' .. val})</code>
                如果不用 "val"，可以不写: 
<code class="example">                        call map(myDict, {key -&gt; 'item: ' .. key})</code>
                如果不用 "key"，可以使用短名: 
<code class="example">                        call map(myDict, {_, val -&gt; 'item: ' .. val})</code>

                对  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  而言，本操作是原位操作 (直接在输入上
                修改)。要想不更动原始输入，先建立备份: 
<code class="example">                        :let tlist = map(copy(mylist), ' v:val .. "\t"')</code>
<code class="example"></code>
                返回 <code class="special">{expr1}</code>，经过过滤的  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> ，或者新的
                 <a href="eval.html#Blob">Blob</a>  或  <a href="eval.html#String">String</a> 。
                执行 <code class="special">{expr2}</code> 出现错误时，不再处理 <code class="special">{expr1}</code> 的其余项目。
                <code class="special">{expr2}</code> 是函数引用时，忽略函数里的错误，除非该函数用 "abort"
                标志位定义。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;map(expr2)</code>

                返回类型:  <a href="eval.html#String">String</a> 、 <a href="eval.html#Blob">Blob</a> 、list&lt;<code class="special">{type}</code>&gt; 或 dict&lt;<code class="special">{type}</code>&gt;，
                取决于 <code class="special">{expr1}</code>


maparg(<code class="special">{name}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code> [, <code class="special">{dict}</code>]]])         <b class="vimtag"> <a name="maparg()">maparg()</a> </b>
                当 <code class="special">{dict}</code> 省略或为零，返回模式 <code class="special">{mode}</code> 名为 <code class="special">{name}</code> 的映射的右手
                边 (rhs)。返回字符串中的特殊字符用和 ":map" 命令输出的同样方式
                进行翻译。如果 <code class="special">{dict}</code> 为 TRUE，返回字典，见下。要得到所有映射
                的列表，可用  <a href="builtin.html#maplist()">maplist()</a> 。

                如果没有名为 <code class="special">{name}</code> 的映射，<code class="special">{dict}</code> 为 FALSE 时返回空串，否则返
                回空字典。如果名为 <code class="special">{name}</code> 的映射为空，返回 "<code class="special">&lt;Nop&gt;</code>"。

                <code class="special">{name}</code> 可包含特殊键名，一如 ":map" 命令。

                <code class="special">{mode}</code> 可以使用下列字符串之一:
                        "n"     普通模式
                        "v"     可视模式 (包括选择)
                        "o"     操作符等待模式
                        "i"     插入模式
                        "c"     命令行模式
                        "s"     选择模式
                        "x"     可视模式
                        "l"     语言映射  <a href="map.html#language-mapping">language-mapping</a> 
                        "t"     终端-作业
                        ""      普通、可视和操作符等待模式。
                如果没有提供 <code class="special">{mode}</code>，使用 "" 指定的模式。

                如果提供 <code class="special">{abbr}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，使用缩写而不是映射。

                如果提供 <code class="special">{dict}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，返回字典，包含关于映射的所有信
                息。有如下项目:                         <b class="vimtag"> <a name="mapping-dict">mapping-dict</a> </b>
                  "lhs"      映射的 <code class="special">{lhs}</code>，作为键盘输入
                  "lhsraw"   映射的 <code class="special">{lhs}</code>，保留原始字节
                  "lhsrawalt" 映射的 <code class="special">{lhs}</code>，保留原始字节，这是一种替代形式，仅
                              当和 "lhsraw" 不同时才会存在
                  "rhs"      映射的 <code class="special">{rhs}</code>，作为键盘输入。
                  "silent"   1 若是  <a href="map.html#:map-silent">:map-silent</a>  映射，否则为 0。
                  "noremap"  1 若是映射的 <code class="special">{rhs}</code> 不能再映射。
                  "script"   1 若是映射使用 <code class="special">&lt;script&gt;</code> 定义。
                  "expr"     1 若是表达式映射 ( <a href="map.html#:map-%3Cexpr%3E">:map-&lt;expr&gt;</a> )。
                  "buffer"   1 若是缓冲区本地映射 ( <a href="map.html#:map-local">:map-local</a> )。
                  "mode"     映射定义使用的模式。除了以上提到的模式以外，还会
                             使用:
                             " "     普通、可视和操作符等待模式
                             "!"     插入和命令行模式
                                     ( <a href="map.html#mapmode-ic">mapmode-ic</a> )
                  "sid"      脚本局部 ID，用于 <code class="special">&lt;sid&gt;</code> 映射 ( <a href="map.html#%3CSID%3E">&lt;SID&gt;</a> )。负值用于
                             特殊上下文。
                  "scriptversion"  脚本版本。 <a href="vim9.html#Vim9">Vim9</a>  脚本返回 999999。
                  "lnum"     "sid" 中的行号，如果未知则为零。
                  "nowait"   不等待其它更长的映射。( <a href="map.html#:map-%3Cnowait%3E">:map-&lt;nowait&gt;</a> )。
                  "abbr"     如为缩写  <a href="map.html#abbreviations">abbreviations</a>  则为真。
                  "mode_bits" "mode" 的 Vim 内部二进制表示。 <a href="builtin.html#mapset()">mapset()</a>  忽略
                             之，只用 "mode"。用法举例可见  <a href="builtin.html#maplist()">maplist()</a> 。其值来
                             自 src/vim.h，将来可能会改变。

                此字典可用  <a href="builtin.html#mapset()">mapset()</a>  来恢复映射。

                先检查局部于当前缓冲区的映射，然后再检查全局映射。
                此函数可以用来给键映射。如果已经映射过，还可以使用原来映射的内
                容。大意: 
<code class="example">                        exe 'nnoremap &lt;Tab&gt; ==' .. maparg('&lt;Tab&gt;', 'n')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetKey()-&gt;maparg('n')</code>

                返回类型:  <a href="eval.html#String">String</a>  或 dict<code class="special">&lt;any&gt;</code>，取决于 <code class="special">{dict}</code>


mapcheck(<code class="special">{name}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])                  <b class="vimtag"> <a name="mapcheck()">mapcheck()</a> </b>
                检查是否有模式 <code class="special">{mode}</code> 下匹配 <code class="special">{name}</code> 的映射。 <a href="builtin.html#maparg()">maparg()</a>  说明
                <code class="special">{mode}</code> 和 <code class="special">{name}</code> 里的特殊键名。
                如果提供 <code class="special">{abbr}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，使用缩写而不是映射。
                匹配在映射名以 <code class="special">{name}</code> 开始或者映射名等于 <code class="special">{name}</code> 的开始部分时候
                发生。

<code class="section">                        匹配映射        "a"     "ab"    "abc" </code>
                   mapcheck("a")        是      是       是
                   mapcheck("abc")      是      是       是
                   mapcheck("ax")       是      否       否
                   mapcheck("b")        否      否       否

                和  <a href="builtin.html#maparg()">maparg()</a>  的差别是，mapcheck() 查找匹配 <code class="special">{name}</code> 的映射，而
                 <a href="builtin.html#maparg()">maparg()</a>  只查找名字完全符合 <code class="special">{name}</code> 的映射。
                如果没有 <code class="special">{name}</code> 开始的映射，返回空字符串。如果有一个，返回该映
                射的右手边。如果有多个，返回其中某一个的右手边。如果该右手边为
                空，返回 "<code class="special">&lt;Nop&gt;</code>"。
                先检查局部于当前缓冲区的映射，然后再检查全局映射。
                该函数用于检查是否可以无二义性地添加映射。例如: 
<code class="example">        :if mapcheck("_vv") == ""</code>
<code class="example">        :   map _vv :set guifont=7x13&lt;CR&gt;</code>
<code class="example">        :endif</code>
                就避免了在已有 "_v" 或者 "_vvv" 映射的时候添加 "_vv" 映射。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetKey()-&gt;mapcheck('n')</code>

                返回类型:  <a href="eval.html#String">String</a> 


maplist([<code class="special">{abbr}</code>])                                       <b class="vimtag"> <a name="maplist()">maplist()</a> </b>
                返回所有映射的  <a href="eval.html#List">List</a> 。每个列表项目是  <a href="eval.html#Dict">Dict</a> ，和  <a href="builtin.html#maparg()">maparg()</a>  返
                回值相同，见  <a href="builtin.html#mapping-dict">mapping-dict</a> 。如果给出 <code class="special">{abbr}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，使用
                缩写而不是映射。

                显示后手边使用 'MultiMatch' 的所有映射的例子: 
<code class="example">                        vim9script</code>
<code class="example">                        echo maplist()-&gt;filter(</code>
<code class="example">                                (_, m) =&gt; match(m.rhs, 'MultiMatch') &gt;= 0)</code>
                要找到特定  <a href="map.html#:map-modes">:map-modes</a>  的所有映射需要点技巧。 <a href="builtin.html#mapping-dict">mapping-dict</a> 
                里的 "mode_bits" 可以简化。例如，对应普通、插入或命令行模式的
                mode_bits 是 0x19。要找到所有这些模式的映射: 
<code class="example">                        vim9script</code>
<code class="example">                        var saved_maps = []</code>
<code class="example">                        for m in maplist()</code>
<code class="example">                            if and(m.mode_bits, 0x19) != 0</code>
<code class="example">                                saved_maps-&gt;add(m)</code>
<code class="example">                            endif</code>
<code class="example">                        endfor</code>
<code class="example">                        echo saved_maps-&gt;mapnew((_, m) =&gt; m.lhs)</code>
                mode_bits 的值在 Vim 的 src/vim.h 源代码里定义，运行时可用
                 <a href="map.html#:map-commands">:map-commands</a>  和 "maplist()" 找到。例如: 
<code class="example">                        vim9script</code>
<code class="example">                        omap xyzzy &lt;Nop&gt;</code>
<code class="example">                        var op_bit = maplist()-&gt;filter(</code>
<code class="example">                            (_, m) =&gt; m.lhs == 'xyzzy')[0].mode_bits</code>
<code class="example">                        ounmap xyzzy</code>
<code class="example">                        echo printf("Operator-pending mode bit: 0x%x", op_bit)</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt;


mapnew(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                <b class="vimtag"> <a name="mapnew()">mapnew()</a> </b>
                类似于  <a href="builtin.html#map()">map()</a> ，但生成并返回新的列表或字典而不是替换 <code class="special">{expr1}</code>
                里的项目。<code class="special">{expr1}</code> 保持不变。项目仍然可由 <code class="special">{expr2}</code> 改变，如果不
                想如此，先用  <a href="builtin.html#deepcopy()">deepcopy()</a> 。

                返回类型:  <a href="eval.html#String">String</a> 、 <a href="eval.html#Blob">Blob</a> 、list&lt;<code class="special">{type}</code>&gt; 或 dict&lt;<code class="special">{type}</code>&gt;，
                取决于 <code class="special">{expr1}</code>


mapset(<code class="special">{mode}</code>, <code class="special">{abbr}</code>, <code class="special">{dict}</code>)                          <b class="vimtag"> <a name="mapset()">mapset()</a> </b>
mapset(<code class="special">{dict}</code>)
                从  <a href="builtin.html#maparg()">maparg()</a>  或  <a href="builtin.html#maplist()">maplist()</a>  返回的字典中恢复映射。dict.buffer
                为真时，使用缓冲区映射，此时在当前缓冲区上设置映射；调用者应确
                保要操作的缓冲区是当前缓冲区。此特性可以把一个缓冲区上的映射复
                制到另一个缓冲区里。dict.mode 值可以恢复适用于多个模式的单个映
                射，比如使用 mode 值 '!'、' '、<code class="badlink">'nox'</code> 或 'v'。 <b class="vimtag"> <a name="E1276">E1276</a> </b>

                第一种形式里，<code class="special">{mode}</code> 和 <code class="special">{abbr}</code> 应和  <a href="builtin.html#maparg()">maparg()</a>  调用时所用之值
                相同。 <b class="vimtag"> <a name="E460">E460</a> </b>
                <code class="special">{mode}</code> 用于定义映射设置所在的模式，而不是 <code class="special">{dict}</code> 中的 "mode"
                项目。
                保存和恢复映射的示例: 
<code class="example">                        let save_map = maparg('K', 'n', 0, 1)</code>
<code class="example">                        nnoremap K 其它映射值</code>
<code class="example">                        ...</code>
<code class="example">                        call mapset('n', 0, save_map)</code>
                <code class="note">注意</code> 要替换适用于若干模式下的映射，如  <a href="map.html#:map!">:map!</a>  这样的，你需要分
                别保存/恢复所有模式下的映射，它们可能不同。

                第二种形式里，<code class="special">{dict}</code> 是唯一的参数，mode 和 abbr 取自于 dict。
                示例: 
<code class="example">                        vim9script</code>
<code class="example">                        var save_maps = maplist()-&gt;filter(</code>
<code class="example">                                                (_, m) =&gt; m.lhs == 'K')</code>
<code class="example">                        nnoremap K somethingelse</code>
<code class="example">                        cnoremap K somethingelse2</code>
<code class="example">                        # ...</code>
<code class="example">                        unmap K</code>
<code class="example">                        for d in save_maps</code>
<code class="example">                            mapset(d)</code>
<code class="example">                        endfor</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


match(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])            <b class="vimtag"> <a name="match()">match()</a> </b>
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，返回匹配 <code class="special">{pat}</code> 的第一个项目的索引。每个
                项目用作字符串， <a href="eval.html#List">List</a>  和  <a href="eval.html#Dictionary">Dictionary</a>  使用回显的形式。

                否则，<code class="special">{expr}</code> 用作字符串。返回数值，给出 <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 匹配的
                (字节计算的偏移量) 位置。

                在第一个字符或  <a href="eval.html#List">List</a>  项目上的匹配返回零。若无匹配，返回 -1。
                要得到子匹配，见  <a href="builtin.html#matchlist()">matchlist()</a> 。

                例如: 
<code class="example">                        :echo match("testing", "ing")   " 返回 4</code>
<code class="example">                        :echo match([1, 'x'], '\a')     " 返回 1</code>
                 <a href="builtin.html#string-match">string-match</a>  说明如何使用 <code class="special">{pat}</code>。
                                                        <b class="vimtag"> <a name="strpbrk()">strpbrk()</a> </b>
                Vim 没有 strpbrk() 函数。但你可以这么做: 
<code class="example">                        :let sepidx = match(line, '[.,;: \t]')</code>
                                                        <b class="vimtag"> <a name="strcasestr()">strcasestr()</a> </b>
                Vim 没有 strcasestr() 函数。但你可以在模式里加入 "\c" 以忽略大
                小写: 
<code class="example">                        :let idx = match(haystack, '\cneedle')</code>

                如果给出 <code class="special">{start}</code>，搜索从字符串的字节位置 <code class="special">{start}</code> 或  <a href="eval.html#List">List</a>  索
                引为 <code class="special">{start}</code> 的项目开始。
                不过，结果仍然从第一个字符/项目开始算起。比如: 
<code class="example">                        :echo match("testing", "ing", 2)</code>
                返回结果是 "4"。 
<code class="example">                        :echo match("testing", "ing", 4)</code>
                返回结果还是 "4"。 
<code class="example">                        :echo match("testing", "t", 2)</code>
                返回 "3"。
                对字符串而言，如果 <code class="special">{start}</code> &gt; 0，其行为就像该字符串在 <code class="special">{start}</code>
                个字节后开始，因而 "^" 会从 <code class="special">{start}</code> 开始匹配。如果给出 <code class="special">{count}</code>
                时则不是如此，此时忽略 <code class="special">{start}</code> 字节前的匹配 (有一点复杂，这是
                为了后向兼容)。
                对字符串而言，如果 <code class="special">{start}</code> &lt; 0，它被置为 0。对列表而言，此索引
                从尾部起算。
                如果 <code class="special">{start}</code> 越界 (字符串 <code class="special">{start}</code> &gt; strlen(<code class="special">{expr}</code>)，而  <a href="eval.html#List">List</a> 
                <code class="special">{start}</code> &gt; len(<code class="special">{expr}</code>))，返回 -1。

                如果给出 <code class="special">{count}</code>，使用第 <code class="special">{count}</code> 个匹配。如果字符串里找到一个
                匹配，下一匹配从此匹配之后一个字符开始寻找。所以下例返回 1: 
<code class="example">                        echo match("testing", "..", 0, 2)</code>
                 <a href="eval.html#List">List</a>  里，搜索从下一个项目开始。
                <code class="note">注意</code> 如果加入 <code class="special">{count}</code>，<code class="special">{start}</code> 使用的方式有所改变。见上。

                                                        <b class="vimtag"> <a name="match-pattern">match-pattern</a> </b>
                 <a href="pattern.html#pattern">pattern</a>  说明可以接受的模式。
                <a href="options.html#'ignorecase'">'ignorecase'</a> 选项用来设定模式是否忽略大小写。 <code class="emphasis">不</code> 使用
                <a href="options.html#'smartcase'">'smartcase'</a>。匹配总是假定置位了 <a href="options.html#'magic'">'magic'</a> 而 <a href="options.html#'cpoptions'">'cpoptions'</a> 为空。
                <code class="note">注意</code> 优先考虑开始处的匹配，所以使用 "*" (任意数目的匹配) 时，
                模式倾向于寻找开始处的零匹配而不是文本内部的多数目匹配。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;match('word')</code>
<code class="example">                        GetList()-&gt;match('word')</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


                                                        <b class="vimtag"> <a name="matchadd()">matchadd()</a> </b> <b class="vimtag"> <a name="E290">E290</a> </b> <b class="vimtag"> <a name="E798">E798</a> </b> <b class="vimtag"> <a name="E799">E799</a> </b> <b class="vimtag"> <a name="E801">E801</a> </b> <b class="vimtag"> <a name="E957">E957</a> </b>
matchadd(<code class="special">{group}</code>, <code class="special">{pattern}</code> [, <code class="special">{priority}</code> [, <code class="special">{id}</code> [, <code class="special">{dict}</code>]]])
                定义模式 (一个 "匹配")， 在当前窗口用高亮组 <code class="special">{group}</code> 高亮。返回
                标识号 (ID)， <a href="builtin.html#matchdelete()">matchdelete()</a>  可用该 ID 来删除匹配。该 ID 是和
                窗口绑定的。
                匹配是大小写敏感和带魔术的，但大小写敏感性和魔术性在 <code class="special">{pattern}</code>
                里可被显式关闭。不使用 <a href="options.html#'magic'">'magic'</a>、<a href="options.html#'smartcase'">'smartcase'</a> 和
                <a href="options.html#'ignorecase'">'ignorecase'</a> 选项。
                "Conceal" 值是特别的，它使匹配被隐藏。

                可选的 <code class="special">{priority}</code> 参数指定匹配的优先级。高优先级的匹配的高亮会
                否决低优先级匹配的高亮。优先级用整数指定 (负整数也无不可)。如
                果未指定 <code class="special">{priority}</code> 参数，缺省优先级为 10。<a href="options.html#'hlsearch'">'hlsearch'</a> 的优先级
                为零，这样所有正优先级的匹配都可以否决它。语法高亮 (见
                <a href="options.html#'syntax'">'syntax'</a>) 采用不同的机制，无论选择的优先级如何，匹配总会否决语
                法的高亮。

                可选的 <code class="special">{id}</code> 参数请求特定的匹配 ID。如果指定的 ID 已用，报错，
                并不加入该匹配。ID 用正整数指定 (不含零)。ID 1、2 和 3 分别为
                 <a href="pattern.html#:match">:match</a> 、 <a href="pattern.html#:2match">:2match</a>  和  <a href="pattern.html#:3match">:3match</a>  命令保留。3 是为  <a href="pi_paren.html#matchparen">matchparen</a> 
                插件保留的。

                如果 <code class="special">{id}</code> 未指定或为 -1， <a href="builtin.html#matchadd()">matchadd()</a>  自动选择一个可用的 ID，
                至少为 1000。

                可选的 <code class="special">{dict}</code> 参数允许更多定制。目前，可用来指定特定于匹配的隐
                藏字符，使用  <a href="syntax.html#hl-Conceal">hl-Conceal</a>  高亮匹配来显示。该字典有以下成员:

                        conceal     显示的特殊字符，而非匹配 (只用于
                                     <a href="syntax.html#hl-Conceal">hl-Conceal</a>  高亮匹配，见  <a href="syntax.html#:syn-cchar">:syn-cchar</a> )
                        window      不使用当前窗口，而使用指定窗口号或窗口 ID
                                    的其它窗口。

                匹配的数目不限， <a href="pattern.html#:match">:match</a>  诸命令则有此局限。

                出错时返回 -1。

                示例: 
<code class="example">                        :highlight MyGroup ctermbg=green guibg=green</code>
<code class="example">                        :let m = matchadd("MyGroup", "TODO")</code>
                要删除该模式: 
<code class="example">                        :call matchdelete(m)</code>
<code class="example"></code>
                用  <a href="builtin.html#getmatches()">getmatches()</a>  可以得到  <a href="builtin.html#matchadd()">matchadd()</a>  和  <a href="pattern.html#:match">:match</a>  定义的匹配
                列表。 <a href="builtin.html#clearmatches()">clearmatches()</a>  可一次删除所有的匹配。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetGroup()-&gt;matchadd('TODO')</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


                                                        <b class="vimtag"> <a name="matchaddpos()">matchaddpos()</a> </b>
matchaddpos(<code class="special">{group}</code>, <code class="special">{pos}</code> [, <code class="special">{priority}</code> [, <code class="special">{id}</code> [, <code class="special">{dict}</code>]]])
                和  <a href="builtin.html#matchadd()">matchadd()</a>  相同，但需要位置列表 <code class="special">{pos}</code> 而非匹配模式。比
                 <a href="builtin.html#matchadd()">matchadd()</a>  更快，因为无需处理正则表达式并设置缓冲区行边界以
                重画屏幕。主要用于需要快速增加或删除匹配的场合，如匹配括号的高
                亮。

                <code class="special">{pos}</code> 是位置的列表。每个位置为以下之一:
                - 数值。该行整行被高亮。首行的行号为 1。
                - 单个数值的列表。如 <code class="special">[23]</code>。该行整行被高亮。
                - 包含两个数值的列表，如 [23, 11]。前面的数是行号，后面的是列
                  号 (首列为 1，必须对应  <a href="builtin.html#col()">col()</a>  返回的字节索引)。此位置的字符
                  被高亮。
                - 包含三个数值的列表，如 [23, 11, 3]。同上，但第三个数给出高亮
                  字节计的长度。

                出错时返回 -1。

                示例: 
<code class="example">                        :highlight MyGroup ctermbg=green guibg=green</code>
<code class="example">                        :let m = matchaddpos("MyGroup", [[23, 24], 34])</code>
                模式的删除: 
<code class="example">                        :call matchdelete(m)</code>
<code class="example"></code>
                 <a href="builtin.html#getmatches()">getmatches()</a>  返回  <a href="builtin.html#matchaddpos()">matchaddpos()</a>  加入的匹配。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetGroup()-&gt;matchaddpos([23, 11])</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


matcharg(<code class="special">{nr}</code>)                                          <b class="vimtag"> <a name="matcharg()">matcharg()</a> </b>
                选择 <code class="special">{nr}</code> 号匹配的项目，它们分别用  <a href="pattern.html#:match">:match</a> 、 <a href="pattern.html#:2match">:2match</a>  或
                 <a href="pattern.html#:3match">:3match</a>  命令设置。
                返回两个项目的  <a href="eval.html#List">List</a> :
                        使用的高亮组名
                        使用的模式。
                如果 <code class="special">{nr}</code> 不是 1、2 或 3，返回空  <a href="eval.html#List">List</a> 。
                如果没有匹配的项目，返回 ['', '']。
                这用来保存和恢复  <a href="pattern.html#:match">:match</a> 。
                用  <a href="pattern.html#:match">:match</a>  命令高亮的匹配限于三个。 <a href="builtin.html#matchadd()">matchadd()</a>  无此限制。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMatch()-&gt;matcharg()</code>

                返回类型: list<code class="special">&lt;string&gt;</code>


matchbufline(<code class="special">{buf}</code>, <code class="special">{pat}</code>, <code class="special">{lnum}</code>, <code class="special">{end}</code>, [, <code class="special">{dict}</code>])   <b class="vimtag"> <a name="matchbufline()">matchbufline()</a> </b>
                返回缓冲区 <code class="special">{buf}</code> 从 <code class="special">{lnum}</code> 到 <code class="special">{end}</code> 行上模式 <code class="special">{pat}</code> 的所有匹配
                组成的  <a href="eval.html#List">List</a> 。

                <code class="special">{lnum}</code> 和 <code class="special">{end}</code> 可以是行号或者代表 <code class="special">{buf}</code> 末行的 "$"。

                <code class="special">{dict}</code> 参数支持以下项目:
                    submatches  包含子表达式信息 ( <a href="pattern.html#%2F\(">/\(</a> )

                对每个匹配，返回以下项目的  <a href="eval.html#Dict">Dict</a> :
                    byteidx     匹配的开始字节索引
                    lnum        匹配所在的行号
                    text        匹配内容字符串
                <code class="note">注意</code> 一行上可能有多处匹配。

                此函数只适用于已载入的缓冲区。有必要的话先调用  <a href="builtin.html#bufload()">bufload()</a> 。

                 <a href="builtin.html#match-pattern">match-pattern</a>  说明模式相关选项设定的效果。

                <code class="special">{buf}</code> 不是合法缓冲区、缓冲区未载入以及 <code class="special">{lnum}</code> 或 <code class="special">{end}</code> 不合法
                时，报错并返回空  <a href="eval.html#List">List</a> 。

                示例: 
<code class="example">                    " 假定缓冲区 5 第 3 行包含了 "a"</code>
<code class="example">                    :echo matchbufline(5, '\&lt;\k\+\&gt;', 3, 3)</code>
<code class="example">                    [{'lnum': 3, 'byteidx': 0, 'text': 'a'}]</code>
<code class="example">                    " 假定缓冲区 10 第 4 行包含了 "tik tok"</code>
<code class="example">                    :echo matchbufline(10, '\&lt;\k\+\&gt;', 1, 4)</code>
<code class="example">                    [{'lnum': 4, 'byteidx': 0, 'text': 'tik'},</code>
<code class="example">                     {'lnum': 4, 'byteidx': 4, 'text': 'tok'}]</code>

                如果给出 <code class="special">{submatch}</code> 且为 v:true，同时返回 "\1"、"\2" 等的子表
                达式。例如: 
<code class="example">                    " 假定缓冲区 2 第 2 行包含了 "acd"</code>
<code class="example">                    :echo matchbufline(2, '\(a\)\?\(b\)\?\(c\)\?\(.*\)', 2, 2</code>
<code class="example">                                                \ {'submatches': v:true})</code>
<code class="example">                    [{'lnum': 2, 'byteidx': 0, 'text': 'acd', 'submatches':</code>
<code class="example">                    ['a', '', 'c', 'd', '', '', '', '', '']}]</code>
                "submatches" 列表永远包含 9 个项目。如果没找到某子表达式，对应
                位置返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;matchbufline('mypat', 1, '$')</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt; 或 list<code class="special">&lt;any&gt;</code>


matchdelete(<code class="special">{id}</code> [, <code class="special">{win}</code>)                              <b class="vimtag"> <a name="matchdelete()">matchdelete()</a> </b> <b class="vimtag"> <a name="E802">E802</a> </b> <b class="vimtag"> <a name="E803">E803</a> </b>
                删除之前用  <a href="builtin.html#matchadd()">matchadd()</a>  或  <a href="pattern.html#:match">:match</a>  诸命令定义的 ID 为 <code class="special">{id}</code> 的
                匹配。如果成功，返回 0，不然返回 -1。示例见  <a href="builtin.html#matchadd()">matchadd()</a> 。
                 <a href="builtin.html#clearmatches()">clearmatches()</a>  可一次删除所有的匹配。
                如果指定 <code class="special">{win}</code>，使用指定窗口号或窗口 ID 的窗口而不是当前窗口。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMatch()-&gt;matchdelete()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


matchend(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])         <b class="vimtag"> <a name="matchend()">matchend()</a> </b>
                和  <a href="builtin.html#match()">match()</a>  相同，但返回匹配之后的第一个字符的位置。比如: 
<code class="example">                        :echo matchend("testing", "ing")</code>
                返回 "7"。
                                                        <b class="vimtag"> <a name="strspn()">strspn()</a> </b> <b class="vimtag"> <a name="strcspn()">strcspn()</a> </b>
                Vim 没有 strspn() 或 strcspn() 函数，但可用 matchend() 实现: 
<code class="example">                        :let span = matchend(line, '[a-zA-Z]')</code>
<code class="example">                        :let span = matchend(line, '[^a-zA-Z]')</code>
                不过没有匹配时，它返回 -1。

                如果给出 <code class="special">{start}</code>，和  <a href="builtin.html#match()">match()</a>  里的用法相同。 
<code class="example">                        :echo matchend("testing", "ing", 2)</code>
                返回 "7"。 
<code class="example">                        :echo matchend("testing", "ing", 5)</code>
                返回 "-1"。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，结果和  <a href="builtin.html#match()">match()</a>  相同。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;matchend('word')</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


matchfuzzy(<code class="special">{list}</code>, <code class="special">{str}</code> [, <code class="special">{dict}</code>])                    <b class="vimtag"> <a name="matchfuzzy()">matchfuzzy()</a> </b>
                如果 <code class="special">{list}</code> 为字符串列表，返回  <a href="eval.html#List">List</a> ，包含 <code class="special">{list}</code> 中的所有模
                糊匹配 <code class="special">{str}</code> 的字符串。返回列表中的字符串依匹配分数排序。

                可选的 <code class="special">{dict}</code> 参数总是支持以下项目:
                    matchseq    如果此项目存在，只返回按照 <code class="special">{str}</code> 里字符的出现
                                顺序的匹配。
                    limit       <code class="special">{list}</code> 里返回的最大匹配数。零代表没有限制。

                如果 <code class="special">{list}</code> 为字典列表，则可选的 <code class="special">{dict}</code> 参数还支持以下项目:
                    key         用于模糊匹配 <code class="special">{str}</code> 项目的键。该项目值必须为字
                                符串。
                    text_cb     对 <code class="special">{list}</code> 中每个项目都会调用的  <a href="eval.html#Funcref">Funcref</a> ，用于
                                获取模糊匹配的文本。此函数应接受字典项目作为参
                                数，并返回该项目用于模糊匹配的文本。

                <code class="special">{str}</code> 视作字符串常数， <code class="emphasis">不</code> 支持正则表达式匹配。<code class="special">{str}</code> 支持的最大
                长度为 256。

                如果 <code class="special">{str}</code> 包含空白分隔的多个单词，返回包含所有这些单词的字符
                串的列表。

                如果没有匹配的字符串或有错误，返回空列表。如果 <code class="special">{str}</code> 的长度大
                于 256，也返回空列表。

                如果给出 <code class="special">{limit}</code>，matchfuzzy() 会找到 <code class="special">{list}</code> 里最多那么多的匹
                配，排序后返回。

                参考  <a href="pattern.html#fuzzy-matching">fuzzy-matching</a>  关于模式匹配的详细说明。

                示例: 
<code class="example">                   :echo matchfuzzy(["clay", "crow"], "cay")</code>
                返回 ["clay"]. 
<code class="example">                   :echo getbufinfo()-&gt;map({_, v -&gt; v.name})-&gt;matchfuzzy("ndl")</code>
                返回模糊匹配 "ndl" 的缓冲区名的列表。 
<code class="example">                   :echo getbufinfo()-&gt;matchfuzzy("ndl", {'key' : 'name'})</code>
                返回模糊匹配 "ndl" 的缓冲区信息字典的列表。 
<code class="example">                   :echo getbufinfo()-&gt;matchfuzzy("spl",</code>
<code class="example">                                                \ {'text_cb' : {v -&gt; v.name}})</code>
                返回模糊匹配 "spl" 的缓冲区信息字典的列表。 
<code class="example">                   :echo v:oldfiles-&gt;matchfuzzy("test")</code>
                返回模糊匹配 "test" 的文件名的列表。 
<code class="example">                   :let l = readfile("buffer.c")-&gt;matchfuzzy("str")</code>
                返回 "buffer.c" 文件中模糊匹配 "str" 的行的列表。 
<code class="example">                   :echo ['one two', 'two one']-&gt;matchfuzzy('two one')</code>
                返回 ['two one', 'one two']。 
<code class="example">                   :echo ['one two', 'two one']-&gt;matchfuzzy('two one',</code>
<code class="example">                                                \ {'matchseq': 1})</code>
                返回 ['two one']。

                返回类型: list<code class="special">&lt;string&gt;</code> 或 list<code class="special">&lt;any&gt;</code>


matchfuzzypos(<code class="special">{list}</code>, <code class="special">{str}</code> [, <code class="special">{dict}</code>])                 <b class="vimtag"> <a name="matchfuzzypos()">matchfuzzypos()</a> </b>
                和  <a href="builtin.html#matchfuzzy()">matchfuzzy()</a>  相同，但返回列表，包含匹配字符串的列表、匹配
                <code class="special">{str}</code> 中的字符的字符位置的列表、和匹配分数的列表。可用
                 <a href="builtin.html#byteidx()">byteidx()</a>  把字符位置转为字节位置。

                如果 <code class="special">{str}</code> 在字符串中有多个匹配，只返回最佳匹配的位置。

                如果没有匹配的字符串或有错，返回包含三个空列表项目的列表。

                示例: 
<code class="example">                        :echo matchfuzzypos(['testing'], 'tsg')</code>
                返回 [[<code class="badlink">'testing'</code>], [[0, 2, 6]], <code class="special">[99]</code>] 
<code class="example">                        :echo matchfuzzypos(['clay', 'lacy'], 'la')</code>
                返回 [[<code class="badlink">'lacy'</code>, <code class="badlink">'clay'</code>], [[0, 1], [1, 2]], [153, 133]] 
<code class="example">                        :echo [{'text': 'hello', 'id' : 10}]</code>
<code class="example">                          \ -&gt;matchfuzzypos('ll', {'key' : 'text'})</code>
                返回 [[{<code class="badlink">'id'</code>: 10, <code class="badlink">'text'</code>: <code class="badlink">'hello'</code>}], [[2, 3]], <code class="special">[127]</code>]

                返回类型: list&lt;list<code class="special">&lt;any&gt;</code>&gt;


matchlist(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])        <b class="vimtag"> <a name="matchlist()">matchlist()</a> </b>
                和  <a href="builtin.html#match()">match()</a>  相同，但返回  <a href="eval.html#List">List</a> 。列表第一项是匹配的字符串，和
                 <a href="builtin.html#matchstr()">matchstr()</a>  返回值相同。其后的项目是子匹配，类似
                 <a href="change.html#:substitute">:substitute</a>  的 "\1"、"\2" 等。如果某个可选的子匹配不匹配，用
                空字符串代替。例如: 
<code class="example">                        echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')</code>
                返回: [<a href="options.html#'acd'">'acd'</a>, 'a', '', 'c', 'd', '', '', '', '', '']
                如果没有匹配，返回空列表。

                可以接受列表，但没什么用处。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;matchlist('word')</code>

                返回类型: list<code class="special">&lt;string&gt;</code> 或 list<code class="special">&lt;any&gt;</code>


matchstrlist(<code class="special">{list}</code>, <code class="special">{pat}</code> [, <code class="special">{dict}</code>])                  <b class="vimtag"> <a name="matchstrlist()">matchstrlist()</a> </b>
                返回 <code class="special">{list}</code> 里模式 <code class="special">{pat}</code> 的所有匹配组成的  <a href="eval.html#List">List</a> 。
                <code class="special">{list}</code> 是字符串  <a href="eval.html#List">List</a> 。<code class="special">{pat}</code> 用来匹配 <code class="special">{list}</code> 里的每个字符串。

                <code class="special">{dict}</code> 参数支持以下项目:
                    submatches  包含子表达式信息 ( <a href="pattern.html#%2F\(">/\(</a> )

                对每个匹配，返回以下项目的  <a href="eval.html#Dict">Dict</a> :
                    byteidx     匹配的开始字节索引。
                    lnum        匹配所在的 <code class="special">{list}</code> 索引。
                    text        匹配内容字符串
                    submatches  子表达式列表。仅当 <code class="special">{dict}</code> 里的 "submatches" 设
                                为 v:true 时才存在。

                 <a href="builtin.html#match-pattern">match-pattern</a>  说明模式相关选项设定的效果。

                示例: 
<code class="example">                    :echo matchstrlist(['tik tok'], '\&lt;\k\+\&gt;')</code>
<code class="example">                    [{'idx': 0, 'byteidx': 0, 'text': 'tik'},</code>
<code class="example">                     {'idx': 0, 'byteidx': 4, 'text': 'tok'}]</code>
<code class="example">                    :echo matchstrlist(['a', 'b'], '\&lt;\k\+\&gt;')</code>
<code class="example">                    [{'idx': 0, 'byteidx': 0, 'text': 'a'},</code>
<code class="example">                     {'idx': 1, 'byteidx': 0, 'text': 'b'}]</code>

                如果给出 <code class="special">{submatch}</code> 且为 v:true，同时返回 "\1"、"\2" 等的子表
                达式。例如: 
<code class="example">                    :echo matchstrlist(['acd'], '\(a\)\?\(b\)\?\(c\)\?\(.*\)',</code>
<code class="example">                                                \ #{submatches: v:true})</code>
<code class="example">                    [{'idx': 0, 'byteidx': 0, 'text': 'acd',</code>
<code class="example">                      'submatches': ['a', '', 'c', 'd', '', '', '', '', '']}]</code>
                "submatches" 列表永远包含 9 个项目。如果没找到某子表达式，对应
                位置返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetListOfStrings()-&gt;matchstrlist('mypat')</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt; 或 list<code class="special">&lt;any&gt;</code>


matchstr(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])         <b class="vimtag"> <a name="matchstr()">matchstr()</a> </b>
                和  <a href="builtin.html#match()">match()</a>  相同，但返回匹配的字符串。例如: 
<code class="example">                        :echo matchstr("testing", "ing")</code>
                返回 "ing"。
                如果没有匹配，返回 ""。
                如果给出 <code class="special">{start}</code>，它和  <a href="builtin.html#match()">match()</a>  里的用法相同。 
<code class="example">                        :echo matchstr("testing", "ing", 2)</code>
                返回 "ing"。 
<code class="example">                        :echo matchstr("testing", "ing", 5)</code>
                返回 ""。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，返回匹配的项目。其类型不改变，因而不一
                定是字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;matchstr('word')</code>

                返回类型:  <a href="eval.html#String">String</a> 


matchstrpos(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])      <b class="vimtag"> <a name="matchstrpos()">matchstrpos()</a> </b>
                和  <a href="builtin.html#matchstr()">matchstr()</a>  相同，但返回匹配的字符串和匹配的始末位置。例
                如: 
<code class="example">                        :echo matchstrpos("testing", "ing")</code>
                返回 ["ing", 4, 7]。
                如果没有匹配，返回 ["", -1, -1]。
                如果给出 <code class="special">{start}</code>，它和  <a href="builtin.html#match()">match()</a>  里的用法相同。 
<code class="example">                        :echo matchstrpos("testing", "ing", 2)</code>
                返回 ["ing", 4, 7]。 
<code class="example">                        :echo matchstrpos("testing", "ing", 5)</code>
                返回 ["", -1, -1]。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，返回匹配项目，<code class="special">{pat}</code> 匹配的首个项目的索
                引，匹配的开始位置和结束位置。 
<code class="example">                        :echo matchstrpos([1, '__x'], '\a')</code>
                返回 ["x", 1, 2, 3]。
                不改变类型，不必然是字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;matchstrpos('word')</code>

                返回类型: list<code class="special">&lt;any&gt;</code>


max(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="max()">max()</a> </b>
                返回 <code class="special">{expr}</code> 所有项目的最大值。例如: 
<code class="example">                        echo max([apples, pears, oranges])</code>
<code class="example"></code>
                <code class="special">{expr}</code> 可以是  <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。如果是字典，返
                回字典中所有值的最大值。如果 <code class="special">{expr}</code> 不是列表、元组或字典，或者
                其中某个项目不能用作数值，出错。空  <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a>  或
                 <a href="eval.html#Dictionary">Dictionary</a>  返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;max()</code>

                返回类型: any，取决于 <code class="special">{expr}</code>


menu_info(<code class="special">{name}</code> [, <code class="special">{mode}</code>])                            <b class="vimtag"> <a name="menu_info()">menu_info()</a> </b>
                返回指定模式 <code class="special">{mode}</code> 下的菜单 <code class="special">{name}</code> 的信息。须指定不带快捷字符
                ('&amp;') 的菜单名。<code class="special">{name}</code> 为 "" 时，返回顶层菜单名。

                <code class="special">{mode}</code> 可为下列字符串之一:
                        "n"     普通
                        "v"     可视 (包括选择)
                        "o"     操作符等待
                        "i"     插入
                        "c"     命令行
                        "s"     选择
                        "x"     可视
                        "t"     终端作业
                        ""      普通、可视和操作符等待
                        "!"     插入和命令行
                <code class="special">{mode}</code> 省略时使用 "" 作为模式。

                返回包含以下项的  <a href="eval.html#Dictionary">Dictionary</a> :
                  accel         菜单项目加速文本  <a href="gui.html#menu-text">menu-text</a> 
                  display       显示名 (不带 '&amp;' 的名字)
                  enabled       如果此菜单项目打开，返回 v:true
                                参考  <a href="gui.html#:menu-enable">:menu-enable</a> 
                  icon          图标文件名 (用于工具栏)  <a href="gui.html#toolbar-icon">toolbar-icon</a> 
                  iconidx       内建图标的索引
                  modes         菜单为之定义的模式。除了上述模式以外，还使用以
                                下字符:
                                " "     普通、可视和操作符等待
                  name          菜单项目名。
                  noremenu      如果菜单项目的 <code class="special">{rhs}</code> 不可重映射返回 v:true，否
                                则返回 v:false。
                  priority      菜单顺序优先级  <a href="gui.html#menu-priority">menu-priority</a> 
                  rhs           菜单项目的右手边。返回字符串中的特殊字符以
                                ":menu" 命令列表输出的同样的方式进行翻译。如果
                                菜单的 <code class="special">{rhs}</code> 为空，返回 "<code class="special">&lt;Nop&gt;</code>"。
                  script        如果 <code class="special">{rhs}</code> 允许局部于脚本的重映射，返回
                                v:true，否则返回 v:false。见  <a href="gui.html#:menu-script">:menu-script</a> 。
                  shortcut      快捷键 (菜单名中 '&amp;' 之后的字符)
                                 <a href="gui.html#menu-shortcut">menu-shortcut</a> 
                  silent        菜单项目创建时如带 <code class="special">&lt;silent&gt;</code> 参数，返回 v:true
                                 <a href="gui.html#:menu-silent">:menu-silent</a> 
                  submenus      包含返回子菜单名的  <a href="eval.html#List">List</a> 。仅当菜单项目有子菜
                                单时才存在。

                如果菜单项目找不到，返回空字典。

                示例: 
<code class="example">                        :echo menu_info('Edit.Cut')</code>
<code class="example">                        :echo menu_info('File.Save', 'n')</code>
<code class="example"></code>
<code class="example">                        " 显示缓冲区里的整个菜单树</code>
<code class="example">                        func ShowMenu(name, pfx)</code>
<code class="example">                          let m = menu_info(a:name)</code>
<code class="example">                          call append(line('$'), a:pfx .. m.display)</code>
<code class="example">                          for child in m-&gt;get('submenus', [])</code>
<code class="example">                            call ShowMenu(a:name .. '.' .. escape(child, '.'),</code>
<code class="example">                                                        \ a:pfx .. '    ')</code>
<code class="example">                          endfor</code>
<code class="example">                        endfunc</code>
<code class="example">                        new</code>
<code class="example">                        for topmenu in menu_info('').submenus</code>
<code class="example">                          call ShowMenu(topmenu, '')</code>
<code class="example">                        endfor</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMenuName()-&gt;menu_info('v')</code>

                返回类型: dict<code class="special">&lt;any&gt;</code>


min(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="min()">min()</a> </b>
                返回 <code class="special">{expr}</code> 所有项目的最小值。例如: 
<code class="example">                        echo min([apples, pears, oranges])</code>
<code class="example"></code>
                <code class="special">{expr}</code> 可以是  <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。如果是字典，返
                回字典中所有值的最小值。如果 <code class="special">{expr}</code> 不是列表、元组或字典，或者
                其中某个项目不能用作数值，出错。空  <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a>  或
                 <a href="eval.html#Dictionary">Dictionary</a>  返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;min()</code>

                返回类型: any，取决于 <code class="special">{expr}</code>


mkdir(<code class="special">{name}</code> [, <code class="special">{flags}</code> [, <code class="special">{prot}</code>]])                    <b class="vimtag"> <a name="mkdir()">mkdir()</a> </b> <b class="vimtag"> <a name="E739">E739</a> </b>
                建立目录 <code class="special">{name}</code>。

                <code class="special">{flags}</code> 给出时，必须为字符串。空串无效果。

                <code class="special">{flags}</code> 包含以下字符标志位:
                 "p"    必要时建立中间目录
                 "D"    当前函数结束时删除 <code class="special">{name}</code>，但不会递归删除  <a href="userfunc.html#:defer">:defer</a> 
                 "R"    当前函数结束时递归删除 <code class="special">{name}</code>  <a href="userfunc.html#:defer">:defer</a> 

                <code class="note">注意</code> <code class="special">{name}</code> 多于一个目录部分且使用 "p" 时，有些目录可能已经存
                在。此时只有真正创建的那层目录和其包含的部分会被调度删除。
                如用: 
<code class="example">                        call mkdir('subdir/tmp/autoload', 'pR')</code>
                而 "subdir" 已存在时，那么调度删除的会是 "subdir/tmp"，相当
                于: 
<code class="example">                        defer delete('subdir/tmp', 'rf')</code>
                <code class="note">注意</code> 如果延迟调度失败，目录不会删除。应该只有内存溢出时才会出
                现这种情况。

                如果给出 <code class="special">{prot}</code>，它用于设置新目录的权限。缺省为 0o755
                (rwxr-xr-x: 用户自己可读写，其它人可读)。用 0o700 使其它人不可
                读。这只用于新创建的那些目录。<code class="note">注意</code>: umask 适用于 <code class="special">{prot}</code> (Unix
                上)。
                示例: 
<code class="example">                        :call mkdir($HOME .. "/tmp/foo/bar", "p", 0o700)</code>
<code class="example"></code>
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                如果目录已存在且传递了 "p" 标志位，不报错 (从补丁 8.0.1708
                起)。如果没有 "p" 位就会失败。

                此函数返回数值，如果调用成功则为 TRUE，如果目录创建失败或部分
                失败则为 FALSE。

                不一定在所有系统上都可用。要检查这一点，使用: 
<code class="example">                        :if exists("*mkdir")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;mkdir()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


mode([<code class="special">{expr}</code>])                                          <b class="vimtag"> <a name="mode()">mode()</a> </b>
                返回指示当前模式的字符串。
                如果指定 <code class="special">{expr}</code> 并且其值为非零的数值或非空的字符串
                ( <a href="eval.html#non-zero-arg">non-zero-arg</a> )，返回完整模式，不然，返回第一个字母。
                另见  <a href="builtin.html#state()">state()</a> 。

                   n        普通模式
                   no       操作符等待模式
                   nov      操作符等待模式 (强制面向字符  <a href="motion.html#o_v">o_v</a> )
                   noV      操作符等待模式 (强制面向行  <a href="motion.html#o_V">o_V</a> )
                   no<code class="keystroke">CTRL-v</code> 操作符等待模式 (强制面向列块  <a href="motion.html#o_CTRL-V">o_CTRL-V</a> )；
                                <code class="keystroke">CTRL-V</code> 是单个字符
                   niI       <a href="insert.html#Insert-mode">Insert-mode</a>  用  <a href="insert.html#i_CTRL-O">i_CTRL-O</a>  进入的普通模式
                   niR       <a href="insert.html#Replace-mode">Replace-mode</a>  用  <a href="insert.html#i_CTRL-O">i_CTRL-O</a>  进入的普通模式
                   niV       <a href="insert.html#Virtual-Replace-mode">Virtual-Replace-mode</a>  用  <a href="insert.html#i_CTRL-O">i_CTRL-O</a>  进入的普通模
                            式
                   nt       终端-普通 (插入会转到终端-作业模式)
                   v        面向字符的可视模式
                   vs       选择模式用  <a href="visual.html#v_CTRL-O">v_CTRL-O</a>  进入的面向字符的可视模式
                   V        面向行的可视模式
                   Vs       选择模式用  <a href="visual.html#v_CTRL-O">v_CTRL-O</a>  进入的面向行的可视模式
                   <code class="keystroke">CTRL-V</code>   面向列块的可视模式
                   <code class="keystroke">CTRL-Vs</code>  选择模式用  <a href="visual.html#v_CTRL-O">v_CTRL-O</a>  进入的面向列块的可视模式
                   s        面向字符的选择模式
                   S        面向行的选择模式
                   <code class="keystroke">CTRL-S</code>   面向列块的选择模式
                   i        插入模式
                   ic       插入模式补全  <a href="insert.html#compl-generic">compl-generic</a> 
                   ix       插入模式  <a href="insert.html#i_CTRL-X">i_CTRL-X</a>  补全
                   R        替换模式  <a href="change.html#R">R</a> 
                   Rc       替换模式补全  <a href="insert.html#compl-generic">compl-generic</a> 
                   Rx       替换模式  <a href="insert.html#i_CTRL-X">i_CTRL-X</a>  补全
                   Rv       虚拟替换模式  <a href="change.html#gR">gR</a> 
                   Rvc      虚拟替换模式补全  <a href="insert.html#compl-generic">compl-generic</a> 
                   Rvx      虚拟替换模式  <a href="insert.html#i_CTRL-X">i_CTRL-X</a>  补全
                   Rvc      虚拟替换模式补全  <a href="change.html#gR">gR</a> 
                   Rvx      虚拟替换模式  <a href="change.html#gR">gR</a> 
                   c        命令行编辑模式
                   ct       终端-作业模式下的命令行编辑
                   cr       命令行编辑替换模式  <a href="cmdline.html#c_%3CInsert%3E">c_&lt;Insert&gt;</a> 
                   cv       Vim Ex 模式  <a href="intro.html#gQ">gQ</a> 
                   cvr      Vim Ex 替换模式  <a href="cmdline.html#c_%3CInsert%3E">c_&lt;Insert&gt;</a> 
                   ce       普通 Ex 模式  <a href="intro.html#Q">Q</a> 
                   r        输入回车的提示
                   rm       -- more -- 提示
                   r?        <a href="editing.html#:confirm">:confirm</a>  等等的询问
                   !        执行外壳或外部命令时
                   t        终端-作业模式: 键入传给作业

                可用于 <a href="options.html#'statusline'">'statusline'</a> 选项或  <a href="builtin.html#remote_expr()">remote_expr()</a> 。在其它的多数地方，
                它总是返回 "c" 或 "n"。
                <code class="note">注意</code>将来可能会加入更多模式和更多特定模式。最好不要比较整个字符
                串而只比较开头的字符 (一或多个)。
                另见  <a href="builtin.html#visualmode()">visualmode()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        DoFull()-&gt;mode()</code>

                返回类型:  <a href="eval.html#String">String</a> 


mzeval(<code class="special">{expr}</code>)                                          <b class="vimtag"> <a name="mzeval()">mzeval()</a> </b>
                计算 MzScheme 表达式 <code class="special">{expr}</code> 并返回计算结果，转换为 Vim 本身的
                数据结构。
                数值和字符串返回本身。
                组对 (pair) (包含列表 (list) 和非常规列表 (improper list)) 和
                向量 (vector) 以 Vim  <a href="eval.html#List">List</a>  形式返回。
                哈希表 (hash table) 以 Vim  <a href="eval.html#Dictionary">Dictionary</a>  形式返回，其键转换成字
                符串。
                所有其它类型依 display 函数调用的结果转换为字符串。
                示例: 
<code class="example">                    :mz (define l (list 1 2 3))</code>
<code class="example">                    :mz (define h (make-hash)) (hash-set! h "list" l)</code>
<code class="example">                    :echo mzeval("l")</code>
<code class="example">                    :echo mzeval("h")</code>

                <code class="note">注意</code>  <a href="vim9.html#:def">:def</a>  函数里的局部变量对 <code class="special">{expr}</code> 不可见。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;mzeval()</code>

                返回类型: any，取决于 <code class="special">{expr}</code>

                <code class="notvi">{仅当编译时带  <a href="various.html#+mzscheme">+mzscheme</a>  特性才有效}</code>

nextnonblank(<code class="special">{lnum}</code>)                                    <b class="vimtag"> <a name="nextnonblank()">nextnonblank()</a> </b>
                返回第一个从 <code class="special">{lnum}</code> 开始的非空白行的行号。例如: 
<code class="example">                        if getline(nextnonblank(1)) =~ "Java"</code>
                <code class="special">{lnum}</code> 非法或者在从该行开始都没有非空白行时，返回零。
                <code class="special">{lnum}</code> 用法类似于  <a href="builtin.html#getline()">getline()</a> 。
                另见  <a href="builtin.html#prevnonblank()">prevnonblank()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;nextnonblank()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


ngettext(<code class="special">{single}</code>, <code class="special">{plural}</code>, <code class="special">{number}</code>[, <code class="special">{domain}</code>)       <b class="vimtag"> <a name="ngettext()">ngettext()</a> </b>
                根据语言的单复数形式规则，返回包含消息正确值的字符串。例如: 
<code class="example">                        ngettext("File", "Files", 2)  # 返回 "Files"</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        1-&gt;ngettext("File", "Files")  # 返回 "File"</code>

                 <a href="builtin.html#gettext()">gettext()</a>  说明 domain 参数。

                返回类型:  <a href="eval.html#String">String</a> 


nr2char(<code class="special">{expr}</code> [, <code class="special">{utf8}</code>])                              <b class="vimtag"> <a name="nr2char()">nr2char()</a> </b>
                返回单个字符组成的字符串，该字符的数值为 <code class="special">{expr}</code>。例如: 
<code class="example">                        nr2char(64)             返回 "@"</code>
<code class="example">                        nr2char(32)             返回 " "</code>
                如果 <code class="special">{utf8}</code> 省略或为零，使用当前的 <a href="options.html#'encoding'">'encoding'</a>。比如对 "utf-8"
                来说: 
<code class="example">                        nr2char(300)            返回带有弓形的 I</code>
                如果 <code class="special">{utf8}</code> 为 TRUE，则总返回 utf-8 字符。
                <code class="note">注意</code> 文件里的 NUL 字符须用 nr2char(10) 指定。因为 Vim 用换行符
                来表示 NUL。真正的 NUL 是 nr2char(0)，而它会终结字符串，因而返
                回空串。
                要把字符值的列表转换为字符串: 
<code class="example">                    let list = [65, 66, 67]</code>
<code class="example">                    let str = join(map(list, {_, val -&gt; nr2char(val)}), '')</code>
                结果是: "ABC"

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetNumber()-&gt;nr2char()</code>

                返回类型:  <a href="eval.html#String">String</a> 


or(<code class="special">{expr}</code>, <code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="or()">or()</a> </b>
                对两个参数进行按位或。参数须转换为数值。列表、字典或浮点数参数
                会报错。
                另见  <a href="builtin.html#and()">and()</a>  和  <a href="builtin.html#xor()">xor()</a> 。
                示例: 
<code class="example">                        :let bits = or(bits, 0x80)</code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :let bits = bits-&gt;or(0x80)</code>
<code class="example"></code>
                理据: 之所以定义函数而不是像很多语言那样使用 "|" 字符，是因为
                Vi 一直以来都用 "|" 来分隔命令。在很多地方，"|" 是操作符还是命
                令分隔符是有歧义的。

                返回类型:  <a href="eval.html#Number">Number</a> 


pathshorten(<code class="special">{path}</code> [, <code class="special">{len}</code>])                           <b class="vimtag"> <a name="pathshorten()">pathshorten()</a> </b>
                缩短路径 <code class="special">{path}</code> 里的目录名，返回其结果。路径的尾部亦即文件名，
                保持不变。路径的其余部分被缩短为 <code class="special">{len}</code> 个字符。如果 <code class="special">{len}</code> 省略
                或小于 1，则假定为 1 (单个字母)。保持每个部分引导的 '~' 和 '.'
                字符不变。例如: 
<code class="example">                        :echo pathshorten('~/.vim/autoload/myfile.vim')</code>
<code class="section">                        ~/.v/a/myfile.vim </code>

<code class="example">                        :echo pathshorten('~/.vim/autoload/myfile.vim', 2)</code>
<code class="section">                        ~/.vi/au/myfile.vim </code>
                该路径实际存在与否并不相干。
                出错时返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetDirectories()-&gt;pathshorten()</code>

                返回类型:  <a href="eval.html#String">String</a> 


perleval(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="perleval()">perleval()</a> </b>
                在标量上下文计算 Perl 表达式 <code class="special">{expr}</code>，返回结果转换为 Vim 数据结
                构。如果其值不能转换，返回 Perl 表示的字符串形式。
                <code class="note">备注</code>: 如果要数组或哈希表，<code class="special">{expr}</code> 必须返回它们的引用。
                例如: 
<code class="example">                        :echo perleval('[1 .. 4]')</code>
                        [1, 2, 3, 4]

                <code class="note">注意</code>  <a href="vim9.html#:def">:def</a>  函数里的局部变量对 <code class="special">{expr}</code> 不可见。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;perleval()</code>

                返回类型: any，取决于 <code class="special">{expr}</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+perl">+perl</a>  特性才有效}</code>


popup_ 函数文档在这里:  <a href="popup.html#popup-functions">popup-functions</a> 


pow(<code class="special">{x}</code>, <code class="special">{y}</code>)                                           <b class="vimtag"> <a name="pow()">pow()</a> </b>
                返回浮点数，即 <code class="special">{x}</code> 的 <code class="special">{y}</code> 次方。
                <code class="special">{x}</code> 和 <code class="special">{y}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回
                0.0。
                示例: 
<code class="example">                        :echo pow(3, 3)</code>
                        27.0 
<code class="example">                        :echo pow(2, 16)</code>
                        65536.0 
<code class="example">                        :echo pow(32, 0.20)</code>
                        2.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;pow(3)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


preinserted()                                           <b class="vimtag"> <a name="preinserted()">preinserted()</a> </b>
                如果文本在光标后插入，返回非零值。这是因为 <a href="options.html#'completeopt'">'completeopt'</a> 里有
                "preinsert"，或 <a href="options.html#'completeopt'">'completeopt'</a> 里有 "longest" 且 <a href="options.html#'autocomplete'">'autocomplete'</a>
                已激活。否则返回零。

                返回类型:  <a href="eval.html#Number">Number</a> 


prevnonblank(<code class="special">{lnum}</code>)                                    <b class="vimtag"> <a name="prevnonblank()">prevnonblank()</a> </b>
                返回第一个 <code class="special">{lnum}</code> 所在或之上的非空白行的行号。例如: 
<code class="example">                        let ind = indent(prevnonblank(v:lnum - 1))</code>
                <code class="special">{lnum}</code> 非法或者在该行和它之前都没有非空白行时，返回零。
                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。
                另见  <a href="builtin.html#nextnonblank()">nextnonblank()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;prevnonblank()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


printf(<code class="special">{fmt}</code>, <code class="special">{expr1}</code> ...)                              <b class="vimtag"> <a name="printf()">printf()</a> </b>
                返回 <code class="special">{fmt}</code> 指定的字符串，其中每个 "%" 项目被它们对应的参数排版
                后的形式取代。例如: 
<code class="example">                        printf("%4d: E%d %.30s", lnum, errno, msg)</code>
                可能的返回结果:
<code class="section">                        "  99: E42 asdfasdfasdfasdfasdfasdfasdfas" </code>

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        Compute()-&gt;printf("result: %d")</code>

                要用列表来传递项目，可用  <a href="builtin.html#call()">call()</a> 。

                常用的项目有:
                  %s    字符串
                  %6S   右对齐到 6 个显示单元的字符串
                  %6s   右对齐到 6 个字节的字符串
                  %.9s  截短到 9 个字节的字符串
                  %c    单个字节
                  %d    十进制数
                  %5d   十进制数，用空格补足到 5 个字符
                  %x    十六进制数
                  %04x  十六进制数，用 0 补足到 4 个字符
                  %X    十六进制数，用大写字母的十六进制字母
                  %o    八进制数
                  %08b  二进制数，用 0 补足到 8 个字符
                  %f    浮点数，形如 12.23、inf、-inf 或 nan
                  %F    浮点数，形如 12.23、INF、-INF 或 NAN
                  %e    浮点数，形如 1.23e3、inf、-inf 或 nan
                  %E    浮点数，形如 1.23E3、INF、-INF 或 NAN
                  %g    浮点数，根据不同的值，使用合适的 %f 或 %e
                  %G    浮点数，根据不同的值，使用合适的 %F 或 %E
                  %%    % 字符本身

                转换规格说明以 '%' 开始，以转换类型结束。所有其它的字符按原样
                复制到结果中。

                "%" 开始转换规格说明。其后的参数依序如下:

                        % [pos-argument] <code class="special">[flags]</code> [field-width] [.precision] type

                pos-argument
                        至多一个的位置参数标识符。形式为 <code class="special">{n$}</code>，其中 n &gt;= 1。

                flags
                        零或多个下面的标志位:

                    #         转换值为 "替换形式"。对 c、d 和 s 转换，此选项无
                              效。对 o 转换，增加数值的精度，使得输出字符串的
                              第一个字符总是 0 (除非打印零值，且显式地使用精度
                              0)。
                              对 b 和 B 转换，非零值在前面加上字符串 "0b" (B
                              转换用 "0B")。
                              对 x 和 X 转换，非零值在前面加上字符串 "0x" (X
                              转换用 "0X")。

                    0 (零)    以 0 填充。对所有的转换，左侧用 0 而非空格填充。
                              如果对数值的转换给出精度 (d、b、B、o、x 和 X)，
                              忽略 0 标志位。

                    -         负域宽度标志位；转换后的值被左对齐到域边界上。该
                              值右侧用空格填充，而不是在左侧用空格或 0 填充。
                              如果两个标志位同时给出，- 否决 0。

                    ' ' (空格)  带符号转换 (d) 产生的正数左侧加上空格。

                    +         带符号转换产生的数值之前总加上符号。如果两个标志
                              位同时给出，+ 否决空格。

                field-width
                        可选的十进制数位字符串，指定最小的字段宽度。如果转换后
                        的值的字节数小于字段宽度，在左侧 (或右侧，如果给定左对
                        齐标志位的话) 用空格填充到字段宽度。S 转换以显示单元计
                        数。

                .precision
                        可选的精度，形式为句号 '.' 后跟一个可选的数位字符串。
                        如果省略了数位字符串，假设精度为零。
                        它给出 d、o、x 和 X 转换显示的最小数位数量，或 s 转换
                        显示的字符串的字节的最大数量，或 S 转换显示的字符串的
                        显示单元的最大数量。
                        对浮点数而言，指定小数点后的数位个数。

                type
                        指定要进行的转换类型的单个字符，见下。

                字段宽度、精度 (两者都有亦可) 可以用星号 '*' 代替数位字符串。
                此情形下，一个数值参数指定字段宽度或精度。负的字段宽度被理解为
                带左对齐的标志位后跟一个正数字段宽度；负的精度被理解为就像不存
                在一样。例如: 
<code class="example">                        :echo printf("%d: %.*s", nr, width, line)</code>
                限制 "line" 文本的长度为 "width" 个字节。

                如果要排版的参数以位置参数标识符指定而又用 '*' 来指示用于指定
                宽度或精度的数值参数，后者也必须用 <code class="special">{n$}</code> 位置参数标识符来指定。
                见  <a href="builtin.html#printf-$">printf-$</a> 。


                转换标识符和它们的含义如下:

                                <b class="vimtag"> <a name="printf-d">printf-d</a> </b> <b class="vimtag"> <a name="printf-b">printf-b</a> </b> <b class="vimtag"> <a name="printf-B">printf-B</a> </b> <b class="vimtag"> <a name="printf-o">printf-o</a> </b>
                                <b class="vimtag"> <a name="printf-x">printf-x</a> </b> <b class="vimtag"> <a name="printf-X">printf-X</a> </b>
                dbBoxX  数值参数被转换为带符号十进制 (d)，无符号二进制 (b 和
                        B)、无符号八进制 (o) 或无符号十六进制 (x 和 X) 记法。x
                        转换用字母 "abcdef"；X 转换用 "ABCDEF" 字母。
                        如果提供了精度，它给出必须出现的数位的最少数目；如果转
                        换后的值不需要那么多数位，左侧用 0 填充。
                        任何情况下数值字段都不会被未给定或者更小的字段宽度所截
                        短；如果转换后的值宽于字段宽度，字段会扩展以容纳转换后
                        的值。
                        'h' 修饰符指示参数为 16 位。
                        'l' 修饰符指示参数为长整型，具体是 32 位还是 64 位取决
                        于你的系统。
                        'L' 修饰符指示参数为 64 位。
                        b 和 B 转换标识符不接受宽度修饰符而总假定为 64 位整型
                        参数。
                        通常这些修饰符不怎么有用。如果类型可从参数推知，修饰符
                        被忽略。

                i       d 的别名
                D       ld 的别名
                U       lu 的别名
                O       lo 的别名

                                                        <b class="vimtag"> <a name="printf-c">printf-c</a> </b>
                c       数值参数被转换为字节，写入产生的字符。

                                                        <b class="vimtag"> <a name="printf-s">printf-s</a> </b>
                s       使用字符串参数的文本。如果指定精度，使用不多于给定数目
                        的字节数。
                        如果参数不是字符串型，使用 ":echo" 相同的格式自动转换
                        到文本。
                                                        <b class="vimtag"> <a name="printf-S">printf-S</a> </b>
                S       使用字符串参数的文本。如果指定精度，使用不多于给定数目
                        的显示单元数。

                                                        <b class="vimtag"> <a name="printf-f">printf-f</a> </b> <b class="vimtag"> <a name="E807">E807</a> </b>
                f F     浮点数参数被转换为形如 123.456 的字符串。精度指定小数
                        点后面的位数。如果精度为零，则省略小数点本身。如果未指
                        定精度，缺省为 6。那个很大很大的数 (超出返回或除以零的
                        结果) 用 %f 显示 "inf" 或 "-inf" (%F 则显示 INF 或
                        -INF)。
                        "0.0 / 0.0" 用 %f 显示 "nan" (%F 显示 NAN)。
                        示例: 
<code class="example">                                echo printf("%.2f", 12.115)</code>
                                12.12
                        <code class="note">注意</code> 截断方式取决于系统库。如不确定，使用  <a href="builtin.html#round()">round()</a> 。

                                                        <b class="vimtag"> <a name="printf-e">printf-e</a> </b> <b class="vimtag"> <a name="printf-E">printf-E</a> </b>
                e E     浮点数参数被转换为形如 1.234e+03 或用 'E' 的话
                        1.234E+03 的字符串。精度指定小数点后面的位数，和 'f'
                        一样。

                                                        <b class="vimtag"> <a name="printf-g">printf-g</a> </b> <b class="vimtag"> <a name="printf-G">printf-G</a> </b>
                g G     如果浮点数参数在 0.001 (含) 和 10000000.0 (不含) 之
                        间，则其转换同 'f'，不然，'g' 同 'e' 而 'G' 同 'E'。如
                        果未指定精度，除了小数点之后的那个零以外，不显示多余的
                        零和 '+' 负号。因而，10000000.0 显示为 1.0e7。

                                                        <b class="vimtag"> <a name="printf-%">printf-%</a> </b>
                %       写入 '%'。不转换参数。这里完整的转换规格说明是 "%%"。

                如果期待数值参数，字符串参数也被接受并自动转换。
                如果期待浮点数或字符串参数，数值参数也被接受并自动转换。
                其它参数类型产生错误信息。

                                                        <b class="vimtag"> <a name="E766">E766</a> </b> <b class="vimtag"> <a name="E767">E767</a> </b>
                <code class="special">{exprN}</code> 参数的数量必须和 "%" 项目的数量完全匹配。不论参数不足
                还是过多，都会给出错误。至多可用 18 个参数。

                                                        <b class="vimtag"> <a name="printf-$">printf-$</a> </b>
                若干语言中，错误和资讯消息使用与对应的英语消息不同的单词次序会
                更可读。可用指定位置参数来完成使用不同单词次序的翻译。例如: 
<code class="example"></code>
<code class="example">                    #, c-format</code>
<code class="example">                    msgid "%s returning %s"</code>
<code class="example">                    msgstr "返回值 %2$s 来自 %1$s"</code>

                此例中，输出句子里的两个字符串参数顺序被颠倒。 
<code class="example"></code>
<code class="example">                    echo printf(</code>
<code class="example">                        "In The Netherlands, vim's creator's name is: %1$s %2$s",</code>
<code class="example">                        "Bram", "Moolenaar")</code>
                    In The Netherlands, vim's creator's name is: Bram Moolenaar 
<code class="example"></code>
<code class="example">                    echo printf(</code>
<code class="example">                        "In Belgium, vim's creator's name is: %2$s %1$s",</code>
<code class="example">                        "Bram", "Moolenaar")</code>
                    In Belgium, vim's creator's name is: Moolenaar Bram

                可用 '*' 标识符来指定宽度 (还有精度)。此时，必须给出字段宽度对
                应在参数列表中的位置。 
<code class="example"></code>
<code class="example">                    echo printf("%1$*2$.*3$d", 1, 2, 3)</code>
                    001 
<code class="example">                    echo printf("%2$*3$.*1$d", 1, 2, 3)</code>
                      2 
<code class="example">                    echo printf("%3$*1$.*2$d", 1, 2, 3)</code>
                    03 
<code class="example">                    echo printf("%1$*2$.*3$g", 1.4142, 2, 3)</code>
                    1.414

                可以通过直接值或者位置参数混合给出宽度和/或精度: 
<code class="example"></code>
<code class="example">                    echo printf("%1$4.*2$f", 1.4142135, 6)</code>
                    1.414214 
<code class="example">                    echo printf("%1$*2$.4f", 1.4142135, 6)</code>
                    1.4142 
<code class="example">                    echo printf("%1$*2$.*3$f", 1.4142135, 6, 2)</code>
                      1.41

                因为字段宽度或精度导致字符串超过 1 MiB (1024*1024 = 1048576)
                个字符时。会出现溢出错误  <a href="change.html#E1510">E1510</a> 。

                                                        <b class="vimtag"> <a name="E1500">E1500</a> </b>
                不能混合位置和非位置参数: 
<code class="example">                    echo printf("%s%1$s", "One", "Two")</code>
                    E1500: Cannot mix positional and non-positional arguments:
                    %s%1$s

                                                        <b class="vimtag"> <a name="E1501">E1501</a> </b>
                排版字符串里不能跳过位置参数: 
<code class="example">                    echo printf("%3$s%1$s", "One", "Two", "Three")</code>
                    E1501: format argument 2 unused in $-style format:
                    %3$s%1$s

                                                        <b class="vimtag"> <a name="E1502">E1502</a> </b>
                [field-width] (或 <code class="special">[precision]</code>) 参数可以重用: 
<code class="example">                    echo printf("%1$d at width %2$d is: %01$*2$d", 1, 2)</code>
                    1 at width 2 is: 01

                但不能用于不同的类型: 
<code class="example">                    echo printf("%1$d at width %2$ld is: %01$*2$d", 1, 2)</code>
                    E1502: Positional argument 2 used as field width reused as
                    different type: long int/int

                                                        <b class="vimtag"> <a name="E1503">E1503</a> </b>
                使用位置参数时，如果给出错误位置或参数，报错: 
<code class="example">                    echo printf("%1$d at width %2$d is: %01$*2$.*3$d", 1, 2)</code>
                    E1503: Positional argument 3 out of bounds: %1$d at width
                    %2$d is: %01$*2$.*3$d

                只报首个错误: 
<code class="example">                    echo printf("%01$*2$.*3$d %4$d", 1, 2)</code>
                    E1503: Positional argument 3 out of bounds: %01$*2$.*3$d
                    %4$d

                                                        <b class="vimtag"> <a name="E1504">E1504</a> </b>
                位置参数可多次使用: 
<code class="example">                    echo printf("%1$s %2$s %1$s", "One", "Two")</code>
                    One Two One

                但不能用于不同的类型: 
<code class="example">                    echo printf("%1$s %2$s %1$d", "One", "Two")</code>
                    E1504: Positional argument 1 type used inconsistently:
                    int/string

                                                        <b class="vimtag"> <a name="E1505">E1505</a> </b>
                排版字符串的若干其他排版错误会报此错: 
<code class="example">                    echo printf("%1$d at width %2$d is: %01$*2$.3$d", 1, 2)</code>
                    E1505: Invalid format specifier: %1$d at width %2$d is:
                    %01$*2$.3$d

                                                        <b class="vimtag"> <a name="E1507">E1507</a> </b>
                此内部错误指示位置格式参数的解析产生了已知错误之外的其他问题。
                请给 Vim 发送错误报告并提供当时使用的准确格式字符串和参数。

                返回类型:  <a href="eval.html#String">String</a> 


prompt_getprompt(<code class="special">{buf}</code>)                                 <b class="vimtag"> <a name="prompt_getprompt()">prompt_getprompt()</a> </b>
                返回缓冲区 <code class="special">{buf}</code> 的实际提示文本。<code class="special">{buf}</code> 可以是缓冲区名或号。
                 <a href="channel.html#prompt-buffer">prompt-buffer</a> 。

                如果缓冲区不存在或不是提示缓冲区，返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;prompt_getprompt()</code>

                返回类型:  <a href="eval.html#String">String</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>


prompt_setcallback(<code class="special">{buf}</code>, <code class="special">{expr}</code>)                       <b class="vimtag"> <a name="prompt_setcallback()">prompt_setcallback()</a> </b>
                设置缓冲区 <code class="special">{buf}</code> 的提示回调为 <code class="special">{expr}</code>。<code class="special">{expr}</code> 为空串时删除回
                调。只对 <a href="options.html#'buftype'">'buftype'</a> 为 "prompt" 的 <code class="special">{buf}</code> 有效。

                按下回车时触发本回调。此时当前缓冲区总是提示缓冲区。在回调触发
                前，会加入一行新的提示行，因此，触发该回调的提示行会是倒数第二
                行。
                如果回调要为缓冲区增加新文本，必须在最后一行之前插入，因为那是
                当前提示所在的位置，此操作可以异步进行。
                回调调用时所带的一个参数是提示行输入的文本。如果用户直接按了回
                车，这会是一个空串。
                示例: 
<code class="example">                   func s:TextEntered(text)</code>
<code class="example">                     if a:text == 'exit' || a:text == 'quit'</code>
<code class="example">                       stopinsert</code>
<code class="example">                       " 复位 'modified'，这样缓冲区才可以被关闭。</code>
<code class="example">                       " 假定没有需要保存的内容。</code>
<code class="example">                       set nomodified</code>
<code class="example">                       close</code>
<code class="example">                     else</code>
<code class="example">                       " 应用 "a:text" 的实际操作，此例只是重复一次。</code>
<code class="example">                       call append(line('$') - 1, 'Entered: "' .. a:text .. '"')</code>
<code class="example">                     endif</code>
<code class="example">                   endfunc</code>
<code class="example">                   call prompt_setcallback(bufnr(), function('s:TextEntered'))</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;prompt_setcallback(callback)</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

prompt_setinterrupt(<code class="special">{buf}</code>, <code class="special">{expr}</code>)                      <b class="vimtag"> <a name="prompt_setinterrupt()">prompt_setinterrupt()</a> </b>
                设置缓冲区 <code class="special">{buf}</code> 的回调为 <code class="special">{expr}</code>。<code class="special">{expr}</code> 为空串时删除回调。只
                对 <a href="options.html#'buftype'">'buftype'</a> 为 "prompt" 的 <code class="special">{buf}</code> 有效。

                插入模式按 <code class="keystroke">CTRL-C</code> 时触发本回调。不设置回调会使 Vim 退出插入模
                式，就和其它缓冲区一样。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;prompt_setinterrupt(callback)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

prompt_setprompt(<code class="special">{buf}</code>, <code class="special">{text}</code>)                         <b class="vimtag"> <a name="prompt_setprompt()">prompt_setprompt()</a> </b>
                设置缓冲区 <code class="special">{buf}</code> 的提示文本为 <code class="special">{text}</code>。<code class="special">{text}</code> 多数会以空格结
                尾。
                结果只对 <a href="options.html#'buftype'">'buftype'</a> 为 "prompt" 的 <code class="special">{buf}</code> 可见。示例: 
<code class="example">                        call prompt_setprompt(bufnr(), 'command: ')</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;prompt_setprompt('command: ')</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

prop_ 函数文档在这里:  <a href="textprop.html#text-prop-functions">text-prop-functions</a> 

pum_getpos()                                            <b class="vimtag"> <a name="pum_getpos()">pum_getpos()</a> </b>
                如果弹出菜单 (见  <a href="insert.html#ins-completion-menu">ins-completion-menu</a> ) 不可见，返回空
                 <a href="eval.html#Dictionary">Dictionary</a> ，不然，返回带以下键的  <a href="eval.html#Dictionary">Dictionary</a> :
                        height          可见项目数
                        width           屏幕单元格数
                        row             顶部屏幕行号 (0 为初行)
                        col             最左侧屏幕列号 (0 为初列)
                        size            项目总数
                        scrollbar       如果滚动条为可见则为  <a href="eval.html#TRUE">TRUE</a> 

                这里的值和  <a href="autocmd.html#CompleteChanged">CompleteChanged</a>  发生时  <a href="eval.html#v:event">v:event</a>  的一样。

                返回类型: dict<code class="special">&lt;any&gt;</code>


pumvisible()                                            <b class="vimtag"> <a name="pumvisible()">pumvisible()</a> </b>
                如果弹出菜单可见，返回非零，不然返回零。见
                 <a href="insert.html#ins-completion-menu">ins-completion-menu</a> 。
                可以用来避免一些会删除弹出菜单的动作。

                返回类型:  <a href="eval.html#Number">Number</a> 


py3eval(<code class="special">{expr}</code> [, <code class="special">{locals}</code>])                            <b class="vimtag"> <a name="py3eval()">py3eval()</a> </b>
                计算 Python 表达式 <code class="special">{expr}</code> 并返回计算结果，转换为 Vim 本身的数
                据结构。
                给出 <code class="special">{locals}</code> 字典时，它定义了表达式里可用的局部变量。键是变量
                名，而值是变量值。 <a href="eval.html#Dictionary">Dictionary</a> 、 <a href="eval.html#List">List</a>  和  <a href="eval.html#Tuple">Tuple</a>  的值都是引
                用，因此可通过表达式更新 (一如使用了 python-bindeval 一样)。
                数值和字符串返回本身 (字符串经过复制，Unicode 字符串还须额外用
                <a href="options.html#'encoding'">'encoding'</a> 转换)。
                列表返回 Vim  <a href="eval.html#List">List</a>  类型。
                元组返回 Vim  <a href="eval.html#Tuple">Tuple</a>  类型。
                字典返回 Vim  <a href="eval.html#Dictionary">Dictionary</a>  类型，键值转换为字符串。
                <code class="note">注意</code>  <a href="vim9.html#:def">:def</a>  函数里的局部变量对 <code class="special">{expr}</code> 不可见。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;py3eval()</code>
<code class="example">                        'b",".join(l)'-&gt;py3eval({'l': ['a', 'b', 'c']})</code>

                返回类型: any，取决于 <code class="special">{expr}</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+python3">+python3</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="E858">E858</a> </b> <b class="vimtag"> <a name="E859">E859</a> </b>
pyeval(<code class="special">{expr}</code> [, <code class="special">{locals}</code>])                             <b class="vimtag"> <a name="pyeval()">pyeval()</a> </b>
                计算 Python 表达式 <code class="special">{expr}</code> 并返回计算结果，转换为 Vim 本身的数
                据结构。
                <code class="special">{locals}</code> 见  <a href="builtin.html#py3eval()">py3eval()</a> 。
                数值和字符串返回本身 (字符串经过复制)。
                列表返回 Vim  <a href="eval.html#List">List</a>  类型。
                元组返回 Vim  <a href="eval.html#Tuple">Tuple</a>  类型。
                字典返回 Vim  <a href="eval.html#Dictionary">Dictionary</a>  类型，出现非字符串的键值报错。
                <code class="note">注意</code>  <a href="vim9.html#:def">:def</a>  函数里的局部变量对 <code class="special">{expr}</code> 不可见。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;pyeval()</code>

                返回类型: any，取决于 <code class="special">{expr}</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+python">+python</a>  特性才有效}</code>


pyxeval(<code class="special">{expr}</code> [, <code class="special">{locals}</code>])                            <b class="vimtag"> <a name="pyxeval()">pyxeval()</a> </b>
                计算 Python 表达式 <code class="special">{expr}</code> 并返回计算结果，转换为 Vim 本身的数
                据结构。
                <code class="special">{locals}</code> 见  <a href="builtin.html#py3eval()">py3eval()</a> 。
                使用 Python 2 或 3，见  <a href="if_pyth.html#python_x">python_x</a>  和 <a href="options.html#'pyxversion'">'pyxversion'</a>。
                另见:  <a href="builtin.html#pyeval()">pyeval()</a> 、 <a href="builtin.html#py3eval()">py3eval()</a> 

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;pyxeval()</code>

                返回类型: any，取决于 <code class="special">{expr}</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+python">+python</a>  或  <a href="various.html#+python3">+python3</a>  特性才有效}</code>


rand([<code class="special">{expr}</code>])                                          <b class="vimtag"> <a name="rand()">rand()</a> </b> <b class="vimtag"> <a name="random">random</a> </b>
                用 <code class="special">{expr}</code> 作为种子，返回 xoshiro128** 算法产生的伪随机数。返回
                数值是 32 位的，为了统一起见，即使是 64 位系统上也是。
                可由  <a href="builtin.html#srand()">srand()</a>  初始化 <code class="special">{expr}</code>，rand() 会进行更新。如果省略
                <code class="special">{expr}</code>，使用并更新一个内部的种子值。
                <code class="special">{expr}</code> 非法时返回 -1。

                示例: 
<code class="example">                        :echo rand()</code>
<code class="example">                        :let seed = srand()</code>
<code class="example">                        :echo rand(seed)</code>
<code class="example">                        :echo rand(seed) % 16  " 随机数 0 - 15</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                                                        <b class="vimtag"> <a name="E726">E726</a> </b> <b class="vimtag"> <a name="E727">E727</a> </b>
range(<code class="special">{expr}</code> [, <code class="special">{max}</code> [, <code class="special">{stride}</code>]])                    <b class="vimtag"> <a name="range()">range()</a> </b>
                返回数值的  <a href="eval.html#List">List</a> :
                - 如果只有指定 <code class="special">{expr}</code>: [0, 1, ..., <code class="special">{expr}</code> - 1]
                - 如果指定了 <code class="special">{max}</code>: [<code class="special">{expr}</code>, <code class="special">{expr}</code> + 1, ..., <code class="special">{max}</code>]
                - 如果指定了 <code class="special">{stride}</code>: [<code class="special">{expr}</code>, <code class="special">{expr}</code> + <code class="special">{stride}</code>, ..., <code class="special">{max}</code>]
                  (每次给 <code class="special">{expr}</code> 递增 <code class="special">{stride}</code>，但不会产生超过 <code class="special">{max}</code> 的值)。
                如果最大值比开始值小一，返回空列表。如果更小，报错。
                例如: 
<code class="example">                        range(4)                " [0, 1, 2, 3]</code>
<code class="example">                        range(2, 4)             " [2, 3, 4]</code>
<code class="example">                        range(2, 9, 3)          " [2, 5, 8]</code>
<code class="example">                        range(2, -2, -1)        " [2, 1, 0, -1, -2]</code>
<code class="example">                        range(0)                " []</code>
<code class="example">                        range(2, 0)             " 出错！</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;range()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


readblob(<code class="special">{fname}</code> [, <code class="special">{offset}</code> [, <code class="special">{size}</code>]])               <b class="vimtag"> <a name="readblob()">readblob()</a> </b>
                以二进制方式读取文件 <code class="special">{fname}</code>，并返回  <a href="eval.html#Blob">Blob</a> 。
                给出 <code class="special">{offset}</code> 时，从指定的偏移开始读取文件。如果给出的是负值，
                指定从文件尾开始计算的偏移。如要读取最后的 12 个字节: 
<code class="example">                        readblob('file.bin', -12)</code>
                给出 <code class="special">{size}</code> 时，只读取指定的长度。如要读取文件开始的 100 个字
                节: 
<code class="example">                        readblob('file.bin', 0, 100)</code>
                <code class="special">{size}</code> 为 -1 或省略时，读取从 <code class="special">{offset}</code> 开始的全部数据。
                Unix 上也可用于从字符设备读取数据，须显式指定 <code class="special">{size}</code>。仅当设备
                支持定位时，可指定 <code class="special">{offset}</code>。否则它必须为零。例如要从串行终端
                读取 10 个字节: 
<code class="example">                        readblob('/dev/ttyS0', 0, 10)</code>
                文件不能打开时报错，返回空  <a href="eval.html#Blob">Blob</a> 。
                如果偏移超过文件尾，返回空 blob。
                试图读取比实际可用更多的字节时，结果被截短。
                另见  <a href="builtin.html#readfile()">readfile()</a>  和  <a href="builtin.html#writefile()">writefile()</a> 。

                返回类型:  <a href="eval.html#Blob">Blob</a> 


readdir(<code class="special">{directory}</code> [, <code class="special">{expr}</code> [, <code class="special">{dict}</code>]])              <b class="vimtag"> <a name="readdir()">readdir()</a> </b>
                返回 <code class="special">{directory}</code> 中的文件和目录名的列表。如果不需要复杂的处
                理，如限制匹配的数目等等，也可用  <a href="builtin.html#glob()">glob()</a> 。
                列表经过排序 (大小写敏感)，要改变排序顺序，见下 <code class="special">{dict}</code> 参数。

                <code class="special">{expr}</code> 省略时包含所有的项目。
                如果给出 <code class="special">{expr}</code>，计算其值决定如何处理:
                        如果 <code class="special">{expr}</code> 结果为 -1， 不处理后续的项目。
                        如果 <code class="special">{expr}</code> 结果为 0，不把本项加入列表。
                        如果 <code class="special">{expr}</code> 结果为 1，把本项加入列表。
                总是排除 "." 和 ".." 项目。
                每次计算 <code class="special">{expr}</code> 时  <a href="eval.html#v:val">v:val</a>  设为项目名。
                <code class="special">{expr}</code> 如果是函数，把名字作为参数传递。
                例如，要得到 ".txt" 结尾的文件列表: 
<code class="example">                  readdir(dirname, {n -&gt; n =~ '.txt$'})</code>
                要跳隐藏和备份文件: 
<code class="example">                  readdir(dirname, {n -&gt; n !~ '^\.\|\~$'})</code>
                                                        <b class="vimtag"> <a name="E857">E857</a> </b>
                可选的 <code class="special">{dict}</code> 参数允许更多定制。目前可用于指定排序是否和如何进
                行。此字典有以下成员:

                    sort    如何对系统返回值进行排序。
                            合法值是:
                                "none"      不排序 (最快速的方法)
                                "case"      大小写敏感排序 (按每个字符的字节
                                            值，技术上，使用 strcmp()) (缺省)
                                "icase"     大小写不敏感排序 (技术上，使用
                                            strcasecmp())
                                "collate"   使用 "POSIX" 或 "C"  <a href="mbyte.html#locale">locale</a>  的排
                                            序规则排序 (技术上，使用
                                            strcoll())
                            其它值被忽略，不报错。

                例如，要得到当前目录下的所有文件的列表，而不对个别项目排序: 
<code class="example">                  readdir('.', '1', #{sort: 'none'})</code>
                要想得到目录树: 
<code class="example">                  function! s:tree(dir)</code>
<code class="example">                      return {a:dir : map(readdir(a:dir),</code>
<code class="example">                      \ {_, x -&gt; isdirectory(x) ?</code>
<code class="example">                      \          {x : s:tree(a:dir .. '/' .. x)} : x})}</code>
<code class="example">                  endfunction</code>
<code class="example">                  echo s:tree(".")</code>

                出错时返回空列表。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetDirName()-&gt;readdir()</code>

                返回类型: list<code class="special">&lt;string&gt;</code> 或 list<code class="special">&lt;any&gt;</code>


readdirex(<code class="special">{directory}</code> [, <code class="special">{expr}</code> [, <code class="special">{dict}</code>]])            <b class="vimtag"> <a name="readdirex()">readdirex()</a> </b>
                 <a href="builtin.html#readdir()">readdir()</a>  的扩展版。
                返回 <code class="special">{directory}</code> 中的文件和目录信息字典的列表。
                可用于在读取目录列表的同时获得这些文件和目录的属性。这比先调用
                 <a href="builtin.html#readdir()">readdir()</a>  然后为每个文件和目录分别调用  <a href="builtin.html#getfperm()">getfperm()</a> 、
                 <a href="builtin.html#getfsize()">getfsize()</a> 、 <a href="builtin.html#getftime()">getftime()</a>  和  <a href="builtin.html#getftype()">getftype()</a>  要快得多，尤其是在
                MS-Windows 上。
                列表缺省按名字排序 (大小写敏感)，可选的 <code class="special">{dict}</code> 参数可用来改变
                如何排序，见  <a href="builtin.html#readdir()">readdir()</a> 。

                文件和目录信息字典包含以下项:
                        group   项目的组名。(仅用于 Unix)
                        name    项目名。
                        perm    项目权限。见  <a href="builtin.html#getfperm()">getfperm()</a> 。
                        size    项目大小。见  <a href="builtin.html#getfsize()">getfsize()</a> 。
                        time    项目时间戳。见  <a href="builtin.html#getftime()">getftime()</a> 。
                        type    项目类型。
                                Unix 上，大致相当于  <a href="builtin.html#getftype()">getftype()</a> ，除了以下例
                                外:
                                    目录的符号链接      "linkd"
                                    其它符号链接        "link"
                                MS-Windows 上:
                                    普通文件            "file"
                                    目录                "dir"
                                    连接点              "junction"
                                    目录的符号链接      "linkd"
                                    其它符号链接        "link"
                                    其它重解析点        "reparse"
                        user    项目拥有者的名字。(仅用于 Unix)
                Unix 上，如果项目是符号链接，字典包含链接目标的信息 (除了
                "type" 项外)。
                MS-Windows 上，由于性能方面的原因，同样情况包含的是符号链接本
                身的信息。

                <code class="special">{expr}</code> 省略时包含所有的项目。
                如果给出 <code class="special">{expr}</code>，计算其值决定如何处理:
                        如果 <code class="special">{expr}</code> 结果为 -1， 不处理后续的项目。
                        如果 <code class="special">{expr}</code> 结果为 0，不把本项加入列表。
                        如果 <code class="special">{expr}</code> 结果为 1，把本项加入列表。
                总是排除 "." 和 ".." 项目。
                每次计算 <code class="special">{expr}</code> 时， <a href="eval.html#v:val">v:val</a>  设为对应项目的  <a href="eval.html#Dictionary">Dictionary</a> 。
                如果 <code class="special">{expr}</code> 为函数，此项目被作为参数传入。
                例如，要获取所有以 ".txt" 结尾的文件列表: 
<code class="example">                  readdirex(dirname, {e -&gt; e.name =~ '.txt$'})</code>

                例如，要得到当前目录下的所有文件的列表，而不对个别项目排序: 
<code class="example">                  readdirex(dirname, '1', #{sort: 'none'})</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetDirName()-&gt;readdirex()</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt; 或 list<code class="special">&lt;any&gt;</code>


readfile(<code class="special">{fname}</code> [, <code class="special">{type}</code> [, <code class="special">{max}</code>]])                  <b class="vimtag"> <a name="readfile()">readfile()</a> </b>
                读入文件 <code class="special">{fname}</code> 并返回  <a href="eval.html#List">List</a> 。，文件每行一项。在 NL 字符处断
                开行。以 CR 分隔的 Macintosh 文件会返回单个长行 (除非某处出现
                了 NL)。
                所有的 NUL 字符被 NL 字符替代。
                如果 <code class="special">{type}</code> 包含 "b"，使用二进制模式:
                - 如果末行以 NL 结尾，附加额外的一个空列表项。
                - 不删除 CR 字符。
                否则:
                - NL 之前的 CR 字符被删除。
                - 末行是否以 NL 结尾没有影响。
                - <a href="options.html#'encoding'">'encoding'</a> 如是 Unicode 编码，删除文本可能有的 UTF-8 字节顺
                  序标识。
                如果给出 <code class="special">{max}</code>，指定读入的最大行数。可用于只想检查文件开始十行
                这样的场合: 
<code class="example">                        :for line in readfile(fname, '', 10)</code>
<code class="example">                        :  if line =~ 'Date' | echo line | endif</code>
<code class="example">                        :endfor</code>
                如果 <code class="special">{max}</code> 为负，返回从文件尾部起算 -<code class="special">{max}</code> 行，有多少算多少。
                如果 <code class="special">{max}</code> 为零，返回空列表。
                <code class="note">注意</code> 如果没有 <code class="special">{max}</code>，把整个文件读到内存。
                也要 <code class="note">注意</code> 这里不识别编码。如果需要，把文件读到缓冲区里。
                已废弃 (用  <a href="builtin.html#readblob()">readblob()</a>  代之): 如果 <code class="special">{type}</code> 包含 "B"，返回
                 <a href="eval.html#Blob">Blob</a> ，包含未经修改的文件二进制数据。
                如果文件不能打开，给出错误信息，并返回空列表。
                另见  <a href="builtin.html#writefile()">writefile()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFileName()-&gt;readfile()</code>

                返回类型: list<code class="special">&lt;string&gt;</code> 或 list<code class="special">&lt;any&gt;</code>


reduce(<code class="special">{object}</code>, <code class="special">{func}</code> [, <code class="special">{initial}</code>])                  <b class="vimtag"> <a name="reduce()">reduce()</a> </b> <b class="vimtag"> <a name="E998">E998</a> </b>
                为 <code class="special">{object}</code> 中的每个项目调用 <code class="special">{func}</code>，其中 <code class="special">{object}</code> 为
                 <a href="eval.html#String">String</a> 、 <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a>  或  <a href="eval.html#Blob">Blob</a> 。<code class="special">{func}</code> 调用时带两个参数:
                目前的结果，和当前项目。处理完所有项目，返回最终结果。 <b class="vimtag"> <a name="E1132">E1132</a> </b>

                <code class="special">{initial}</code> 为初始值。如果省略，使用 <code class="special">{object}</code> 的首个项目，而从第
                二个项目开始调用 <code class="special">{func}</code>。如果 <code class="special">{initial}</code> 未给出且 <code class="special">{object}</code> 为
                空，则结果不能进行计算，报错 E998。

                示例: 
<code class="example">                        echo reduce([1, 3, 5], { acc, val -&gt; acc + val })</code>
<code class="example">                        echo reduce(['x', 'y'], { acc, val -&gt; acc .. val }, 'a')</code>
<code class="example">                        echo reduce(0z1122, { acc, val -&gt; 2 * acc + val })</code>
<code class="example">                        echo reduce('xyz', { acc, val -&gt; acc .. ',' .. val })</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        echo mylist-&gt;reduce({ acc, val -&gt; acc + val }, 0)</code>

                返回类型:  <a href="eval.html#String">String</a> 、 <a href="eval.html#Blob">Blob</a> 、list&lt;<code class="special">{type}</code>&gt; 或 dict&lt;<code class="special">{type}</code>&gt;，
                取决于 <code class="special">{object}</code> 和 <code class="special">{func}</code>


reg_executing()                                         <b class="vimtag"> <a name="reg_executing()">reg_executing()</a> </b>
                返回在执行中的单个字母寄存器名。如果没有在执行的寄存器，返回空
                串。见  <a href="repeat.html#@">@</a> 。

                返回类型:  <a href="eval.html#String">String</a> 


reg_recording()                                         <b class="vimtag"> <a name="reg_recording()">reg_recording()</a> </b>
                返回在记录中的单个字母寄存器名。如果没有在记录的寄存器，返回空
                串。见  <a href="repeat.html#q">q</a> 。

                返回类型:  <a href="eval.html#String">String</a> 


reltime()                                               <b class="vimtag"> <a name="reltime()">reltime()</a> </b>
reltime(<code class="special">{start}</code>)
reltime(<code class="special">{start}</code>, <code class="special">{end}</code>)
                返回代表时间值的项目。此项目为项目列表，成员项目取决于不同的系
                统。Vim 9 脚本中其类型可用 list<code class="special">&lt;any&gt;</code>。
                可以把此项目传递给  <a href="builtin.html#reltimestr()">reltimestr()</a>  以转换为字符串，或
                 <a href="builtin.html#reltimefloat()">reltimefloat()</a>  以转换为浮点数。例如，要看到 Work() 函数花费
                的时间: 
<code class="example">                        var startTime = reltime()</code>
<code class="example">                        Work()</code>
<code class="example">                        echo startTime-&gt;reltime()-&gt;reltimestr()</code>

                没有参数时，返回当前时间 (具体表示方式和系统相关，不能当作挂钟
                (wall-clock) 时间，为此，可用  <a href="builtin.html#localtime()">localtime()</a> )。
                带一个参数时，返回参数指定的时间以来的时间。
                带两个参数时，返回 <code class="special">{start}</code> 和 <code class="special">{end}</code> 之间跨越的时间。
                <code class="special">{start}</code> 和 <code class="special">{end}</code> 参数必须是 reltime() 返回的值。出错时在老式脚
                本里返回空列表，Vim9 脚本里报错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetStart()-&gt;reltime()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>


reltimefloat(<code class="special">{time}</code>)                                    <b class="vimtag"> <a name="reltimefloat()">reltimefloat()</a> </b>
                返回代表 <code class="special">{time}</code> 的时间值的浮点数。
                示例: 
<code class="example">                        let start = reltime()</code>
<code class="example">                        call MyFunction()</code>
<code class="example">                        let seconds = reltimefloat(reltime(start))</code>
                参见  <a href="builtin.html#reltimestr()">reltimestr()</a>  关于开销的注释。
                另见  <a href="repeat.html#profiling">profiling</a> 。
                出错时在老式脚本里返回 0.0，Vim9 脚本里报错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        reltime(start)-&gt;reltimefloat()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>


reltimestr(<code class="special">{time}</code>)                                      <b class="vimtag"> <a name="reltimestr()">reltimestr()</a> </b>
                返回字符串，代表 <code class="special">{time}</code> 的时间值。
                形式是秒数、句号和毫秒数。例如: 
<code class="example">                        let start = reltime()</code>
<code class="example">                        call MyFunction()</code>
<code class="example">                        echo reltimestr(reltime(start))</code>
                <code class="note">注意</code> 命令本身额外的开销也计算在时间里。时间的准确度取决于系
                统。 <a href="builtin.html#reltimefloat()">reltimefloat()</a>  会给出最高准确度，一些系统里可达纳秒极。
                返回结果包含引导的空格，使字符串能很好地对齐。如果你不需要，用
                 <a href="builtin.html#split()">split()</a>  可以删掉。 
<code class="example">                        echo split(reltimestr(reltime(start)))[0]</code>
                另见  <a href="repeat.html#profiling">profiling</a> 。
                出错时在老式脚本里返回空串，Vim9 脚本里报错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        reltime(start)-&gt;reltimestr()</code>

                返回类型:  <a href="eval.html#String">String</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="remote_expr()">remote_expr()</a> </b> <b class="vimtag"> <a name="E449">E449</a> </b>
remote_expr(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code> [, <code class="special">{timeout}</code>]])
                发送 <code class="special">{string}</code> 到 <code class="special">{server}</code>。<code class="special">{server}</code> 参数是字符串，另见
                 <a href="remote.html#{server}">{server}</a> 。

                该发送的字符串是一个表达式，而返回的是远端执行的结果。这个结果
                必然是字符串或  <a href="eval.html#List">List</a> 。其它类型会转换为字符串。 <a href="eval.html#List">List</a>  转换成字
                符串的方法是把项目用换行符连接起来 (末项之后没有)，就像用
                join(expr, "\n") 那样。

                如果给出 <code class="special">{idvar}</code> 且非空，将 <code class="special">{serverid}</code> 保存在以它命令的变量
                里，此后的  <a href="builtin.html#remote_read()">remote_read()</a>  需要使用此值。

                如果给出 <code class="special">{timeout}</code>，在给定的秒数后读取超时。否则，使用 600 秒
                超时。

                另见  <a href="remote.html#clientserver">clientserver</a>   <a href="autocmd.html#RemoteReply">RemoteReply</a> 。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                <code class="note">注意</code>: 任何错误会在本地产生错误信息，但返回的结果只是一个空字符
                串。

                在全局命名空间中计算变量，而和当前激活的函数无关。调试模式例
                外，此时会计算局部于函数的变量和参数。

                例如: 
<code class="example">                        :echo remote_expr("gvim", "2+2")</code>
<code class="example">                        :echo remote_expr("gvim1", "b:current_syntax")</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerName()-&gt;remote_expr(expr)</code>

                返回类型:  <a href="eval.html#String">String</a>  或 list&lt;<code class="special">{type}</code>&gt;


remote_foreground(<code class="special">{server}</code>)                             <b class="vimtag"> <a name="remote_foreground()">remote_foreground()</a> </b>
                把名为 <code class="special">{server}</code> 的 Vim 服务器带到前台。<code class="special">{server}</code> 参数是字符串，
                另见  <a href="remote.html#{server}">{server}</a> 。
                这类似于: 
<code class="example">                        remote_expr({server}, "foreground()")</code>
                Win32 系统除外。那里，客户端完成实际的工作。因为操作系统不
                总能允许服务器把自己带到前台。
                <code class="note">注意</code>: 如果窗口最小化，并不恢复之， <a href="builtin.html#foreground()">foreground()</a>  会这么做。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerName()-&gt;remote_foreground()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅可用在 Win32、Motif 和 GTK GUI 版本和 Win32 的控制台版本}</code>


remote_peek(<code class="special">{serverid}</code> [, <code class="special">{retvar}</code>])                    <b class="vimtag"> <a name="remote_peek()">remote_peek()</a> </b>
                如果 <code class="special">{serverid}</code> 有可用的字符串，返回正数。如果指定了
                <code class="special">{retvar}</code>，复制任何应答字符串到 <code class="special">{retvar}</code> 指定的变量。<code class="special">{retvar}</code>
                必须是一个用来指定变量名的字符串。
                如果没有可用的应答，返回 0。
                出错时返回 -1。
                另见  <a href="remote.html#clientserver">clientserver</a> 。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                示例: 
<code class="example">                   :let repl = ""</code>
<code class="example">                   :echo "PEEK: " .. remote_peek(id, "repl") .. ": " .. repl</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerId()-&gt;remote_peek()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


remote_read(<code class="special">{serverid}</code>, [<code class="special">{timeout}</code>])                    <b class="vimtag"> <a name="remote_read()">remote_read()</a> </b>
                返回从 <code class="special">{serverid}</code> 发送的存在时间最长的应答，并删除之。除非给出
                以秒计的 <code class="special">{timeout}</code>，该调用会等待直到有应答为止。如果没有应答或
                出错，返回空串。
                另见  <a href="remote.html#clientserver">clientserver</a> 。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                例如: 
<code class="example">                        :echo remote_read(id)</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerId()-&gt;remote_read()</code>

                返回类型:  <a href="eval.html#String">String</a> 


remote_send(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code>])             <b class="vimtag"> <a name="remote_send()">remote_send()</a> </b> <b class="vimtag"> <a name="E241">E241</a> </b>
                发送 <code class="special">{string}</code> 到 <code class="special">{server}</code>。<code class="special">{server}</code> 参数是字符串，另见
                 <a href="remote.html#{server}">{server}</a> 。

                发送的字符串是输入键的序列。函数立即返回。Vim 的服务器端不对键
                进行映射  <a href="map.html#:map">:map</a> 。

                如果给出 <code class="special">{idvar}</code>，将 <code class="special">{serverid}</code> 保存在以它命令的变量里，此后的
                 <a href="builtin.html#remote_read()">remote_read()</a>  需要使用此值。

                另见  <a href="remote.html#clientserver">clientserver</a>   <a href="autocmd.html#RemoteReply">RemoteReply</a> 。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>

                <code class="note">注意</code>: 任何错误会在服务器端报告，从而影响那里的显示。
                例如: 
<code class="example">                :echo remote_send("gvim", ":DropAndReply " .. file,</code>
<code class="example">                 \ "serverid") .. remote_read(serverid)</code>
<code class="example"></code>
<code class="example">                :autocmd NONE RemoteReply *</code>
<code class="example">                 \ echo remote_read(expand("&lt;amatch&gt;"))</code>
<code class="example">                :echo remote_send("gvim", ":sleep 10 | echo " ..</code>
<code class="example">                 \ 'server2client(expand("&lt;client&gt;"), "HELLO")&lt;CR&gt;')</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerName()-&gt;remote_send(keys)</code>

                返回类型:  <a href="eval.html#String">String</a> 


remote_startserver(<code class="special">{name}</code>)                              <b class="vimtag"> <a name="remote_startserver()">remote_startserver()</a> </b> <b class="vimtag"> <a name="E941">E941</a> </b> <b class="vimtag"> <a name="E942">E942</a> </b>
                成为服务器 <code class="special">{name}</code>。<code class="special">{name}</code> 不能为空串。
                如果已作为服务器运行，也即  <a href="eval.html#v:servername">v:servername</a>  不为空时此操作失败。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerName()-&gt;remote_startserver()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>


remove(<code class="special">{list}</code>, <code class="special">{idx}</code>)                                   <b class="vimtag"> <a name="remove()">remove()</a> </b>
remove(<code class="special">{list}</code>, <code class="special">{idx}</code>, <code class="special">{end}</code>)
                没有 <code class="special">{end}</code>: 删除  <a href="eval.html#List">List</a>  <code class="special">{list}</code> 里索引为 <code class="special">{idx}</code> 的项目并返回之。
                有 <code class="special">{end}</code>: 删除从 <code class="special">{idx}</code> 到 <code class="special">{end}</code> (闭区间) 的项目，并返回这些项
                目的  <a href="eval.html#List">List</a> 。如果 <code class="special">{idx}</code> 指向和 <code class="special">{end}</code> 相同的项目，返回单个项目
                的列表。如果 <code class="special">{end}</code> 指向 <code class="special">{idx}</code> 之前的项目，报错。
                 <a href="eval.html#list-index">list-index</a>  说明 <code class="special">{idx}</code> 和 <code class="special">{end}</code> 可能的取值。
                出错时返回零。
                例如: 
<code class="example">                        :echo "last item: " .. remove(mylist, -1)</code>
<code class="example">                        :call remove(mylist, 0, 9)</code>

                用  <a href="builtin.html#delete()">delete()</a>  来删除文件。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;remove(idx)</code>

                返回类型: any，取决于 <code class="special">{list}</code>


remove(<code class="special">{blob}</code>, <code class="special">{idx}</code>)
remove(<code class="special">{blob}</code>, <code class="special">{idx}</code>, <code class="special">{end}</code>)
                没有 <code class="special">{end}</code>: 删除  <a href="eval.html#Blob">Blob</a>  <code class="special">{blob}</code> 里索引为 <code class="special">{idx}</code> 的字节并返回之。
                有 <code class="special">{end}</code>: 删除从 <code class="special">{idx}</code> 到 <code class="special">{end}</code> (闭区间) 的字节，并返回这些字
                节构成的的  <a href="eval.html#Blob">Blob</a> 。如果 <code class="special">{idx}</code> 指向和 <code class="special">{end}</code> 相同的字节，返回单
                个字节构成的  <a href="eval.html#Blob">Blob</a> 。如果 <code class="special">{end}</code> 指向 <code class="special">{idx}</code> 之前的字节，报错。
                出错时返回零。
                示例: 
<code class="example">                        :echo "last byte: " .. remove(myblob, -1)</code>
<code class="example">                        :call remove(mylist, 0, 9)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


remove(<code class="special">{dict}</code>, <code class="special">{key}</code>)
                删除 <code class="special">{dict}</code> 里键为 <code class="special">{key}</code> 的项目并返回其值。例如: 
<code class="example">                        :echo "removed " .. remove(dict, "one")</code>
                如果 <code class="special">{dict}</code> 里没有键 <code class="special">{key}</code>，报错。
                出错时返回零。

                返回类型: any，取决于 <code class="special">{dict}</code>


rename(<code class="special">{from}</code>, <code class="special">{to}</code>)                                    <b class="vimtag"> <a name="rename()">rename()</a> </b>
                把文件名 <code class="special">{from}</code> 换成 <code class="special">{to}</code>。这也可用来在文件系统间移动文件。返
                回数值，如果文件成功换名，返回零，如果换名失败，返回非零。
                <code class="note">注意</code> 如果 <code class="special">{to}</code> 已存在，它被覆盖且没有提示。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetOldName()-&gt;rename(newname)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


repeat(<code class="special">{expr}</code>, <code class="special">{count}</code>)                                 <b class="vimtag"> <a name="repeat()">repeat()</a> </b>
                重复 <code class="special">{expr}</code> <code class="special">{count}</code> 次，并返回连接后的结果。例如: 
<code class="example">                        :let separator = repeat('-', 80)</code>
                如果 <code class="special">{count}</code> 为零或负，返回空。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a>  或  <a href="eval.html#Blob">Blob</a>  类型，返回连接 <code class="special">{expr}</code>
                <code class="special">{count}</code> 次的结果。例如: 
<code class="example">                        :let longlist = repeat(['a', 'b'], 3)</code>
                返回 ['a', 'b', 'a', 'b', 'a', 'b']。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;repeat(count)</code>

                返回类型:  <a href="eval.html#String">String</a> 、 <a href="eval.html#Blob">Blob</a> 、list&lt;<code class="special">{type}</code>&gt; 或 tuple&lt;<code class="special">{type}</code>&gt;，取
                决于 <code class="special">{expr}</code>


resolve(<code class="special">{filename}</code>)                                     <b class="vimtag"> <a name="resolve()">resolve()</a> </b> <b class="vimtag"> <a name="E655">E655</a> </b>
                在 MS-Windows 上，如果 <code class="special">{filename}</code> 是一个快捷方式 (.lnk 文件)，
                返回简化的快捷方式指向的路径。当 <code class="special">{filename}</code> 为符号链接或连接点
                (junction point) 时，返回目的地的完整路径。如果该连接
                (junction) 的目的地已被删除，返回 <code class="special">{filename}</code>。
                在 Unix 上，反复分析 <code class="special">{filename}</code> 的所有路径部分的符号链接的真正
                路径，直到返回最简化的结果为止。为了处理循环链接的问题，符号链
                接的分析在 100 次叠代之后停止。
                在其它系统上，返回简化了的 <code class="special">{filename}</code>。
                简化的工作通过  <a href="builtin.html#simplify()">simplify()</a>  完成。
                resolve() 保留指向当前目录的首个路径部分 (保证结果仍然是相对路
                径名)，也保留出现在尾部的路径分隔符。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;resolve()</code>

                返回类型:  <a href="eval.html#String">String</a> 


reverse(<code class="special">{object}</code>)                                       <b class="vimtag"> <a name="reverse()">reverse()</a> </b>
                反转 <code class="special">{object}</code> 项目的顺序。<code class="special">{object}</code> 必须是  <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a> 、
                 <a href="eval.html#Blob">Blob</a>  或者  <a href="eval.html#String">String</a> 。如果是列表或 Blob，直接对 <code class="special">{object}</code> 进行
                原位修改。
                如果是元组，返回新元组。
                如果是字符串，返回新字符串。
                如果 <code class="special">{object}</code> 不是列表、元组、blob 或字符串，返回零。
                如果你不想修改列表或 Blob，先构建一个备份: 
<code class="example">                        :let revlist = reverse(copy(mylist))</code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;reverse()</code>

                返回类型:  <a href="eval.html#String">String</a> 、 <a href="eval.html#Blob">Blob</a> 、list&lt;<code class="special">{type}</code>&gt; 或 tuple&lt;<code class="special">{type}</code>&gt;，取
                决于 <code class="special">{object}</code>


round(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="round()">round()</a> </b>
                返回浮点数，即最接近于 <code class="special">{expr}</code> 的整数。如果 <code class="special">{expr}</code> 在两个整数的
                正中间，使用 (<code class="vim">译者注</code>: 绝对值) 较大 (远离零的) 那个。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回 0.0。
                示例: 
<code class="example">                        echo round(0.456)</code>
                        0.0  
<code class="example">                        echo round(4.5)</code>
                        5.0 
<code class="example">                        echo round(-4.5)</code>
                        -5.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;round()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


rubyeval(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="rubyeval()">rubyeval()</a> </b>
                计算 Ruby 表达式 <code class="special">{expr}</code> 并返回计算结果，转换为 Vim 本身的数
                据结构。
                数值、浮点数和字符串返回本身 (字符串经过复制)。
                数值返回 Vim  <a href="eval.html#List">List</a>  类型。
                哈希表返回 Vim  <a href="eval.html#Dictionary">Dictionary</a>  类型。
                其它对象返回它们 "Object#to_s" 方法返回的字符串。
                <code class="note">注意</code>  <a href="vim9.html#:def">:def</a>  函数里的局部变量对 <code class="special">{expr}</code> 不可见。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRubyExpr()-&gt;rubyeval()</code>

                返回类型: any，取决于 <code class="special">{expr}</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+ruby">+ruby</a>  特性才有效}</code>

screenattr(<code class="special">{row}</code>, <code class="special">{col}</code>)                                <b class="vimtag"> <a name="screenattr()">screenattr()</a> </b>
                类似于  <a href="builtin.html#screenchar()">screenchar()</a> ，但返回属性。是个相当任意的值，只可用于
                和其他位置的属性进行比较。
                如果 row 或 col 越界，返回 -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRow()-&gt;screenattr(col)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


screenchar(<code class="special">{row}</code>, <code class="special">{col}</code>)                                <b class="vimtag"> <a name="screenchar()">screenchar()</a> </b>
                返回数值，即屏幕 [row, col] 位置的字符。可用于任何可能的屏幕
                位置，包括状态行，窗口分隔符和命令行。左上位置的行列号都为一。
                返回字符不包括组合字符。双字节编码可能只返回第一个字节。
                主要用于调试。
                行号或列号越界时返回 -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRow()-&gt;screenchar(col)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


screenchars(<code class="special">{row}</code>, <code class="special">{col}</code>)                               <b class="vimtag"> <a name="screenchars()">screenchars()</a> </b>
                返回数值  <a href="eval.html#List">List</a> 。第一个数值和  <a href="builtin.html#screenchar()">screenchar()</a>  返回的相同。其后
                的数值是附加于基础字符之上的组合字符。
                主要用于测试。
                如果 row 或 col 超出范围返回空列表。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRow()-&gt;screenchars(col)</code>

                返回类型: list<code class="special">&lt;number&gt;</code> 或 list<code class="special">&lt;any&gt;</code>


screencol()                                             <b class="vimtag"> <a name="screencol()">screencol()</a> </b>
                返回数值，即当前光标的屏幕列号。最左列的列号为 1。
                主要用于调试。

                <code class="note">注意</code>: 总是返回当前屏幕列，所以直接用于命令 (例如 ":echo
                screencol()") 时会返回命令行内的列号，其在命令执行时永远为 1。
                要得到文件中的光标位置，可用下面这些映射: 
<code class="example">                        nnoremap &lt;expr&gt; GG ":echom " .. screencol() .. "\n"</code>
<code class="example">                        nnoremap &lt;silent&gt; GG :echom screencol()&lt;CR&gt;</code>
<code class="example">                        nnoremap GG &lt;Cmd&gt;echom screencol()&lt;CR&gt;</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


screenpos(<code class="special">{winid}</code>, <code class="special">{lnum}</code>, <code class="special">{col}</code>)                       <b class="vimtag"> <a name="screenpos()">screenpos()</a> </b>
                返回字典，窗口 <code class="special">{winid}</code> 在缓冲区行 <code class="special">{lnum}</code> 和列 <code class="special">{col}</code> 上的文本字
                符的屏幕位置。<code class="special">{col}</code> 是从一开始的字节索引。
                字典有以下成员:
                        row     屏幕行
                        col     首个屏幕列
                        endcol  末尾屏幕列
                        curscol 光标所在屏幕列
                如果指定位置不可见，所有的值均为零。
                当字符占据多于一个屏幕单元格时，"endcol" 和 "col" 的值会不同。
                例如制表符的 "col" 可能是 1 而 "eolcol" 会是 8。
                "curscol" 值是光标会放置的地方。对于制表符而言会和 "endcol" 相
                同。而对双宽字符来说，就会为 "col" 相同。
                此处忽略  <a href="syntax.html#conceal">conceal</a>  特性，列号的行算假定 <a href="options.html#'conceallevel'">'conceallevel'</a> 为零。
                要得到  <a href="syntax.html#conceal">conceal</a>  考虑在内的值，可以把光标放在合适的位置，然后
                用  <a href="builtin.html#screencol()">screencol()</a> 。
                如果位置在关闭的折叠里，返回其首个字符的屏幕位置，不使用
                <code class="special">{col}</code>。
                <code class="special">{winid}</code> 非法时返回空字典。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;screenpos(lnum, col)</code>

                返回类型: dict<code class="special">&lt;number&gt;</code> 或 dict<code class="special">&lt;any&gt;</code>


screenrow()                                             <b class="vimtag"> <a name="screenrow()">screenrow()</a> </b>
                返回数值，即当前光标的屏幕行号。最顶行的行号为 1。
                主要用于调试。
                代为替代，也可用  <a href="builtin.html#winline()">winline()</a> 。

                <code class="note">注意</code>: 和  <a href="builtin.html#screencol()">screencol()</a>  的限制相同。

                返回类型:  <a href="eval.html#Number">Number</a> 


screenstring(<code class="special">{row}</code>, <code class="special">{col}</code>)                              <b class="vimtag"> <a name="screenstring()">screenstring()</a> </b>
                返回字符串，包含在屏幕位置 [row, col] 上的基本字符和任何组合字
                符。类似于  <a href="builtin.html#screenchars()">screenchars()</a> ，但返回字符组成的字符串。
                主要用于测试。
                如果行或列超出范围，返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRow()-&gt;screenstring(col)</code>

                返回类型:  <a href="eval.html#String">String</a> 

                                                        <b class="vimtag"> <a name="search()">search()</a> </b>
search(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code> [, <code class="special">{skip}</code>]]]])
                搜索正则表达式模式 <code class="special">{pattern}</code>。搜索从光标位置 (用  <a href="builtin.html#cursor()">cursor()</a>  可
                以得到) 开始。

                如果找到了匹配，返回其所在的行号。
                如果找不到匹配，返回 0 并且光标位置不改变。不会给出错误信息。
                要取得匹配的字符串，可用  <a href="builtin.html#matchbufline()">matchbufline()</a> 。

                <code class="special">{flags}</code> 是字符串，可以包含以下字符标志位:
                'b'     反向 (Backward) 搜索，而不是正向搜索
                'c'     接受光标 (Cursor) 位置上的匹配
                'e'     移到匹配的尾部 (End)
                'n'     不 (Not) 移动光标
                'p'     返回匹配的子模式 (Pattern) 号 (见下)
                's'     在光标上次的位置上设置 (Set) ' 位置标记
                'w'     在文件尾部处回绕 (Wrap) 到文件开始处
                'W'     不在文件尾部处回绕 (Wrap)
                'z'     从光标列开始搜索而不是第零 (Zero) 列
                如果 'w' 和 'W' 都没有给出，根据 <a href="options.html#'wrapscan'">'wrapscan'</a> 选项决定。

                如果提供 's' 标志位，只有在光标移动的时候才设置 ' 位置标记。
                's' 标志位不能和 'n' 标志位一起使用。

                适用 <a href="options.html#'ignorecase'">'ignorecase'</a>、<a href="options.html#'smartcase'">'smartcase'</a> 和 <a href="options.html#'magic'">'magic'</a> 标志位。

                如果没给出 'z' 标志位，正向搜索总是从第零列开始，然后跳过光标
                之前的匹配。如果 <a href="options.html#'cpo'">'cpo'</a> 中有 'c' 标志位，下次搜索从匹配之后的位
                置开始。没有 'c' 标志位则下次搜索从匹配开始处的后一列开始。这
                对有重叠的匹配会有关系。见  <a href="options.html#cpo-c">cpo-c</a> 。也可插入 "\ze" 来改变匹配
                结束的位置，见  <a href="pattern.html#%2F\ze">/\ze</a> 。

                反向搜索给出 'z' 标志位时，搜索从第零列开始，所以不会找到当前
                行的任何匹配 (除非从文件尾回绕)。

                如果给出 <code class="special">{stopline}</code> 参数，搜索在搜索完该行后结束。可用于限制搜
                索在给出的行范围内。例如: 
<code class="example">                        let match = search('(', 'b', line("w0"))</code>
<code class="example">                        let end = search('END', '', line("w$"))</code>
                如果使用了 <code class="special">{stopline}</code> 且非零，隐含意味着搜索不会在文件尾回绕。
                零就相当于没给出该参数。

                                <b class="vimtag"> <a name="E1285">E1285</a> </b> <b class="vimtag"> <a name="E1286">E1286</a> </b> <b class="vimtag"> <a name="E1287">E1287</a> </b> <b class="vimtag"> <a name="E1288">E1288</a> </b> <b class="vimtag"> <a name="E1289">E1289</a> </b>
                如果给出 <code class="special">{timeout}</code> 参数，搜索在超过给出的毫秒数后中止。这样，
                如果 <code class="special">{timeout}</code> 为 500，搜索在半秒钟后中止。该值不能为负。
                零就相当于没给出该参数。

                <code class="note">注意</code>: 超时仅在搜索时考虑，计算 <code class="special">{skip}</code> 表达式时不会。
                <code class="notvi">{仅当在编译时加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>

                如果给出 <code class="special">{skip}</code> 表达式，对匹配开始处的光标位置进行计算。如果计
                算结果非零，跳过此匹配。可用于，比如说，跳过注释或字符串内部的
                匹配。
                <code class="special">{skip}</code> 可以是作为表达式计算的字符串、函数引用或匿名函数。
                <code class="special">{skip}</code> 省略或为空时，接受所有匹配。
                计算 <code class="special">{skip}</code> 时如果出错，中断搜索并返回 -1。
                                                        <b class="vimtag"> <a name="search()-sub-match">search()-sub-match</a> </b>
                如果有 'p' 标志位，返回值比第一个匹配的 \(\) 里的子模式的编号
                多一。如果所有子模式都不匹配但整个模式匹配，返回一。
                要得到列号，使用  <a href="builtin.html#searchpos()">searchpos()</a> 。

                光标定位在匹配的文本上，除非使用了 'n' 标志位。

                示例 (遍历参数列表里的所有文件): 
<code class="example">                    :let n = 1</code>
<code class="example">                    :while n &lt;= argc()      " 循环遍历参数列表的每个文件</code>
<code class="example">                    :  exe "argument " .. n</code>
<code class="example">                    :  " 从文件最后一个字符开始并回绕，这样第一个搜索可以找到</code>
<code class="example">                    :  " 文件开始的匹配</code>
<code class="example">                    :  normal G$</code>
<code class="example">                    :  let flags = "w"</code>
<code class="example">                    :  while search("foo", flags) &gt; 0</code>
<code class="example">                    :    s/foo/bar/g</code>
<code class="example">                    :    let flags = "W"</code>
<code class="example">                    :  endwhile</code>
<code class="example">                    :  update               " 如果修改过，写入文件</code>
<code class="example">                    :  let n = n + 1</code>
<code class="example">                    :endwhile</code>

                使用一些标志位的示例: 
<code class="example">                    :echo search('\&lt;if\|\(else\)\|\(endif\)', 'ncpe')</code>
                这会在光标之下或之后寻找关键字 "if"、"else" 和 "endif"。因为有
                'p' 标志位，会根据找到的是哪 个关键字返回 1、2 或 3，如果找不
                到会返回 0。如果光标在行的第一个单词上:
<code class="section">                    if (foo == 0) | let foo = foo + 1 | endif </code>
                此函数返回 1。没有 'c' 标志位的话，函数会找到 "endif" 并返回
                3。如果没有 'e' 标志位且光标在 "if" 的 "f" 上也会同样如此。'n'
                标志位告诉函数不移动光标。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPattern()-&gt;search()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


searchcount([<code class="special">{options}</code>])                                <b class="vimtag"> <a name="searchcount()">searchcount()</a> </b>
                获取或更新最近搜索计数，就像不带 "S" 标志位的 <code class="badlink">'shoftmess'</code> 所显
                示的那样。即便 <a href="options.html#'shortmess'">'shortmess'</a> 包含 "S" 标志位，此函数同样适用。

                返回  <a href="eval.html#Dictionary">Dictionary</a> 。如果没有设置前次模式且未指定 "pattern"，此
                字典为空。

<code class="section">                  键            类型            意义 </code>
                  current        <a href="eval.html#Number">Number</a>         匹配的当前位置；
                                                0 如果光标位置在首个匹配之前
                  exact_match    <a href="eval.html#Boolean">Boolean</a>        1 如果 "current" 在 "pos" 上匹
                                                配，否则为 0
                  total          <a href="eval.html#Number">Number</a>         找到的匹配总数
                  incomplete     <a href="eval.html#Number">Number</a>         0: 搜索全部完成
                                                1: 重计算超时
                                                2: 超过最大计数

                <code class="special">{options}</code> 见下。

                要取得最近一次按下  <a href="pattern.html#n">n</a>  或  <a href="pattern.html#N">N</a>  时的搜索计数，调用此函数，并带上
                `recompute: 0`。有时，因为 <a href="options.html#'maxsearchcount'">'maxsearchcount'</a>，这会返回错误的信
                息。如果计数超过 <a href="options.html#'maxsearchcount'">'maxsearchcount'</a>，结果必是
                <a href="options.html#'maxsearchcount'">'maxsearchcount'</a> + 1。如果要得到正确的信息，指定
                `recompute: 1`: 
<code class="example"></code>
<code class="example">                        " result == 'maxsearchcount' + 1 如果有很多匹配</code>
<code class="example">                        let result = searchcount(#{recompute: 0})</code>
<code class="example"></code>
<code class="example">                        " 以下则返回正确结果 (recompute 缺省为 1)</code>
<code class="example">                        let result = searchcount()</code>

                此函数可用于给 <a href="options.html#'statusline'">'statusline'</a> 加入计数: 
<code class="example">                        function! LastSearchCount() abort</code>
<code class="example">                          let result = searchcount(#{recompute: 0})</code>
<code class="example">                          if empty(result)</code>
<code class="example">                            return ''</code>
<code class="example">                          endif</code>
<code class="example">                          if result.incomplete ==# 1     " 超时</code>
<code class="example">                            return printf(' /%s [?/??]', @/)</code>
<code class="example">                          elseif result.incomplete ==# 2 " 超过最大计数</code>
<code class="example">                            if result.total &gt; result.maxcount &amp;&amp;</code>
<code class="example">                            \  result.current &gt; result.maxcount</code>
<code class="example">                              return printf(' /%s [&gt;%d/&gt;%d]', @/,</code>
<code class="example">                              \             result.current, result.total)</code>
<code class="example">                            elseif result.total &gt; result.maxcount</code>
<code class="example">                              return printf(' /%s [%d/&gt;%d]', @/,</code>
<code class="example">                              \             result.current, result.total)</code>
<code class="example">                            endif</code>
<code class="example">                          endif</code>
<code class="example">                          return printf(' /%s [%d/%d]', @/,</code>
<code class="example">                          \             result.current, result.total)</code>
<code class="example">                        endfunction</code>
<code class="example">                        let &amp;statusline ..= '%{LastSearchCount()}'</code>
<code class="example"></code>
<code class="example">                        " 如果只想打开 'hlsearch' 时显示计数，也可以如此</code>
<code class="example">                        " let &amp;statusline ..=</code>
<code class="example">                        " \   '%{v:hlsearch ? LastSearchCount() : ""}'</code>

                也可以更新搜索计数，可用于  <a href="autocmd.html#CursorMoved">CursorMoved</a>  或  <a href="autocmd.html#CursorMovedI">CursorMovedI</a>  自
                动命令: 
<code class="example"></code>
<code class="example">                        autocmd CursorMoved,CursorMovedI *</code>
<code class="example">                          \ let s:searchcount_timer = timer_start(</code>
<code class="example">                          \   200, function('s:update_searchcount'))</code>
<code class="example">                        function! s:update_searchcount(timer) abort</code>
<code class="example">                          if a:timer ==# s:searchcount_timer</code>
<code class="example">                            call searchcount(#{</code>
<code class="example">                            \ recompute: 1, maxcount: 0, timeout: 100})</code>
<code class="example">                            redrawstatus</code>
<code class="example">                          endif</code>
<code class="example">                        endfunction</code>

                也可用 "pattern" 来统计在当前缓冲区里匹配指定模式的文本数目: 
<code class="example"></code>
<code class="example">                        " 统计此缓冲区中的 '\&lt;foo\&gt;' 数</code>
<code class="example">                        " (注意 这也会更新搜索计数)</code>
<code class="example">                        let result = searchcount(#{pattern: '\&lt;foo\&gt;'})</code>
<code class="example"></code>
<code class="example">                        " 要恢复旧模式的旧搜索计数，可再次搜索</code>
<code class="example">                        call searchcount()</code>

                <code class="special">{options}</code> 必须为  <a href="eval.html#Dictionary">Dictionary</a> 。可包含:
<code class="section">                  键            类型            含义 </code>
                  recompute      <a href="eval.html#Boolean">Boolean</a>        如果为  <a href="eval.html#TRUE">TRUE</a> ，就像执行了  <a href="pattern.html#n">n</a> 
                                                或  <a href="pattern.html#N">N</a>  那样重新计算计数。
                                                否则，返回最近的计算结果 (当执
                                                行了  <a href="pattern.html#n">n</a>  或  <a href="pattern.html#N">N</a>  假定
                                                <a href="options.html#'shortmess'">'shortmess'</a> 里没有 "S"，此函数
                                                执行时有同样效果)。
                                                (缺省:  <a href="eval.html#TRUE">TRUE</a> )
                  pattern        <a href="eval.html#String">String</a>         就像给出和  <a href="change.html#@%2F">@/</a>  不同的模式那样
                                                重新计算。
                                                和在调用此函数前执行以下命令的
                                                效果相同 
<code class="example">                                                  let @/ = pattern</code>
                                                (缺省:  <a href="change.html#@%2F">@/</a> )
                  timeout        <a href="eval.html#Number">Number</a>         0 或负数代表无超时。
                                                以毫秒计的对结果重计算的超时
                                                (缺省: 0)
                  maxcount       <a href="eval.html#Number">Number</a>         0 或负数代表无限制。对结果重计
                                                算时匹配文本的最大计数。如果搜
                                                索超过总数，"total" 值成为
                                                `maxcount + 1`
                                                (缺省: <a href="options.html#'maxsearchcount'">'maxsearchcount'</a>)
                  pos            <a href="eval.html#List">List</a>           重计算结果时的
                                                `[lnum, col, off]` 值。
                                                这会改变 "current" 返回值。见
                                                 <a href="builtin.html#cursor()">cursor()</a> 、 <a href="builtin.html#getpos()">getpos()</a> 
                                                (缺省: 光标所在位置)

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetSearchOpts()-&gt;searchcount()</code>

                返回类型: dict<code class="special">&lt;number&gt;</code>


searchdecl(<code class="special">{name}</code> [, <code class="special">{global}</code> [, <code class="special">{thisblock}</code>]])         <b class="vimtag"> <a name="searchdecl()">searchdecl()</a> </b>
                搜索 <code class="special">{name}</code> 的声明。

                如果 <code class="special">{global}</code> 参数非零，使用  <a href="pattern.html#gD">gD</a>  的工作方式，寻找文件的第一个
                匹配。否则使用  <a href="pattern.html#gd">gd</a>  的工作方式，寻找函数里的第一个匹配。

                如果 <code class="special">{thisblock}</code> 参数非零，忽略光标位置前结束的 <code class="special">{}</code> 块里的匹
                配。可以避免只有在别的作用域里才有效的变量声明。

                移动光标到找到的匹配上。
                返回零代表成功，非零代表失败。
                例如: 
<code class="example">                        if searchdecl('myvar') == 0</code>
<code class="example">                           echo getline('.')</code>
<code class="example">                        endif</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;searchdecl()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                                                        <b class="vimtag"> <a name="searchpair()">searchpair()</a> </b>
searchpair(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code>
                                [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]]])
                搜索嵌套的 start-end 组对的匹配。这可以用来查找匹配 "if" 的
                "endif"。在这里面的其它的 if/endif 组对被忽略。搜索从光标开
                始。缺省正向搜索，在 <code class="special">{flags}</code> 里包含 'b' 的时候反向搜索。
                如果找到一个匹配，光标移动到那里并返回行号。如果没有匹配，
                返回 0 或者 -1，光标不移动。不会给出错误信息。

                <code class="special">{start}</code>、<code class="special">{middle}</code> 和 <code class="special">{end}</code> 都是模式，见  <a href="pattern.html#pattern">pattern</a> 。它们不能包
                含 \( \) 对，但可以使用 \%( \)。如果 <code class="special">{middle}</code> 非空，在相应的方
                向试图寻找它 (如果找到，停留在哪里)，但在嵌套的 start-end 组对
                里面的不算。一个典型的应用是: 
<code class="example">                        searchpair('\&lt;if\&gt;', '\&lt;else\&gt;', '\&lt;endif\&gt;')</code>
                如果 <code class="special">{middle}</code> 为空，跳过 "else"。

                <code class="special">{flags}</code> 'b'、'c'、'n'、's'、'w' 和 'W' 的使用方式和  <a href="builtin.html#search()">search()</a> 
                类似。此外，还可用:
                'r'     重复 (Repeat) 直到没有更多匹配位置；会找到最外层的组
                        对。隐含 'W' 标志位。
                'm'     返回匹配 (Match) 的数目而不是匹配的行号；使用 'r' 时会
                        &gt; 1。
                <code class="note">备注</code>: 最好使用 'W' 标志位，避免在文件尾回绕。

                如果找到 <code class="special">{start}</code>、<code class="special">{middle}</code> 或 <code class="special">{end}</code> 的匹配，计算 <code class="special">{skip}</code> 表达
                式，此时假定光标定位在匹配的开始处。如果返回零，该匹配被跳过。
                比如，可能是出现在注释里的匹配。
                如果 <code class="special">{skip}</code> 不提供或者为空，接受每一个匹配。如果计算 <code class="special">{skip}</code> 时
                出现错误，搜索被中止，并返回 -1。
                <code class="special">{skip}</code> 可以是字符串、匿名函数、函数引用或偏函数。其它类型会报
                错。
                 <a href="vim9.html#:def">:def</a>  函数里，<code class="special">{skip}</code> 参数如是字符串常量，会编译为指令的一部
                分。

                <code class="special">{stopline}</code> 和 <code class="special">{timeout}</code> 见  <a href="builtin.html#search()">search()</a> 。

                使用 <a href="options.html#'ignorecase'">'ignorecase'</a> 的值。忽略 <a href="options.html#'magic'">'magic'</a>，使用模式时假设它总是置位
                的。

                搜索从准确的光标处开始。根据搜索方向，寻找从下一个字符开始的
                <code class="special">{start}</code>、<code class="special">{middle}</code> 或 <code class="special">{end}</code>。比如: 
<code class="example">                        if 1</code>
<code class="example">                          if 2</code>
<code class="example">                          endif 2</code>
<code class="example">                        endif 1</code>
                如果从 "if 2" 开始且光标在 "i" 上并正向搜索，找到的是
                "endif 2"。如果刚好在 "if 2" 之前开始，找到的是 "endif 1"。因
                为先找到的了 "if 2"，而它被认为是嵌套的 if/endif，以 "if 2"
                开始，以 "endif 2" 结束。
                如果反向搜索且 <code class="special">{end}</code> 多于一个字符，在模式的最后加上 "\zs" 可能
                有用，这样光标在 end 匹配的中间某位置的时候，仍然可以找到匹配
                的 start 匹配。

                例如，要找到 Vim 脚本里的 "endif" 命令: 
<code class="example"></code>
<code class="example">        :echo searchpair('\&lt;if\&gt;', '\&lt;el\%[seif]\&gt;', '\&lt;en\%[dif]\&gt;', 'W',</code>
<code class="example">                        \ 'getline(".") =~ "^\\s*\""')</code>
<code class="example"></code>
                光标必须在要寻找匹配的 "if" 之上或之后。<code class="note">注意</code> 单引号字符串的使
                用，它避免了反斜杠的麻烦。skip 表达式只用来发现行首的注释，命
                令之后的不行。另外，一行中间的单词 "en" 或 "if" 也被认为是匹
                配。
                另一个例子，搜索匹配 "}" 的 "{": 
<code class="example"></code>
<code class="example">        :echo searchpair('{', '', '}', 'bW')</code>
<code class="example"></code>
                只需要光标在需要匹配的 "}" 之上或之前就可以了。要拒绝语法高亮
                识别为字符串的匹配: 
<code class="example"></code>
<code class="example">        :echo searchpair('{', '', '}', 'bW',</code>
<code class="example">             \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                                                        <b class="vimtag"> <a name="searchpairpos()">searchpairpos()</a> </b>
searchpairpos(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code>
                                [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]]])
                和  <a href="builtin.html#searchpair()">searchpair()</a>  相同，但返回  <a href="eval.html#List">List</a> ，包含匹配的行号和列号。
                 <a href="eval.html#List">List</a>  的第一个元素是行号，而第二个元素是匹配所在的列位置的字
                节位置。如果没有匹配，返回 [0, 0]。 
<code class="example"></code>
<code class="example">                        :let [lnum,col] = searchpairpos('{', '', '}', 'n')</code>

                 <a href="tips.html#match-parens">match-parens</a>  提供一个更复杂更有用的例子。

                返回类型: list<code class="special">&lt;number&gt;</code>

                                                        <b class="vimtag"> <a name="searchpos()">searchpos()</a> </b>
searchpos(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code> [, <code class="special">{skip}</code>]]]])
                和  <a href="builtin.html#search()">search()</a>  相同，但返回  <a href="eval.html#List">List</a> ，包含匹配的行号和列号。
                 <a href="eval.html#List">List</a>  的第一个元素是行号，而第二个元素是匹配所在的列位置的字
                节位置。如果没有匹配，返回 [0, 0]。
                例如: 
<code class="example">        :let [lnum, col] = searchpos('mypattern', 'n')</code>
<code class="example"></code>
                如果给出 'p' 标志位，返回值里有一个附加项目，包含匹配的子模式
                号  <a href="builtin.html#search()-sub-match">search()-sub-match</a> 。例如: 
<code class="example">        :let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')</code>
                此例中如果找到小写字母  <a href="pattern.html#%2F\l">/\l</a>  "submatch" 为 2，如果找到大写字母
                 <a href="pattern.html#%2F\u">/\u</a>  则为 3。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPattern()-&gt;searchpos()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


server2client(<code class="special">{clientid}</code>, <code class="special">{string}</code>)                     <b class="vimtag"> <a name="server2client()">server2client()</a> </b>
                发送应答字符串到 <code class="special">{clientid}</code>。最近刚发送过字符串的 <code class="special">{clientid}</code>
                可以通过 expand("<code class="special">&lt;client&gt;</code>") 得到。
                <code class="notvi">{仅当在编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                返回零代表成功，-1 代表失败。
                <code class="note">备注</code>:
                该 id 应在接受下一个命令前保存。也就是，在接收命令返回之前 (译
                者注: 似应为 "之后") 和任何等待输入的命令之前。
                另见  <a href="remote.html#clientserver">clientserver</a> 。
                示例: 
<code class="example">                        :echo server2client(expand("&lt;client&gt;"), "HELLO")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetClientId()-&gt;server2client(string)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


serverlist()                                            <b class="vimtag"> <a name="serverlist()">serverlist()</a> </b>
                返回可用的服务器名字列表，每行一个。如果没有服务器或者该信息
                无法得到，返回空字符串。另见  <a href="remote.html#clientserver">clientserver</a> 。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                示例: 
<code class="example">                        :echo serverlist()</code>

                返回类型:  <a href="eval.html#String">String</a> 


setbufline(<code class="special">{buf}</code>, <code class="special">{lnum}</code>, <code class="special">{text}</code>)                       <b class="vimtag"> <a name="setbufline()">setbufline()</a> </b>
                设置缓冲区 <code class="special">{buf}</code> 的第 <code class="special">{lnum}</code> 行为 <code class="special">{text}</code>。相当于为指定缓冲区
                调用  <a href="builtin.html#setline()">setline()</a> 。

                此函数只能用于已载入的缓冲区。有必要的话先调用  <a href="builtin.html#bufload()">bufload()</a> 。

                要插入行可用  <a href="builtin.html#appendbufline()">appendbufline()</a> 。
                清除 <code class="special">{lnum}</code> 中的任何文本属性。

                <code class="special">{text}</code> 可以是字符串，用来设置单行文本，也可以是字符串列表，用
                来设置多行文本。如果列表范围超出末行之下，则添加额外的行。如果
                列表为空，不作任何改变并返回零。

                <code class="special">{buf}</code> 的用法可见上述  <a href="builtin.html#bufname()">bufname()</a> 。

                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#setline()">setline()</a> 。
                "$" 指定 <code class="special">{buf}</code> 缓冲区的末行。
                如果 <code class="special">{lnum}</code> 正好在末行之下，在末行之下添加 <code class="special">{text}</code>。

                如果 <code class="special">{buf}</code> 不是合法缓冲区、缓冲区未载入、或 <code class="special">{lnum}</code> 不合法，返
                回 1。 <a href="vim9.html#Vim9">Vim9</a>  脚本里会报错。
                成功时返回 0。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetText()-&gt;setbufline(buf, lnum)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setbufvar(<code class="special">{buf}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)                      <b class="vimtag"> <a name="setbufvar()">setbufvar()</a> </b>
                设置缓冲区 <code class="special">{buf}</code> 的选项或局部变量 <code class="special">{varname}</code> 的值为 <code class="special">{val}</code>。
                也可用于全局或者局部于窗口的选项，但不能用于全局或者局部于窗口
                的变量。
                如果设置局部于窗口的选项，全局值不会改变。
                <code class="special">{buf}</code> 的使用方式见上  <a href="builtin.html#bufname()">bufname()</a> 。
                <code class="special">{varname}</code> 参数是字符串。
                <code class="note">注意</code>必须使用不带 "b:" 的变量名。
                示例: 
<code class="example">                        :call setbufvar(1, "&amp;mod", 1)</code>
<code class="example">                        :call setbufvar("todo", "myvar", "foobar")</code>
                该命令在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetValue()-&gt;setbufvar(buf, varname)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setcellwidths(<code class="special">{list}</code>)                                   <b class="vimtag"> <a name="setcellwidths()">setcellwidths()</a> </b>
                指定字符范围的单元宽度覆盖。用于告知 Vim 在终端显示时字符以屏
                幕单元计的宽度。此设置超越 <a href="options.html#'ambiwidth'">'ambiwidth'</a>。示例: 
<code class="example">                   call setcellwidths([</code>
<code class="example">                                \ [0x111, 0x111, 1],</code>
<code class="example">                                \ [0x2194, 0x2199, 2],</code>
<code class="example">                                \ ])</code>
<code class="example"></code>
                <code class="special">{list}</code> 参数为三个数值组成的列表的列表:
                [<code class="special">{low}</code>, <code class="special">{high}</code>, <code class="special">{width}</code>]。              <b class="vimtag"> <a name="E1109">E1109</a> </b> <b class="vimtag"> <a name="E1110">E1110</a> </b>
                "low" 和 "high" 可以相同，代表单个字符。否则，它们指定从 "low"
                到 "high" (闭区间) 的字符范围。         <b class="vimtag"> <a name="E1111">E1111</a> </b> <b class="vimtag"> <a name="E1114">E1114</a> </b>
                只能指定值为 0x80 和更高的字符。

                "width" 可为 1 或 2，指定以屏幕单元计的字符宽度。
                                                        <b class="vimtag"> <a name="E1112">E1112</a> </b>
                如果参数不合法或范围相互有重叠，报错。  <b class="vimtag"> <a name="E1113">E1113</a> </b>

                如果新值导致 <a href="options.html#'fillchars'">'fillchars'</a> 或 <a href="options.html#'listchars'">'listchars'</a> 非法，拒绝新值并报错。

                要清除覆盖，传递空 <code class="special">{list}</code>: 
<code class="example">                   setcellwidths([]);</code>
<code class="example"></code>
                可用 $VIMRUNTIME/tools/emoji_list.vim 脚本来查看已知表情字符的
                效果。移动光标穿过文本来检查终端使用的单元宽度是否匹配 Vim 所
                知的表情字符宽度。如果看上去有问题，请调节 <code class="special">{list}</code> 参数。

                返回类型:  <a href="eval.html#Number">Number</a> 


setcharpos(<code class="special">{expr}</code>, <code class="special">{list}</code>)                              <b class="vimtag"> <a name="setcharpos()">setcharpos()</a> </b>
                同  <a href="builtin.html#setpos()">setpos()</a> ，但使用指定列号作为行内字符索引，而不是字节索
                引。

                示例:
                在第 8 行的文本 "여보세요" 上: 
<code class="example">                        call setcharpos('.', [0, 8, 4, 0])</code>
                定位光标在第四个字符 '요' 上。 
<code class="example">                        call setpos('.', [0, 8, 4, 0])</code>
                定位光标在第二个字符 '보' 上。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPosition()-&gt;setcharpos('.')</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setcharsearch(<code class="special">{dict}</code>)                                   <b class="vimtag"> <a name="setcharsearch()">setcharsearch()</a> </b>
                用 <code class="special">{dict}</code> 设置当前字符搜索信息，带有以下项目:

                    char        下次  <a href="motion.html#,">,</a>  或  <a href="motion.html#;">;</a>  命令使用的字符；空字符串清除字
                                符搜索
                    forward     字符搜索的方向；1 为正向，0 为反向
                    until       字符搜索的类型；1 为  <a href="motion.html#t">t</a>  为  <a href="motion.html#T">T</a>  字符搜索，0 为
                                 <a href="motion.html#f">f</a>  或  <a href="motion.html#F">F</a>  字符搜索

                可用于在脚本中保存/恢复用户的字符搜索: 
<code class="example">                        :let prevsearch = getcharsearch()</code>
<code class="example">                        :" 执行改写用户搜索的命令</code>
<code class="example">                        :call setcharsearch(prevsearch)</code>
                另见  <a href="builtin.html#getcharsearch()">getcharsearch()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        SavedSearch()-&gt;setcharsearch()</code>

                返回类型: dict<code class="special">&lt;any&gt;</code>


setcmdline(<code class="special">{str}</code> [, <code class="special">{pos}</code>])                             <b class="vimtag"> <a name="setcmdline()">setcmdline()</a> </b>
                设置命令行为 <code class="special">{str}</code>，并设置光标位置为 <code class="special">{pos}</code>。
                <code class="special">{pos}</code> 如省略，光标会定位于文本后。
                如果成功，返回 0，如果不在编辑命令行，返回 1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;setcmdline()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setcmdpos(<code class="special">{pos}</code>)                                        <b class="vimtag"> <a name="setcmdpos()">setcmdpos()</a> </b>
                设置命令行的光标位置到字节位置 <code class="special">{pos}</code>。第一个位置为 1。
                用  <a href="builtin.html#getcmdpos()">getcmdpos()</a>  得到当前的位置。
                只有在编辑命令行时有效，所以必须在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a> 、 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a> 
                或带 '=' 的  <a href="cmdline.html#c_CTRL-R_CTRL-R">c_CTRL-R_CTRL-R</a>  里使用。对于  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  和带
                '=' 的  <a href="cmdline.html#c_CTRL-R_CTRL-R">c_CTRL-R_CTRL-R</a> ，在命令行设为表达式的内容之后才设置位
                置。对于  <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a> ，在计算表达式之后但在插入返回的文本之前
                设置位置。
                如果数值太大，光标放在行尾。如果小于 1，结果没有定义。
                如果成功，返回 0，如果不在编辑命令行，返回 1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPos()-&gt;setcmdpos()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setcursorcharpos(<code class="special">{lnum}</code>, <code class="special">{col}</code> [, <code class="special">{off}</code>])               <b class="vimtag"> <a name="setcursorcharpos()">setcursorcharpos()</a> </b>
setcursorcharpos(<code class="special">{list}</code>)
                同  <a href="builtin.html#cursor()">cursor()</a> ，但使用指定列号作为行内的字符索引，而不是字节索
                引。

                示例:
                在第 4 行的文本 "여보세요" 上: 
<code class="example">                        call setcursorcharpos(4, 3)</code>
                定位光标在第三个字符 '세' 上。 
<code class="example">                        call cursor(4, 3)</code>
                定位光标在第一个字符 '여' 上。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCursorPos()-&gt;setcursorcharpos()</code>

                位置可以设置时返回 0，否则返回 -1。
                返回类型:  <a href="eval.html#Number">Number</a> 


setenv(<code class="special">{name}</code>, <code class="special">{val}</code>)                                   <b class="vimtag"> <a name="setenv()">setenv()</a> </b>
                设置环境变量 <code class="special">{name}</code> 值为 <code class="special">{val}</code>。例如: 
<code class="example">                        call setenv('HOME', '/home/myhome')</code>
<code class="example"></code>
                如果 <code class="special">{val}</code> 为  <a href="eval.html#v:null">v:null</a> ，删除该环境变量。
                另见  <a href="eval.html#expr-env">expr-env</a> 。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetPath()-&gt;setenv('PATH')</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setfperm(<code class="special">{fname}</code>, <code class="special">{mode}</code>)                               <b class="vimtag"> <a name="setfperm()">setfperm()</a> </b> <b class="vimtag"> <a name="chmod">chmod</a> </b>
                设置 <code class="special">{fname}</code> 的文件权限为 <code class="special">{mode}</code>。
                <code class="special">{mode}</code> 必须是 9 个字符的字符串。形如 "rwxrwxrwx"，每组 "rwx"
                标志位代表着，按次序，文件拥有者、文件所属组和其他用户的权限。
                '-' 字符代表关闭权限，其他字符代表打开。不支持多字节字符。

                例如 "rw-r-----" 意味着用户可读写，组只读，其他不可访问。
                "xx-x-----" 作用相同。

                返回非零代表成功，零代表失败。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;setfperm(mode)</code>

                要读取权限可见  <a href="builtin.html#getfperm()">getfperm()</a> 。

                返回类型:  <a href="eval.html#Number">Number</a> 


setline(<code class="special">{lnum}</code>, <code class="special">{text}</code>)                                 <b class="vimtag"> <a name="setline()">setline()</a> </b>
                设置当前缓冲区第 <code class="special">{lnum}</code> 行的内容为 <code class="special">{text}</code>。要插入新行，用
                 <a href="builtin.html#append()">append()</a> 。要设置其它缓冲区的行，可用  <a href="builtin.html#setbufline()">setbufline()</a> 。
                清除 <code class="special">{lnum}</code> 中的任何文本属性。见  <a href="textprop.html#text-prop-cleared">text-prop-cleared</a> 

                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。
                如果 <code class="special">{lnum}</code> 正好在末行之下，在末行之下添加 <code class="special">{text}</code>。
                <code class="special">{text}</code> 可以是任何类型或任何类型的列表，每个项目会被转换为字符
                串。<code class="special">{text}</code> 为空列表时，不进行任何改变且返回 FALSE。

                如果成功，返回 FALSE。如果失败 (多数是因为 <code class="special">{lnum}</code> 不合法) 返回
                TRUE。
                 <a href="vim9.html#Vim9">Vim9</a>  脚本里如果 <code class="special">{lnum}</code> 非法会报错。

                例如: 
<code class="example">                        :call setline(5, strftime("%c"))</code>
<code class="example"></code>
                如果 <code class="special">{text}</code> 为  <a href="eval.html#List">List</a> ，那么第 <code class="special">{lnum}</code> 行和其后的行被设为列表里
                的项目。例如: 
<code class="example">                        :call setline(5, ['aaa', 'bbb', 'ccc'])</code>
                等价于: 
<code class="example">                        :for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]</code>
<code class="example">                        :  call setline(n, l)</code>
<code class="example">                        :endfor</code>
<code class="example"></code>
                <code class="note">注意</code>: 这里不会设置 '[ 和 '] 位置标记。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetText()-&gt;setline(lnum)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setloclist(<code class="special">{nr}</code>, <code class="special">{list}</code> [, <code class="special">{action}</code> [, <code class="special">{what}</code>]])        <b class="vimtag"> <a name="setloclist()">setloclist()</a> </b>
                创建或替代或加入到窗口 <code class="special">{nr}</code> 的位置列表。
                <code class="special">{nr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 为零，使用当前窗口。

                如果是位置列表窗口，修改所显示的位置列表。如果窗口号 <code class="special">{nr}</code> 非
                法，返回 -1。
                其它同  <a href="builtin.html#setqflist()">setqflist()</a> 。
                另见  <a href="quickfix.html#location-list">location-list</a> 。

                关于 <code class="special">{action}</code>，可见  <a href="builtin.html#setqflist-action">setqflist-action</a> 。

                如果给出可选的 <code class="special">{what}</code> 字典参数，只设置 <code class="special">{what}</code> 中列出的项目。
                关于 <code class="special">{what}</code> 支持的键值的列表，参见  <a href="builtin.html#setqflist()">setqflist()</a> 。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetLoclist()-&gt;setloclist(winnr)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setmatches(<code class="special">{list}</code> [, <code class="special">{win}</code>])                            <b class="vimtag"> <a name="setmatches()">setmatches()</a> </b>
                恢复  <a href="builtin.html#getmatches()">getmatches()</a>  为当前窗口保存的匹配列表。如果成功，返回
                0，否则返回 -1。原有的所有匹配都被清除。示例见
                 <a href="builtin.html#getmatches()">getmatches()</a> 。
                如果给出 <code class="special">{win}</code>，使用带此窗口号或窗口 ID 的窗口而不是当前窗口。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMatches()-&gt;setmatches()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setpos(<code class="special">{expr}</code>, <code class="special">{list}</code>)                                  <b class="vimtag"> <a name="setpos()">setpos()</a> </b>
                设置字符串 <code class="special">{expr}</code> 的位置。可能的值:
                        .       光标
                        'x      位置标记 x

                <code class="special">{list}</code> 必须是带四个或五个数值的  <a href="eval.html#List">List</a> :
                    [bufnum, lnum, col, off]
                    [bufnum, lnum, col, off, curswant]

                "bufnum" 是缓冲区号。零代表当前缓冲区。如果设置大写位置标记，
                "bufnum" 是位置标记位置的一部分。对其它的位置标记，它用于指定
                设置位置标记的缓冲区。可以用  <a href="builtin.html#bufnr()">bufnr()</a>  函数把文件名转化为缓冲
                区号。
                设置光标和 ' 位置标记时忽略 "bufnum"，因为它们和窗口相关，而不
                是缓冲区相关。
                不修改跳转表。

                "lnum" 和 "col" 是缓冲区里的位置。第一列为 1。"lnum" 为零则删
                除位置标记。"col" 如小于 1，则以 1 代替。要使用字符计数而不是
                字节计数，用  <a href="builtin.html#setcharpos()">setcharpos()</a> 。

                除非使用了 <a href="options.html#'virtualedit'">'virtualedit'</a>，不用 "off" 值。这是从对应字符开始位
                置以屏幕列计的位移。例如，在制表之中或最后一个字符之后的某个位
                置。

                "curswant" 值只用于设置光标位置。它指定垂直移动光标时的首选
                列。如果没有 "curswants" 值，不设置首选列。如果有但用于设置位
                置标记时，也没有效果。

                <code class="note">注意</code>对 '&lt; 和 '&gt; 而言，改变行号可能会使两者在实际中被调换，以保
                证 '&lt; 总是在 '&gt; 之前。

                如果位置可以设置，返回 0，否则返回 -1。如果 <code class="special">{expr}</code> 不合法，报
                错。

                另见  <a href="builtin.html#setcharpos()">setcharpos()</a> 、 <a href="builtin.html#getpos()">getpos()</a>  和  <a href="builtin.html#getcurpos()">getcurpos()</a> 。

                这并不能恢复垂直移动使用的列；如果用它设置了光标位置， <a href="motion.html#j">j</a>  和
                 <a href="motion.html#k">k</a>  动作会跳转到上次的列上！ <a href="builtin.html#cursor()">cursor()</a>  也可设置首选列。另见
                 <a href="builtin.html#winrestview()">winrestview()</a>  的 "curswant" 键。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPosition()-&gt;setpos('.')</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setqflist(<code class="special">{list}</code> [, <code class="special">{action}</code> [, <code class="special">{what}</code>]])               <b class="vimtag"> <a name="setqflist()">setqflist()</a> </b>
                创建或替代或加入到快速修复表。

                如果提供了可选的 <code class="special">{what}</code> 字典参数，只设置 <code class="special">{what}</code> 列出的项目，忽
                略首个参数 <code class="special">{list}</code>。<code class="special">{what}</code> 支持的项目见下。
                                                        <b class="vimtag"> <a name="setqflist-what">setqflist-what</a> </b>
                如果不给出 <code class="special">{what}</code>，使用 <code class="special">{list}</code> 里的项目。每个 <code class="special">{list}</code> 项目是一
                个字典。<code class="special">{list}</code> 里非字典的项目被忽略。每个字典项目可以包含以下
                的项目:

                    bufnr       缓冲区号；必须为某个合法缓冲区的编号
                    filename    文件名；仅当 "bufnr" 不存在或者不合法时才使用
                    module      模块名；如果给出，在快速修复错误窗口用它而不是
                                文件名
                    lnum        缓冲区里的行号
                    end_lnum    如果项目跨越多行，末行的行号
                    pattern     用于定位错误的模式
                    col         列号
                    vcol        非零: "col" 是可视列
                                零: "col" 是字节位置
                    end_col     如果项目跨越多列，末列的列号
                    nr          错误号
                    text        错误描述
                    type        错误类型，'E'、'W' 等。
                    valid       经过识别的错误信息
                    user_data   项目关联的定制数据，可为任意类型。

                "col"、"vcol"、"nr"、"type" 和 "text" 项目是可选的。"lnum" 或
                "pattern" 项目用来定位匹配的错误行。
                如果 "filename" 和 "bufnr" 项目都不存在或者 "lnum" 和
                "pattern" 项目都不存在，那么此项目不被当作错误行处理。
                如果 "pattern" 和 "lnum" 都存在，使用 "pattern"。
                如果不提供 "valid" 项目，则在 "bufnr" 为合法的缓冲区或
                "filename" 存在时，置位 valid 标志位。
                如果 <code class="special">{list}</code> 为空，快速修复列表被清除。
                <code class="note">注意</code> 此列表和  <a href="builtin.html#getqflist()">getqflist()</a>  返回之值不尽相同。

                <code class="special">{action}</code> 值:                            <b class="vimtag"> <a name="setqflist-action">setqflist-action</a> </b> <b class="vimtag"> <a name="E927">E927</a> </b>
                'a'     把 <code class="special">{list}</code> 项目加入已有的快速修复列表。如果该列表尚不存
                        在，建立新表。

                'r'     <code class="special">{list}</code> 项目替换当前快速修复列表项目。也可用于清除列
                        表: 
<code class="example">                                :call setqflist([], 'r')</code>

                'u'     和 'r' 类似，但试图保留快速修复列表里的当前选择。
                'f'     释放快速修复堆栈上的所有快速修复列表。

                如果 <code class="special">{action}</code> 不存在或者设为 ' '，那么建立新表。栈中在当前快速
                修复列表之后加入新快速修复列表并释放其后的所有列表。要在栈的尾
                部加入新快速修复列表，把 <code class="special">{what}</code> 中的 "nr" 设为 "$"。

                <code class="special">{what}</code> 支持以下项目:
                    context     快速修复列表上下文。见  <a href="quickfix.html#quickfix-context">quickfix-context</a> 
                    efm         解析 "lines" 时使用的 errorformat。如果没有给
                                出，使用 <a href="options.html#'errorformat'">'errorformat'</a> 选项值。
                                见  <a href="quickfix.html#quickfix-parse">quickfix-parse</a> 
                    id          快速修复列表标识号  <a href="quickfix.html#quickfix-ID">quickfix-ID</a> 
                    idx         <code class="badlink">'id'</code> 或 <code class="badlink">'nr'</code> 指定的快速修复列表的当前项的索
                                引。如果设为 '$'，列表的末项设为当前项。见
                                 <a href="quickfix.html#quickfix-index">quickfix-index</a> 
                    items       快速修复项目的列表，同 <code class="special">{list}</code> 参数。
                    lines       用 <a href="options.html#'efm'">'efm'</a> (<code class="vim">译者注</code>: 原文作 <a href="options.html#'errorformat'">'errorformat'</a>，似不
                                妥) 解析文本行列表并其结果项目加入快速修复列表
                                <code class="special">{nr}</code> 或 <code class="special">{id}</code> 中。只支持  <a href="eval.html#List">List</a>  类型。
                                见  <a href="quickfix.html#quickfix-parse">quickfix-parse</a> 
                    nr          快速修复堆栈中的列表号；零代表当前快速修复列
                                表，"$" 代表最后的快速修复列表。
                    quickfixtextfunc
                                获取显示在快速修复窗口的文本的函数。值可取函数
                                名、函数引用或匿名函数。参见
                                 <a href="quickfix.html#quickfix-window-function">quickfix-window-function</a>  解释如何写此函数并
                                给出示例。
                    title       快速修复列表标题。见  <a href="quickfix.html#quickfix-title">quickfix-title</a> 
                忽略 <code class="special">{what}</code> 中不支持的项目。
                如果不给出 "nr"，修改当前快速修复列表。要创建新的快速修复列
                表，"nr" 可设为比快速修复栈大小大一的值。

                在修改快速修复列表时，要保证修改的是正确的列表，应用 "id" 而不
                是 "nr" 来指定列表。

                示例 (另见  <a href="quickfix.html#setqflist-examples">setqflist-examples</a> ): 
<code class="example">                   :call setqflist([], 'r', {'title': 'My search'})</code>
<code class="example">                   :call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})</code>
<code class="example">                   :call setqflist([], 'a', {'id':qfid, 'lines':["F1:10:L10"]})</code>

                返回零代表成功，-1 代表失败。

                该函数用来独立于 <a href="options.html#'errorformat'">'errorformat'</a> 的设置建立快速修复列表。
                `:cc 1` 这样的命令可以跳转到第一个位置上。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetErrorlist()-&gt;setqflist()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setreg(<code class="special">{regname}</code>, <code class="special">{value}</code> [, <code class="special">{options}</code>])                <b class="vimtag"> <a name="setreg()">setreg()</a> </b>
                设置寄存器 <code class="special">{regname}</code> 的值为 <code class="special">{value}</code>。
                如果 <code class="special">{regname}</code> 为 "" 或 "@"，使用无名寄存器 '"'。
                <code class="special">{regname}</code> 参数为字符串。 <a href="vim9.html#Vim9-script">Vim9-script</a>  中 <code class="special">{regname}</code> 必须为单个
                字符。

                <code class="special">{value}</code> 可以是  <a href="builtin.html#getreg()">getreg()</a>  或  <a href="builtin.html#getreginfo()">getreginfo()</a>  返回的任何类型，包
                括  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dict">Dict</a> 。
                如果 <code class="special">{options}</code> 包含 "a" 或者 <code class="special">{regname}</code> 为大写，该值被附加于现
                有值之后。

                <code class="special">{options}</code> 还可以指定寄存器新类型的规格:
                    "c" 或 "v"         <a href="motion.html#characterwise">characterwise</a>  (面向字符) 模式
                    "l" 或 "V"         <a href="motion.html#linewise">linewise</a>  (面向行) 模式
                    "b" 或 "&lt;<code class="keystroke">CTRL-V</code>&gt;"  <a href="visual.html#blockwise-visual">blockwise-visual</a>  (面向列块) 模式
                如果 "b" 或 "&lt;<code class="keystroke">CTRL-V</code>&gt;" 之后紧跟数值，那么该数值用作选择的宽度
                - 如果没有指定，那么列块的宽度设为最长的行字符数 (把 <code class="special">&lt;Tab&gt;</code>
                看作一个字符)。

                如果 <code class="special">{options}</code> 没有寄存器设置，那么字符串值 <code class="special">{value}</code> 缺省使用面
                向字符模式，除非 <code class="special">{value}</code> 以 <code class="special">&lt;NL&gt;</code> 结尾，列表值的 <code class="special">{value}</code> 缺省使
                用面向行模式。不会自动选择面向列块模式。
                返回零代表成功，非零代表失败。

                                                        <b class="vimtag"> <a name="E883">E883</a> </b>
                <code class="note">备注</code>: 设置搜索和表达式寄存器时，不可使用多于一个项目的
                       <a href="eval.html#List">List</a> 。无项目的列表相当于空串。

                示例: 
<code class="example">                        :call setreg(v:register, @*)</code>
<code class="example">                        :call setreg('*', @%, 'ac')</code>
<code class="example">                        :call setreg('a', "1\n2\n3", 'b5')</code>
<code class="example">                        :call setreg('"', { 'points_to': 'a'})</code>
<code class="example"></code>
                本例说明如何使用函数来保存和恢复寄存器: 
<code class="example">                        :let var_a = getreginfo()</code>
<code class="example">                        :call setreg('a', var_a)</code>
                或: 
<code class="example">                        :let var_a = getreg('a'， 1)</code>
<code class="example">                        :let var_amode = getregtype('a')</code>
<code class="example">                            ....</code>
<code class="example">                        :call setreg('a', var_a, var_amode)</code>
<code class="example"></code>
                <code class="note">备注</code>: 如果不提供  <a href="builtin.html#getreg()">getreg()</a>  的第三个参数，就不能可靠地恢复寄存
                器值，因为此时，换行符和 Nul 字节都用换行符表示，见
                 <a href="pattern.html#NL-used-for-Nul">NL-used-for-Nul</a> )。

                你可以通过附加空串来改变寄存器的类型: 
<code class="example">                        :call setreg('a', '', 'al')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetText()-&gt;setreg('a')</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


settabvar(<code class="special">{tabnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)                    <b class="vimtag"> <a name="settabvar()">settabvar()</a> </b>
                设置标签页 <code class="special">{tabnr}</code> 的标签页局部变量 <code class="special">{varname}</code> 的值为 <code class="special">{val}</code>。
                 <a href="eval.html#t:var">t:var</a> 
                <code class="special">{varname}</code> 参数是字符串。
                <code class="note">注意</code> 自动命令是阻塞的，可能不会触发副作用，比如设置 <a href="options.html#'filetype'">'filetype'</a>
                的时候。
                <code class="note">注意</code> 必须使用不带 "t:" 的名字。
                标签页的编号从一开始。
                该命令在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetValue()-&gt;settabvar(tab, name)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


settabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)        <b class="vimtag"> <a name="settabwinvar()">settabwinvar()</a> </b>
                设置窗口 <code class="special">{nr}</code> 的选项或局部变量 <code class="special">{varname}</code> 的值为 <code class="special">{val}</code>。
                标签页的编号从一开始。 <a href="builtin.html#setwinvar()">setwinvar()</a>  总是使用当前标签页。
                <code class="special">{winnr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{winnr}</code> 为零，使用当前窗口。
                <code class="note">注意</code> 自动命令是阻塞的，可能不会触发副作用，比如设置 <a href="options.html#'filetype'">'filetype'</a>
                或 <a href="options.html#'syntax'">'syntax'</a> 的时候。
                也可用于全局或者局部于缓冲区的选项，但不能用于全局或者局部于缓
                冲区的变量。
                如果设置局部于缓冲区的选项，全局值不会改变。
                <code class="note">注意</code> 必须使用不带 "w:" 的变量名。
                示例: 
<code class="example">                        :call settabwinvar(1, 1, "&amp;list", 0)</code>
<code class="example">                        :call settabwinvar(3, 2, "myvar", "foobar")</code>
                该命令在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第四个参数传递的: 
<code class="example">                        GetValue()-&gt;settabwinvar(tab, winnr, name)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


settagstack(<code class="special">{nr}</code>, <code class="special">{dict}</code> [, <code class="special">{action}</code>])                  <b class="vimtag"> <a name="settagstack()">settagstack()</a> </b>
                用 <code class="special">{dict}</code> 修改窗口 <code class="special">{nr}</code> 标签栈。
                <code class="special">{nr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。

                要查阅 <code class="special">{dict}</code> 支持项的列表，可参考  <a href="builtin.html#gettagstack()">gettagstack()</a> 。
                "curidx" 在标签栈修改之前生效。
                                                        <b class="vimtag"> <a name="E962">E962</a> </b>
                标签栈如何修改取决于 <code class="special">{action}</code> 参数:
                - 如果 <code class="special">{action}</code> 没给出或是 'r'，标签栈被替换。
                - 如果 <code class="special">{action}</code> 是 'a'，则 <code class="special">{dict}</code> 中的新项被压进标签栈里。
                - 如果 <code class="special">{action}</code> 是 't'，删除标签栈的当前项或 <code class="special">{dict}</code> 中的
                  "curidx" 项里面的所有项目，然后把新项压进标签栈里。

                当前索引设为修改之后的标签栈的长度之后的那项。

                成功时返回零，失败则返回 -1。

                示例 (更多示例可见  <code class="badlink">tag-stack-examples</code> ):
                    清空窗口 3 的标签栈: 
<code class="example">                        call settagstack(3, {'items' : []})</code>
<code class="example"></code>
                    保存并恢复标签栈: 
<code class="example">                        let stack = gettagstack(1003)</code>
<code class="example">                        " do something else</code>
<code class="example">                        call settagstack(1003, stack)</code>
<code class="example">                        unlet stack</code>

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetStack()-&gt;settagstack(winnr)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


setwinvar(<code class="special">{winnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)                    <b class="vimtag"> <a name="setwinvar()">setwinvar()</a> </b>
                类似于  <a href="builtin.html#settabwinvar()">settabwinvar()</a> ，只用当前标签页。
                示例: 
<code class="example">                        :call setwinvar(1, "&amp;list", 0)</code>
<code class="example">                        :call setwinvar(2, "myvar", "foobar")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetValue()-&gt;setwinvar(winnr, name)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


sha256(<code class="special">{expr}</code>)                                          <b class="vimtag"> <a name="sha256()">sha256()</a> </b>
                返回 64 位十六进制字符串，即 <code class="special">{expr}</code> 的 SHA256 校验码。
                <code class="special">{expr}</code> 可以是字符串或 blob。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;sha256()</code>
<code class="example">                        GetBlob()-&gt;sha256()</code>

                返回类型:  <a href="eval.html#String">String</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+cryptv">+cryptv</a>  特性才有效}</code>

shellescape(<code class="special">{string}</code> [, <code class="special">{special}</code>])                     <b class="vimtag"> <a name="shellescape()">shellescape()</a> </b>
                转义 <code class="special">{string}</code> 以便用作外壳命令的参数。
                如果 <a href="options.html#'shell'">'shell'</a> 包含 powershell (MS-Windows) 或 pwsh
                (MS-Windows、Linux 和 macOS)，用单引号包围 <code class="special">{string}</code>，并给内部
                的单引号加倍。
                在 MS-Windows 上，如果未设定 <a href="options.html#'shellslash'">'shellslash'</a>，用双引号包围
                <code class="special">{string}</code>，并给 <code class="special">{string}</code> 内的双引号加倍。
                否则，用单引号包围，并把所有的 "'" 替换为 "'\''"。

                <code class="special">{special}</code> 参数为 Vim 命令中使用的关键字进行额外转义。当它给出
                且不是零值或空串时 ( <a href="eval.html#non-zero-arg">non-zero-arg</a> )，特殊项目如 "!"、"%"、"#"
                和 "<code class="special">&lt;cword&gt;</code>" 等 ( <a href="builtin.html#expand()">expand()</a>  列出) 会在前面加上反斜杠。
                 <a href="various.html#:!">:!</a>  命令会再把此反斜杠删除。

                如果 <a href="options.html#'shell'">'shell'</a> 以 "csh" 结尾，"!" 字符会被转义 (仍是当 <code class="special">{special}</code>
                为  <a href="eval.html#non-zero-arg">non-zero-arg</a>  时)。这是因为 csh 和 tcsh 即使在单引号内仍然
                使用 "!" 用于历史替换。

                如果 <code class="special">{special}</code> 为  <a href="eval.html#non-zero-arg">non-zero-arg</a> ，<code class="special">&lt;NL&gt;</code> 也被转义。<a href="options.html#'shell'">'shell'</a> 以
                "csh" 结尾时，转义两次。

                <a href="options.html#'shell'">'shell'</a> 以 "fish" 结尾时，"\" 字符被转义。这是因为 fish 把 "\"
                作为单引号内的转义字符。

                 <a href="various.html#:!">:!</a>  命令的示例: 
<code class="example">                    :exe '!dir ' .. shellescape(expand('&lt;cfile&gt;'), 1)</code>
                返回光标所在文件给出的目录列表。 <a href="builtin.html#system()">system()</a>  的示例: 
<code class="example">                    :call system("chmod +w -- " .. shellescape(expand("%")))</code>
                另见  <a href="cmdline.html#::S">::S</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCommand()-&gt;shellescape()</code>

                返回类型:  <a href="eval.html#String">String</a> 


shiftwidth([<code class="special">{col}</code>])                                     <b class="vimtag"> <a name="shiftwidth()">shiftwidth()</a> </b>
                返回 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 的有效值。即 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 值，除非其为零时则
                返回 <a href="options.html#'tabstop'">'tabstop'</a> 的值。此函数是 2012 年 7.3.694 补丁版本引入的，
                现在应该大家都有了 (不过可选的 <code class="special">{col}</code> 参数是 8.1.542 以后才有
                的)。

                给出一个参数 <code class="special">{col}</code> 时，指定列号，返回它所用的 <a href="options.html#'shiftwidth'">'shiftwidth'</a>
                值。这和 <a href="options.html#'vartabstop'">'vartabstop'</a> 特性有关。如果打开 <a href="options.html#'vartabstop'">'vartabstop'</a> 设置没有
                给出 <code class="special">{col}</code>，假定为列 1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetColumn()-&gt;shiftwidth()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

sign_ 函数文档在这里:  <a href="sign.html#sign-functions-details">sign-functions-details</a> 。


simplify(<code class="special">{filename}</code>)                                    <b class="vimtag"> <a name="simplify()">simplify()</a> </b>
                在不改变含义的前提下，尽可能简化文件名。快捷方式 (MS-Windows
                上) 或者符号链接 (Unix 上) 不会被解析。如果 <code class="special">{filename}</code> 第一个
                路径部分指定了当前目录，结果也会是如此。而结尾的路径分隔符也不
                会被删除。在 Unix 上 "//path" 不作改动，但 "///path" 被简化为
                "/path" (这符合 posix 规范)。
                示例: 
<code class="example">                        simplify("./dir/.././/file/") == "./file/"</code>
                <code class="note">注意</code>: 组合 "dir/.." 只有在 "dir" 是可以遍历的或者不存在的目录
                才会被删掉。Unix 上，如果 "dir" 是同一目录下的符号链接，也会删
                除该组合。为了在简化路径名之前解析所有牵涉到的符号链接，使用
                 <a href="builtin.html#resolve()">resolve()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;simplify()</code>

                返回类型:  <a href="eval.html#String">String</a> 


sin(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="sin()">sin()</a> </b>
                返回浮点数，即以弧度测量的 <code class="special">{expr}</code> 的正弦值。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回 0.0。
                示例: 
<code class="example">                        :echo sin(100)</code>
                        -0.506366 
<code class="example">                        :echo sin(-4.01)</code>
                        0.763301

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;sin()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


sinh(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="sinh()">sinh()</a> </b>
                返回 <code class="special">{expr}</code> 的双曲正弦值，返回值为 [-inf, inf] 区间内的浮点
                数。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回 0.0。
                示例: 
<code class="example">                        :echo sinh(0.5)</code>
                        0.521095 
<code class="example">                        :echo sinh(-0.9)</code>
                        -1.026517

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;sinh()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


slice(<code class="special">{expr}</code>, <code class="special">{start}</code> [, <code class="special">{end}</code>])                        <b class="vimtag"> <a name="slice()">slice()</a> </b>
                类似  <a href="eval.html#slice">slice</a>  表达式 "expr[start : end]"，但 "end" 的用法是闭
                的。而且对字符串而言，索引使用的是字符索引而不是字节索引，就像
                 <a href="vim9.html#vim9script">vim9script</a>  里的处理方式一样。另外，组合字符被视为前导的基准
                字符的一部分。
                如果 <code class="special">{end}</code> 省略，分片会继续到末项为止。
                如果 <code class="special">{end}</code> 为 -1，则末项会被排除。
                <code class="special">{start}</code> 或 <code class="special">{end}</code> 非法时返回空值。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetList()-&gt;slice(offset)</code>

                返回类型: list&lt;<code class="special">{type}</code>&gt; 或 tuple&lt;<code class="special">{type}</code>&gt;


sort(<code class="special">{list}</code> [, <code class="special">{how}</code> [, <code class="special">{dict}</code>]])                       <b class="vimtag"> <a name="sort()">sort()</a> </b> <b class="vimtag"> <a name="E702">E702</a> </b>
                给 <code class="special">{list}</code> 项目排序，原地直接修改列表。返回 <code class="special">{list}</code>。

                如果你不想修改列表，先构建一个备份: 
<code class="example">                        :let sortedlist = sort(copy(mylist))</code>
<code class="example"></code>
                如果 <code class="special">{how}</code> 省略或为字符串，则 sort() 对每个项目使用字符串表示
                形式进行排序。数值排在字符串之后， <a href="eval.html#List">List</a>  排在数值之后。要给当
                前缓冲区的文本排序，用  <a href="change.html#:sort">:sort</a> 。

                如果给出 <code class="special">{how}</code> 且为 'i'，忽略大小写。老式脚本里为了后向兼容，
                值为一也可用于忽略大小写。零代表不忽略大小写。

                如果给出 <code class="special">{how}</code> 且为 'l'，排序使用当前排序规则 locale。实现细
                节: 用 strcoll() 来进行字符串比较。关于如何查看或设置排序规则
                locale，参见  <a href="mlang.html#:language">:language</a> 。 <a href="eval.html#v:collate">v:collate</a>  也可用于检查当前
                locale。按 locale 的排序通常忽略大小写。示例: 
<code class="example">                        " ö 的排位顺序类似于英语 locale 的 o。</code>
<code class="example">                        :language collate en_US.UTF8</code>
<code class="example">                        :echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')</code>
<code class="section">                        ['n', 'o', 'O', 'ö', 'p', 'z'] </code>

<code class="example">                        " ö 在瑞典 locale 里排在 z 之后。</code>
<code class="example">                        :language collate sv_SE.UTF8</code>
<code class="example">                        :echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')</code>
<code class="section">                        ['n', 'o', 'O', 'p', 'z', 'ö'] </code>
                Mac 上此功能不能正常工作。

                如果给出 <code class="special">{how}</code> 且为 'n'，按数值顺序排序 (实现细节: 用 strtod()
                函数来解析数值。字符串、列表、字典和函数引用均视作 0)。<code class="note">注意</code> 这
                里不能用来排序包含数值的字符串！

                如果给出 <code class="special">{how}</code> 且为 'N'，按数值顺序排序。和 'n' 类似，但包含数
                位的字符串会被当作数值。

                如果给出 <code class="special">{how}</code> 且为 'f'，按数值顺序排序。所有值的类型必须是数
                值或浮点数。

                如果 <code class="special">{how}</code> 为  <a href="eval.html#Funcref">Funcref</a>  或函数名，调用该函数来比较项目。函数调
                用时使用两个项目作为参数，函数返回时，0 代表相等，1 或更高代表
                第一个排在第二个之后，-1 或更小代表第一个排在第二个之前。

                <code class="special">{dict}</code> 用于带 "dict" 属性的函数，并设为局部变量 "self"。
                 <a href="eval.html#Dictionary-function">Dictionary-function</a> 

                排序是稳定的，相同值 (数值或字符串) 的项目保持原有的顺序不变。
                例如，按数值顺序排序时，文本字符串会紧挨在一起，按原先的顺序出
                现。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;sort()</code>
<code class="example"></code>
                另见  <a href="builtin.html#uniq()">uniq()</a> 。

                例如: 
<code class="example">                        func MyCompare(i1, i2)</code>
<code class="example">                           return a:i1 == a:i2 ? 0 : a:i1 &gt; a:i2 ? 1 : -1</code>
<code class="example">                        endfunc</code>
<code class="example">                        eval mylist-&gt;sort("MyCompare")</code>
                对这个简单的例子，有更简短的一个比较版本，不考虑溢出情况: 
<code class="example">                        func MyCompare(i1, i2)</code>
<code class="example">                           return a:i1 - a:i2</code>
<code class="example">                        endfunc</code>
                简单表达式可用匿名函数: 
<code class="example">                        eval mylist-&gt;sort({i1, i2 -&gt; i1 - i2})</code>

                返回类型: list&lt;<code class="special">{type}</code>&gt;


sound_clear()                                           <b class="vimtag"> <a name="sound_clear()">sound_clear()</a> </b>
                停止播放所有声音。

                有些 Linux 系统可能需要 libcanberra-pulse 包，否则声音不会停
                止。

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+sound">+sound</a>  特性才有效}</code>


sound_playevent(<code class="special">{name}</code> [, <code class="special">{callback}</code>])                  <b class="vimtag"> <a name="sound_playevent()">sound_playevent()</a> </b>
                播放 <code class="special">{name}</code> 定义的声音。支持的事件名取决于系统。通常使用的是
                XDG 声音名。Ubuntu 上可以在
                /usr/share/sounds/freedesktop/stereo 中找到。例如: 
<code class="example">                        call sound_playevent('bell')</code>
                MS-Windows 上，<code class="special">{name}</code> 可以是 SystemAsterisk、SystemDefault、
                SystemExclamation、SystemExit、SystemHand、SystemQuestion、
                SystemStart、SystemWelcome 等等。

                <code class="special">{callback}</code> 给出时，在声音结束后调用。首个参数是声音 ID，第二个
                参数是状态:
                        0       声音播放到结束
                        1       声音被中断
                        2       声音启动后出错
                示例: 
<code class="example">                   func Callback(id, status)</code>
<code class="example">                     echomsg "sound " .. a:id .. " finished with " .. a:status</code>
<code class="example">                   endfunc</code>
<code class="example">                   call sound_playevent('bell', 'Callback')</code>
<code class="example"></code>
                MS-Windows: 此函数不支持 <code class="special">{callback}</code>。

                返回声音 ID，可传递给  <a href="builtin.html#sound_stop()">sound_stop()</a> 。
                如果声音不能播放，返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetSoundName()-&gt;sound_playevent()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+sound">+sound</a>  特性才有效}</code>


sound_playfile(<code class="special">{path}</code> [, <code class="special">{callback}</code>])                   <b class="vimtag"> <a name="sound_playfile()">sound_playfile()</a> </b>
                类似于  <a href="builtin.html#sound_playevent()">sound_playevent()</a>  但播放声音文件 <code class="special">{path}</code>。<code class="special">{path}</code> 必须
                是完整路径。Ubuntu 上可以用此命令找可播放的文件: 
<code class="example">                    :!find /usr/share/sounds -type f | grep -v index.theme</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetSoundPath()-&gt;sound_playfile()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+sound">+sound</a>  特性才有效}</code>


sound_stop(<code class="special">{id}</code>)                                        <b class="vimtag"> <a name="sound_stop()">sound_stop()</a> </b>
                停止播放声音 <code class="special">{id}</code>。<code class="special">{id}</code> 必须是之前  <a href="builtin.html#sound_playevent()">sound_playevent()</a>  或
                 <a href="builtin.html#sound_playfile()">sound_playfile()</a>  的返回值。

                有些 Linux 系统可能需要 libcanberra-pulse 包，否则声音不会停
                止。

                MS-Windows 上，本函数不能用于  <a href="builtin.html#sound_playevent()">sound_playevent()</a>  启动的事件声
                音。要停止事件声音，用  <a href="builtin.html#sound_clear()">sound_clear()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        soundid-&gt;sound_stop()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+sound">+sound</a>  特性才有效}</code>


soundfold(<code class="special">{word}</code>)                                       <b class="vimtag"> <a name="soundfold()">soundfold()</a> </b>
                返回 <code class="special">{word}</code> 按发音折叠的等价形式。使用当前窗口的 <a href="options.html#'spelllang'">'spelllang'</a>
                中第一个支持按发音折叠的语言。<a href="options.html#'spell'">'spell'</a> 必须置位。如果不能按发音
                折叠，按原样返回 <code class="special">{word}</code>。
                可用来提供拼写建议。<code class="note">注意</code> 此方法可能很慢。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWord()-&gt;soundfold()</code>

                返回类型:  <a href="eval.html#String">String</a> 


spellbadword([<code class="special">{sentence}</code>])                              <b class="vimtag"> <a name="spellbadword()">spellbadword()</a> </b>
                没有参数: 返回光标所在或之后的拼写错误的单词。光标移动到这个坏
                词的开始处。如果光标行上没有坏词，返回空字符串，不移动光标。

                有参数: 返回 <code class="special">{sentence}</code> 里第一个拼写错误的单词。如果没有拼写错
                误，返回空字符串。

                返回值是两个项目的列表:
                - 错误拼写的单词，或空字符串。
                - 拼写错误的类型:
                        "bad"           拼写错误
                        "rare"          偏僻词
                        "local"         只在其它区域里合法的单词
                        "caps"          单词应该大写开头
                例如: 
<code class="example">                        echo spellbadword("the quik brown fox")</code>
<code class="section">                        [<code class="badlink">'quik'</code>, <code class="badlink">'bad'</code>] </code>

                使用当前窗口的拼写信息和 <a href="options.html#'spelllang'">'spelllang'</a> 的值。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;spellbadword()</code>

                返回类型: list<code class="special">&lt;string&gt;</code>


spellsuggest(<code class="special">{word}</code> [, <code class="special">{max}</code> [, <code class="special">{capital}</code>]])            <b class="vimtag"> <a name="spellsuggest()">spellsuggest()</a> </b>
                返回  <a href="eval.html#List">List</a> ，包含替代 <code class="special">{word}</code> 的拼写建议。
                如果给出 <code class="special">{max}</code>，返回的建议不超过此数目。否则，返回不超过 25 个
                建议。

                如果给出 <code class="special">{capital}</code> 参数且非零，只给出大写开头的拼写建议。
                <a href="options.html#'spellcapcheck'">'spellcapcheck'</a> 匹配后再使用此功能。

                <code class="special">{word}</code> 可以是后跟其它文本的错误拼写单词。这样可以对两个被分开
                的单词进行连接。建议里也包含附加文本，以便你替换整行。

                <code class="special">{word}</code> 也可以是个好词。返回和它类似的单词。建议里不包含 <code class="special">{word}</code>
                自身，但可能会出现其大写开头的形式。

                使用当前窗口的拼写信息、 <a href="options.html#'spelllang'">'spelllang'</a> 和 <a href="options.html#'spellsuggest'">'spellsuggest'</a> 的值。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWord()-&gt;spellsuggest()</code>

                返回类型: list<code class="special">&lt;string&gt;</code> 或 list<code class="special">&lt;any&gt;</code>


split(<code class="special">{string}</code> [, <code class="special">{pattern}</code> [, <code class="special">{keepempty}</code>]])           <b class="vimtag"> <a name="split()">split()</a> </b>
                从 <code class="special">{string}</code> 构造  <a href="eval.html#List">List</a> 。
                如果 <code class="special">{pattern}</code> 省略或为空，用每个空白分隔的字符序列构造一个项
                目。
                否则，在匹配 <code class="special">{pattern}</code> 的地方分割字符串，删除匹配部分的字符。
                <a href="options.html#'ignorecase'">'ignorecase'</a> 此处不适用，要忽略大小写，加上 \c。 <a href="pattern.html#%2F\c">/\c</a> 
                如果列表的首末项目为空，省略它们，除非 <code class="special">{keepempty}</code> 参数给出且
                非零。其它空项目在 <code class="special">{pattern}</code> 匹配至少一个字符或者 <code class="special">{keepempty}</code>
                非零的时候被保留。
                例如: 
<code class="example">                        :let words = split(getline('.'), '\W\+')</code>
                要把字符串分割到每个字符: 
<code class="example">                        :for c in split(mystring, '\zs')</code>
                如果你想保留分隔符，可以在模式尾部用 '\zs': 
<code class="example">                        :echo split('abc:def:ghi', ':\zs')</code>
<code class="section">                        ['abc:', 'def:', <code class="badlink">'ghi'</code>] </code>
                分割首项可能为空的表格: 
<code class="example">                        :let items = split(line, ':', 1)</code>
                逆函数是  <a href="builtin.html#join()">join()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;split()</code>

                返回类型: list<code class="special">&lt;string&gt;</code>


sqrt(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="sqrt()">sqrt()</a> </b>
                返回  <a href="eval.html#Float">Float</a> ，即 <code class="special">{expr}</code> 的非负平方根。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> ，否则返回 0.0。
                如果 <code class="special">{expr}</code> 为负，返回 NaN (Not a Number，非数)。
                示例: 
<code class="example">                        :echo sqrt(100)</code>
                        10.0 
<code class="example">                        :echo sqrt(-4.01)</code>
                        nan
                "nan" 可能不同，取决于系统库。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;sqrt()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


srand([<code class="special">{expr}</code>])                                         <b class="vimtag"> <a name="srand()">srand()</a> </b>
                初始化  <a href="builtin.html#rand()">rand()</a>  用的种子:
                - 如果没给出 <code class="special">{expr}</code>，如果可以，读取 /dev/urandom 并用作种子，
                  否则，用 time(NULL) 也就是 epoch 时间；后者只有秒级精确度。
                - <code class="special">{expr}</code> 给出时必须是数值。用于初始种子值。可用于测试或需要可
                  预测序列的场合。

                示例: 
<code class="example">                        :let seed = srand()</code>
<code class="example">                        :let seed = srand(userinput)</code>
<code class="example">                        :echo rand(seed)</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


state([<code class="special">{what}</code>])                                         <b class="vimtag"> <a name="state()">state()</a> </b>
                返回字符串，包含指示当前状态的字符。主要用于要做一些可能不总是
                安全的操作的回调。大致上，做的事是:
                - 回调使用 state() 检查工作是否安全。
                  是:  马上开始做。
                  否:  加入工作队列，新增  <a href="autocmd.html#SafeState">SafeState</a>  和/或  <a href="autocmd.html#SafeStateAgain">SafeStateAgain</a> 
                       自动命令 ( <a href="autocmd.html#SafeState">SafeState</a>  在顶层触发， <a href="autocmd.html#SafeStateAgain">SafeStateAgain</a>  在处
                       理完信息和回调后触发)。
                - SafeState 或 SafeStateAgain 触发时执行你的自动命令，检查
                   <a href="builtin.html#state()">state()</a>  看看工作现在是否可以了，如果是的话从队列中删除之并
                  执行，如果队列为空也删除自动命令。
                另见  <a href="builtin.html#mode()">mode()</a> 。

                <code class="special">{what}</code> 给出时只加入此字符串中的字符。例如，下例检查屏幕是否有
                滚动: 
<code class="example">                        if state('s') == ''</code>
<code class="example">                           " 屏幕还未滚动</code>

                这些字符指示状态，一般而言指示有东西在忙:
                    m   映射、 <a href="various.html#:normal">:normal</a>  命令、 <a href="builtin.html#feedkeys()">feedkeys()</a>  或庞大的命令进行到
                        中途时
                    o   操作符等待状态，如  <a href="change.html#d">d</a>  之后
                    a   插入模式自动补全激活时
                    x   执行自动命令时
                    w   处于阻塞等待时，如  <a href="channel.html#ch_evalexpr()">ch_evalexpr()</a> 、 <a href="channel.html#ch_read()">ch_read()</a>  或
                         <a href="channel.html#ch_readraw()">ch_readraw()</a>  读入 json 时
                    S   不触发 SafeState 或 SafeStateAgain，如  <a href="motion.html#f">f</a>  或计数之后
                    c   调用了包括定时器在内的回调 (递归时会重复，多至 "ccc")
                    s   屏幕已经为消息滚动过

                返回类型:  <a href="eval.html#String">String</a> 


str2blob(<code class="special">{list}</code> [, <code class="special">{options}</code>])                          <b class="vimtag"> <a name="str2blob()">str2blob()</a> </b>
                返回 blob，把字符串列表 <code class="special">{list}</code> 里的字符转换为字节序列。

                每个列表项目后，在 blob 里加入 <code class="special">&lt;NL&gt;</code> 字节。而字符串里的换行符在
                blob 里转换为 <code class="special">&lt;NUL&gt;</code> 字节。

                <code class="special">{options}</code> 如不提供，使用当前 <a href="options.html#'encoding'">'encoding'</a> 值把字符转换为字节。

                参数 <code class="special">{options}</code> 是  <a href="eval.html#Dict">Dict</a> ，支持以下项目:
                    encoding    构造 blob 前用此编码进行字符转换。
                                值为  <a href="eval.html#String">String</a> 。支持的值见  <a href="mbyte.html#encoding-names">encoding-names</a> 。

                如果字符编码失败，报错且返回空 blob。

                <code class="special">{list}</code> 为空时返回空 blob。

                另见  <a href="builtin.html#blob2str()">blob2str()</a> 

                示例: 
<code class="example">                    str2blob(["ab"])            返回 0z6162</code>
<code class="example">                    str2blob(["«»"])            返回 0zC2ABC2BB</code>
<code class="example">                    str2blob(["a\nb"])          返回 0z610062</code>
<code class="example">                    str2blob(["a","b"])         返回 0z610A62</code>
<code class="example">                    str2blob(["«»"], {'encoding': 'latin1'}) 返回 0zABBB</code>
<code class="example">                    str2blob(readfile('myfile.txt'))</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetListOfStrings()-&gt;str2blob()</code>

                返回类型:  <a href="eval.html#Blob">Blob</a> 


str2float(<code class="special">{string}</code> [, <code class="special">{quoted}</code>])                        <b class="vimtag"> <a name="str2float()">str2float()</a> </b>
                把字符串 <code class="special">{string}</code> 转换为浮点数。这和使用浮点数的工作方式一样，
                见  <a href="eval.html#floating-point-format">floating-point-format</a> ，但稍稍宽松一点。例如，接受
                "1e40"，而表达式中你必须书写 "1.0e40"。也接受十六进制形式
                "0x123"，但其它的如二进制或八进制不行。
                如果 <code class="special">{quoted}</code> 存在且非零，忽略小数点之前的内嵌单引号，也就是
                "1'000.0" 等于一千。
                安静地忽略数值之后的文本。
                小数点必须是 '.'，和当前的 locale 无关。逗号会使数值转换结束:
                "12,345.67" 转换为 12.0。用  <a href="builtin.html#substitute()">substitute()</a>  可以拿掉千分位分
                隔符: 
<code class="example">                        let f = str2float(substitute(text, ',', '', 'g'))</code>

                如果转换失败，返回 0.0。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        let f = text-&gt;substitute(',', '', 'g')-&gt;str2float()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


str2list(<code class="special">{string}</code> [, <code class="special">{utf8}</code>])                           <b class="vimtag"> <a name="str2list()">str2list()</a> </b>
                返回包含代表字符串 <code class="special">{string}</code> 中的每个字符数值的列表。例如: 
<code class="example">                        str2list(" ")           返回 [32]</code>
<code class="example">                        str2list("ABC")         返回 [65, 66, 67]</code>
                 <a href="builtin.html#list2str()">list2str()</a>  是逆操作。

                <code class="special">{utf8}</code> 省略或为零时，使用当前 <a href="options.html#'encoding'">'encoding'</a>。
                <code class="special">{utf8}</code> 为 TRUE 时，总是把字符串当作 UTF-8 字符。
                使用 UTF-8 时，组合字符正常工作: 
<code class="example">                        str2list("á")         返回 [97, 769]</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;str2list()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


str2nr(<code class="special">{string}</code> [, <code class="special">{base}</code> [, <code class="special">{quoted}</code>]])                <b class="vimtag"> <a name="str2nr()">str2nr()</a> </b>
                把字符串 <code class="special">{string}</code> 转化为数值。
                <code class="special">{base}</code> 是转换的基底，可以为 2、8、10 或 16。
                给出 <code class="special">{quoted}</code> 且非零时，忽略内嵌的单引号，所以 "1'000'000" 是
                一百万。

                如果省略 <code class="special">{base}</code>，使用基底 10。这也意味着开头的零不会导致八进制
                的转换，缺省的字符串到数值的转化并非如此。例如: 
<code class="example">                        let nr = str2nr('0123')</code>

                如果 <code class="special">{base}</code> 为 16，忽略开头的 "0x" 或 "0X"。如果使用别的基底，
                返回零。类似的，如果 <code class="special">{base}</code> 为 8，忽略开头的 "0"、"0o" 或
                "0O"，如果 <code class="special">{base}</code> 为 2，忽略开头的 "0b" 或 "0B"。
                安静地忽略数值之后的文本。

                如果 <code class="special">{string}</code> 为空或出错，返回 0。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;str2nr()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


strcharlen(<code class="special">{string}</code>)                                    <b class="vimtag"> <a name="strcharlen()">strcharlen()</a> </b>
                返回数值，给出字符串 <code class="special">{string}</code> 中的字符数。忽略组合字符。
                 <a href="builtin.html#strchars()">strchars()</a>  可计算组合字符分别计算的字符数目。

                如果 <code class="special">{string}</code> 为空或出错，返回 0。

                另见  <a href="builtin.html#strlen()">strlen()</a> 、 <a href="builtin.html#strdisplaywidth()">strdisplaywidth()</a>  和  <a href="builtin.html#strwidth()">strwidth()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;strcharlen()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


strcharpart(<code class="special">{src}</code>, <code class="special">{start}</code> [, <code class="special">{len}</code> [, <code class="special">{skipcc}</code>]])      <b class="vimtag"> <a name="strcharpart()">strcharpart()</a> </b>
                和  <a href="builtin.html#strpart()">strpart()</a>  类似，但用字符索引和长度而不是字节索引和长度。
                <code class="special">{skipcc}</code> 省略或为零时，组合字符也算一个字符。
                <code class="special">{skipcc}</code> 设为 1 时，组合字符被视作前导的基准字符的一部分，这和
                 <a href="builtin.html#slice()">slice()</a>  类似。
                使用字符索引时如果字符不存在，返回值里忽略之但算作一个字符。例
                如: 
<code class="example">                        strcharpart('abc', -1, 2)</code>
                返回 'a'。

                出错时返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;strcharpart(5)</code>

                返回类型:  <a href="eval.html#String">String</a> 


strchars(<code class="special">{string}</code> [, <code class="special">{skipcc}</code>])                         <b class="vimtag"> <a name="strchars()">strchars()</a> </b>
                返回数值，给出字符串 <code class="special">{string}</code> 中的字符数。
                <code class="special">{skipcc}</code> 省略或为零时，组合字符也算一个字符。
                <code class="special">{skipcc}</code> 设为 1 时，计算时忽略组合字符。
                 <a href="builtin.html#strcharlen()">strcharlen()</a>  的行为总是如此。

                出错时返回零。

                另见  <a href="builtin.html#strlen()">strlen()</a> 、 <a href="builtin.html#strdisplaywidth()">strdisplaywidth()</a>  和  <a href="builtin.html#strwidth()">strwidth()</a> 。

                <code class="special">{skipcc}</code> 只在 7.4.755 之后才出现。为了后向兼容，可以这样定义
                包装函数: 
<code class="example">                    if has("patch-7.4.755")</code>
<code class="example">                      function s:strchars(str, skipcc)</code>
<code class="example">                        return strchars(a:str, a:skipcc)</code>
<code class="example">                      endfunction</code>
<code class="example">                    else</code>
<code class="example">                      function s:strchars(str, skipcc)</code>
<code class="example">                        if a:skipcc</code>
<code class="example">                          return strlen(substitute(a:str, ".", "x", "g"))</code>
<code class="example">                        else</code>
<code class="example">                          return strchars(a:str)</code>
<code class="example">                        endif</code>
<code class="example">                      endfunction</code>
<code class="example">                    endif</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;strchars()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


strdisplaywidth(<code class="special">{string}</code> [, <code class="special">{col}</code>])                     <b class="vimtag"> <a name="strdisplaywidth()">strdisplaywidth()</a> </b>
                返回数值，给出字符串 <code class="special">{string}</code> 在 <code class="special">{col}</code> 开始时在屏幕上占据的显
                示单元的数目 (首列为零)。<code class="special">{col}</code> 省略时假定为零。否则给出开始计
                算的屏幕列号。该值对制表符的计算有影响。
                使用当前窗口的选项设置。其中影响显示的选项也对返回值有影响，如
                <a href="options.html#'tabstop'">'tabstop'</a> 和 <a href="options.html#'display'">'display'</a>。
                <code class="special">{string}</code> 如包含东亚二义性宽度字符类，<a href="options.html#'ambiwidth'">'ambiwidth'</a> 也会影响返回
                结果。
                出错时返回零。
                另见  <a href="builtin.html#strlen()">strlen()</a> 、 <a href="builtin.html#strwidth()">strwidth()</a>  和  <a href="builtin.html#strchars()">strchars()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;strdisplaywidth()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


strftime(<code class="special">{format}</code> [, <code class="special">{time}</code>])                           <b class="vimtag"> <a name="strftime()">strftime()</a> </b>
                返回字符串，即经过 <code class="special">{format}</code> 字符串的格式转换的日期和时间。使用
                给定的 <code class="special">{time}</code>，如果没有给出时间，使用当前时间。可以接受的
                <code class="special">{format}</code> 取决于你的系统。这意味着该函数不是可移植的！
                可用的格式参见 C 函数 strftime() 的参考手册。返回结果的最大长
                度是 80 个字符。另见  <a href="builtin.html#localtime()">localtime()</a> 、 <a href="builtin.html#getftime()">getftime()</a>  和
                 <a href="builtin.html#strptime()">strptime()</a> 。
                可以用  <a href="mlang.html#:language">:language</a>  命令改变语言。
                示例: 
<code class="example">                  :echo strftime("%c")             Sun Apr 27 11:49:23 1997</code>
<code class="example">                  :echo strftime("%Y %b %d %X")    1997 Apr 27 11:53:25</code>
<code class="example">                  :echo strftime("%y%m%d %T")      970427 11:53:55</code>
<code class="example">                  :echo strftime("%H:%M")          11:55</code>
<code class="example">                  :echo strftime("%c", getftime("file.c"))</code>
<code class="example">                                                   显示 file.c 的修改时间。</code>
                并非所有系统都可以用。要检查这一点，用: 
<code class="example">                        :if exists("*strftime")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFormat()-&gt;strftime()</code>

                返回类型:  <a href="eval.html#String">String</a> 


strgetchar(<code class="special">{str}</code>, <code class="special">{index}</code>)                              <b class="vimtag"> <a name="strgetchar()">strgetchar()</a> </b>
                获取 <code class="special">{str}</code> 中的第 <code class="special">{index}</code> 个字符对应的数值。使用以零为基底的字
                符索引而不是字节索引。这里，组合字符当作单独的字符。
                 <a href="builtin.html#nr2char()">nr2char()</a>  可用来把数值转换为字符串。
                <code class="special">{index}</code> 非法时返回 -1。
                另见  <a href="builtin.html#strcharpart()">strcharpart()</a>  和  <a href="builtin.html#strchars()">strchars()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;strgetchar(5)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


stridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])                <b class="vimtag"> <a name="stridx()">stridx()</a> </b>
                返回数值，给出字符串 <code class="special">{haystack}</code> 里第一个字符串 <code class="special">{needle}</code> 出现的
                字节位置。
                如果给出 <code class="special">{start}</code>，搜索从 <code class="special">{start}</code> 位置开始。可用来寻找第二个匹
                配: 
<code class="example">                        :let colon1 = stridx(line, ":")</code>
<code class="example">                        :let colon2 = stridx(line, ":", colon1 + 1)</code>
                搜索对大小写敏感。
                模式搜索可用  <a href="builtin.html#match()">match()</a> 。
                如果 <code class="special">{needle}</code> 不出现在 <code class="special">{haystack}</code> 里，返回 -1。
                另见  <a href="builtin.html#strridx()">strridx()</a> 。示例: 
<code class="example">                  :echo stridx("An Example", "Example")      3</code>
<code class="example">                  :echo stridx("Starting point", "Start")    0</code>
<code class="example">                  :echo stridx("Starting point", "start")   -1</code>
                                                        <b class="vimtag"> <a name="strstr()">strstr()</a> </b> <b class="vimtag"> <a name="strchr()">strchr()</a> </b>
                stridx() 和 C 函数 strstr() 类似。如果使用单个字符，和
                strchr() 类似。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetHaystack()-&gt;stridx(needle)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


string(<code class="special">{expr}</code>)                                          <b class="vimtag"> <a name="string()">string()</a> </b>
                返回 <code class="special">{expr}</code> 转换后的字符串。如果 <code class="special">{expr}</code> 为数值、浮点数、字符
                串、blob 或它们的复合形式，那么用  <a href="builtin.html#eval()">eval()</a>  可以把结果转回去。
<code class="section">                        <code class="special">{expr}</code> 类型     返回值 </code>
                        字符串          <code class="badlink">'string'</code> (单引号加倍)
                        数值            123
                        浮点数          123.123456 或 1.23456e8
                        函数引用        function(<code class="badlink">'name'</code>)
                        blob            0z00112233.44556677.8899
                        列表            [item, item]
                        元组            (item, item)
                        字典            {key: value, key: value}
                        类              class SomeName
                        对象            object of SomeName {lnum: 1, col: 3}
                        枚举            enum Enumname
                        枚举值          enum name.value {name: str,
                                        ordinal: nr}

                 <a href="eval.html#List">List</a> 、 <a href="eval.html#Tuple">Tuple</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  中如有递归引用，被替换为
                "[...]"、"(...)" 或 "<code class="special">{...}</code>"。在此结果上运行  <a href="builtin.html#eval()">eval()</a>  会出错。

                对对象而言，调用 string() 方法以得到对象的文本表示。如果此方法
                不存在，使用缺省表示。  <a href="vim9class.html#object-string()">object-string()</a> 

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;string()</code>
<code class="example"></code>
                另见  <a href="builtin.html#strtrans()">strtrans()</a> 。

                返回类型:  <a href="eval.html#String">String</a> 


strlen(<code class="special">{string}</code>)                                        <b class="vimtag"> <a name="strlen()">strlen()</a> </b>
                返回数值，即字符串 <code class="special">{string}</code> 的字节长度。
                如果参数为数值，先把它转化为字符串。
                其它类型报错并返回零。
                要计算多字节字符的数目，可用  <a href="builtin.html#strchars()">strchars()</a> 。
                另见  <a href="builtin.html#len()">len()</a> 、 <a href="builtin.html#strdisplaywidth()">strdisplaywidth()</a>  和  <a href="builtin.html#strwidth()">strwidth()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;strlen()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


strpart(<code class="special">{src}</code>, <code class="special">{start}</code> [, <code class="special">{len}</code> [, <code class="special">{chars}</code>]])           <b class="vimtag"> <a name="strpart()">strpart()</a> </b>
                返回字符串，<code class="special">{src}</code> 从第 <code class="special">{start}</code> 个字节开始字节长度为 <code class="special">{len}</code> 的子
                串。
                <code class="special">{chars}</code> 存在且为 TRUE 时，<code class="special">{len}</code> 为字符位置的个数 (组合字符不单
                独统计，因此 "1" 代表一个基本字符并可后跟任意的组合字符)。
                要以字符而不是字节计算 <code class="special">{start}</code>，用  <a href="builtin.html#strcharpart()">strcharpart()</a> 。

                如果选择不存在的字节，不会产生错误。只是那些字节被忽略而已。
                如果没有提供 <code class="special">{len}</code>，子串从 <code class="special">{start}</code> 开始直到 <code class="special">{src}</code> 的结尾。 
<code class="example">                        strpart("abcdefg", 3, 2)    == "de"</code>
<code class="example">                        strpart("abcdefg", -2, 4)   == "ab"</code>
<code class="example">                        strpart("abcdefg", 5, 4)    == "fg"</code>
<code class="example">                        strpart("abcdefg", 3)       == "defg"</code>
<code class="example"></code>
                <code class="note">注意</code>: 要得到第一个字符，<code class="special">{start}</code> 必须是零。比如，要得到光标所在
                的字符: 
<code class="example">                        strpart(getline("."), col(".") - 1, 1, v:true)</code>

                出错时返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;strpart(5)</code>

                返回类型:  <a href="eval.html#String">String</a> 


strptime(<code class="special">{format}</code>, <code class="special">{timestring}</code>)                        <b class="vimtag"> <a name="strptime()">strptime()</a> </b>
                返回数值，代表期待能匹配 <code class="special">{format}</code> 指定格式的 <code class="special">{timestring}</code> 中的
                日期和时间的 unix 时间戳。

                可接受的 <code class="special">{format}</code> 取决于系统，所以不可移植！具体格式见 C 函数
                strptime() 的手册页。特别要<code class="note">注意</code>避免 "%c"。$TZ 的值也相关。

                如果 <code class="special">{timestring}</code> 不能用 <code class="special">{format}</code> 格式解析，返回零。如果不知道
                <code class="special">{timestring}</code> 的格式，可以尝试不同的 <code class="special">{format}</code> 值直到返回非零值
                为止。

                另见  <a href="builtin.html#strftime()">strftime()</a> 。
                示例: 
<code class="example">                  :echo strptime("%Y %b %d %X", "1997 Apr 27 11:49:23")</code>
                  862156163 
<code class="example">                  :echo strftime("%c", strptime("%y%m%d %T", "970427 11:53:55"))</code>
                  Sun Apr 27 11:53:55 1997 
<code class="example">                  :echo strftime("%c", strptime("%Y%m%d%H%M%S", "19970427115355") + 3600)</code>
                  Sun Apr 27 12:53:55 1997

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFormat()-&gt;strptime(timestring)</code>

                不是在所有系统都可用。要确认: 
<code class="example">                        :if exists("*strptime")</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


strridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])               <b class="vimtag"> <a name="strridx()">strridx()</a> </b>
                返回数值，给出字符串 <code class="special">{haystack}</code> 里最后一个字符串 <code class="special">{needle}</code> 出现
                的字节位置。
                如果给出 <code class="special">{start}</code>，此位置之外的匹配被忽略。可用来寻找上次匹配之
                前的匹配: 
<code class="example">                        :let lastcomma = strridx(line, ",")</code>
<code class="example">                        :let comma2 = strridx(line, ",", lastcomma - 1)</code>
                搜索对大小写敏感。
                模式搜索可用  <a href="builtin.html#match()">match()</a> 。
                如果 <code class="special">{needle}</code> 不出现在 <code class="special">{haystack}</code> 里，返回 -1。
                如果 <code class="special">{needle}</code> 为空，返回 <code class="special">{haystack}</code> 的长度。
                另见  <a href="builtin.html#stridx()">stridx()</a> 。示例: 
<code class="example">                  :echo strridx("an angry armadillo", "an")          3</code>
                                                        <b class="vimtag"> <a name="strrchr()">strrchr()</a> </b>
                如果使用单个字符，和 C 函数 strrchr() 类似。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetHaystack()-&gt;strridx(needle)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


strtrans(<code class="special">{string}</code>)                                      <b class="vimtag"> <a name="strtrans()">strtrans()</a> </b>
                返回等于 <code class="special">{string}</code> 的字符串，但所有的不可显示字符被翻译成可显示
                的字符序列 <a href="options.html#'isprint'">'isprint'</a>，类似于窗口里显示的形式。例如: 
<code class="example">                        echo strtrans(@a)</code>
                会显示寄存器里的换行符为 "^@" 而不是开启新行。

                出错时返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;strtrans()</code>

                返回类型:  <a href="eval.html#String">String</a> 


strutf16len(<code class="special">{string}</code> [, <code class="special">{countcc}</code>])                     <b class="vimtag"> <a name="strutf16len()">strutf16len()</a> </b>
                返回数值，给出字符串 <code class="special">{string}</code> (转换为 utf-16 后) utf-16 代码单
                元数。

                <code class="special">{countcc}</code> 为真时，组合字符单独计算。
                <code class="special">{countcc}</code> 忽略或为假时，忽略组合字符。

                出错时返回零。

                另见  <a href="builtin.html#strlen()">strlen()</a>  和  <a href="builtin.html#strcharlen()">strcharlen()</a> 。
                示例: 
<code class="example">                    echo strutf16len('a')               返回 1</code>
<code class="example">                    echo strutf16len('©')               返回 1</code>
<code class="example">                    echo strutf16len('😊')              返回 2</code>
<code class="example">                    echo strutf16len('ą́')           返回 1</code>
<code class="example">                    echo strutf16len('ą́', v:true)   返回 3</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        gettext()-&gt;strutf16len()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


strwidth(<code class="special">{string}</code>)                                      <b class="vimtag"> <a name="strwidth()">strwidth()</a> </b>
                返回数值，给出字符串 <code class="special">{string}</code> 在屏幕上占据的显示单元的数目。制
                表符算作一个单元。如果不想这样，可用  <a href="builtin.html#strdisplaywidth()">strdisplaywidth()</a> 。
                <code class="special">{string}</code> 如包含东亚二义性宽度字符类，<a href="options.html#'ambiwidth'">'ambiwidth'</a> 也会影响返回
                结果。
                出错时返回零。
                另见  <a href="builtin.html#strlen()">strlen()</a> 、 <a href="builtin.html#strdisplaywidth()">strdisplaywidth()</a>  和  <a href="builtin.html#strchars()">strchars()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;strwidth()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


submatch(<code class="special">{nr}</code> [, <code class="special">{list}</code>])                               <b class="vimtag"> <a name="submatch()">submatch()</a> </b> <b class="vimtag"> <a name="E935">E935</a> </b>
                只用于  <a href="change.html#:substitute">:substitute</a>  命令或  <a href="builtin.html#substitute()">substitute()</a>  函数中的表达式内。
                返回匹配文本的第 <code class="special">{nr}</code> 个子匹配。<code class="special">{nr}</code> 为 0 则返回整个匹配的文
                本。
                <code class="note">注意</code> 字符串中的 NL 既可以代表多行匹配的行尾，也可以是文件中的
                NUL 字符。
                另见  <a href="change.html#sub-replace-expression">sub-replace-expression</a> 。

                如果给出 <code class="special">{list}</code> 且非零，submatch() 返回字符串的列表，和带两个
                参数的  <a href="builtin.html#getline()">getline()</a>  类似。文本中的 NL 代表文件中的 NUL 字符。
                只在  <a href="change.html#:substitute">:substitute</a>  中可能返回多于一个项目， <a href="builtin.html#substitute()">substitute()</a>  中此
                列表总是包含一个或零个项目，因为没有真正的行尾。

                递归使用  <a href="builtin.html#substitute()">substitute()</a>  时，只能得到当前 (最深的) 调用的子匹
                配。

                出错时返回空字符串或空列表。

                例如: 
<code class="example">                        :s/\d\+/\=submatch(0) + 1/</code>
<code class="example">                        :echo substitute(text, '\d\+', '\=submatch(0) + 1', '')</code>
                找到行内第一个数值并加 1。
                使用 <code class="special">&lt;NL&gt;</code> 可以包含换行符。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetNr()-&gt;submatch()</code>

                返回类型:  <a href="eval.html#String">String</a>  或 list<code class="special">&lt;string&gt;</code>，取决于 <code class="special">{list}</code>


substitute(<code class="special">{string}</code>, <code class="special">{pat}</code>, <code class="special">{sub}</code>, <code class="special">{flags}</code>)             <b class="vimtag"> <a name="substitute()">substitute()</a> </b>
                返回相当于 <code class="special">{string}</code> 的字符串，但其中 <code class="special">{pat}</code> 的首个匹配被替代成
                <code class="special">{sub}</code>。
                如果 <code class="special">{flags}</code> 为 "g"，替换 <code class="special">{string}</code> 里的所有 <code class="special">{pat}</code> 匹配。否则，
                <code class="special">{flags}</code> 应该为 ""。

                和 ":substitute" 命令 (不带任何标志位) 类似。但此处 <code class="special">{pat}</code> 的匹
                配总假定 <a href="options.html#'magic'">'magic'</a> 选项已置位且 <a href="options.html#'cpoptions'">'cpoptions'</a> 为空 (为了脚本的可移
                植性)。
                <a href="options.html#'ignorecase'">'ignorecase'</a> 仍然适用， <a href="pattern.html#%2F\c">/\c</a>  或  <a href="pattern.html#%2F\C">/\C</a>  可用来直接指定是否忽略或
                匹配大小写并忽略 <a href="options.html#'ignorecase'">'ignorecase'</a> 的设置。
                <a href="options.html#'smartcase'">'smartcase'</a> 此处不适用。
                 <a href="builtin.html#string-match">string-match</a>  说明如何使用 <code class="special">{pat}</code>。

                <code class="special">{sub}</code> 里的 '~' 不会被换成前一个 <code class="special">{sub}</code>。
                <code class="note">注意</code> <code class="special">{sub}</code> 里的一些代码有特殊含义  <a href="change.html#sub-replace-special">sub-replace-special</a> 。比
                如，要替换若干文本为 "\n" (两个字符)，要用 "\\\\n" 或 '\\n'。

                如果 <code class="special">{pat}</code> 在 <code class="special">{string}</code> 里不能匹配，返回没有修改的 <code class="special">{string}</code>。

                示例: 
<code class="example">                   :let &amp;path = substitute(&amp;path, ",\\=[^,]*$", "", "")</code>
                删除 <a href="options.html#'path'">'path'</a> 选项的最后一部分。 
<code class="example">                   :echo substitute("testing", ".*", "\\U\\0", "")</code>
                返回 "TESTING"。

                <code class="special">{sub}</code> 参数以 \= 开始时，其余部分视为一个表达式，见
                 <a href="change.html#sub-replace-expression">sub-replace-expression</a> 。示例: 
<code class="example">                   :echo substitute(s, '%\(\x\x\)',</code>
<code class="example">                           \ '\=nr2char("0x" .. submatch(1))', 'g')</code>
<code class="example"></code>
                <code class="special">{sub}</code> 若是函数引用，调用该函数，带一个可选参数。示例: 
<code class="example">                   :echo substitute(s, '%\(\x\x\)', SubNr, 'g')</code>
                可选参数是包含完整匹配及多达九个子匹配的列表，就像
                 <a href="builtin.html#submatch()">submatch()</a>  的返回值那样。示例: 
<code class="example">                   :echo substitute(s, '%\(\x\x\)', {m -&gt; '0x' .. m[1]}, 'g')</code>
<code class="example"></code>
                出错时返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;substitute(pat, sub, flags)</code>

                返回类型:  <a href="eval.html#String">String</a> 


swapfilelist()                                          <b class="vimtag"> <a name="swapfilelist()">swapfilelist()</a> </b>
                返回交换文件名的列表，就像 "vim -r" 显示的那样。参见  <a href="starting.html#-r">-r</a>  命令
                参数。<a href="options.html#'directory'">'directory'</a> 选项指定检视的目录。如果只想看到当前目录下的
                交换文件，可临时设置 <a href="options.html#'directory'">'directory'</a> 为点号: 
<code class="example">                        let save_dir = &amp;directory</code>
<code class="example">                        let &amp;directory = '.'</code>
<code class="example">                        let swapfiles = swapfilelist()</code>
<code class="example">                        let &amp;directory = save_dir</code>

                返回类型: list<code class="special">&lt;string&gt;</code>


swapinfo(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="swapinfo()">swapinfo()</a> </b>
                返回字曲，保存关于交换文件 <code class="special">{fname}</code> 的信息。可用的域是:
                        version Vim 版本
                        user    用户名
                        host    主机名
                        fname   原始文件名
                        pid     创建交换文件的 Vim 进程的 PID
                        mtime   以秒计的最近修改时间
                        inode   可选: 文件的 INODE 值
                        dirty   如果文件修改过为 1，否则为 0
                <code class="note">注意</code> "user" 和 "host" 被缩短为最多 39 个字节。如果失败，加入
                "error" 项目说明相关原因:
                        Cannot open file: 文件找不到或不能访问
                        Cannot read file: 不能读入首块
                        Not a swap file: 没有包含正确的块 ID
                        Magic number mismatch: 首块的信息不正确

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;swapinfo()</code>

                返回类型: dict<code class="special">&lt;any&gt;</code> 或 dict<code class="special">&lt;string&gt;</code>


swapname(<code class="special">{buf}</code>)                                         <b class="vimtag"> <a name="swapname()">swapname()</a> </b>
                返回缓冲区 <code class="special">{buf}</code> 所用的交换文件路径。
                <code class="special">{buf}</code> 的使用方式见上  <a href="builtin.html#bufname()">bufname()</a> 。
                如果缓冲区 <code class="special">{buf}</code> 是当前缓冲区，结果相当于  <a href="recover.html#:swapname">:swapname</a>  (除非没
                有交换文件)。
                如果缓冲区 <code class="special">{buf}</code> 无交换文件，返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufname()-&gt;swapname()</code>

                返回类型:  <a href="eval.html#String">String</a> 


synID(<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{trans}</code>)                           <b class="vimtag"> <a name="synID()">synID()</a> </b>
                返回数值，即当前窗口 <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列所在的语法 ID。
                语法 ID  可以用在  <a href="builtin.html#synIDattr()">synIDattr()</a>  和  <a href="builtin.html#synIDtrans()">synIDtrans()</a> ，以得到文本
                的语法信息。

                最左列的 <code class="special">{col}</code> 为 1。第一行的 <code class="special">{lnum}</code> 为 1。适用 <a href="options.html#'synmaxcol'">'synmaxcol'</a> 的
                值，如果行比它更长，就返回零。
                <code class="note">注意</code> 位置在最后一个字符之后是插入模式下可能的光标位置。此时，
                synID() 返回零。<code class="special">{lnum}</code> 的用法见  <a href="builtin.html#getline()">getline()</a> 。

                如果 <code class="special">{trans}</code> 为  <a href="eval.html#TRUE">TRUE</a> ，透明的项目被简约为它们实际显露的项目。
                这可以用于你想知道实际使用的颜色的情形。如果 <code class="special">{trans}</code> 为
                 <a href="eval.html#FALSE">FALSE</a> ，返回透明的项目本身。这可用于想知道实际有效的语法项目
                的情形 (比如，在括号内部)。
                <code class="note">警告</code>: 本函数可能很慢。最佳速度可以通过正向遍历文件获得。

                出错时返回零。

                例如 (回显光标所在的语法项目的名字): 
<code class="example">                        :echo synIDattr(synID(line("."), col("."), 1), "name")</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


synIDattr(<code class="special">{synID}</code>, <code class="special">{what}</code> [, <code class="special">{mode}</code>])                   <b class="vimtag"> <a name="synIDattr()">synIDattr()</a> </b>
                返回字符串，syntax ID <code class="special">{synID}</code> 的 <code class="special">{what}</code> 属性。可用于得到语法项
                目的相关信息。
                <code class="special">{mode}</code> 可以是 "gui"、"cterm" 或 "term"，从而得到的是该模式下的
                属性。如果忽略 <code class="special">{mode}</code> 或者指定了非法的值，使用当前激活的高亮方
                式的属性 (GUI、cterm 或 term)。
                使用  <a href="builtin.html#synIDtrans()">synIDtrans()</a>  来跟随链接的高亮组。
<code class="section">                <code class="special">{what}</code>          结果 </code>
                "name"          语法项目的名字
                "fg"            前景色 (GUI: 用于设置颜色的色彩名，cterm: 色彩
                                号，以字符串形式出现，term: 空字符串)
                "bg"            背景色 (细节同 "fg")
                "font"          字体名 (只适用于 GUI)  <a href="syntax.html#highlight-font">highlight-font</a> 
                "sp"            用于 GUI 的特殊颜色 (细节同 "fg")
                                 <a href="syntax.html#highlight-guisp">highlight-guisp</a> 
                "ul"            用于 cterm 的下划线颜色: 字符串形式出现的数值
                "fg#"           类似于 "fg"，但只适用于 GUI，而且 GUI 使用的名
                                字形如 "#RRGGBB"。
                "bg#"           "bg"，细节同 "fg#"
                "sp#"           "sp"，细节同 "fg#"
                "bold"          "1" 如果粗体
                "italic"        "1" 如果斜体
                "reverse"       "1" 如果反显
                "inverse"       "1" 如果反显 (= reverse)
                "standout"      "1" 如果突出
                "underline"     "1" 如果下划线
                "undercurl"     "1" 如果下曲线
                "strike"        "1" 如果删除线
                "nocombine"     "1" 如果指定了 nocombine

                出错时返回空串。

                示例 (回显光标所在的语法项目的颜色): 
<code class="example">        :echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">        :echo synID(line("."), col("."), 1)-&gt;synIDtrans()-&gt;synIDattr("fg")</code>

                返回类型:  <a href="eval.html#String">String</a> 


synIDtrans(<code class="special">{synID}</code>)                                     <b class="vimtag"> <a name="synIDtrans()">synIDtrans()</a> </b>
                返回数值，即 <code class="special">{synID}</code> 经过翻译的语法 ID。这是用于高亮字符的语法
                组的 ID。":highlight link" 给出的高亮组被跟随，以找到实际使用
                的组。

                出错时返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">        :echo synID(line("."), col("."), 1)-&gt;synIDtrans()-&gt;synIDattr("fg")</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


synconcealed(<code class="special">{lnum}</code>, <code class="special">{col}</code>)                             <b class="vimtag"> <a name="synconcealed()">synconcealed()</a> </b>
                返回  <a href="eval.html#List">List</a> ，目前包含三个值:
                1. 如果 <code class="special">{lnum}</code> 和 <code class="special">{col}</code> 所在位置的字符不在可隐藏区域，列表的第
                   一个项目为 0，否则为 1。<code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。
                2. 列表的第二个项目为字符串。如果第一个值为 1，第二个值包含代
                   替被隐藏文本实际显示的文本，视乎 <a href="options.html#'conceallevel'">'conceallevel'</a> 和
                   <a href="options.html#'listchars'">'listchars'</a> 的当前值而定。
                3. 列表的第三个，也即最后一个项目是代表匹配的特定语法区域的唯
                   一的数值。这用于在有两个连续的使用相同替代字符的区域时，检
                   测此处是否是一个新的可隐藏区域的开始。例如，如果文本是
                   "123456"，"23" 和 "45" 都被隐藏，而替代字符是 "X"，则:
<code class="section">                        call                    returns </code>
                        synconcealed(lnum, 1)   [0, '', 0]
                        synconcealed(lnum, 2)   [1, 'X', 1]
                        synconcealed(lnum, 3)   [1, 'X', 1]
                        synconcealed(lnum, 4)   [1, 'X', 2]
                        synconcealed(lnum, 5)   [1, 'X', 2]
                        synconcealed(lnum, 6)   [0, '', 0]

                <code class="note">注意</code>: 不考虑  <a href="builtin.html#matchadd()">matchadd()</a>  高亮项目，因为语法和匹配高亮是两种不
                同的机制  <a href="pattern.html#syntax-vs-match">syntax-vs-match</a> 。

                返回类型: list<code class="special">&lt;any&gt;</code>


synstack(<code class="special">{lnum}</code>, <code class="special">{col}</code>)                                 <b class="vimtag"> <a name="synstack()">synstack()</a> </b>
                返回  <a href="eval.html#List">List</a> ，即当前窗口在 <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列语法项目的堆栈。
                <code class="special">{lnum}</code> 的用法可见  <a href="builtin.html#getline()">getline()</a> 。列表的每个项目是像  <a href="builtin.html#synID()">synID()</a>  返
                回那样的 ID。
                列表的第一个项目是最外层区域，其后依次是包含在内的项目。末项即
                 <a href="builtin.html#synID()">synID()</a>  返回的项目，除非不是整个项目都被高亮，或者它是一个透
                明项目。
                此函数可用于调试语法文件。
                显示光标所在的语法项目栈的示例: 
<code class="example">                        for id in synstack(line("."), col("."))</code>
<code class="example">                           echo synIDattr(id, "name")</code>
<code class="example">                        endfor</code>
                <code class="special">{lnum}</code> 和 <code class="special">{col}</code> 指定的位置非法时，返回空列表。行末字符之后的位
                置以及空行的第一个位置是合法的位置。

                返回类型: list<code class="special">&lt;number&gt;</code> 或 list<code class="special">&lt;any&gt;</code>


system(<code class="special">{expr}</code> [, <code class="special">{input}</code>])                              <b class="vimtag"> <a name="system()">system()</a> </b> <b class="vimtag"> <a name="E677">E677</a> </b>
                得到外壳命令 <code class="special">{expr}</code>  <a href="eval.html#String">String</a>  形式的输出结果。要得到  <a href="eval.html#List">List</a>  形
                式的输出结果，见  <a href="builtin.html#systemlist()">systemlist()</a> 。

                如果给出 <code class="special">{input}</code> 且为  <a href="eval.html#String">String</a> ，该字符串被写到文件里，并传给外
                壳命令作为标准输入。字符串照原样写入，你需要自己<code class="note">注意</code>使用合适的
                换行符。
                如果给出 <code class="special">{input}</code> 且为  <a href="eval.html#List">List</a> ，它被写到文件里，就像
                 <a href="builtin.html#writefile()">writefile()</a>  带 <code class="special">{binary}</code> 设为 "b" 的工作方式那样 (即，列表项
                目间写入换行符，列表项目内部的换行符改写为 NUL)。
                如果给出 <code class="special">{input}</code> 且为数值，代表已存在的缓冲区的合法缓冲区号，
                逐行将该缓冲区的内容写入文件，每行以 NL 结尾，文本内的 NL 以
                NUL 字符代替。

                不使用管道，也不使用 <a href="options.html#'shelltemp'">'shelltemp'</a> 选项。

                如果加上前缀  <a href="various.html#:silent">:silent</a> ，终端不设为加工 (cooked) 模式。这用于不
                需要用户输入的命令，以避免屏幕上显示多余的字符而需要用
                 <a href="various.html#CTRL-L">CTRL-L</a>  来清除。 
<code class="example">                        :silent let f = system('ls *.vim')</code>

                <code class="note">注意</code>:  <a href="builtin.html#shellescape()">shellescape()</a>  或  <a href="builtin.html#expand()">expand()</a>  的  <a href="cmdline.html#::S">::S</a>  或
                 <a href="builtin.html#fnamemodify()">fnamemodify()</a>  可以转义命令参数里的特殊字符。<code class="special">{expr}</code> 里的换行
                可能会使命令失败。<a href="options.html#'shellquote'">'shellquote'</a> 和 <a href="options.html#'shellxquote'">'shellxquote'</a> 里的字符也可能
                会引起麻烦。
                这不是用来执行交互命令的。

                返回字符串。示例: 
<code class="example">                    :let files = system('ls ' .. shellescape(expand('%:h')))</code>
<code class="example">                    :let files = system('ls ' .. expand('%:h:S'))</code>
<code class="example"></code>
                要使结果更独立于所用的系统，外壳输出的结果被过滤，Macintosh 的
                <code class="special">&lt;CR&gt;</code> 被换成 <code class="special">&lt;NL&gt;</code>，而 DOS 系列的系统上 <code class="special">&lt;CR&gt;</code><code class="special">&lt;NL&gt;</code> 也被换成 <code class="special">&lt;NL&gt;</code>。
                为了避免字符串在 NUL 处被截断，所有的 NUL 的字符被替换为 SOH
                (0x01)。

                使用若干选项，以下面的方法构造要执行的命令:
        <a href="options.html#'shell'">'shell'</a> <a href="options.html#'shellcmdflag'">'shellcmdflag'</a> <a href="options.html#'shellxquote'">'shellxquote'</a> <code class="special">{expr}</code> <a href="options.html#'shellredir'">'shellredir'</a> <code class="special">{tmp}</code> <a href="options.html#'shellxquote'">'shellxquote'</a>
                (<code class="special">{tmp}</code> 是自动生成的一个文件名)。
                Unix 上，<code class="special">{expr}</code> 用大括号包围，以便支持连接的多条命令。

                以加工 ("cooked") 模式执行命令，这样 <code class="keystroke">CTRL-C</code> 可以用来中止命令
                (至少在 Unix 上是如此)。

                返回的错误代码可以在  <a href="eval.html#v:shell_error">v:shell_error</a>  里找到。
                该函数不能运行于  <a href="starting.html#restricted-mode">restricted-mode</a> 。

                <code class="note">注意</code> 上面提到的选项值如有错误，该函数就会失败。使用若干安全代
                理应用时也有报告说它会失败。
                不同于 ":!cmd"，没有自动对改变过的文件的检查。使用
                 <a href="editing.html#:checktime">:checktime</a>  来强制这种检查。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :echo GetCmd()-&gt;system()</code>

                返回类型:  <a href="eval.html#String">String</a> 


systemlist(<code class="special">{expr}</code> [, <code class="special">{input}</code>])                          <b class="vimtag"> <a name="systemlist()">systemlist()</a> </b>
                和  <a href="builtin.html#system()">system()</a>  相同，但返回由行组成的  <a href="eval.html#List">List</a>  (以 NL 分隔的输出
                各部分)，NUL 转换为 NL。输出的工作方式和  <a href="builtin.html#readfile()">readfile()</a>  带
                <code class="special">{binary}</code> 参数设为 "b" 相同，除了结果以 NL 结尾时不会有额外的空
                项目以外。
                <code class="note">注意</code> MS-Windows 上可能会有拖尾的 CR 字符。

                要看到 "echo hello" 和 "echo -n hello" 的区别，参见  <a href="builtin.html#system()">system()</a> 
                和  <a href="builtin.html#split()">split()</a> : 
<code class="example">                        echo system('echo hello')-&gt;split('\n', 1)</code>

                有错时，返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :echo GetCmd()-&gt;systemlist()</code>

                返回类型: list<code class="special">&lt;string&gt;</code>


tabpagebuflist([<code class="special">{arg}</code>])                                 <b class="vimtag"> <a name="tabpagebuflist()">tabpagebuflist()</a> </b>
                返回  <a href="eval.html#List">List</a> ，每个项目是当前标签页里每个窗口相关联的缓冲区的编
                号。
                <code class="special">{arg}</code> 指定使用的标签页的编号。如果省略，使用当前标签页。
                <code class="special">{arg}</code> 非法时返回数值零。
                要得到所有标签页里的所有缓冲区的列表，这样用: 
<code class="example">                        let buflist = []</code>
<code class="example">                        for i in range(tabpagenr('$'))</code>
<code class="example">                           call extend(buflist, tabpagebuflist(i + 1))</code>
<code class="example">                        endfor</code>
                <code class="note">注意</code> 缓冲区可能出现于多于一个窗口里。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabpage()-&gt;tabpagebuflist()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


tabpagenr([<code class="special">{arg}</code>])                                      <b class="vimtag"> <a name="tabpagenr()">tabpagenr()</a> </b>
                返回数值，当前标签页号。第一个标签页的编号为 1。

                可选参数 <code class="special">{arg}</code> 支持以下值:
                        $       最后一个标签页的编号 (即标签页总数)。
                        #       最近访问的标签页编号 ( <a href="tabpage.html#g%3CTab%3E">g&lt;Tab&gt;</a>  对应)。如果没有
                                前次标签页，返回 0。
                该数值可用于  <a href="tabpage.html#:tab">:tab</a>  命令。

                出错时返回零。

                返回类型:  <a href="eval.html#Number">Number</a> 


tabpagewinnr(<code class="special">{tabarg}</code> [, <code class="special">{arg}</code>])                        <b class="vimtag"> <a name="tabpagewinnr()">tabpagewinnr()</a> </b>
                类似于  <a href="builtin.html#winnr()">winnr()</a> ，但使用标签页 <code class="special">{tabarg}</code>。
                <code class="special">{tabarg}</code> 指定要使用的标签页号。
                <code class="special">{arg}</code> 的用法类似于  <a href="builtin.html#winnr()">winnr()</a> :
                - 如果省略，返回当前窗口号，也就是转到该标签页时会使用的窗口。
                - 如果是 "$"，返回窗口的总数。
                - 如果是 "#"，返回上次的窗口编号。
                用于的例子: 
<code class="example">                    tabpagewinnr(1)         " 标签页 1 的当前窗口</code>
<code class="example">                    tabpagewinnr(4, '$')    " 标签页 4 的窗口总数</code>
                <code class="special">{tabarg}</code> 非法时返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabpage()-&gt;tabpagewinnr()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


tagfiles()                                              <b class="vimtag"> <a name="tagfiles()">tagfiles()</a> </b>
                返回  <a href="eval.html#List">List</a> ，当前缓冲区用于搜索的标签文件名。这是 <a href="options.html#'tags'">'tags'</a> 选项
                扩展后的内容。

                返回类型: list<code class="special">&lt;string&gt;</code> 或 list<code class="special">&lt;any&gt;</code>


taglist(<code class="special">{expr}</code> [, <code class="special">{filename}</code>])                          <b class="vimtag"> <a name="taglist()">taglist()</a> </b>
                返回匹配正则表达式 <code class="special">{expr}</code> 的标签  <a href="eval.html#List">List</a> 。

                如果传入 <code class="special">{filename}</code>，用于像  <a href="tagsrch.html#:tselect">:tselect</a>  那样给结果排序。见
                 <a href="tagsrch.html#tag-priority">tag-priority</a> 。<code class="special">{filename}</code> 必须是文件的完整路径。

                每个列表项目是一个至少包含以下项目的字典:
                        name            标签名。
                        filename        标签定义的文件名。它或者相对于当前目
                                        录，或者包含完整路径。
                        cmd             用于在文件里定位标签的 Ex 命令。
                        kind            标签类型。该项目的值取决于特定于语言的
                                        类型值。只在 Universal/Exuberant ctags
                                        或 hdrtag 生成的标签文件里存在。
                        static          特定于文件的标签。详见  <a href="tagsrch.html#static-tag">static-tag</a> 。
                可能还有一些其它项目，取决于标签文件的内容: access、
                implementation、inherits 和 signature。这些字段的信息参见
                ctags 文档。C 代码里可能出现字段 "struct"、"class" 和 "enum"，
                它们给出标签所在的实体的名字。

                ex 命令 "cmd" 可以是 ex 搜索模式、行号或者行号后跟字节位置。

                如果没有匹配的标签，返回空列表。

                要得到标签的准确匹配，<code class="special">{expr}</code> 里必须使用 '^' 和 '$'。这也可加快
                函数的工作速度。
                关于标签搜索正则表达式模式的详情见  <a href="tagsrch.html#tag-regexp">tag-regexp</a> 。

                <a href="options.html#'tags'">'tags'</a> 提供 Vim 如何定位标签文件的信息。 <a href="tagsrch.html#tags-file-format">tags-file-format</a>  说
                明不同的 ctags 工具生成的标签文件的格式。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTagpattern()-&gt;taglist()</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt; 或 list<code class="special">&lt;any&gt;</code>


tan(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="tan()">tan()</a> </b>
                返回以弧度测量的 <code class="special">{expr}</code> 的正切值。返回值是 [-inf, inf] 区间内
                的浮点数。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回 0.0。
                示例: 
<code class="example">                        :echo tan(10)</code>
                        0.648361 
<code class="example">                        :echo tan(-4.01)</code>
                        -1.181502

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;tan()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


tanh(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="tanh()">tanh()</a> </b>
                返回 <code class="special">{expr}</code> 的双曲正切值，返回值为 [-1, 1] 区间内的浮点数。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回 0.0。
                示例: 
<code class="example">                        :echo tanh(0.5)</code>
                        0.462117 
<code class="example">                        :echo tanh(-1)</code>
                        -0.761594

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;tanh()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


tempname()                                              <b class="vimtag"> <a name="tempname()">tempname()</a> </b> <b class="vimtag"> <a name="temp-file-name">temp-file-name</a> </b>
                返回字符串，它是一个不存在的文件名。可以用作临时文件。该文件在
                至少 26 个接连的调用内不会重复。例如: 
<code class="example">                        :let tmpfile = tempname()</code>
<code class="example">                        :exe "redir &gt; " .. tmpfile</code>
                Unix 上，文件会存在用户个人的目录中  <a href="change.html#tempfile">tempfile</a> ，Vim 退出时会被
                递归删除，而其他系统上退出时不会自动清除临时文件。
                MS-Windows 上，如果置位了 <a href="options.html#'shellslash'">'shellslash'</a> 选项或者 <a href="options.html#'shellcmdflag'">'shellcmdflag'</a>
                以 '-' 开始且 <a href="options.html#'shell'">'shell'</a> 不包含 powershell 或 pwsh 的时候，使用正
                斜杠。

                返回类型:  <a href="eval.html#String">String</a> 


term_ 函数文档在这里:  <code class="badlink">terminal-functions-details</code> 


terminalprops()                                         <b class="vimtag"> <a name="terminalprops()">terminalprops()</a> </b>
                返回 Vim 从  <a href="term.html#t_RV">t_RV</a>  请求得到的响应中检测到的终端属性的
                 <a href="eval.html#Dictionary">Dictionary</a> 。响应本身见  <a href="eval.html#v:termresponse">v:termresponse</a> 。如果
                 <a href="eval.html#v:termresponse">v:termresponse</a>  为空，这里的多数值会是 'u'，代表未知。
                   cursor_style         是否可发送  <a href="term.html#t_RS">t_RS</a>  **
                   cursor_blink_mode    是否可发送  <a href="term.html#t_RC">t_RC</a>  **
                   underline_rgb         <a href="term.html#t_8u">t_8u</a>  是否可用 **
                   mouse                支持的鼠标类型
                   kitty                是否检测到 Kitty 终端

                ** 值 'u' 代表未知，'y' 代表是，'n' 代表否

                如果没有  <a href="various.html#+termresponse">+termresponse</a>  特性，返回空字典。

                如果 "cursor_style" 是 'y'，则发送  <a href="term.html#t_RS">t_RS</a>  以请求当前光标风格。
                如果 "cursor_blink_mode" 是 'y'，则发送  <a href="term.html#t_RC">t_RC</a>  以请求当前光标
                闪烁状态。
                如果  <a href="term.html#t_u7">t_u7</a>  非空，也会置位 "cursor_style" 和
                "cursor_blink_mode"，此时 Vim 会在启动时检测  <a href="term.html#t_RS">t_RS</a>  和  <a href="term.html#t_RC">t_RC</a> 
                是否可发送。

                如果 "underline_rgb" 不是 'y'， <a href="term.html#t_8u">t_8u</a>  会设为空。这会避免把它发
                送到 xterm 以清除色彩。

                "mouse" 对应的值 'u' 代表未知

                另见:
                - <a href="options.html#'ambiwidth'">'ambiwidth'</a> - 由  <a href="term.html#t_u7">t_u7</a>  检测。
                -  <a href="eval.html#v:termstyleresp">v:termstyleresp</a>  和  <a href="eval.html#v:termblinkresp">v:termblinkresp</a> ，对应  <a href="term.html#t_RS">t_RS</a>  和
                   <a href="term.html#t_RC">t_RC</a>  的响应。

                返回类型: dict<code class="special">&lt;string&gt;</code>


test_ 函数文档在这里:  <a href="testing.html#test-functions-details">test-functions-details</a> 


timer_info([<code class="special">{id}</code>])                                      <b class="vimtag"> <a name="timer_info()">timer_info()</a> </b>
                返回定时器信息的列表。
                给出 <code class="special">{id}</code> 时只返回此定时器的信息。如果定时器 <code class="special">{id}</code> 不存在，返回
                空列表。
                省略 <code class="special">{id}</code> 时，返回所有定时器的信息。

                每个定时器的信息以  <a href="eval.html#Dictionary">Dictionary</a>  形式保存，有以下项目:
                    "id"            定时器号
                    "time"          定时器开始时间
                    "remaining"     定时器剩余时间
                    "repeat"        定时器激活的次数；-1 代表永远
                    "callback"      回调
                    "paused"        如果定时器暂停为 1，否则为 0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTimer()-&gt;timer_info()</code>

                返回类型: list&lt;dict<code class="special">&lt;any&gt;</code>&gt; 或 list<code class="special">&lt;any&gt;</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>


timer_pause(<code class="special">{timer}</code>, <code class="special">{paused}</code>)                          <b class="vimtag"> <a name="timer_pause()">timer_pause()</a> </b>
                暂停或恢复定时器。暂停的定时器在到期是不调用回调。如果经过足够
                时间，恢复定时器会使回调几乎被立即调用。

                暂停定时器可用于短期停止回调的调用。

                如果 <code class="special">{paused}</code> 计算为非零的数值或非空的字符串，暂停定时器，否则
                恢复定时器。
                见  <a href="eval.html#non-zero-arg">non-zero-arg</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTimer()-&gt;timer_pause(1)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>


                                                        <b class="vimtag"> <a name="timer_start()">timer_start()</a> </b> <b class="vimtag"> <a name="timer">timer</a> </b> <b class="vimtag"> <a name="timers">timers</a> </b>
timer_start(<code class="special">{time}</code>, <code class="special">{callback}</code> [, <code class="special">{options}</code>])
                新建定时器并返回定时器号。

                <code class="special">{time}</code> 是毫秒计的等待时间。指示调用回调的最短时间。系统如果繁
                忙或 Vim 不在等待输入时，时间会更长。可用零值，此时回调会在
                Vim 回到主循环时执行。

                <code class="special">{callback}</code> 是要调用的函数。可以是函数名或  <a href="eval.html#Funcref">Funcref</a> 。调用时接
                受一个参数，即定时器号。只有在 Vim 等待输入时才会调用回调。
                如果要显示信息，看看  <a href="popup.html#popup_notification()">popup_notification()</a> ，以避免信息显示干
                扰用户的操作。

                <code class="special">{options}</code> 是字典。支持的项目:
                   "repeat"     重复调用回调的次数。-1 代表永远。无定义时，调
                                用回调一次。
                                如果定时器连续出错三次，取消重复。这避免了 Vim
                                因为过多的错误信息导致的不可用的情形。

                出错时返回 -1。

                示例: 
<code class="example">                        func MyHandler(timer)</code>
<code class="example">                          echo 'Handler called'</code>
<code class="example">                        endfunc</code>
<code class="example">                        let timer = timer_start(500, 'MyHandler',</code>
<code class="example">                                \ {'repeat': 3})</code>
                这会以 500 毫秒间隔调用 MyHandle() 三次。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMsec()-&gt;timer_start(callback)</code>
<code class="example"></code>
                该命令在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>


timer_stop(<code class="special">{timer}</code>)                                     <b class="vimtag"> <a name="timer_stop()">timer_stop()</a> </b>
                停止定时器。不再调用定时器回调。
                <code class="special">{timer}</code> 是  <a href="builtin.html#timer_start()">timer_start()</a>  返回的定时器号，所以必须是数值。如
                果 <code class="special">{timer}</code> 不存在，不报错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTimer()-&gt;timer_stop()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>


timer_stopall()                                         <b class="vimtag"> <a name="timer_stopall()">timer_stopall()</a> </b>
                停止所有定时器。不再调用定时器回调。用于有定时器工作不正常的场
                合。如果没有任何定时器，不报错。

                返回类型:  <a href="eval.html#Number">Number</a> 

                <code class="notvi">{仅当编译时加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>


tolower(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="tolower()">tolower()</a> </b>
                返回给出字符串的备份，但所有的大写字符变为小写 (就如同在字符串
                上应用了  <a href="change.html#gu">gu</a>  一样)。出错时返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;tolower()</code>

                返回类型:  <a href="eval.html#String">String</a> 


toupper(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="toupper()">toupper()</a> </b>
                返回给出字符串的备份，但所有的小写字符变为大写 (就如同在字符串
                上应用了  <a href="change.html#gU">gU</a>  一样)。出错时返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;toupper()</code>

                返回类型:  <a href="eval.html#String">String</a> 


tr(<code class="special">{src}</code>, <code class="special">{fromstr}</code>, <code class="special">{tostr}</code>)                           <b class="vimtag"> <a name="tr()">tr()</a> </b>
                返回 <code class="special">{src}</code> 字符串的备份，其中 <code class="special">{fromstr}</code> 里的每个字符被 <code class="special">{tostr}</code>
                字符串里同样的位置的字符替代。也就是，<code class="special">{fromstr}</code> 的第一个字符被
                翻译成 <code class="special">{tostr}</code> 的第一个字符，依此类推。和 unix 命令 "tr" 完全
                相同。
                能正确处理多字节字符。

                出错时返回空串。

                例如: 
<code class="example">                        echo tr("hello there", "ht", "HT")</code>
                返回 "Hello THere" 
<code class="example">                        echo tr("&lt;blob&gt;", "&lt;&gt;", "{}")</code>
                返回 "<code class="special">{blob}</code>"

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;tr(from, to)</code>

                返回类型:  <a href="eval.html#String">String</a> 


trim(<code class="special">{text}</code> [, <code class="special">{mask}</code> [, <code class="special">{dir}</code>]])                       <b class="vimtag"> <a name="trim()">trim()</a> </b>
                返回 <code class="special">{text}</code> 从头部和/或尾部删除 <code class="special">{mask}</code> 里出现的字符后的字符
                串。

                如果 <code class="special">{mask}</code> 没给出或为空串，<code class="special">{mask}</code> 是所有直到 0x20 的字符，包
                括 Tab、空格、NL 和 CR，加上不换行空格 0xa0。

                可选的 <code class="special">{dir}</code> 参数指定删除字符的位置:
                        0       从 <code class="special">{text}</code> 的头部和尾部删除
                        1       只从 <code class="special">{text}</code> 的头部删除
                        2       只从 <code class="special">{text}</code> 的尾部删除
                省略时两端都进行删除。

                此函数能正确处理多字节字符。
                出错时返回空串。

                示例: 
<code class="example">                        echo trim("   some text ")</code>
                返回 "some text" 
<code class="example">                        echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") .. "_TAIL"</code>
                返回 "RESERVE_TAIL" 
<code class="example">                        echo trim("rm&lt;Xrm&lt;&gt;X&gt;rrm", "rm&lt;&gt;")</code>
                返回 "Xrm<code class="special">&lt;&gt;</code>X" (不删除中间部分的字符) 
<code class="example">                        echo trim("  vim  ", " ", 2)</code>
                返回 "  vim"

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;trim()</code>

                返回类型:  <a href="eval.html#String">String</a> 


trunc(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="trunc()">trunc()</a> </b>
                返回浮点数，即绝对值小于等于 <code class="special">{expr}</code> 的最大整数 (向零取整)。
                <code class="special">{expr}</code> 的计算结果必须是  <a href="eval.html#Float">Float</a>  或  <a href="eval.html#Number">Number</a> 。否则返回 0.0。
                示例: 
<code class="example">                        echo trunc(1.456)</code>
                        1.0  
<code class="example">                        echo trunc(-5.456)</code>
                        -5.0  
<code class="example">                        echo trunc(4.0)</code>
                        4.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;trunc()</code>

                返回类型:  <a href="eval.html#Float">Float</a> 


tuple2list(<code class="special">{tuple}</code>)                                     <b class="vimtag"> <a name="tuple2list()">tuple2list()</a> </b>
                从元组项目的浅备份建立列表。示例: 
<code class="example">                        tuple2list((1, 2, 3))           返回 [1, 2, 3]</code>
                 <a href="builtin.html#list2tuple()">list2tuple()</a>  是逆操作。

                此函数不会递归转换 <code class="special">{tuple}</code> 里的所有元组项目为列表。<code class="note">注意</code>列表和
                元组的项目只有一份，所以修改项目会同时修改元组和列表里的内容。

                出错时返回空列表。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTuple()-&gt;tuple2list()</code>

                返回类型: list&lt;<code class="special">{type}</code>&gt; (取决于给出的  <a href="eval.html#Tuple">Tuple</a> )


type(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="type()">type()</a> </b>
                返回数值，代表 <code class="special">{expr}</code> 的类型。
                不要直接使用此值，最好用含有此值的 v:t_ 变量:
                        数值:       0   <a href="eval.html#v:t_number">v:t_number</a> 
                        字符串:     1   <a href="eval.html#v:t_string">v:t_string</a> 
                        函数引用:   2   <a href="eval.html#v:t_func">v:t_func</a> 
                        列表:       3   <a href="eval.html#v:t_list">v:t_list</a> 
                        字典:       4   <a href="eval.html#v:t_dict">v:t_dict</a> 
                        浮点数:     5   <a href="eval.html#v:t_float">v:t_float</a> 
                        布尔值:     6   <a href="eval.html#v:t_bool">v:t_bool</a>  (v:false 和 v:true)
                        None:       7   <a href="eval.html#v:t_none">v:t_none</a>  (v:null 和 v:none)
                        作业:       8   <a href="eval.html#v:t_job">v:t_job</a> 
                        通道:       9   <a href="eval.html#v:t_channel">v:t_channel</a> 
                        blob:      10   <a href="eval.html#v:t_blob">v:t_blob</a> 
                        类:        12   <a href="eval.html#v:t_class">v:t_class</a> 
                        对象:      13   <a href="eval.html#v:t_object">v:t_object</a> 
                        类型别名:  14   <a href="eval.html#v:t_typealias">v:t_typealias</a> 
                        枚举:      15   <a href="eval.html#v:t_enum">v:t_enum</a> 
                        枚举值:    16   <a href="eval.html#v:t_enumvalue">v:t_enumvalue</a> 
                        元组:      17   <a href="eval.html#v:t_tuple">v:t_tuple</a> 
                为了后向兼容，可以这样用此函数: 
<code class="example">                        :if type(myvar) == type(0)</code>
<code class="example">                        :if type(myvar) == type("")</code>
<code class="example">                        :if type(myvar) == type(function("tr"))</code>
<code class="example">                        :if type(myvar) == type([])</code>
<code class="example">                        :if type(myvar) == type({})</code>
<code class="example">                        :if type(myvar) == type(0.0)</code>
<code class="example">                        :if type(myvar) == type(v:false)</code>
<code class="example">                        :if type(myvar) == type(v:none)</code>
                要检查 v:t_ 这些变量是否存在，可用: 
<code class="example">                        :if exists('v:t_number')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;type()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


typename(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="typename()">typename()</a> </b>
                返回 <code class="special">{expr}</code> 类型的字符串描述。
                例如: 
<code class="example">                        echo typename([1, 2, 3])</code>
<code class="section">                        list<code class="special">&lt;number&gt;</code> </code>

                返回类型:  <a href="eval.html#String">String</a> 


undofile(<code class="special">{name}</code>)                                        <b class="vimtag"> <a name="undofile()">undofile()</a> </b>
                返回用于名为 <code class="special">{name}</code> 的文件的撤销文件名。使用 <a href="options.html#'undodir'">'undodir'</a> 选项并
                寻找实际存在的目录。并不检查该撤销文件是否存在。
                <code class="special">{name}</code> 总是扩展为完整路径，因为内部是这么使用的。
                <code class="special">{name}</code> 为空时 undofile() 也返回空字符串，因为无名缓冲区不写入
                任何撤销文件。
                可用于  <a href="undo.html#:wundo">:wundo</a>  和  <a href="undo.html#:rundo">:rundo</a> 。
                如果编译时没有  <a href="various.html#+persistent_undo">+persistent_undo</a>  选项，总是返回空字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;undofile()</code>

                返回类型:  <a href="eval.html#String">String</a> 


undotree([<code class="special">{buf}</code>])                                       <b class="vimtag"> <a name="undotree()">undotree()</a> </b>
                返回当前缓冲区或 <code class="special">{buf}</code> 给出时所指定的缓冲区的撤销树的当前状
                态。
                返回值是包含以下项目的  <a href="eval.html#Dictionary">Dictionary</a> :
                  "seq_last"    最大使用的撤销序列号。
                  "seq_cur"     撤销树中当前位置的序列号。如果有撤销过的改变，
                                和 "seq_last" 会有不同。
                  "time_cur"    最近用于  <a href="undo.html#:earlier">:earlier</a>  和相关命令的时间。
                                可用  <a href="builtin.html#strftime()">strftime()</a>  转换成可读的格式。
                  "save_last"   最后的文件写入编号。如果没有写入，返回零。
                  "save_cur"    撤销树当前位置的编号。
                  "synced"      如果最后的撤销块已经同步，返回非零值。等待用户
                                输入时会发生。见  <a href="undo.html#undo-blocks">undo-blocks</a> 。
                  "entries"     关于撤销块的信息的字典的列表。

                "entries" 列表的第一个值是最老的撤销项目。每个列表项目是一个包
                含以下项目的字典:
                  "seq"         撤销序列号。和  <a href="undo.html#:undolist">:undolist</a>  显示的相同。
                  "time"        改变发生的时间。可用  <a href="builtin.html#strftime()">strftime()</a>  转换成可读的
                                格式。
                  "newhead"     只出现在最后加入的项目。标识最后的改变，并指示
                                将来的改变加入所在的位置。
                  "curhead"     只出现在最后撤销的项目。表示撤销树当前的位置，
                                该块可用于 redo 命令。如果最后改变之后没有撤销
                                动作，此项目不出现。
                  "save"        只出现在文件写入前最后的块。该值为写入计数。首
                                次写入的编号为 1，最后一次是上面提及的
                                "save_last"。
                  "alt"         替代项。这又是一个撤销块的列表。每个项目又可以
                                有 "alt" 项目。

                返回类型: dict<code class="special">&lt;any&gt;</code>


uniq(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])                      <b class="vimtag"> <a name="uniq()">uniq()</a> </b> <b class="vimtag"> <a name="E882">E882</a> </b>
                原地删除重复相邻的 <code class="special">{list}</code> 项目的第二个及之后的版本。返回
                <code class="special">{list}</code>。如果不想对列表进行修改，先建立一个备份: 
<code class="example">                        :let newlist = uniq(copy(mylist))</code>
                缺省比较函数使用每个项目的字符串表示形式。关于 <code class="special">{func}</code> 和
                <code class="special">{dict}</code> 的使用可见  <a href="builtin.html#sort()">sort()</a> 。
                要删除当前缓冲区里的重复文本，可见  <a href="change.html#:uniq">:uniq</a> 。

                <code class="special">{list}</code> 不是  <a href="eval.html#List">List</a>  时返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;uniq()</code>

                返回类型: list&lt;<code class="special">{type}</code>&gt;


uri_decode(<code class="special">{string}</code>)                                    <b class="vimtag"> <a name="uri_decode()">uri_decode()</a> </b>
                返回 <code class="special">{string}</code> 的 URI 解码形式。逆转百分号编码 (把 "%3D" 这样的
                序列还原为对应的字符)。

                解码遵循如下标准的百分符解码规则:
                    - "%HH" 被替换为十六进制 HH 对应的字符。
                    - 如果解码的字节序列构成合法的 UTF-8，合并为对应的字符。否
                      则，保留原先的字节序列。
                    - 非法或不完整的编码 (如 "%GZ"、"%3" 或拖尾的 "%") 保持不
                      变。

                <code class="special">{string}</code> 为空时返回空串。

                示例: 
<code class="example">                        :echo uri_decode('c%3A%5Cmy%5Cdir%5Cfoo%20bar')</code>
<code class="example">                        c:\my\dir\foo bar</code>
<code class="example">                        :echo uri_decode('%CE%B1%CE%B2%CE%B3')</code>
<code class="example">                        αβγ</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mystr-&gt;uri_decode()</code>

                Return type:  <a href="eval.html#String">String</a> 

uri_encode(<code class="special">{string}</code>)                                    <b class="vimtag"> <a name="uri_encode()">uri_encode()</a> </b>
                返回 <code class="special">{string}</code> 的 URI 编码形式。URI 编码把不安全或保留的字符替
                换为百分号编码的序列。

                编码遵循如下标准的百分符编码规则:
                    - 字母数字字符 [0-9A-Za-z] 保持不变。
                    - "-"、"_"、"." 和 "~" 也保持不变。
                    - 所有其它字符被替换为 "%HH"，其中的 HH 是两位大写十六进制
                      数字。
                    - 已有的百分符编码序列不作修改。

                <code class="special">{string}</code> 为空时返回空串。

                示例: 
<code class="example">                        :echo uri_encode('c:\my\dir\foo bar')</code>
<code class="example">                        c%3A%5Cmy%5Cdir%5Cfoo%20bar</code>
<code class="example">                        :echo uri_encode('key=value&amp;name=αβγ')</code>
<code class="example">                        key%3Dvalue%26name%3D%CE%B1%CE%B2%CE%B3</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mystr-&gt;uri_encode()</code>

                返回类型:  <a href="eval.html#String">String</a> 


utf16idx(<code class="special">{string}</code>, <code class="special">{idx}</code> [, <code class="special">{countcc}</code> [, <code class="special">{charidx}</code>]])   <b class="vimtag"> <a name="utf16idx()">utf16idx()</a> </b>
                类似于  <a href="builtin.html#charidx()">charidx()</a> ，但返回 <code class="special">{string}</code> <code class="special">{idx}</code> 字节对应的 (转换为
                UTF-16 后) UTF-16 代码单元索引。

                <code class="special">{charidx}</code> 给出且为 TRUE 时，<code class="special">{idx}</code> 用于给出字符串 <code class="special">{string}</code> 里的
                字符索引而不是字节索引。
                出现在 UTF-8 序列中间的 <code class="special">{idx}</code> 会向下取整到该序列的开始位置。

                如果参数非法或者 <code class="special">{string}</code> 里少于 <code class="special">{idx}</code> 个字节，返回 -1。如果正
                好有 <code class="special">{idx}</code> 个字节，返回整个字符串以 UTF-16 代码单元计的长度。

                关于如何从 UTF-16 索引来获取字节索引，可见  <a href="builtin.html#byteidx()">byteidx()</a>  和
                 <a href="builtin.html#byteidxcomp()">byteidxcomp()</a> ，而要从 UTF-16 索引获取字符索引，可见
                 <code class="badlink">charidx</code> 。
                更多详情可参见  <a href="eval.html#string-offset-encoding">string-offset-encoding</a> 。
                示例: 
<code class="example">                        echo utf16idx('a😊😊', 3)       返回 2</code>
<code class="example">                        echo utf16idx('a😊😊', 7)       返回 4</code>
<code class="example">                        echo utf16idx('a😊😊', 1, 0, 1) 返回 2</code>
<code class="example">                        echo utf16idx('a😊😊', 2, 0, 1) 返回 4</code>
<code class="example">                        echo utf16idx('aą́c', 6)             返回 2</code>
<code class="example">                        echo utf16idx('aą́c', 6, 1)  返回 4</code>
<code class="example">                        echo utf16idx('a😊😊', 9)       返回 -1</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;utf16idx(idx)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


values(<code class="special">{dict}</code>)                                          <b class="vimtag"> <a name="values()">values()</a> </b>
                返回  <a href="eval.html#List">List</a> ，<code class="special">{dict}</code> 的所有值。 <a href="eval.html#List">List</a>  项目的顺序不定。另见
                 <a href="builtin.html#items()">items()</a>  和  <a href="builtin.html#keys()">keys()</a> 。
                <code class="special">{dict}</code> 不是  <a href="eval.html#Dict">Dict</a>  时返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mydict-&gt;values()</code>

                返回类型: list<code class="special">&lt;any&gt;</code>


virtcol(<code class="special">{expr}</code> [, <code class="special">{list}</code> [, <code class="special">{winid}</code>]])                  <b class="vimtag"> <a name="virtcol()">virtcol()</a> </b>
                返回数值，即 <code class="special">{expr}</code> 给定的文件位置的屏幕列号。也就是，直到该位
                置的字符为止的行的部分所占据的屏幕单元数目。如果该位置是一个
                <code class="special">&lt;Tab&gt;</code>，返回的数值是 <code class="special">&lt;Tab&gt;</code> 占据的最后一列。比如，如果 <code class="special">&lt;Tab&gt;</code> 在
                第 1 列，而 <a href="options.html#'ts'">'ts'</a> 设为 8 的话，返回 8。忽略  <code class="badlink">conceal()</code>  因素。
                关于字节位置，见  <a href="builtin.html#col()">col()</a> 。

                <code class="special">{expr}</code> 用法见  <a href="builtin.html#getpos()">getpos()</a>  和  <a href="builtin.html#col()">col()</a> 。
                <code class="special">{expr}</code> 为 "$" 时代表光标行的行尾，所以返回值是光标行的单元数加
                一。

                如果使用 <a href="options.html#'virtualedit'">'virtualedit'</a>，<code class="special">{expr}</code> 可以用 [lnum, col, off]，其中
                "off" 是字符位置开始计算的屏幕列。例如，制表中或最后一个字符之
                后的某个位置。"off" 若省略，则假定为零。如果在当前模式下使用了
                虚拟编辑，也可能返回行尾之后的位置。另见 <a href="options.html#'virtualedit'">'virtualedit'</a>

                <code class="special">{list}</code> 如果存在且非零，virtcol() 返回字符占据的首个和末个屏幕
                位置组成的列表。

                如果给出可选的 <code class="special">{winid}</code> 参数，从该窗口取值而不是当前窗口。

                <code class="note">注意</code> 只能使用当前文件的位置标记。
                示例: 
<code class="example">                        " 文本 "foo^Lbar" 光标在 "^L" 上:</code>
<code class="example"></code>
<code class="example">                        virtcol(".")    " 返回 5</code>
<code class="example">                        virtcol(".", 1) " 返回 [4, 5]</code>
<code class="example">                        virtcol("$")    " 返回 9</code>
<code class="example"></code>
<code class="example">                        " 文本 "          there"，'t 在 'h' 上:</code>
<code class="example"></code>
<code class="example">                        virtcol("'t")   " 返回 6</code>

                第一列为 1。返回 0 或 [0,0] 代表错误。

                一个更高级的示例，显示所有行的最大长度: 
<code class="example">                    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPos()-&gt;virtcol()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


virtcol2col(<code class="special">{winid}</code>, <code class="special">{lnum}</code>, <code class="special">{col}</code>)                     <b class="vimtag"> <a name="virtcol2col()">virtcol2col()</a> </b>
                返回数值，窗口 <code class="special">{winid}</code> 在缓冲区行 <code class="special">{lnum}</code> 和虚拟列 <code class="special">{col}</code> 所在的
                字符的字节索引。

                如果缓冲区行 <code class="special">{lnum}</code> 为空行，返回 0。

                如果 <code class="special">{col}</code> 大于 <code class="special">{lnum}</code> 行的最后的虚拟列，返回最后虚拟列所在的
                字符的字节索引。

                多字节字符返回该字符首个字节的列号。

                <code class="special">{winid}</code> 参数可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。如果为零，使用当前窗
                口。

                窗口 <code class="special">{winid}</code> 不存在或缓冲区行 <code class="special">{lnum}</code> 或虚拟列 <code class="special">{col}</code> 非法时，返
                回 -1。

                另见  <a href="builtin.html#screenpos()">screenpos()</a> 、 <a href="builtin.html#virtcol()">virtcol()</a>  和  <a href="builtin.html#col()">col()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;virtcol2col(lnum, col)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


visualmode([<code class="special">{expr}</code>])                                    <b class="vimtag"> <a name="visualmode()">visualmode()</a> </b>
                返回字符串，它描述当前缓冲区最近使用的可视模式。一开始，它返回
                空字符串，一旦使用了可视模式，返回 "v"、"V" 或 "&lt;<code class="keystroke">CTRL-V</code>&gt;" (单
                个 <code class="keystroke">CTRL-V</code> 字符)，分别代表面向字符、面向行、和面向列块的可视模
                式。
                例如: 
<code class="example">                        :exe "normal " .. visualmode()</code>
                进入和上次相同的可视模式。也可以用于在脚本里根据最近的可视模式
                采取不同的行动。
                如果当前正处于可视模式中， <a href="builtin.html#mode()">mode()</a>  可得到具体的可视模式 (例如
                在  <a href="map.html#:vmap">:vmap</a>  中可用)。
                如果提供 <code class="special">{expr}</code> 并且计算结果是非零数值或者是非空字符串，那么将
                清除可视模式，并返回旧的值。见  <a href="eval.html#non-zero-arg">non-zero-arg</a> 。

                返回类型:  <a href="eval.html#String">String</a> 


wildmenumode()                                          <b class="vimtag"> <a name="wildmenumode()">wildmenumode()</a> </b>
                如果 wildmenu 打开，返回  <a href="eval.html#TRUE">TRUE</a> ，否则返回  <a href="eval.html#FALSE">FALSE</a> 。参见
                <a href="options.html#'wildmenu'">'wildmenu'</a> 和 <a href="options.html#'wildmode'">'wildmode'</a>。
                可用于在映射中方便地处理 <a href="options.html#'wildcharm'">'wildcharm'</a> 选项。(只对  <a href="map.html#mapmode-c">mapmode-c</a> 
                映射有意义)。

                例如要使 <code class="special">&lt;c-j&gt;</code> 在 wildmode 中等价于 <code class="special">&lt;down&gt;</code>，可用: 
<code class="example">    :cnoremap &lt;expr&gt; &lt;C-j&gt; wildmenumode() ? "\&lt;Down&gt;\&lt;Tab&gt;" : "\&lt;c-j&gt;"</code>

                (<code class="note">备注</code>: 这需要 <a href="options.html#'wildcharm'">'wildcharm'</a> 合适的设置配合)。

                返回类型:  <a href="eval.html#Number">Number</a> 


wildtrigger()                                           <b class="vimtag"> <a name="wildtrigger()">wildtrigger()</a> </b>
                启动命令行上的通配扩展，其行为应用 <a href="options.html#'wildmode'">'wildmode'</a> 和 <a href="options.html#'wildoptions'">'wildoptions'</a>
                设置的定义。

                此函数也打开搜索模式的补全，如  <a href="pattern.html#%2F">/</a> 、 <a href="pattern.html#?">?</a> 、 <a href="change.html#:s">:s</a> 、 <a href="repeat.html#:g">:g</a> 、 <a href="repeat.html#:v">:v</a>  和
                 <a href="quickfix.html#:vimgrep">:vimgrep</a> 。

                不像手动按 <a href="options.html#'wildchar'">'wildchar'</a> 那样，此函数在找不到匹配时不响铃，一般而
                言操作会更安静。这样更适合补全的自动触发，

                <code class="note">注意</code>: 在浏览命令行历史后，wildtrigger() 的首个调用是空操作；需
                要第二次调用来启动扩展。这是为了在命令行自动补全里支持历史浏
                览。

                见  <a href="cmdline.html#cmdline-completion">cmdline-completion</a> 。

                返回值永远是 0。

                返回类型: <a href="eval.html#Number">Number</a> 


win_execute(<code class="special">{id}</code>, <code class="special">{command}</code> [, <code class="special">{silent}</code>])               <b class="vimtag"> <a name="win_execute()">win_execute()</a> </b>
                类似于  <a href="builtin.html#execute()">execute()</a>  但在窗口 <code class="special">{id}</code> 的上下文中执行。该窗口会被临
                时设为当前窗口，不触发自动命令，也不会改变目录。执行 <code class="special">{command}</code>
                时会触发自动命令，这可能有意想不到的副作用。如有必要可用
                 <a href="autocmd.html#:noautocmd">:noautocmd</a> 。
                示例: 
<code class="example">                        call win_execute(winid, 'set syntax=python')</code>
                和  <a href="builtin.html#setwinvar()">setwinvar()</a>  相同但不触发自动命令也不实际显示语法高亮。
                                                        <b class="vimtag"> <a name="E994">E994</a> </b>
                不是所有的命令都允许在弹出窗口中使用。
                窗口 <code class="special">{id}</code> 不存在时不报错，且返回空字符串。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetCommand()-&gt;win_execute(winid)</code>

                返回类型:  <a href="eval.html#String">String</a> 


win_findbuf(<code class="special">{bufnr}</code>)                                    <b class="vimtag"> <a name="win_findbuf()">win_findbuf()</a> </b>
                返回包含缓冲区 <code class="special">{bufnr}</code> 的窗口的所有  <a href="windows.html#window-ID">window-ID</a>  的  <a href="eval.html#List">List</a> 。如
                果没有这样的窗口，返回空列表。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufnr()-&gt;win_findbuf()</code>

                返回类型: list<code class="special">&lt;number&gt;</code> 或 list<code class="special">&lt;any&gt;</code>


win_getid([<code class="special">{win}</code> [, <code class="special">{tab}</code>]])                            <b class="vimtag"> <a name="win_getid()">win_getid()</a> </b>
                返回指定窗口的  <a href="windows.html#window-ID">window-ID</a> 。
                忽略 <code class="special">{win}</code> 则使用当前窗口。
                给定 <code class="special">{win}</code> 时，这是窗口号。顶部窗口的窗口号为 1。
                忽略 <code class="special">{tab}</code> 则使用当前标签页，否则使用标签页 <code class="special">{tab}</code>。首个标签页
                的标签页号为一。
                如果找不到这样的窗口，返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;win_getid()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


win_gettype([<code class="special">{nr}</code>])                                     <b class="vimtag"> <a name="win_gettype()">win_gettype()</a> </b>
                返回窗口类型:
                        "autocmd"       自动命令窗口。用于执行自动命令的临时窗
                                        口。
                        "command"       命令行窗口  <a href="cmdline.html#cmdwin">cmdwin</a> 
                        (空)            正常窗口
                        "loclist"        <a href="quickfix.html#location-list-window">location-list-window</a> 
                        "popup"         弹出窗口  <a href="popup.html#popup">popup</a> 
                        "preview"       预览窗口  <a href="windows.html#preview-window">preview-window</a> 
                        "quickfix"       <a href="quickfix.html#quickfix-window">quickfix-window</a> 
                        "unknown"       窗口 <code class="special">{nr}</code> 找不到

                <code class="special">{nr}</code> 省略时返回当前窗口的类型。
                给出 <code class="special">{nr}</code> 时返回给出窗口号或  <a href="windows.html#window-ID">window-ID</a>  的窗口的类型。

                另见 <a href="options.html#'buftype'">'buftype'</a> 选项。在弹出窗口中运行终端时，<a href="options.html#'buftype'">'buftype'</a> 为
                "terminal" 而 win_gettype() 返回 "popup"。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;win_gettype()</code>

                返回类型:  <a href="eval.html#String">String</a> 


win_gotoid(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="win_gotoid()">win_gotoid()</a> </b>
                转到 ID 为 <code class="special">{expr}</code> 的窗口。可能会改变当前标签页。
                如果成功返回 TRUE，如果找不到这样的窗口，返回 FALSE。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;win_gotoid()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


win_id2tabwin(<code class="special">{expr}</code>)                                   <b class="vimtag"> <a name="win_id2tabwin()">win_id2tabwin()</a> </b>
                返回包含 ID 为 <code class="special">{expr}</code> 的窗口的标签页号和窗口号的列表:
                [tabnr, winnr]。
                如果找不到这样的窗口，返回 [0, 0]。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;win_id2tabwin()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


win_id2win(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="win_id2win()">win_id2win()</a> </b>
                返回 ID 为 <code class="special">{expr}</code> 的窗口号。
                如果在当前标签页下找不到这样的窗口，返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;win_id2win()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


win_move_separator(<code class="special">{nr}</code>, <code class="special">{offset}</code>)                      <b class="vimtag"> <a name="win_move_separator()">win_move_separator()</a> </b>
                把窗口 <code class="special">{nr}</code> 的垂直分割符 (也就是右边界) 移动 <code class="special">{offset}</code> 列，就像
                用鼠标拖动一样。<code class="special">{nr}</code> 可是以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。正 <code class="special">{offset}</code>
                向右移动，负 <code class="special">{offset}</code> 向左移动。移动窗口的垂直分割符会改变窗口
                的宽度以及其它紧贴着同一分割符的相邻窗口的宽度。移动幅度可能小
                于指定的位移 (如因为维持 <a href="options.html#'winminwidth'">'winminwidth'</a> 的需要)。如果该窗口能找
                到，返回 TRUE，否则 FALSE。
                最右侧的窗口或者全宽窗口上会失败，因为此时右侧没有分割符。
                只适用于当前标签页。 <b class="vimtag"> <a name="E1308">E1308</a> </b>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;win_move_separator(offset)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


win_move_statusline(<code class="special">{nr}</code>, <code class="special">{offset}</code>)                     <b class="vimtag"> <a name="win_move_statusline()">win_move_statusline()</a> </b>
                把窗口 <code class="special">{nr}</code> 的状态行 (也就是下边界) 移动 <code class="special">{offset}</code> 行，就像用鼠
                标拖动一样。<code class="special">{nr}</code> 可是以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。正 <code class="special">{offset}</code> 向
                下移动，负 <code class="special">{offset}</code> 向上移动。移动窗口的状态行会改变窗口的高度
                以及其它紧贴着同一状态行的相邻窗口的高度。移动幅度可能小于指定
                的位移 (如因为维持 <a href="options.html#'winminheight'">'winminheight'</a> 的需要)。如果该窗口能找到，
                返回 TRUE，否则 FALSE。
                只适用于当前标签页。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;win_move_statusline(offset)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


win_screenpos(<code class="special">{nr}</code>)                                     <b class="vimtag"> <a name="win_screenpos()">win_screenpos()</a> </b>
                返回两个数值的列表，即窗口 <code class="special">{nr}</code> 的屏幕位置: [row, col]。首个窗
                口的位置总是 [1, 1]，除非它有标签页行，此时为 [2, 1]。
                <code class="special">{nr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。零代表当前窗口。
                如果找不到窗口，返回 [0, 0]。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;win_screenpos()</code>

                返回类型: list<code class="special">&lt;number&gt;</code>


win_splitmove(<code class="special">{nr}</code>, <code class="special">{target}</code> [, <code class="special">{options}</code>])             <b class="vimtag"> <a name="win_splitmove()">win_splitmove()</a> </b>
                暂时切换到窗口 <code class="special">{target}</code>，移动窗口 <code class="special">{nr}</code> 为紧贴 <code class="special">{target}</code> 的新分
                割窗口。
                和  <a href="windows.html#:split">:split</a>  之类的命令不同，不创建新窗口 (移动后窗口 <code class="special">{nr}</code> 的窗
                口 ID 不变)。

                <code class="special">{nr}</code> 和 <code class="special">{target}</code> 都可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。两者必须都在当
                前标签页中。

                如果成功返回零，失败返回非零。

                <code class="special">{options}</code> 是包含以下可选项的  <a href="eval.html#Dictionary">Dictionary</a> :
                  "vertical"    为 TRUE 时垂直分割，类似于  <a href="windows.html#:vsplit">:vsplit</a> 。
                  "rightbelow"  为 TRUE 时分割在下方或右方 (垂直时)。为 FALSE
                                时分割在上方或左方 (垂直时)。如果未给出，使用
                                <a href="options.html#'splitbelow'">'splitbelow'</a> 和 <a href="options.html#'splitright'">'splitright'</a>。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;win_splitmove(target)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


winbufnr(<code class="special">{nr}</code>)                                          <b class="vimtag"> <a name="winbufnr()">winbufnr()</a> </b>
                返回数值，即窗口 <code class="special">{nr}</code> 相关联的缓冲区号。<code class="special">{nr}</code> 可以是窗口号或
                 <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 为零，返回当前窗口的缓冲区号。
                如果窗口 <code class="special">{nr}</code> 不存在，返回 -1。
                示例: 
<code class="example">  :echo "当前窗口的文件是 " .. bufname(winbufnr(0))</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        FindWindow()-&gt;winbufnr()-&gt;bufname()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


wincol()                                                <b class="vimtag"> <a name="wincol()">wincol()</a> </b>
                返回数值，窗口光标的虚拟列。亦即从窗口左侧起算的屏幕列数。最左
                列为第一列。

                返回类型:  <a href="eval.html#Number">Number</a> 


windowsversion()                                        <b class="vimtag"> <a name="windowsversion()">windowsversion()</a> </b>
                返回字符串。MS-Windows 上指示 OS 版本。例如，Windows 10 是
                "10.0"。Windows 8 是 "6.2"，Windows XP 是 "5.1"。非 MS-Windows
                系统上返回空串。

                返回类型:  <a href="eval.html#String">String</a> 


winheight(<code class="special">{nr}</code>)                                         <b class="vimtag"> <a name="winheight()">winheight()</a> </b>
                返回数值，窗口 <code class="special">{nr}</code> 的高度。
                <code class="special">{nr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 为零，返回当前窗口的高度。如果窗口 <code class="special">{nr}</code> 不存在，返回
                -1。
                存在的窗口的高度至少为零。
                不计入任何窗口工具条行。
                示例: 
<code class="example">  :echo "当前窗口有 " .. winheight(0) .. " 行。"</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;winheight()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


winlayout([<code class="special">{tabnr}</code>])                                    <b class="vimtag"> <a name="winlayout()">winlayout()</a> </b>
                返回嵌套列表，包含标签页中的窗口布局。

                未给出 <code class="special">{tabnr}</code> 则使用当前标签页，否则使用号码为 <code class="special">{tabnr}</code> 的标签
                页。如果标签页 <code class="special">{tabnr}</code> 找不到，返回空列表。

                叶窗口返回:
                        [<code class="badlink">'leaf'</code>, <code class="special">{winid}</code>]
                水平分割的窗口构成一列，它们返回:
                        [<code class="badlink">'col'</code>, [{nested list of windows}]]
                垂直分割的窗口构成一行，它们返回:
                        [<code class="badlink">'row'</code>, [{nested list of windows}]]

                示例: 
<code class="example">                        " 标签页中只有一个窗口</code>
<code class="example">                        :echo winlayout()</code>
<code class="example">                        ['leaf', 1000]</code>
<code class="example">                        " 两个水平分割的窗口</code>
<code class="example">                        :echo winlayout()</code>
<code class="example">                        ['col', [['leaf', 1000], ['leaf', 1001]]]</code>
<code class="example">                        " 第二个标签页，其中有三个水平分割的窗口，中间窗口有两</code>
<code class="example">                        " 个垂直分割的窗口</code>
<code class="example">                        :echo winlayout(2)</code>
<code class="example">                        ['col', [['leaf', 1002], ['row', [['leaf', 1003],</code>
<code class="example">                                            ['leaf', 1001]]], ['leaf', 1000]]]</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabnr()-&gt;winlayout()</code>

                返回类型: list<code class="special">&lt;any&gt;</code>


winline()                                               <b class="vimtag"> <a name="winline()">winline()</a> </b>
                返回数值，窗口光标所在的屏幕行，亦即，从窗口顶部起算的屏幕行
                数。第一行返回 1。
                如果光标移动，文件的视图会先更新，这可能会导致滚动。

                返回类型:  <a href="eval.html#Number">Number</a> 


winnr([<code class="special">{arg}</code>])                                          <b class="vimtag"> <a name="winnr()">winnr()</a> </b>
                返回数值，当前窗口的编号。最上面的窗口的编号为 1。
                弹出窗口返回零。

                可选参数 <code class="special">{arg}</code> 支持以下值:
                        $       返回最后一个窗口的编号 (即窗口的总数)。
                        #       返回最近访问的窗口号 ( <a href="windows.html#CTRL-W_p">CTRL-W_p</a>  到的地
                                方)。如果没有上次窗口或它在另一个标签页中，返
                                回 0。有些情况下可指向当前窗口 (如计算
                                <a href="options.html#'statusline'">'statusline'</a> 表达式时)。
                        <code class="special">{N}</code>j    当前窗口之下第 N 个窗口的窗口号 ( <a href="windows.html#CTRL-W_j">CTRL-W_j</a>  到
                                的地方)。
                        <code class="special">{N}</code>k    当前窗口之上第 N 个窗口的窗口号 ( <a href="windows.html#CTRL-W_k">CTRL-W_k</a>  到
                                的地方)。
                        <code class="special">{N}</code>h    当前窗口之左第 N 个窗口的窗口号 ( <a href="windows.html#CTRL-W_h">CTRL-W_h</a>  到
                                的地方)。
                        <code class="special">{N}</code>l    当前窗口之右第 N 个窗口的窗口号 ( <a href="windows.html#CTRL-W_l">CTRL-W_l</a>  到
                                的地方)。
                此编号可用于  <a href="windows.html#CTRL-W_w">CTRL-W_w</a>  和 ":wincmd w"  <a href="windows.html#:wincmd">:wincmd</a> 。
                <code class="special">{arg}</code> 非法时，报错并返回零。
                另见  <a href="builtin.html#tabpagewinnr()">tabpagewinnr()</a>  和  <a href="builtin.html#win_getid()">win_getid()</a> 。
                示例: 
<code class="example">                        let window_count = winnr('$')</code>
<code class="example">                        let prev_window = winnr('#')</code>
<code class="example">                        let wnum = winnr('3k')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinval()-&gt;winnr()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


winrestcmd()                                            <b class="vimtag"> <a name="winrestcmd()">winrestcmd()</a> </b>
                返回  <a href="windows.html#:resize">:resize</a>  命令序列，该序列应该能够恢复当前窗口的大小。只
                有在没有窗口被打开或关闭且当前窗口和标签页都没有改变的时候才能
                正确工作。
                示例: 
<code class="example">                        :let cmd = winrestcmd()</code>
<code class="example">                        :call MessWithWindowSizes()</code>
<code class="example">                        :exe cmd</code>

                返回类型:  <a href="eval.html#String">String</a> 


winrestview(<code class="special">{dict}</code>)                                     <b class="vimtag"> <a name="winrestview()">winrestview()</a> </b>
                使用  <a href="builtin.html#winsaveview()">winsaveview()</a>  返回的  <a href="eval.html#Dictionary">Dictionary</a>  来恢复当前窗口的视
                图。
                <code class="note">注意</code> <code class="special">{dict}</code> 不需要包含所有的  <a href="builtin.html#winsaveview()">winsaveview()</a>  返回的值。如果不
                提供某值，则不恢复相应的设置。所以可以用: 
<code class="example">                    :call winrestview({'curswant': 4})</code>

                它只会设置光标的 curswant 值 (垂直移动的光标想移动到的列) 到第
                5 列 (是的，第 5 列)，而其它设置保持不变。这可用于手动设置光标
                位置。

                如果你改变了其中的值，结果无法预测。如果窗口大小改变了，结果不
                会完全一样。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetView()-&gt;winrestview()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


winsaveview()                                           <b class="vimtag"> <a name="winsaveview()">winsaveview()</a> </b>
                返回  <a href="eval.html#Dictionary">Dictionary</a> ，包含当前窗口的信息，这些信息可用来恢复视
                图。
                 <a href="builtin.html#winrestview()">winrestview()</a>  进行视图的恢复。
                可用于定义在缓冲区里跳转后想恢复的原来视图的映射。
                这里不保存折叠的信息。用 <a href="options.html#'foldenable'">'foldenable'</a> 选项来暂时关闭折叠功能，
                这样在移动时折叠就不会打开。这可能有副作用。
                返回值包括:
                        lnum            光标行号
                        col             光标列号 (<code class="note">注意</code>: 首列为零，和
                                         <a href="builtin.html#getcurpos()">getcurpos()</a>  不同)
                        coladd          <a href="options.html#'virtualedit'">'virtualedit'</a> 使用的光标列偏移
                        curswant        垂直移动使用的列 (<code class="note">注意</code>: 首列为零，和
                                         <a href="builtin.html#getcurpos()">getcurpos()</a>  不同)。 <a href="motion.html#$">$</a>  命令后，设为
                                        等于  <a href="eval.html#v:maxcol">v:maxcol</a>  的一个大值。
                        topline         窗口的第一行
                        topfill         填充行，只用于比较模式
                        leftcol         显示的第一列；只用于 <a href="options.html#'wrap'">'wrap'</a> 关闭时
                        skipcol         跳过的列数
                <code class="note">注意</code> 这里不保存任何选项值。

                返回类型: dict<code class="special">&lt;number&gt;</code>


winwidth(<code class="special">{nr}</code>)                                          <b class="vimtag"> <a name="winwidth()">winwidth()</a> </b>
                返回数值，窗口 <code class="special">{nr}</code> 的宽度。
                <code class="special">{nr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 为零，返回当前窗口的宽度。如果窗口 <code class="special">{nr}</code> 不存在，返回
                -1。
                存在的窗口的宽度至少为零。
                示例: 
<code class="example">  :echo "当前窗口有 " .. winwidth(0) .. " 列。"</code>
<code class="example">  :if winwidth(0) &lt;= 50</code>
<code class="example">  :  50 wincmd |</code>
<code class="example">  :endif</code>
                要得到终端或屏幕大小，可见 <a href="options.html#'columns'">'columns'</a> 选项。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;winwidth()</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


wordcount()                                             <b class="vimtag"> <a name="wordcount()">wordcount()</a> </b>
                返回字典，包含当前缓冲区的字节/字符/单词的统计。和  <a href="editing.html#g_CTRL-G">g_CTRL-G</a> 
                包含的信息相同。
                返回值包括:
                        bytes           缓冲区的字节数
                        chars           缓冲区的字符数
                        words           缓冲区的单词数
                        cursor_bytes    光标前的字节数 (不在可视模式下)
                        cursor_chars    光标前的字符数 (不在可视模式下)
                        cursor_words    光标前的单词数 (不在可视模式下)
                        visual_bytes    可视选择的字节数 (只在可视模式下)
                        visual_chars    可视选择的字符数 (只在可视模式下)
                        visual_words    可视选择的单词数 (只在可视模式下)

                返回类型: dict<code class="special">&lt;number&gt;</code>


writefile(<code class="special">{object}</code>, <code class="special">{fname}</code> [, <code class="special">{flags}</code>])                <b class="vimtag"> <a name="writefile()">writefile()</a> </b>
                <code class="special">{object}</code> 为  <a href="eval.html#List">List</a>  时，把列表写到文件 <code class="special">{fname}</code> 里。列表的项目间
                以 NL 分隔。每个列表项必须是字符串或数值。
                所有的 NL 字符被 NUL 字符代替。
                CR 字符的插入需要在把 <code class="special">{list}</code> 传递给 writefile() 之前先做好。

                <code class="special">{object}</code> 为  <a href="eval.html#Blob">Blob</a>  时，把这些字节不加修改地写到文件 <code class="special">{fname}</code>
                里，即使不指定二进制模式也是如此。

                <code class="special">{flags}</code> 必须为字符串。识别以下字符:

                'b'  使用二进制模式: 最后一个列表项目之后没有 NL，最后的空项目
                     使得文件的末行以 NL 结尾。

                'a'  使用附加模式，写入行附加到文件之后: 
<code class="example">                        :call writefile(["foo"], "event.log", "a")</code>
<code class="example">                        :call writefile(["bar"], "event.log", "a")</code>

                'D'  当前函数结束时删除文件。相当于: 
<code class="example">                        :defer delete({fname})</code>
                     不在函数中执行时失败。另见  <a href="userfunc.html#:defer">:defer</a> 。

                's'  写入文件后总是调用 fsync()。在可能的情况下它把文件刷新到
                     盘上。这会多花些时间，但避免系统崩溃时丢失文件的风险。

                'S'  无论 <a href="options.html#'fsync'">'fsync'</a> 选项是否置位都不调用 fsync()。

                     如果 <code class="special">{flags}</code> 不包含 "S" 或 "s"，仅当 <a href="options.html#'fsync'">'fsync'</a> 选项置位时调
                     用 fsync()。

                如果可能，覆盖已有的文件。

                如果写入失败，返回 -1，否则返回 0。如果文件不能建立或者写入失
                败，会有错误信息。

                另见  <a href="builtin.html#readfile()">readfile()</a> 。
                要按字节复制文件: 
<code class="example">                        :let fl = readfile("foo", "b")</code>
<code class="example">                        :call writefile(fl, "foocopy", "b")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;writefile("thefile")</code>

                返回类型:  <a href="eval.html#Number">Number</a> 


xor(<code class="special">{expr}</code>, <code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="xor()">xor()</a> </b>
                对两个参数进行按位异或。参数须转换为数值。列表、字典或浮点数参
                数会报错。
                另见  <a href="builtin.html#and()">and()</a>  和  <a href="builtin.html#or()">or()</a> 。
                示例: 
<code class="example">                        :let bits = xor(bits, 0x80)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :let bits = bits-&gt;xor(0x80)</code>

                返回类型:  <a href="eval.html#Number">Number</a> 

</section><hr class="doubleline" /><section class=inner>
<h4>3. 特性列表                                             <b class="vimtag"> <a name="feature-list">feature-list</a> </b></h4>
有三种类型的特性:
1.  只有在 Vim 编译时加入才会支持的特性  <a href="various.html#+feature-list">+feature-list</a> 。例如: 
<code class="example">        :if has("cindent")</code>
                                                        <b class="vimtag"> <a name="gui_running">gui_running</a> </b>
2.  只有特定条件满足才会支持的特性。例如: 
<code class="example">        :if has("gui_running")</code>
                                                        <b class="vimtag"> <a name="has-patch">has-patch</a> </b>
3.  特定版本之后或在特定版本上并包含了特定补丁。"patch-7.4.248" 特性意味着 Vim
    版本是 7.5 或之后，或 7.4 并包含了补丁 248。例如: 
<code class="example">        :if has("patch-7.4.248")</code>
    <code class="note">注意</code> 包含了补丁 249 但不包含补丁 248 是可能的，但这只适用于 cherrypick 补
    丁的情况。
    <code class="note">注意</code> 此形式只可用于 7.4.237 补丁或之后版本，在这之前，你需要检查补丁号和
    v:version。例如 (确定是 version 6.2.148 或更新的版本): 
<code class="example">        :if v:version &gt; 602 || v:version == 602 &amp;&amp; has("patch148")</code>
<code class="example"></code>
揭示: 要知道 Vim 是否支持文件名中的反斜杠 (MS-Windows)，
用: `if exists('+shellslash')`


acl                     编译时加入了  <a href="editing.html#ACL">ACL</a>  支持。
all_builtin_terms       编译时打开了所有的内建终端。(总为真)
amiga                   Vim 的 Amiga 版本。
arabic                  编译时加入了阿拉伯语的支持。 <a href="arabic.html#Arabic">Arabic</a> 。
arp                     编译时加入了 ARP 的支持。(Amiga)。
autocmd                 编译时加入了自动命令的支持。(总为真)
autochdir               编译时加入了 <a href="options.html#'autochdir'">'autochdir'</a> 的支持
autoservername          自动打开  <a href="remote.html#clientserver">clientserver</a> 
balloon_eval            编译时加入了  <a href="debugger.html#balloon-eval">balloon-eval</a>  的支持。
balloon_multiline       GUI 支持多行气泡。
beos                    Vim 的 BeOS 版本。
browse                  编译时加入了  <a href="editing.html#:browse">:browse</a>  的支持。使  <a href="builtin.html#browse()">browse()</a>  可用。
browsefilter            编译时加入了  <a href="editing.html#browsefilter">browsefilter</a>  的支持。
bsd                     编译时使用了 BSD 家族的 OS (除了 macOS)。
builtin_terms           编译时打开了一些内建终端。(总为真)
byte_offset             编译时加入了 <a href="options.html#'statusline'">'statusline'</a> 中对 'o' 的支持。
channel                 编译时加入了  <a href="channel.html#channel">channel</a>  和  <a href="channel.html#job">job</a>  的支持
cindent                 编译时加入了 <a href="options.html#'cindent'">'cindent'</a> 的支持。(总为真)
clientserver            编译时加入了远程调用的支持。 <a href="remote.html#clientserver">clientserver</a> 。
clipboard               编译时加入了 <a href="options.html#'clipboard'">'clipboard'</a> 的支持。
clipboard_provider      编译时加入了  <code class="badlink">clipboard-providers</code>  的支持。
clipboard_working       编译时加入了 <a href="options.html#'clipboard'">'clipboard'</a> 的支持且可用。
cmdline_compl           编译时加入了  <a href="cmdline.html#cmdline-completion">cmdline-completion</a>  的支持。
cmdline_hist            编译时加入了  <a href="cmdline.html#cmdline-history">cmdline-history</a>  的支持。
cmdline_info            编译时加入了 <a href="options.html#'showcmd'">'showcmd'</a> 和 <a href="options.html#'ruler'">'ruler'</a> 的支持。
comments                编译时加入了 <a href="options.html#'comments'">'comments'</a> 的支持。
compatible              编译时确保和 Vi 非常兼容。
conpty                   <a href="terminal.html#ConPTY">ConPTY</a>  可用的平台。
cryptv                  编译时加入了加密的支持。 <a href="editing.html#encryption">encryption</a> 。
cscope                  编译时加入了  <a href="if_cscop.html#cscope">cscope</a>  的支持。
cursorbind              编译时加入了 <a href="options.html#'cursorbind'">'cursorbind'</a> 的支持 (总为真)
debug                   编译时定义了 "DEBUG"。
dialog_con              编译时加入了控制台对话框的支持。
dialog_con_gui          编译时加入了控制台和 GUI 对话框的支持。
dialog_gui              编译时加入了 GUI 对话框的支持。
diff                    编译时加入了  <a href="diff.html#vimdiff">vimdiff</a>  和 <a href="options.html#'diff'">'diff'</a> 的支持。
digraphs                编译时加入了二合字母的支持。
directx                 编译时加入了 DirectX 和 <a href="options.html#'renderoptions'">'renderoptions'</a> 的支持。
dnd                     编译时加入了 "~ 寄存器的支持  <a href="change.html#quote_%7E">quote_~</a> 。
drop_file               编译时加入了  <a href="gui.html#drop_file">drop_file</a>  的支持。
ebcdic                  在使用 ebcdic 字符集的机器上编译。
emacs_tags              编译时加入了 Emcac 标签的支持。
eval                    编译时加入了表达式计算的支持。当然总要打开啦！
ex_extra                 <a href="various.html#+ex_extra">+ex_extra</a>  (总为真)
extra_search            编译时加入了 <a href="options.html#'incsearch'">'incsearch'</a> 和 <a href="options.html#'hlsearch'">'hlsearch'</a> 的支持。
farsi                   删除了波斯语的支持  <a href="farsi.html#farsi">farsi</a> 。
file_in_path            编译时加入了  <a href="editing.html#gf">gf</a>  和  <a href="cmdline.html#%3Ccfile%3E">&lt;cfile&gt;</a>  的支持。(总为真)
filterpipe              <a href="options.html#'shelltemp'">'shelltemp'</a> 关闭时，外壳读/写/过滤命令使用管道
find_in_path            编译时加入了头文件搜索  <a href="various.html#+find_in_path">+find_in_path</a>  的支持。
float                   编译时加入了  <a href="eval.html#Float">Float</a>  的支持。
fname_case              文件名大小写敏感 (在 Amiga 和 Windows 本特性不存在)。
folding                 编译时加入了  <a href="fold.html#folding">folding</a>  的支持。
footer                  编译时加入了 GUI 信息页脚的支持。 <a href="debugger.html#gui-footer">gui-footer</a> 
fork                    编译时决定使用 fork()/exec() 而不是 system()。
gettext                 编译时加入了信息翻译  <a href="mlang.html#multi-lang">multi-lang</a> 。
gui                     编译时加入了 GUI 的支持。
gui_athena              编译时加入了 Athena GUI。(总为假)
gui_gnome               编译时加入了 Gnome 支持 (同时也定义了 gui_gtk)。
gui_gtk                 编译时加入了 GTK+ GUI (任何版本)。
gui_gtk2                编译时加入了 GTK+ 2 GUI (同时也定义了 gui_gtk)。
gui_gtk3                编译时加入了 GTK+ 3 GUI (同时也定义了 gui_gtk)。
gui_haiku               编译时加入了 Haiku GUI。
gui_mac                 编译时加入了 Macintosh GUI。
gui_motif               编译时加入了 Motif GUI。
gui_photon              编译时加入了 Photon GUI。
gui_running             Vim 在 GUI 上运行，或者 GUI 将很快启动。
gui_win32               编译时加入了 MS-Windows Win32 GUI。
gui_win32s              同上，使用了 Win32s 系统 (Windows 3.1)
haiku                   Vim 的 Haiku 版本。
hangul_input            编译时加入了韩语输入的支持。 <a href="hangulin.html#hangul">hangul</a> 
hpux                    Vim 的 HP-UX 版本。
hurd                    Vim 的 GNU/Hurd 版本
iconv                   可以使用 iconv() 进行转换。
insert_expand           编译时加入了插入模式中 <code class="keystroke">CTRL-X</code> 扩展命令的支持。(总为真)
job                     编译时加入了  <a href="channel.html#channel">channel</a>  和  <a href="channel.html#job">job</a>  的支持
ipv6                    编译时加入了  <a href="channel.html#channel">channel</a>  的 IPv6 网络支持
jumplist                编译时加入了  <a href="motion.html#jumplist">jumplist</a>  的支持。(总为真)
keymap                  编译时加入了 <a href="options.html#'keymap'">'keymap'</a> 的支持。
lambda                  编译时加入了  <a href="eval.html#lambda">lambda</a>  的支持。
langmap                 编译时加入了 <a href="options.html#'langmap'">'langmap'</a> 的支持。
libcall                 编译时加入了  <a href="builtin.html#libcall()">libcall()</a>  的支持。
linebreak               编译时加入了 <a href="options.html#'linebreak'">'linebreak'</a>、<a href="options.html#'breakat'">'breakat'</a>、<a href="options.html#'showbreak'">'showbreak'</a> 和
                        <a href="options.html#'breakindent'">'breakindent'</a> 的支持。
linux                   Vim 的 Linux 版本。
lispindent              编译时加入了 lisp 缩进的支持。(总为真)
listcmds                编译时加入了缓冲区列表  <a href="windows.html#:files">:files</a>  和参数列表  <a href="editing.html#arglist">arglist</a> 
                        的命令。
localmap                编译时加入了局部映射和缩写。 <a href="map.html#:map-local">:map-local</a> 
lua                     编译时加入了 Lua 接口  <a href="if_lua.html#Lua">Lua</a> 。
mac                     Vim 的 Macintosh 版本，参照 osx
macunix                 同 osxdarwin
menu                    编译时加入了  <a href="gui.html#:menu">:menu</a>  的支持。
mksession               编译时加入了  <a href="starting.html#:mksession">:mksession</a>  的支持。
modify_fname            编译时加入了文件名的修饰符支持。 <a href="cmdline.html#filename-modifiers">filename-modifiers</a> 
                        (总为真)
mouse                   编译时加入了鼠标的支持。
mouse_dec               编译时加入了 Dec 终端的鼠标支持。
mouse_gpm               编译时加入了 gpm (Linux 控制台鼠标) 的支持。
mouse_gpm_enabled       GPM 鼠标可用
mouse_netterm           编译时加入了 netterm 的鼠标支持。
mouse_pterm             编译时加入了 qnx 的鼠标支持。
mouse_sysmouse          编译时加入了 sysmouse 支持 (*BSD 控制台鼠标)
mouse_sgr               编译时加入了 sgr 的鼠标支持。
mouse_urxvt             编译时加入了 urxvt 的鼠标支持。
mouse_xterm             编译时加入了 xterm 的鼠标支持。
mouseshape              编译时加入了 <a href="options.html#'mouseshape'">'mouseshape'</a> 的支持。
multi_byte              编译时加入了 <a href="options.html#'encoding'">'encoding'</a> 的支持 (总为真)
multi_byte_encoding     <a href="options.html#'encoding'">'encoding'</a> 设为某个多字节的编码。
multi_byte_ime          编译时加入了 IME 输入方法的支持。
multi_lang              编译时加入了多语言的支持。
mzscheme                编译时加入了 MzScheme 接口支持  <a href="if_mzsch.html#mzscheme">mzscheme</a> 。
nanotime                编译时加入了次秒级的时间戳检查。
netbeans_enabled        编译时加入了  <a href="netbeans.html#netbeans">netbeans</a>  的支持并且已连接上。
netbeans_intg           编译时加入了  <a href="netbeans.html#netbeans">netbeans</a>  的支持。
num64                   编译时加入了64 位  <a href="eval.html#Number">Number</a>  的支持。(总为真)
ole                     编译时加入了 Win32 OLE automation 的支持。
osx                     为 macOS 编译，参照 mac
osxdarwin               为 macOS 编译，带有  <a href="os_mac.html#mac-darwin-feature">mac-darwin-feature</a> 
packages                编译时加入了  <a href="repeat.html#packages">packages</a>  的支持。
path_extra              编译时加入了 <a href="options.html#'path'">'path'</a> 和 <a href="options.html#'tags'">'tags'</a> 上下搜索的支持。
perl                    编译时加入了 Perl 接口。
persistent_undo         编译时加入了持久化撤销历史的支持。
postscript              编译时加入了 PostScript 文件打印的支持。
printer                 编译时加入了  <a href="print.html#:hardcopy">:hardcopy</a>  的支持。
profile                 编译时加入了  <a href="repeat.html#:profile">:profile</a>  的支持。
prof_nsec               剖视结果以纳秒计。
python                  Python 2.x 接口可用。 <a href="if_pyth.html#has-python">has-python</a> 
python_compiled         编译时加入了 Python 2.x 接口。 <a href="if_pyth.html#has-python">has-python</a> 
python_dynamic          Python 2.x 接口已动态载入。 <a href="if_pyth.html#has-python">has-python</a> 
python3                 Python 3.x 接口可用。 <a href="if_pyth.html#has-python">has-python</a> 
python3_compiled        编译时加入了 Python 3.x 接口。 <a href="if_pyth.html#has-python">has-python</a> 
python3_dynamic         Python 3.x 接口已动态载入。 <a href="if_pyth.html#has-python">has-python</a> 
python3_stable          Python 3.x 接口使用 Python 稳定 ABI。 <a href="if_pyth.html#has-python">has-python</a> 
pythonx                 Python 2.x 和/或 3.x 接口可用。 <a href="if_pyth.html#pythonx">pythonx</a> 
qnx                     Vim 的 QNX 版本。
quickfix                编译时加入了  <a href="quickfix.html#quickfix">quickfix</a>  的支持。
reltime                 编译时加入了  <a href="builtin.html#reltime()">reltime()</a>  的支持。
rightleft               编译时加入了 <a href="options.html#'rightleft'">'rightleft'</a> 的支持。
ruby                    编译时加入了 Ruby 接口  <a href="if_ruby.html#ruby">ruby</a> 。
scrollbind              编译时加入了 <a href="options.html#'scrollbind'">'scrollbind'</a> 的支持。(总为真)
showcmd                 编译时加入了 <a href="options.html#'showcmd'">'showcmd'</a> 的支持。
signs                   编译时加入了  <a href="sign.html#:sign">:sign</a>  的支持。
smartindent             编译时加入了 <a href="options.html#'smartindent'">'smartindent'</a> 的支持。(总为真)
socketserver            编译时加入了套接字服务器功能。(只限 Unix)
sodium                  编译时加入了 libsodium 以提供更好的加密支持
sound                   编译时加入了声音的支持，例如  <a href="builtin.html#sound_playevent()">sound_playevent()</a> 
spell                   编译时加入了拼写检查的支持  <a href="spell.html#spell">spell</a> 。
startuptime             编译时加入了  <a href="starting.html#--startuptime">--startuptime</a>  支持。
statusline              编译时加入了 <a href="options.html#'statusline'">'statusline'</a> 和 <a href="options.html#'rulerformat'">'rulerformat'</a> 还有
                        <a href="options.html#'titlestring'">'titlestring'</a> 和 <a href="options.html#'iconstring'">'iconstring'</a> 的特殊格式的支持。
sun                     Vim 的 SunOS 版本。
sun_workshop            删除了 Sun  <a href="workshop.html#workshop">workshop</a>  的支持。
syntax                  编译时加入了语法高亮的支持  <a href="syntax.html#syntax">syntax</a> 。
syntax_items            当前缓冲区有激活的语法高亮项目。
system                  编译时决定使用 system() 而不是 fork()/exec()。
tag_binary              编译时加入了标签文件的二分搜索  <a href="tagsrch.html#tag-binary-search">tag-binary-search</a> 。
                        (总为真)
tag_old_static          删除了老的静态标签的支持，见  <a href="tagsrch.html#tag-old-static">tag-old-static</a> 。
tcl                     编译时加入了 Tcl 接口。
termguicolors           编译时加入了终端的真彩支持。
terminal                编译时加入  <a href="terminal.html#terminal">terminal</a>  的支持。
terminfo                编译时决定使用 terminfo 而不是 termcap。
termresponse            编译时加入了  <a href="term.html#t_RV">t_RV</a>  和  <a href="eval.html#v:termresponse">v:termresponse</a>  的支持。
textobjects             编译时加入了  <a href="motion.html#text-objects">text-objects</a>  的支持。
textprop                编译时加入了  <a href="textprop.html#text-properties">text-properties</a>  的支持。
tgetent                 编译时加入了 tgetent 的支持，可以使用外部 termcap 或
                        terminfo 文件。
timers                  编译时加入了  <a href="builtin.html#timer_start()">timer_start()</a>  支持。
title                   编译时加入了窗口标题的支持。<a href="options.html#'title'">'title'</a>。(总为真)
toolbar                 编译时加入了  <a href="gui.html#gui-toolbar">gui-toolbar</a>  的支持。
ttyin                   输入是终端 (tty)
ttyout                  输出是终端 (tty)
unix                    Vim 的 Unix 版本。 <b class="vimtag"> <a name="+unix">+unix</a> </b>
unnamedplus             编译时加入了 <a href="options.html#'clipboard'">'clipboard'</a> 对 "unnamedplus" 的支持。
user_commands           用户定义命令支持。(总为真)
vartabs                 编译时加入了可变制表位的支持 <a href="options.html#'vartabstop'">'vartabstop'</a>。
vcon                    Win32: 有虚拟终端支持，可用 <a href="options.html#'termguicolors'">'termguicolors'</a>。另见
                         <a href="various.html#+vtp">+vtp</a> 。
vertsplit               编译时加入了垂直分割窗口的支持  <a href="windows.html#:vsplit">:vsplit</a> 。(总为真)
vim_starting            如果在启动载入脚本的阶段则为真。 <a href="starting.html#startup">startup</a> 
                        <b class="vimtag"> <a name="vim_starting">vim_starting</a> </b>
vim9script              编译时加入  <a href="vim9.html#Vim9">Vim9</a>  脚本支持
viminfo                 编译时加入了 viminfo 的支持。
vimscript-1             编译时加入了 Vim 脚本版本 1 的支持
vimscript-2             编译时加入了 Vim 脚本版本 2 的支持
vimscript-3             编译时加入了 Vim 脚本版本 3 的支持
vimscript-4             编译时加入了 Vim 脚本版本 4 的支持
virtualedit             编译时加入了 <a href="options.html#'virtualedit'">'virtualedit'</a> 选项支持。(总为真)
visual                  编译时加入了可视模式的支持。(总为真)
visualextra             编译时加入了附加的可视模式命令支持。(总为真)
                         <a href="visual.html#blockwise-operators">blockwise-operators</a> 。
vms                     Vim 的 VMS 版本。
vreplace                编译时加入了  <a href="change.html#gR">gR</a>  和  <a href="change.html#gr">gr</a>  命令支持。(总为真)
vtp                     编译时加入了 vcon 支持  <a href="various.html#+vtp">+vtp</a>  (检查 vcon 可知当前控制
                        台是否支持)。
wayland                 编译时加入了 Wayland 协议支持。
wayland_clipboard       编译时加入了 Wayland 剪贴板支持。
wayland_focus_steal     编译时加入了 Wayland 剪贴板焦点盗取支持。
wildignore              编译时加入了 <a href="options.html#'wildignore'">'wildignore'</a> 选项支持。
wildmenu                编译时加入了 <a href="options.html#'wildmenu'">'wildmenu'</a> 选项支持。
win16                   旧版本 MS-Windows 3.1 (总为假)
win32                   Vim 的 Win32 版本。(MS-Windows 95 及其后的 32 或 64 位
                        版本)。
win32unix               Vim 的 Win32 版本。使用 Unix 文件命名 (Cygwin)
win64                   Vim 的 Win64 版本。(MS-Windows 64 位)。
win95                   支持 MS-Windows 95/98/ME 的 Win32 版本 (总为假)
winaltkeys              编译时加入了 <a href="options.html#'winaltkeys'">'winaltkeys'</a> 选项。
windows                 编译时加入了多窗口的支持。(总为真)
writebackup             编译时决定缺省打开 <a href="options.html#'writebackup'">'writebackup'</a>。
xattr                   编译时加入了扩展属性支持  <a href="editing.html#xattr">xattr</a>  (目前只有 Linux 支
                        持)。
xfontset                编译时加入了 X 字体集 的支持。 <a href="mbyte.html#xfontset">xfontset</a> 。
xim                     编译时加入了 X 输入法 的支持。 <a href="mbyte.html#xim">xim</a> 。
xpm                     编译时加入了 pixmap 的支持。
xpm_w32                 编译时加入了 Win32 的 pixmap 的支持。(只为后向兼容而
                        保留，用 "xpm" 代替)
xsmp                    编译时加入了 X 会话管理 的支持。
xsmp_interact           编译时加入了交互的 X 会话管理 的支持。
xterm_clipboard         编译时加入了 xterm 剪贴板的支持。
xterm_save              编译时加入了保存和恢复 xterm 屏幕的支持。
x11                     编译时加入了 X11 的支持。


</section><hr class="doubleline" /><section class=inner>
<h4>4. 字符串里的模式匹配                                   <b class="vimtag"> <a name="string-match">string-match</a> </b></h4>
这是若干函数共同的功能。 <a href="pattern.html#pattern">pattern</a>  说明的正则表达式通常用于寻找缓冲区行的匹配。
如果匹配用来在字符串里寻找匹配，几乎所有的功能都相同。唯一的区别是，字符串是作
为单行处理的。如果字符串里包含了 "\n" 字符，它并不看作是模式里的换行。它可以匹
配模式里的 "\n"，甚至于 "."。示例: 
<code class="example">        :let a = "aaaa\nxxxx"</code>
<code class="example">        :echo matchstr(a, "..\n..")</code>
<code class="example">        aa</code>
<code class="example">        xx</code>
<code class="example">        :echo matchstr(a, "a.x")</code>
<code class="example">        a</code>
<code class="example">        x</code>
<code class="example"></code>
不要忘记 "^" 只会在字符串的第一个字符匹配，而 "$" 在字符串的最后一个字符匹配。
它们不会匹配 "\n" 之后和之前的位置。

 vim:tw=78:ts=8:noet:ft=help:norl:
</section>
</article>
<footer>
Generated by vim2html
</footer>
</body>
</html>
