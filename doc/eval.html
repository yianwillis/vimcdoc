<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<![endif]-->
<title>VIM: eval</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css" />
</head>
<body>
<nav id=banner>
<a href="help.html">帮助总览</a> &middot;
<hr/>
<a href="quickref.html">快速参考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="eval.html#functions">函数列表</a> &middot;
<a href="quickref.html#option-list">选项列表</a> &middot;
<a href="tags.html">标签索引</a> &middot;
<hr/>
<a href="usr_toc.html">用户手册</a> &middot;
<a href="help.html#reference_toc">参考手册</a>
</nav>

<article id=outer>
<header>
<h2>eval</h2>
</header>
<section class=inner>
<b class="vimtag"> <a name="eval.txt">eval.txt</a> </b>      For Vim version 8.2.  最近更新: 2019年12月


                  <code class="vim">VIM 参考手册    by Bram Moolenaar</code>
                                <code class="vim">译者</code>: Willis
                                http://vimcdoc.sf.net


表达式求值                              <b class="vimtag"> <a name="expression">expression</a> </b> <b class="vimtag"> <a name="expr">expr</a> </b> <b class="vimtag"> <a name="E15">E15</a> </b> <b class="vimtag"> <a name="eval">eval</a> </b>

用户手册第 41 章  <a href="usr_41.html#usr_41.txt">usr_41.txt</a>  有使用表达式的介绍。

<code class="note">注意</code>: 表达式求值可以在编译时关闭。如果你这么做，本文档介绍的特性就不复存在。见
 <a href="various.html#+eval">+eval</a>  和  <a href="eval.html#no-eval-feature">no-eval-feature</a> 。

1.  变量                 <a href="eval.html#variables">variables</a> 
    1.1 变量类型
    1.2 函数引用                 <a href="eval.html#Funcref">Funcref</a> 
    1.3 列表                     <a href="eval.html#Lists">Lists</a> 
    1.4 字典                     <a href="eval.html#Dictionaries">Dictionaries</a> 
    1.5 blob                     <a href="eval.html#Blobs">Blobs</a> 
    1.6 变量的更多细节           <a href="eval.html#more-variables">more-variables</a> 
2.  表达式语法           <a href="eval.html#expression-syntax">expression-syntax</a> 
3.  内部变量             <a href="eval.html#internal-variables">internal-variables</a> 
4.  内建函数             <a href="eval.html#functions">functions</a> 
5.  定义函数             <a href="eval.html#user-functions">user-functions</a> 
6.  花括号名字           <a href="eval.html#curly-braces-names">curly-braces-names</a> 
7.  命令                 <a href="eval.html#expression-commands">expression-commands</a> 
8.  例外处理             <a href="eval.html#exception-handling">exception-handling</a> 
9.  示例                 <a href="eval.html#eval-examples">eval-examples</a> 
10. Vim 脚本版本         <a href="eval.html#vimscript-version">vimscript-version</a> 
11. 不包含 +eval 特性    <a href="eval.html#no-eval-feature">no-eval-feature</a> 
12. 沙盘 (sandbox)       <a href="eval.html#eval-sandbox">eval-sandbox</a> 
13. 文本锁               <a href="eval.html#textlock">textlock</a> 

测试支持的文档可见  <a href="testing.html#testing.txt">testing.txt</a> 。
剖视的文档可见  <a href="repeat.html#profiling">profiling</a> 。

</section><hr class="doubleline" /><section class=inner>
<h4>1. 变量                                                 <b class="vimtag"> <a name="variables">variables</a> </b></h4>
<code class="section">1.1 变量类型 </code>
                                                <b class="vimtag"> <a name="E712">E712</a> </b> <b class="vimtag"> <a name="E896">E896</a> </b> <b class="vimtag"> <a name="E897">E897</a> </b> <b class="vimtag"> <a name="E899">E899</a> </b>
有十种类型的变量:

                                                        <b class="vimtag"> <a name="Number">Number</a> </b> <b class="vimtag"> <a name="Integer">Integer</a> </b>
数值            32 位或 64 位带符号整数。 <a href="eval.html#expr-number">expr-number</a> 
                64-位整数只有在编译时带  <a href="various.html#+num64">+num64</a>  特性时才有效。
                示例:  -123  0x10  0177  0b1011

浮点数          带小数的数值。 <a href="eval.html#floating-point-format">floating-point-format</a>  <b class="vimtag"> <a name="Float">Float</a> </b>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>
                示例: 123.456  1.15e-6  -1.1e3

                                                        <b class="vimtag"> <a name="E928">E928</a> </b>
字符串          NUL 结尾的 8 位无符号字符 (即字节) 的串。 <a href="eval.html#expr-string">expr-string</a> 
                示例: "ab\txx\"--"  'x-z''a,c'

列表            项目的有序的序列，详见  <a href="eval.html#List">List</a> 。
                示例: [1, 2, ['a', 'b']]

字典            关联的无序数组: 每个项目包含一个键和一个值。 <a href="eval.html#Dictionary">Dictionary</a> 
                示例:
                        {<code class="badlink">'blue'</code>: "#0000ff", <code class="badlink">'red'</code>: "#ff0000"}
                        #{blue: "#0000ff", red: "#ff0000"}

函数引用        指向一个函数的引用  <a href="eval.html#Funcref">Funcref</a> 。
                示例: function("strlen")
                可以绑定到字典或参数上，这样就类似于一个偏函数。
                示例: function("Callback", <code class="special">[arg]</code>, myDict)

特殊             <a href="eval.html#v:false">v:false</a> 、 <a href="eval.html#v:true">v:true</a> 、 <a href="eval.html#v:none">v:none</a>  和  <a href="eval.html#v:null">v:null</a> 。 <b class="vimtag"> <a name="Special">Special</a> </b>

作业            用于作业，见  <a href="channel.html#job_start()">job_start()</a> 。 <b class="vimtag"> <a name="Job">Job</a> </b> <b class="vimtag"> <a name="Jobs">Jobs</a> </b>

通道            用于通道，见  <a href="channel.html#ch_open()">ch_open()</a> 。 <b class="vimtag"> <a name="Channel">Channel</a> </b> <b class="vimtag"> <a name="Channels">Channels</a> </b>

blob            二进制大对象 (Binary Large Object)。存储任意字符序列。详见
                 <a href="eval.html#Blob">Blob</a> 
                示例: 0zFF00ED015DAF
                0z 是空 blob。


数值和字符串类型之间会根据使用的情况自动转换。

数值到字符串的转换使用数值的 ASCII 表示。例如:
<code class="section">        数值 123        --&gt;     字符串 "123" </code>
<code class="section">        数值 0          --&gt;     字符串 "0" </code>
<code class="section">        数值 -1         --&gt;     字符串 "-1" </code>
                                                        <b class="vimtag"> <a name="octal">octal</a> </b>
字符串到数值的转换则把字符串开头的一系列数字位转换成数值。可以识别十六进制
"0xf9"、八进制 "017" 和二进制 "0b10" 形式的数值 (<code class="note">注意</code>:  <a href="eval.html#scriptversion-4">scriptversion-4</a>  不识
别八进制)。如果字符串不以数字开始，则结果为零。
例如:
<code class="section">        字符串 "456"    --&gt;     数值 456 </code>
<code class="section">        字符串 "6bar"   --&gt;     数值 6 </code>
<code class="section">        字符串 "foo"    --&gt;     数值 0 </code>
<code class="section">        字符串 "0xf1"   --&gt;     数值 241 </code>
<code class="section">        字符串 "0100"   --&gt;     数值 64 </code>
<code class="section">        字符串 "0b101"  --&gt;     数值 5 </code>
<code class="section">        字符串 "-8"     --&gt;     数值 -8 </code>
<code class="section">        字符串 "+8"     --&gt;     数值 0 </code>

要强制从字符串转换到数值，给它加零: 
<code class="example">        :echo "0100" + 0</code>
<code class="section">        64 </code>

要避免开头的零导致八进制的转换，或者想换不同的基底，用  <a href="eval.html#str2nr()">str2nr()</a> 。

                                                <b class="vimtag"> <a name="TRUE">TRUE</a> </b> <b class="vimtag"> <a name="FALSE">FALSE</a> </b> <b class="vimtag"> <a name="Boolean">Boolean</a> </b>
布尔型的操作使用数值类型。零代表假值 (FALSE)，非零代表真值 (TRUE)。也可用
 <a href="eval.html#v:false">v:false</a>  和  <a href="eval.html#v:true">v:true</a> 。函数返回 TRUE 时相当于数值一，FALSE 相当于数值零。

<code class="note">注意</code> 在命令: 
<code class="example">        :if "foo"</code>
<code class="example">        :" _不_ 执行</code>
里，"foo" 被转换成 0，也就是假值。如果字符串以非零数字开始，则代表真值: 
<code class="example">        :if "8foo"</code>
<code class="example">        :" 执行</code>
要测试字符串非空，应该使用 empty(): 
<code class="example">        :if !empty("foo")</code>

                                                        <b class="vimtag"> <a name="non-zero-arg">non-zero-arg</a> </b>
函数参数和  <a href="eval.html#TRUE">TRUE</a>  行为通常略有差异: 如果参数存在且其值为非零数值、 <a href="eval.html#v:true">v:true</a>  或
非空字符串，则视之为真值。
<code class="note">注意</code> " " 和 "0" 也是非空字符串，亦应视为真值。列表、字典和浮点数不是数值或字符
串，因而视为假值。

                <b class="vimtag"> <a name="E745">E745</a> </b> <b class="vimtag"> <a name="E728">E728</a> </b> <b class="vimtag"> <a name="E703">E703</a> </b> <b class="vimtag"> <a name="E729">E729</a> </b> <b class="vimtag"> <a name="E730">E730</a> </b> <b class="vimtag"> <a name="E731">E731</a> </b> <b class="vimtag"> <a name="E908">E908</a> </b> <b class="vimtag"> <a name="E910">E910</a> </b> <b class="vimtag"> <a name="E913">E913</a> </b>
                <b class="vimtag"> <a name="E974">E974</a> </b> <b class="vimtag"> <a name="E975">E975</a> </b> <b class="vimtag"> <a name="E976">E976</a> </b>
 <a href="eval.html#List">List</a> 、 <a href="eval.html#Dictionary">Dictionary</a> 、 <a href="eval.html#Funcref">Funcref</a> 、 <a href="eval.html#Job">Job</a> 、 <a href="eval.html#Channel">Channel</a>  和  <a href="eval.html#Blob">Blob</a>  类型不会自动进行转
换。

                                                        <b class="vimtag"> <a name="E805">E805</a> </b> <b class="vimtag"> <a name="E806">E806</a> </b> <b class="vimtag"> <a name="E808">E808</a> </b>
混合数值和浮点数的计算时，数值转换为浮点数。否则没有自动到浮点数的转换。用
str2float() 可转换字符串到浮点数，printf() 从浮点数到字符串，float2nr() 则从浮
点数到数值。

                        <b class="vimtag"> <a name="E891">E891</a> </b> <b class="vimtag"> <a name="E892">E892</a> </b> <b class="vimtag"> <a name="E893">E893</a> </b> <b class="vimtag"> <a name="E894">E894</a> </b> <b class="vimtag"> <a name="E907">E907</a> </b> <b class="vimtag"> <a name="E911">E911</a> </b> <b class="vimtag"> <a name="E914">E914</a> </b>
期待浮点数的地方也可用数值代替，但其它都不行。

                                                <b class="vimtag"> <a name="no-type-checking">no-type-checking</a> </b>
试图改变变量类型不会报错。


<code class="section">1.2 函数引用 </code>
                                        <b class="vimtag"> <a name="Funcref">Funcref</a> </b> <b class="vimtag"> <a name="E695">E695</a> </b> <b class="vimtag"> <a name="E718">E718</a> </b>
函数引用变量可以通过  <a href="eval.html#function()">function()</a>  函数、 <a href="eval.html#funcref()">funcref()</a>  函数或者  <a href="eval.html#expr-lambda">expr-lambda</a>  匿
名表达式得到。可以在表达式里用它来代替函数名，在围绕参数的括号之前，以调用它引
用的函数。例如: 
<code class="example"></code>
<code class="example">        :let Fn = function("MyFunc")</code>
<code class="example">        :echo Fn()</code>
                                                        <b class="vimtag"> <a name="E704">E704</a> </b> <b class="vimtag"> <a name="E705">E705</a> </b> <b class="vimtag"> <a name="E707">E707</a> </b>
函数引用变量必须以大写字母、"s:"、"w:"、"t:" 或 "b:" 开始。可以用 "g:"，但后面
的名字必须以大写开始。函数引用变量不能和任何函数重名。

特例是可以定义函数并直接把它的函数引用赋给字典的一个项目。例如: 
<code class="example">        :function dict.init() dict</code>
<code class="example">        :   let self.val = 0</code>
<code class="example">        :endfunction</code>
<code class="example"></code>
该字典的键可以用小写字母开始。这里不用实际的函数名。另见  <a href="eval.html#numbered-function">numbered-function</a> 。

函数引用可以用  <a href="eval.html#:call">:call</a>  命令调用: 
<code class="example">        :call Fn()</code>
<code class="example">        :call dict.init()</code>
<code class="example"></code>
所引用的函数的名字可以用  <a href="eval.html#string()">string()</a>  得到， 
<code class="example">        :let func = string(Fn)</code>
<code class="example"></code>
你可以用  <a href="eval.html#call()">call()</a>  来调用函数引用并用一个列表变量来传递参数: 
<code class="example">        :let r = call(Fn, mylist)</code>

                                                                <b class="vimtag"> <a name="Partial">Partial</a> </b>
函数引用可以选择绑定字典和/或参数，也叫偏函数。通过向 function() 或 funcref()
提供字典和/或参数完成。调用函数时，该字典和/或参数被传入函数。例如: 
<code class="example"></code>
<code class="example">        let Cb = function('Callback', ['foo'], myDict)</code>
<code class="example">        call Cb('bar')</code>
<code class="example"></code>
这类似于如下方式地调用函数: 
<code class="example">        call myDict.Callback('foo', 'bar')</code>
<code class="example"></code>
对  <a href="channel.html#ch_open()">ch_open()</a>  这样传递函数作为参数的情况，这很有用。

<code class="note">注意</code> 把函数作为字典的一个成员时，也会绑定函数到字典: 
<code class="example"></code>
<code class="example">        let myDict.myFunction = MyFunction</code>
<code class="example">        call myDict.myFunction()</code>
<code class="example"></code>
这里，调用 "myFunction" 成员时，MyFunction() 会通过 "self" 得到 myDict。如果把
"myFunction" 赋给 otherDict 并调用之，则相应绑定到 otherDict 上: 
<code class="example"></code>
<code class="example">        let otherDict.myFunction = myDict.myFunction</code>
<code class="example">        call otherDict.myFunction()</code>
<code class="example"></code>
现在 "self" 变成了 "otherDict"。但字典如果是显式绑定，这不会发生: 
<code class="example"></code>
<code class="example">        let myDict.myFunction = function(MyFunction, myDict)</code>
<code class="example">        let otherDict.myFunction = myDict.myFunction</code>
<code class="example">        call otherDict.myFunction()</code>
<code class="example"></code>
这里 "self" 还是 "myDict"，因为是通过显式绑定的。


<code class="section">1.3 列表 </code>
                                                <b class="vimtag"> <a name="list">list</a> </b> <b class="vimtag"> <a name="List">List</a> </b> <b class="vimtag"> <a name="Lists">Lists</a> </b> <b class="vimtag"> <a name="E686">E686</a> </b>
列表是项目的有序序列。项目可以是任何类型，用索引号可以进行访问。可以在序列的任
何位置上增加或者删除项目。


<code class="section">列表建立 </code>
                                                        <b class="vimtag"> <a name="E696">E696</a> </b> <b class="vimtag"> <a name="E697">E697</a> </b>
列表用方括号里逗号分隔的项目序列建立。例如: 
<code class="example">        :let mylist = [1, two, 3, "four"]</code>
<code class="example">        :let emptylist = []</code>
<code class="example"></code>
项目可以是任何表达式。用列表作为项目就能建立列表的列表: 
<code class="example">        :let nestlist = [[11, 12], [21, 22], [31, 32]]</code>
<code class="example"></code>
忽略末项之后额外的逗号。


<code class="section">列表索引 </code>
                                                        <b class="vimtag"> <a name="list-index">list-index</a> </b> <b class="vimtag"> <a name="E684">E684</a> </b>
在列表之后的方括号中放上索引号可以访问列表项目。索引从零开始，也就是说，第一个
项目的索引值为零。 
<code class="example">        :let item = mylist[0]           " 得到第一个项目: 1</code>
<code class="example">        :let item = mylist[2]           " 得到第三个项目: 3</code>
<code class="example"></code>
如果返回的项目本身是列表，可以重复这样的操作: 
<code class="example">        :let item = nestlist[0][1]      " 得到第一个列表的第二个项目: 12</code>

负索引从尾端开始计算。索引 -1 指向列表的最后一个项目，-2 指向倒数第二个项目，
依此类推。 
<code class="example">        :let last = mylist[-1]          " 得到最后一个项目: "four"</code>
<code class="example"></code>
要避免非法索引值产生的错误，用  <a href="eval.html#get()">get()</a>  函数。如果项目不存在，它返回零或者你指
定的缺省值: 
<code class="example">        :echo get(mylist, idx)</code>
<code class="example">        :echo get(mylist, idx, "NONE")</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">列表连接 </code>

两个列表可以用 "+" 操作符连接: 
<code class="example">        :let longlist = mylist + [5, 6]</code>
<code class="example">        :let mylist += [7, 8]</code>
<code class="example"></code>
要在前面或后面附加项目，在项目外面加上 [] 从而把它变为一个列表。要改变列表内部
的值，见下  <a href="eval.html#list-modification">list-modification</a> 。


<code class="section">子列表</code>
                                                        <b class="vimtag"> <a name="sublist">sublist</a> </b>
列表的一部分可以通过指定首末两个索引获得，方括号内以冒号分隔两者: 
<code class="example">        :let shortlist = mylist[2:-1]   " 得到列表 [3, "four"]</code>
<code class="example"></code>
首索引的省略类似于用 0。末索引的省略类似于用 -1。 
<code class="example">        :let endlist = mylist[2:]       " 从项目 2 到结束: [3, "four"]</code>
<code class="example">        :let shortlist = mylist[2:2]    " 单个项目的列表: [3]</code>
<code class="example">        :let otherlist = mylist[:]      " 复制列表</code>
<code class="example"></code>
如果首索引在列表末项之后或者末索引小于首索引，返回空列表。没有错误信息。

如果末索引大于等于列表的长度，使用列表长度减一: 
<code class="example">        :let mylist = [0, 1, 2, 3]</code>
<code class="example">        :echo mylist[2:8]               " 返回: [2, 3]</code>

<code class="note">注意</code>: mylist[s:e] 意味着用变量 "s:e" 作为索引。在 ":" 之前用单个字母作为变量要
小心。需要的话加上空格: mylist[s : e]。


<code class="section">列表同一 </code>
                                                        <b class="vimtag"> <a name="list-identity">list-identity</a> </b>
如果变量 "aa" 是列表，把它赋给另一个变量 "bb" 后，两个变量指向同一列表。因此，
对列表 "aa" 的修改也同时修改了 "bb": 
<code class="example">        :let aa = [1, 2, 3]</code>
<code class="example">        :let bb = aa</code>
<code class="example">        :call add(aa, 4)</code>
<code class="example">        :echo bb</code>
        [1, 2, 3, 4]

 <a href="eval.html#copy()">copy()</a>  函数可以复制列表。如上所述，用 [:] 也可。这种方式建立列表的浅备份: 改
变列表中的列表项目仍然会修改复制列表的相应项目: 
<code class="example">        :let aa = [[1, 'a'], 2, 3]</code>
<code class="example">        :let bb = copy(aa)</code>
<code class="example">        :call add(aa, 4)</code>
<code class="example">        :let aa[0][1] = 'aaa'</code>
<code class="example">        :echo aa</code>
        [[1, aaa], 2, 3, 4] 
<code class="example">        :echo bb</code>
        [[1, aaa], 2, 3]

要建立一个完全独立的列表，用  <a href="eval.html#deepcopy()">deepcopy()</a> 。它递归地建立列表值的备份。最深可达
100 层。

可用操作符 "is" 检查两个变量是否指向同一个列表。"isnot" 刚好相反。与此对照，
"==" 比较两个列表的值是否相同。 
<code class="example">        :let alist = [1, 2, 3]</code>
<code class="example">        :let blist = [1, 2, 3]</code>
<code class="example">        :echo alist is blist</code>
        0 
<code class="example">        :echo alist == blist</code>
        1

比较列表时 <code class="note">注意</code>: 如果长度相同，所有项目用 "==" 的比较的结果也相同，两个列表就
认为相同。有一个例外: 数值和字符串总被认为不相同。这里不进行自动类型转换，而在
变量间直接用 "==" 却不是如此。例如: 
<code class="example">        echo 4 == "4"</code>
        1 
<code class="example">        echo [4] == ["4"]</code>
        0

因此可以说，列表的比较比数值和字符串的比较更严格。你同样可以用这种方式比较简单
类型的值，把它们放到列表里就行了: 
<code class="example"></code>
<code class="example">        :let a = 5</code>
<code class="example">        :let b = "5"</code>
<code class="example">        :echo a == b</code>
        1 
<code class="example">        :echo [a] == [b]</code>
        0


<code class="section">列表解包 </code>

要给列表项目解包，即把它们分别存入单独的变量，用方括号把变量括起来，如同把它们
当作列表项目: 
<code class="example">        :let [var1, var2] = mylist</code>
<code class="example"></code>
如果变量和列表的项目数量不同，报错。要处理列表中所有额外的项目，加上 ";" 和单
个变量: 
<code class="example">        :let [var1, var2; rest] = mylist</code>
<code class="example"></code>
它的工作方式就像: 
<code class="example">        :let var1 = mylist[0]</code>
<code class="example">        :let var2 = mylist[1]</code>
<code class="example">        :let rest = mylist[2:]</code>
<code class="example"></code>
如果只有两个项目，不会报错。这时 "rest" 成为空表。


<code class="section">列表修改 </code>
                                                        <b class="vimtag"> <a name="list-modification">list-modification</a> </b>
要修改列表的指定项目，用  <a href="eval.html#:let">:let</a> : 
<code class="example">        :let list[4] = "four"</code>
<code class="example">        :let listlist[0][3] = item</code>
<code class="example"></code>
要修改列表的一部分，可以指定要修改的首末项目。提供的值的个数必须不少于该范围内
的项目数: 
<code class="example">        :let list[3:5] = [3, 4, 5]</code>
<code class="example"></code>
给列表增加和删除项目可以通过函数完成。一些例子如下: 
<code class="example">        :call insert(list, 'a')         " 在最前面插入 'a'</code>
<code class="example">        :call insert(list, 'a', 3)      " 在 list[3] 前插入项目 'a'</code>
<code class="example">        :call add(list, "new")          " 在最后附加字符串项目</code>
<code class="example">        :call add(list, [1, 2])         " 在最后附加新的列表项目</code>
<code class="example">        :call extend(list, [1, 2])      " 在最后扩展列表，使之多包含两个项目</code>
<code class="example">        :let i = remove(list, 3)        " 删除项目 3</code>
<code class="example">        :unlet list[3]                  " 同上</code>
<code class="example">        :let l = remove(list, 3, -1)    " 从项目 3 删除到最后</code>
<code class="example">        :unlet list[3 : ]               " 同上</code>
<code class="example">        :call filter(list, 'v:val !~ "x"')  " 删除有 'x' 的项目</code>
<code class="example"></code>
改变列表项目的顺序: 
<code class="example">        :call sort(list)                " 按字母给列表排序</code>
<code class="example">        :call reverse(list)             " 反转项目的顺序</code>
<code class="example">        :call uniq(sort(list))          " 排序并删除重复项</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">For 循环 </code>

 <a href="eval.html#:for">:for</a>  循环为每个列表项目执行命令。一个变量被依次设为每个列表项目。例如: 
<code class="example">        :for item in mylist</code>
<code class="example">        :   call Doit(item)</code>
<code class="example">        :endfor</code>
<code class="example"></code>
它的工作方式就像: 
<code class="example">        :let index = 0</code>
<code class="example">        :while index &lt; len(mylist)</code>
<code class="example">        :   let item = mylist[index]</code>
<code class="example">        :   :call Doit(item)</code>
<code class="example">        :   let index = index + 1</code>
<code class="example">        :endwhile</code>
<code class="example"></code>
如果你只是想要修改每个列表项目， <a href="eval.html#map()">map()</a>  函数比 for 循环简单得多。

就像  <a href="eval.html#:let">:let</a>  命令， <a href="eval.html#:for">:for</a>  也可以接受变量的列表。这需要参数是列表的列表。 
<code class="example">        :for [lnum, col] in [[1, 3], [2, 8], [3, 0]]</code>
<code class="example">        :   call Doit(lnum, col)</code>
<code class="example">        :endfor</code>
<code class="example"></code>
这就像对列表的每个项目使用了  <a href="eval.html#:let">:let</a>  命令。重复一次，类型必须相同，否则会报错。

也可以用变量保存列表变量的其余项目: 
<code class="example">        :for [i, j; rest] in listlist</code>
<code class="example">        :   call Doit(i, j)</code>
<code class="example">        :   if !empty(rest)</code>
<code class="example">        :      echo "remainder: " . string(rest)</code>
<code class="example">        :   endif</code>
<code class="example">        :endfor</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">列表的相关函数 </code>
                                                <b class="vimtag"> <a name="E714">E714</a> </b>
可用于列表的函数: 
<code class="example">        :let r = call(funcname, list)   " 调用带参数列表的函数</code>
<code class="example">        :if empty(list)                 " 检查 list 是否为空</code>
<code class="example">        :let l = len(list)              " list 项目的数量</code>
<code class="example">        :let big = max(list)            " list 项目的最大值</code>
<code class="example">        :let small = min(list)          " list 项目的最小值</code>
<code class="example">        :let xs = count(list, 'x')      " 计算 list 里 'x' 出现的次数</code>
<code class="example">        :let i = index(list, 'x')       " list 第一个 'x' 的位置</code>
<code class="example">        :let lines = getline(1, 10)     " 得到缓冲区十行文本行</code>
<code class="example">        :call append('$', lines)        " 附加若干文本行到缓冲区尾部</code>
<code class="example">        :let list = split("a b c")      " 用字符串中的项目建立列表</code>
<code class="example">        :let string = join(list, ', ')  " 用 list 项目构造字符串</code>
<code class="example">        :let s = string(list)           " list 的字符串表示</code>
<code class="example">        :call map(list, '"&gt;&gt; " . v:val')  " 在每个项目前加上 "&gt;&gt; "</code>
<code class="example"></code>
不要忘记组合使用不同功能可以简化任务。例如，要计算列表中所有数值的总和: 
<code class="example">        :exe 'let sum = ' . join(nrlist, '+')</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">1.4 字典 </code>
                                <b class="vimtag"> <a name="dict">dict</a> </b> <b class="vimtag"> <a name="Dict">Dict</a> </b> <b class="vimtag"> <a name="Dictionaries">Dictionaries</a> </b> <b class="vimtag"> <a name="Dictionary">Dictionary</a> </b>
字典是关联数组: 每个项目有一个键和一个值。用键可以定位项目，而项目的存储不能确
定任何特定顺序。


<code class="section">字典建立 </code>
                                                <b class="vimtag"> <a name="E720">E720</a> </b> <b class="vimtag"> <a name="E721">E721</a> </b> <b class="vimtag"> <a name="E722">E722</a> </b> <b class="vimtag"> <a name="E723">E723</a> </b>
字典通过花括号里逗号分隔的项目列表建立。每个项目包含以冒号分隔的键和值。一个键
只能出现一次。例如: 
<code class="example">        :let mydict = {1: 'one', 2: 'two', 3: 'three'}</code>
<code class="example">        :let emptydict = {}</code>
                                                        <b class="vimtag"> <a name="E713">E713</a> </b> <b class="vimtag"> <a name="E716">E716</a> </b> <b class="vimtag"> <a name="E717">E717</a> </b>
键必须是字符串。用数值也可以，但它总被自动转换为字符串。所以字符串 '4' 和数值
4 总会找到相同的项目。<code class="note">注意</code> 字符串 <code class="badlink">'04'</code> 和数值 04 是不一样的，因为后者被转换成
字符串 '4'。空字符串也可用作键。
                                                <b class="vimtag"> <a name="literal-Dict">literal-Dict</a> </b> <b class="vimtag"> <a name="%23{}">#{}</a> </b>
要不想给每个键都围上引号，可以用 #<code class="special">{}</code> 形式。这要求键只包含 ASCII 字母、数位、
'-' 和 '_'。例如: 
<code class="example">        :let mydict = #{zero: 0, one_key: 1, two-key: 2, 333: 3}</code>
<code class="note">注意</code> 这里的 333 代表字符串 "333"。空键用 #<code class="special">{}</code> 是不可能的。

值可以是任何表达式。如果值本身是字典，就可以建立嵌套的字典: 
<code class="example">        :let nestdict = {1: {11: 'a', 12: 'b'}, 2: {21: 'c'}}</code>
<code class="example"></code>
忽略末项之后的逗号。


<code class="section">访问项目 </code>

常见的访问项目的方式是把键放入方括号: 
<code class="example">        :let val = mydict["one"]</code>
<code class="example">        :let mydict["four"] = 4</code>
<code class="example"></code>
用这种方式可以给已存在的字典增加新项目，这和列表不同。

如果键只包含字母、数字和下划线，可以使用如下形式  <a href="eval.html#expr-entry">expr-entry</a> : 
<code class="example">        :let val = mydict.one</code>
<code class="example">        :let mydict.four = 4</code>
<code class="example"></code>
因为项目可以是包括列表和字典的任何类型，你可以反复使用索引和键进行访问: 
<code class="example">        :echo dict.key[idx].key</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">字典到列表的转换 </code>

你可以循环遍历字典的所有项目。为此，你需要把字典转为列表，然后把它传递给
 <a href="eval.html#:for">:for</a> 。

通常，你期望遍历所有的键，用  <a href="eval.html#keys()">keys()</a>  函数就可以了: 
<code class="example">        :for key in keys(mydict)</code>
<code class="example">        :   echo key . ': ' . mydict[key]</code>
<code class="example">        :endfor</code>
<code class="example"></code>
键列表没有经过排序。你可能希望先进行排序: 
<code class="example">        :for key in sort(keys(mydict))</code>
<code class="example"></code>
要遍历所有的值，用  <a href="eval.html#values()">values()</a>  函数: 
<code class="example">        :for v in values(mydict)</code>
<code class="example">        :   echo "value: " . v</code>
<code class="example">        :endfor</code>
<code class="example"></code>
如果你想同时得到键和值，用  <a href="eval.html#items()">items()</a>  函数。它返回一个列表，其中每个项目是两个
项目的列表: 键和值: 
<code class="example">        :for [key, value] in items(mydict)</code>
<code class="example">        :   echo key . ': ' . value</code>
<code class="example">        :endfor</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">字典同一 </code>
                                                        <b class="vimtag"> <a name="dict-identity">dict-identity</a> </b>
就像列表那样，你需要用  <a href="eval.html#copy()">copy()</a>  和  <a href="eval.html#deepcopy()">deepcopy()</a>  来构造字典的备份。否则，赋值产
生的结果会引用同一个字典: 
<code class="example">        :let onedict = {'a': 1, 'b': 2}</code>
<code class="example">        :let adict = onedict</code>
<code class="example">        :let adict['a'] = 11</code>
<code class="example">        :echo onedict['a']</code>
<code class="example">        11</code>
<code class="example"></code>
如果所有的键-值组对的比较结果相同，两个字典比较的结果也相同。详情见
 <a href="eval.html#list-identity">list-identity</a> 。


<code class="section">字典修改 </code>
                                                        <b class="vimtag"> <a name="dict-modification">dict-modification</a> </b>
要修改字典已经存在的项目或者增加新的项目，用  <a href="eval.html#:let">:let</a> : 
<code class="example">        :let dict[4] = "four"</code>
<code class="example">        :let dict['one'] = item</code>
<code class="example"></code>
从字典里删除项目可以通过  <a href="eval.html#remove()">remove()</a>  或  <a href="eval.html#:unlet">:unlet</a>  完成。
从 dict 里删除键 "aaa" 的项目有三种方法: 
<code class="example">        :let i = remove(dict, 'aaa')</code>
<code class="example">        :unlet dict.aaa</code>
<code class="example">        :unlet dict['aaa']</code>
<code class="example"></code>
两个字典的合并可以用  <a href="eval.html#extend()">extend()</a> : 
<code class="example">        :call extend(adict, bdict)</code>
这使得 adict 得到扩展，加入所有的 bdict 项目。对于重复的键，adict 项目被覆盖。
可选的第三个参数可以改变这一点。
<code class="note">注意</code> 这不影响字典项目的顺序，不要希望 ":echo adict" 会先显示原有 adict 项目，
然后再显示 bdict 的项目。

从字典里删除多个项目可以用  <a href="eval.html#filter()">filter()</a>  完成: 
<code class="example">        :call filter(dict, 'v:val =~ "x"')</code>
删除 "dict" 里所有值不匹配 "x" 的项目。


<code class="section">字典函数 </code>
                                <b class="vimtag"> <a name="Dictionary-function">Dictionary-function</a> </b> <b class="vimtag"> <a name="self">self</a> </b> <b class="vimtag"> <a name="E725">E725</a> </b> <b class="vimtag"> <a name="E862">E862</a> </b>
定义函数时，如果带有 "dict" 属性，可以以一种特殊方式使用字典。例如: 
<code class="example">        :function Mylen() dict</code>
<code class="example">        :   return len(self.data)</code>
<code class="example">        :endfunction</code>
<code class="example">        :let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}</code>
<code class="example">        :echo mydict.len()</code>
<code class="example"></code>
这类似于面向对象编程的方法。字典项目用作  <a href="eval.html#Funcref">Funcref</a> 。局部变量 "self" 引用函数所
在的字典。

字典里也可以加入指向没有 "dict" 属性的函数的函数引用，不过这时无法使用 "self"
变量。

                                <b class="vimtag"> <a name="numbered-function">numbered-function</a> </b> <b class="vimtag"> <a name="anonymous-function">anonymous-function</a> </b>
要避免额外的函数名，可以定义时直接赋给字典: 
<code class="example">        :let mydict = {'data': [0, 1, 2, 3]}</code>
<code class="example">        :function mydict.len()</code>
<code class="example">        :   return len(self.data)</code>
<code class="example">        :endfunction</code>
<code class="example">        :echo mydict.len()</code>
<code class="example"></code>
该函数会得到一个编号，而 dict.len 的值是指向此函数的  <a href="eval.html#Funcref">Funcref</a> 。该函数只能通过
 <a href="eval.html#Funcref">Funcref</a>  访问。如果没有任何  <a href="eval.html#Funcref">Funcref</a>  引用，它会被自动删除。

编号函数不一定要有 "dict" 属性。

如果你的编号函数有错，可以用一个技巧知道它是什么内容。假定函数是 42，命令为: 
<code class="example"> :function {42}</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">字典相关函数 </code>
                                                        <b class="vimtag"> <a name="E715">E715</a> </b>
可以用于字典的函数: 
<code class="example">        :if has_key(dict, 'foo')        " 如果 dict 有带 "foo" 键的项目则为真</code>
<code class="example">        :if empty(dict)                 " 如果 dict 为空则为真</code>
<code class="example">        :let l = len(dict)              " dict 项目的数量</code>
<code class="example">        :let big = max(dict)            " dict 项目的最大值</code>
<code class="example">        :let small = min(dict)          " dict 项目的最小值</code>
<code class="example">        :let xs = count(dict, 'x')      " 统计 dict 里 'x' 出现的数目</code>
<code class="example">        :let s = string(dict)           " dict 的字符串表示</code>
<code class="example">        :call map(dict, '"&gt;&gt; " . v:val')  " 在每个项目前加上 "&gt;&gt; "</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">1.5 blob </code>
                                                <b class="vimtag"> <a name="blob">blob</a> </b> <b class="vimtag"> <a name="Blob">Blob</a> </b> <b class="vimtag"> <a name="Blobs">Blobs</a> </b> <b class="vimtag"> <a name="E978">E978</a> </b>
blob 是一个二进制对象。例如，可用来读取文件的映像并通过通道发送。

blob 基本类似于数值的  <a href="eval.html#List">List</a> ，其中每个数值是个 8 位字节的值，从 0 到 255。


<code class="section">blob 建立 </code>

可用  <a href="eval.html#blob-literal">blob-literal</a>  建立 blob: 
<code class="example">        :let b = 0zFF00ED015DAF</code>
字节 (一对十六进制字符) 之间可以插入点号以提高可读性。不改变值本身: 
<code class="example">        :let b = 0zFF00.ED01.5DAF</code>
<code class="example"></code>
用  <a href="eval.html#readfile()">readfile()</a>  可从文件里读取 blob，其中 <code class="special">{type}</code> 参数设为 "B"。例如: 
<code class="example">        :let b = readfile('image.png', 'B')</code>
<code class="example"></code>
用  <a href="channel.html#ch_readblob()">ch_readblob()</a>  函数可从通道读取 blob。


<code class="section">blob 索引 </code>
                                                        <b class="vimtag"> <a name="blob-index">blob-index</a> </b> <b class="vimtag"> <a name="E979">E979</a> </b>
blob 之后用方括号放上索引可以访问 blob 中的字节。索引从零开始，因而首个字节的
索引为零。 
<code class="example">        :let myblob = 0z00112233</code>
<code class="example">        :let byte = myblob[0]           " 读取首个字节: 0x00</code>
<code class="example">        :let byte = myblob[2]           " 读取第三个字节: 0x22</code>
<code class="example"></code>
负数索引从末尾开始计算。索引 -1 引用 blob 最后一个字节，-2 是倒数第二个字节，
等等。 
<code class="example">        :let last = myblob[-1]          " 读取最后一个字节: 0x33</code>
<code class="example"></code>
用  <a href="eval.html#get()">get()</a>  函数可以避免索引值非法的错误，如果索引不可用，返回 -1 或你指定的缺
省值: 
<code class="example">        :echo get(myblob, idx)</code>
<code class="example">        :echo get(myblob, idx, 999)</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">blob 遍历 </code>

 <a href="eval.html#:for">:for</a>  循环为 blob 的每个字节执行命令。其中循环变量设为 blob 的每个字节。例如:

<code class="example">        :for byte in 0z112233</code>
<code class="example">        :   call Doit(byte)</code>
<code class="example">        :endfor</code>
会分别用 0x11、0x22 和 0x33 调用 Doit()。


<code class="section">blob 连接 </code>

用 "+" 操作符可以连接两个 blob: 
<code class="example">        :let longblob = myblob + 0z4455</code>
<code class="example">        :let myblob += 0z6677</code>
<code class="example"></code>
要在原位修改 blob，可见下述的  <a href="eval.html#blob-modification">blob-modification</a> 。


<code class="section">blob 部分 </code>

blob 的一部分可用在方括号内指定以冒号分隔的开始处和结束处的索引来获得: 
<code class="example">        :let myblob = 0z00112233</code>
<code class="example">        :let shortblob = myblob[1:2]    " 返回 0z1122</code>
<code class="example">        :let shortblob = myblob[2:-1]   " 返回 0z2233</code>
<code class="example"></code>
开始索引要是省略相当于零。结束索引要是省略相当于 -1。 
<code class="example">        :let endblob = myblob[2:]       " 从项目 2 到尾: 0z2233</code>
<code class="example">        :let shortblob = myblob[2:2]    " 一个字节的 blob: 0z22</code>
<code class="example">        :let otherblob = myblob[:]      " 建立 blob 的备份</code>
<code class="example"></code>
如果开始索引超过 blob 的最后字节，或者结束索引在开始索引之前，返回空 blob。不
报错。

如果结束索引等于或大于列表长度，使用长度减一: 
<code class="example">        :echo myblob[2:8]               " 返回: 0z2233</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">blob 修改 </code>
                                                        <b class="vimtag"> <a name="blob-modification">blob-modification</a> </b>
要修改 blob 的特定字节，可以这么用  <a href="eval.html#:let">:let</a> : 
<code class="example">        :let blob[4] = 0x44</code>
<code class="example"></code>
如果索引是 blob 最后索引加一，附加到尾部。再大的索引会报错。

要改变字节序列，可用 [:] 记法: 
<code class="example">        let blob[1:3] = 0z445566</code>
被替换字节序列的长度必须和提供的值相等。 <b class="vimtag"> <a name="E972">E972</a> </b>

要修改 blob 的部分，指定要修改的开始和结束字节。新值必须和范围的字节数相同: 
<code class="example">        :let blob[3:5] = 0z334455</code>
<code class="example"></code>
也可用  <a href="eval.html#add()">add()</a> 、 <a href="eval.html#remove()">remove()</a>  和  <a href="eval.html#insert()">insert()</a>  函数。


<code class="section">blob 同一 </code>

blob 间可以比较是否值相等: 
<code class="example">        if blob == 0z001122</code>
也可以比较是否同一引用: 
<code class="example">        if blob is otherblob</code>
                                                        <b class="vimtag"> <a name="blob-identity">blob-identity</a> </b> <b class="vimtag"> <a name="E977">E977</a> </b>
当 "aa" 变量是 blob 而把它赋值给另一个变量 "bb" 时，两个变量指向同一个 blob。
因而 "is" 操作符返回真值。

用 [:] 或  <a href="eval.html#copy()">copy()</a>  创建备份时值相等，但是不同的引用: 
<code class="example">        :let blob = 0z112233</code>
<code class="example">        :let blob2 = blob</code>
<code class="example">        :echo blob == blob2</code>
        1 
<code class="example">        :echo blob is blob2</code>
        1 
<code class="example">        :let blob3 = blob[:]</code>
<code class="example">        :echo blob == blob3</code>
        1 
<code class="example">        :echo blob is blob3</code>
        0

blob 建立备份可通过  <a href="eval.html#copy()">copy()</a>  函数。用 [:] 也可以，已有上述。


<code class="section">1.6 变量的更多细节 </code>
                                                        <b class="vimtag"> <a name="more-variables">more-variables</a> </b>
如果你需要知道变量或表达式的类型，使用  <a href="eval.html#type()">type()</a>  函数。

如果 <a href="options.html#'viminfo'">'viminfo'</a> 选项包含 '!' 标志位，大写开头且不包含小写字母的全局变量被保存在
viminfo 文件里  <a href="starting.html#viminfo-file">viminfo-file</a> 。

如果 <a href="options.html#'sessionoptions'">'sessionoptions'</a> 选项包含 "global"，大写开头且包含至少一个小写字母的全局
变量被保存在会话文件里  <a href="starting.html#session-file">session-file</a> 。

<code class="section">变量名                  可以保存的位置 </code>
my_var_6                无
My_Var_6                会话文件
MY_VAR_6                viminfo 文件


可以使用花括号来构造变量名，见  <a href="eval.html#curly-braces-names">curly-braces-names</a> 。

</section><hr class="doubleline" /><section class=inner>
<h4>2. 表达式语法                                           <b class="vimtag"> <a name="expression-syntax">expression-syntax</a> </b></h4>
表达式语法小结，优先级从低到高排列:

 <a href="eval.html#expr1">expr1</a>  expr2
        expr2 ? expr1 : expr1   if-then-else

 <a href="eval.html#expr2">expr2</a>  expr3
        expr3 || expr3 ...      逻辑或

 <a href="eval.html#expr3">expr3</a>  expr4
        expr4 &amp;&amp; expr4 ...      逻辑与

 <a href="eval.html#expr4">expr4</a>  expr5
        expr5 == expr5          等于
        expr5 != expr5          不等于
        expr5 &gt;  expr5          大于
        expr5 &gt;= expr5          大于等于
        expr5 &lt;  expr5          小于
        expr5 &lt;= expr5          小于等于
        expr5 =~ expr5          匹配正规表达式
        expr5 !~ expr5          不匹配正规表达式

        expr5 ==? expr5         等于，忽略大小写
        expr5 ==# expr5         等于，匹配大小写
        等等                    如上，? 忽略大小写，# 则匹配之

        expr5 is expr5          相同的  <a href="eval.html#List">List</a> 、 <a href="eval.html#Dictionary">Dictionary</a>  或  <a href="eval.html#Blob">Blob</a>  实例
        expr5 isnot expr5       不同的  <a href="eval.html#List">List</a> 、 <a href="eval.html#Dictionary">Dictionary</a>  或  <a href="eval.html#Blob">Blob</a>  实例

 <a href="eval.html#expr5">expr5</a>  expr6
        expr6 +  expr6 ...      数值加法、列表或 blob 连接
        expr6 -  expr6 ...      数值减法
        expr6 .  expr6 ...      字符串连接
        expr6 .. expr6 ...      字符串连接

 <a href="eval.html#expr6">expr6</a>  expr7
        expr7 *  expr7 ...      数值乘法
        expr7 /  expr7 ...      数值除法
        expr7 %  expr7 ...      数值求余

 <a href="eval.html#expr7">expr7</a>  expr8
        ! expr7                 逻辑非
        - expr7                 一元减法: 取反
        + expr7                 一元加法: 原值

 <a href="eval.html#expr8">expr8</a>  expr9
        expr8[expr1]            字符串里的字节或者  <a href="eval.html#List">List</a>  的项目
        expr8[expr1 : expr1]    字符串子串或  <a href="eval.html#List">List</a>  的子列表
        expr8.name               <a href="eval.html#Dictionary">Dictionary</a>  的项目
        expr8(expr1, ...)       使用  <a href="eval.html#Funcref">Funcref</a>  变量的函数调用
        expr8-&gt;name(expr1, ...)  <a href="eval.html#method">method</a>  调用

 <a href="eval.html#expr9">expr9</a>  number                  数值常数
        "string"                字符串常数，反斜杠有特殊含义
        <code class="badlink">'string'</code>                字符串常数，' 加倍
        [expr1, ...]             <a href="eval.html#List">List</a> 
        {expr1: expr1, ...}      <a href="eval.html#Dictionary">Dictionary</a> 
        #{key: expr1, ...}       <a href="eval.html#Dictionary">Dictionary</a> 
        &amp;option                 选项值
        (expr1)                 嵌套表达式
        variable                内部变量
        va<code class="special">{ria}</code>ble              带花括号的内部变量
        $VAR                    环境变量
        @r                      寄存器 'r' 的值
        function(expr1, ...)    函数调用
        func<code class="special">{ti}</code>on(expr1, ...)  带花括号的函数调用
        {args -&gt; expr1}         匿名函数表达式


"..." 标明这一层上的操作可以连接。比如: 
<code class="example">        &amp;nu || &amp;list &amp;&amp; &amp;shell == "csh"</code>
<code class="example"></code>
同一层的表达式从左到右进行分析。


expr1                                                   <b class="vimtag"> <a name="expr1">expr1</a> </b> <b class="vimtag"> <a name="E109">E109</a> </b>
</section><hr class="singleline" /><section class=inner>

expr2 ? expr1 : expr1

'?' 之前的表达式作为数值求值。如果结果为  <a href="eval.html#TRUE">TRUE</a> ，最终的结果是 '?' 和 ':' 之间
的表达式的值，不然最终的结果是 ':' 之后的表达式的值。例如: 
<code class="example">        :echo lnum == 1 ? "top" : lnum</code>
<code class="example"></code>
因为第一个表达式是 "expr2"，它不能包含另一个 ?:。另外两个表达式则没有这个限
制，从而使得递归使用 ?: 成为可能。例如: 
<code class="example">        :echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum</code>
<code class="example"></code>
要使之可读，建议使用续行符  <a href="repeat.html#line-continuation">line-continuation</a> : 
<code class="example">        :echo lnum == 1</code>
<code class="example">        :\      ? "top"</code>
<code class="example">        :\      : lnum == 1000</code>
<code class="example">        :\              ? "last"</code>
<code class="example">        :\              : lnum</code>
<code class="example"></code>
在 ':' 前，你总是应该加上空格，否则它可能被错误用在如 "a:1" 这样的变量里。


expr2 和 expr3                                          <b class="vimtag"> <a name="expr2">expr2</a> </b> <b class="vimtag"> <a name="expr3">expr3</a> </b>
</section><hr class="singleline" /><section class=inner>

expr3 || expr3 ..       逻辑或                  <b class="vimtag"> <a name="expr-barbar">expr-barbar</a> </b>
expr4 &amp;&amp; expr4 ..       逻辑与                  <b class="vimtag"> <a name="expr-&&">expr-&amp;&amp;</a> </b>

"||" 和 "&amp;&amp;" 操作符左右两边各接受一个参数。参数是 (或转化为) 数值。运算结果是:

<code class="section">    输入                         输出 </code>
<code class="section">n1      n2              n1 || n2        n1 &amp;&amp; n2 </code>
 <a href="eval.html#FALSE">FALSE</a>   <a href="eval.html#FALSE">FALSE</a>           <a href="eval.html#FALSE">FALSE</a>           <a href="eval.html#FALSE">FALSE</a> 
 <a href="eval.html#FALSE">FALSE</a>   <a href="eval.html#TRUE">TRUE</a>            <a href="eval.html#TRUE">TRUE</a>            <a href="eval.html#FALSE">FALSE</a> 
 <a href="eval.html#TRUE">TRUE</a>    <a href="eval.html#FALSE">FALSE</a>           <a href="eval.html#TRUE">TRUE</a>            <a href="eval.html#FALSE">FALSE</a> 
 <a href="eval.html#TRUE">TRUE</a>    <a href="eval.html#TRUE">TRUE</a>            <a href="eval.html#TRUE">TRUE</a>            <a href="eval.html#TRUE">TRUE</a> 

操作符可以连接。比如: 
<code class="example"></code>
<code class="example">        &amp;nu || &amp;list &amp;&amp; &amp;shell == "csh"</code>
<code class="example"></code>
<code class="note">注意</code> "&amp;&amp;" 比 "||" 优先级高，所以这等价于: 
<code class="example"></code>
<code class="example">        &amp;nu || (&amp;list &amp;&amp; &amp;shell == "csh")</code>
<code class="example"></code>
一旦结果可以确定，表达式使用 "短路" 计算，也就是，不再计算后面的参数，这和 C
的情形类似。比如: 
<code class="example"></code>
<code class="example">        let a = 1</code>
<code class="example">        echo a || b</code>
<code class="example"></code>
这是合法的，即使没有叫 "b" 的变量也是如此。因为 "a" 已经是  <a href="eval.html#TRUE">TRUE</a> ，结果必然是
 <a href="eval.html#TRUE">TRUE</a> 。下面的情形类似: 
<code class="example"></code>
<code class="example">        echo exists("b") &amp;&amp; b == "yes"</code>
<code class="example"></code>
无论 "b" 定义与否，这是合法的。第二个子句只有在 "b" 定义的时候才会被计算。


expr4                                                   <b class="vimtag"> <a name="expr4">expr4</a> </b>
</section><hr class="singleline" /><section class=inner>

expr5 <code class="special">{cmp}</code> expr5

比较两个 expr 表达式，如果结果为假，返回 0，如果结果为真，返回 1。

                        <b class="vimtag"> <a name="expr-%20%20">expr-==</a> </b>  <b class="vimtag"> <a name="expr-!%20">expr-!=</a> </b>  <b class="vimtag"> <a name="expr-%3E">expr-&gt;</a> </b>   <b class="vimtag"> <a name="expr-%3E%20">expr-&gt;=</a> </b>
                        <b class="vimtag"> <a name="expr-%3C">expr-&lt;</a> </b>   <b class="vimtag"> <a name="expr-%3C%20">expr-&lt;=</a> </b>  <b class="vimtag"> <a name="expr-%20%7E">expr-=~</a> </b>  <b class="vimtag"> <a name="expr-!%7E">expr-!~</a> </b>
                        <b class="vimtag"> <a name="expr-%20%20%23">expr-==#</a> </b> <b class="vimtag"> <a name="expr-!%20%23">expr-!=#</a> </b> <b class="vimtag"> <a name="expr-%3E%23">expr-&gt;#</a> </b>  <b class="vimtag"> <a name="expr-%3E%20%23">expr-&gt;=#</a> </b>
                        <b class="vimtag"> <a name="expr-%3C%23">expr-&lt;#</a> </b>  <b class="vimtag"> <a name="expr-%3C%20%23">expr-&lt;=#</a> </b> <b class="vimtag"> <a name="expr-%20%7E%23">expr-=~#</a> </b> <b class="vimtag"> <a name="expr-!%7E%23">expr-!~#</a> </b>
                        <b class="vimtag"> <a name="expr-%20%20?">expr-==?</a> </b> <b class="vimtag"> <a name="expr-!%20?">expr-!=?</a> </b> <b class="vimtag"> <a name="expr-%3E?">expr-&gt;?</a> </b>  <b class="vimtag"> <a name="expr-%3E%20?">expr-&gt;=?</a> </b>
                        <b class="vimtag"> <a name="expr-%3C?">expr-&lt;?</a> </b>  <b class="vimtag"> <a name="expr-%3C%20?">expr-&lt;=?</a> </b> <b class="vimtag"> <a name="expr-%20%7E?">expr-=~?</a> </b> <b class="vimtag"> <a name="expr-!%7E?">expr-!~?</a> </b>
                        <b class="vimtag"> <a name="expr-is">expr-is</a> </b> <b class="vimtag"> <a name="expr-isnot">expr-isnot</a> </b> <b class="vimtag"> <a name="expr-is%23">expr-is#</a> </b> <b class="vimtag"> <a name="expr-isnot%23">expr-isnot#</a> </b>
                        <b class="vimtag"> <a name="expr-is?">expr-is?</a> </b> <b class="vimtag"> <a name="expr-isnot?">expr-isnot?</a> </b>
<code class="section">                使用 <a href="options.html#'ignorecase'">'ignorecase'</a>    匹配大小写     忽略大小写 </code>
等于                    ==              ==#             ==?
不等于                  !=              !=#             !=?
大于                    &gt;               &gt;#              &gt;?
大于等于                &gt;=              &gt;=#             &gt;=?
小于                    &lt;               &lt;#              &lt;?
小于等于                &lt;=              &lt;=#             &lt;=?
匹配正规表达式          =~              =~#             =~?
不匹配正规表达式        !~              !~#             !~?
相同实例                is              is#             is?
不同实例                isnot           isnot#          isnot?

示例:
"abc" ==# "Abc"   结果为 0
"abc" ==? "Abc"   结果为 1
"abc" == "Abc"    如果置位了 <a href="options.html#'ignorecase'">'ignorecase'</a>，结果为 1，不然结果为 0

                                                        <b class="vimtag"> <a name="E691">E691</a> </b> <b class="vimtag"> <a name="E692">E692</a> </b>
 <a href="eval.html#List">List</a>  只能和  <a href="eval.html#List">List</a>  比较，而且只能用 "等于"、"不等于"、"is" 和 "isnot"。比较
针对列表的值，递归进行。忽略大小写意味着比较项目的值时忽略大小写。

                                                        <b class="vimtag"> <a name="E735">E735</a> </b> <b class="vimtag"> <a name="E736">E736</a> </b>
 <a href="eval.html#Dictionary">Dictionary</a>  只能和  <a href="eval.html#Dictionary">Dictionary</a>  比较，而且只能用 "等于"、"不等于"、"is" 和
"isnot"。比较针对  <a href="eval.html#Dictionary">Dictionary</a>  的键/值，递归进行。忽略大小写意味着比较项目的值
时忽略大小写。

                                                        <b class="vimtag"> <a name="E694">E694</a> </b>
 <a href="eval.html#Funcref">Funcref</a>  只能和  <a href="eval.html#Funcref">Funcref</a>  比较，而且只能用 "等于"、"不等于"、"is" 和
"isnot"。这里永不忽略大小写。参数或字典是否绑定 (即偏函数的情况) 是有关系的。
绑定的字典必须相等 (或 "is" 的情况下，相同实例)，参数亦然。

要比较函数引用是否指向相同的函数但忽略绑定的字典和参数，用  <a href="eval.html#get()">get()</a>  来取得函数
名: 
<code class="example">        if get(Part1, 'name') == get(Part2, 'name')</code>
<code class="example">           " Part1 and Part2 refer to the same function</code>
<code class="example"></code>
 <a href="eval.html#List">List</a> 、 <a href="eval.html#Dictionary">Dictionary</a>  或  <a href="eval.html#Blob">Blob</a>  用 "is" 或 "isnot" 时，检查表达式是否指向同一个
 <a href="eval.html#List">List</a>  、 <a href="eval.html#Dictionary">Dictionary</a>  或  <a href="eval.html#Blob">Blob</a>  实例。一个  <a href="eval.html#List">List</a>  的备份和原来的  <a href="eval.html#List">List</a>  不同。
如果不是  <a href="eval.html#List">List</a> 、 <a href="eval.html#Dictionary">Dictionary</a>  或  <a href="eval.html#Blob">Blob</a> ，用 "is" 等价于用 "等于"，而 "isnot"
等价于 "不等于"，有一点区别: 不同的类型总认为有不同的值: 
<code class="example">        echo 4 == '4'</code>
<code class="example">        1</code>
<code class="example">        echo 4 is '4'</code>
<code class="example">        0</code>
<code class="example">        echo 0 is []</code>
<code class="example">        0</code>
"is#"/"isnot#" 和 "is?"/"isnot?" 用于强制匹配和忽略大小写。

如果比较字符串和数值，字符串被转化成数值，而比较是在数值之间进行的。这意味
着: 
<code class="example">        echo 0 == 'x'</code>
<code class="example">        1</code>
因为 'x' 转化的数值为零。不过: 
<code class="example">        echo [0] == ['x']</code>
<code class="example">        0</code>
在列表或字典里不进行这种转换。

如果比较两个字符串，使用 strcmp() 或 stricmp()。因而，比较的是数学上的差异 (比
较字节码)，而不必然是本地语言的字母的差异。

如果操作符后带上 '#'，或者 <a href="options.html#'ignorecase'">'ignorecase'</a> 关闭时使用无 '#' 的版本时，比较使用
strcmp(): 大小写相关。

如果操作符后带上 '?'，或者 <a href="options.html#'ignorecase'">'ignorecase'</a> 打开时使用无 '?' 的版本时，比较使用
stricmp(): 大小写无关。

这里 <a href="options.html#'smartcase'">'smartcase'</a> 不适用。

"=~" 和 "!~" 操作符使用右边的参数作为模式来匹配左边的参数。模式的定义见
 <a href="pattern.html#pattern">pattern</a> 。匹配进行时，总是假设置位了 <a href="options.html#'magic'">'magic'</a> 并且 <a href="options.html#'cpoptions'">'cpoptions'</a> 为空，无论
<a href="options.html#'magic'">'magic'</a> 或 <a href="options.html#'cpoptions'">'cpoptions'</a> 实际的值为何。这使得脚本可移植。要避免在正规表达式里使
用的反斜杠需要加倍的问题，可以使用单引号的字符串，见  <a href="eval.html#literal-string">literal-string</a> 。
既然字符串假定为单行，多行的模式 (包含 \n，即反斜杠-n) 不会被匹配。不过，按本
义出现的单个 NL 字符可以像普通字符一样匹配。比如:
        "foo\nbar" =~ "\n"      结果为 1
        "foo\nbar" =~ "\\n"     结果为 0


expr5 和 expr6                                          <b class="vimtag"> <a name="expr5">expr5</a> </b> <b class="vimtag"> <a name="expr6">expr6</a> </b>
</section><hr class="singleline" /><section class=inner>
expr6 +  expr6  数值加法、 <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a>  连接                 <b class="vimtag"> <a name="expr-+">expr-+</a> </b>
expr6 -  expr6  数值减法                                        <b class="vimtag"> <a name="expr--">expr--</a> </b>
expr6 .  expr6  字符串连接                                      <b class="vimtag"> <a name="expr-.">expr-.</a> </b>
expr6 .. expr6  字符串连接                                      <b class="vimtag"> <a name="expr-..">expr-..</a> </b>

 <a href="eval.html#Lists">Lists</a>  只能用 "+"，而且两个 expr6 必须都是列表。返回两者连接以后的新列表。

字符串连接建议使用 ".."，因为 "." 有二义性，也用于  <a href="eval.html#Dict">Dict</a>  的成员访问和浮点数。
当  <a href="eval.html#vimscript-version">vimscript-version</a>  为 2 或更高时，不允许使用 "."。

expr7 *  expr7 数值乘法                                         <b class="vimtag"> <a name="expr-star">expr-star</a> </b>
expr7 /  expr7 数值除法                                         <b class="vimtag"> <a name="expr-%2F">expr-/</a> </b>
expr7 %  expr7 数值求余                                         <b class="vimtag"> <a name="expr-%">expr-%</a> </b>

除了 "." 和 ".." 以外，这里所有的操作都把字符串转化成数值。
按位操作运算见  <a href="eval.html#and()">and()</a> 、 <a href="eval.html#or()">or()</a>  和  <a href="eval.html#xor()">xor()</a> 。

<code class="note">注意</code> "+" 和 "." 的差异:
        "123" + "456" = 579
        "123" . "456" = "123456"

因为 '.' 和 '+' 与 '-' 的优先级相同，你需要把: 
<code class="example">        1 . 90 + 90.0</code>
看作: 
<code class="example">        (1 . 90) + 90.0</code>
这没问题，因为字符串 "190" 被自动转换为数值 190，然后和浮点数 90.0 相加。不
过: 
<code class="example">        1 . 90 * 90.0</code>
应被看作: 
<code class="example">        1 . (90 * 90.0)</code>
因为 '.' 的优先级比 '*' 低，这 <code class="emphasis">不能</code> 工作，因为它试图连接浮点数和字符串。

数值除以零时，结果取决于该值:
          0 / 0  = -0x80000000  (类似于浮点数的 NaN)
         &gt;0 / 0  =  0x7fffffff  (类似于正无穷大)
         &lt;0 / 0  = -0x7fffffff  (类似于负无穷大)
        (Vim 7.2 之前，总是返回 0x7fffffff)

启用 64-位数值支持时:
          0 / 0  = -0x8000000000000000  (类似于浮点数的 NaN)
         &gt;0 / 0  =  0x7fffffffffffffff  (类似于正无穷大)
         &lt;0 / 0  = -0x7fffffffffffffff  (类似于负无穷大)

如果 '%' 的右边为零，结果为 0。

这些操作不适用于  <a href="eval.html#Funcref">Funcref</a> 。

而 % 也不适用于浮点数。 <b class="vimtag"> <a name="E804">E804</a> </b>


expr7                                                   <b class="vimtag"> <a name="expr7">expr7</a> </b>
</section><hr class="singleline" /><section class=inner>
! expr7                 逻辑非                  <b class="vimtag"> <a name="expr-!">expr-!</a> </b>
- expr7                 一元减法: 取反          <b class="vimtag"> <a name="expr-unary--">expr-unary--</a> </b>
+ expr7                 一元加法: 原值          <b class="vimtag"> <a name="expr-unary-+">expr-unary-+</a> </b>

'!' 把  <a href="eval.html#TRUE">TRUE</a>  变为  <a href="eval.html#FALSE">FALSE</a> ， <a href="eval.html#FALSE">FALSE</a>  变为  <a href="eval.html#TRUE">TRUE</a>  (一)。
'-' 改变数值的符号。
'+' 保持原值。

字符串会先转化为数值。

可以重复和混合这三种运算。例如:
        !-1         == 0
        !!8         == 1
        --9         == 9


expr8                                                   <b class="vimtag"> <a name="expr8">expr8</a> </b>
</section><hr class="singleline" /><section class=inner>
此处表达式或是  <a href="eval.html#expr9">expr9</a> ，或是任意顺序的下面各项之一的序列。例如这些都可以:
        expr8[expr1].name
        expr8.name[expr1]
        expr8(expr1, ...)[expr1].name
        expr8-&gt;(expr1, ...)[expr1]
计算总是从左到右。

expr8[expr1]            字符串或  <a href="eval.html#List">List</a>  的项目          <b class="vimtag"> <a name="expr-[]">expr-[]</a> </b> <b class="vimtag"> <a name="E111">E111</a> </b>
                                                        <b class="vimtag"> <a name="E909">E909</a> </b> <b class="vimtag"> <a name="subscript">subscript</a> </b>
如果 expr8 是数值或字符串，结果是字符串，包含 expr8 里第 expr1 个字节。expr8
视作字符串，expr1 视作数值。这里不识别多字节编码，但可考虑使用  <a href="eval.html#byteidx()">byteidx()</a> ，或
用  <a href="eval.html#split()">split()</a>  把字符串变为字符的列表。

索引 0 给出第一个字节。这和 C 类同。要小心: 文本列号可是从 1 开始的！例如，要
得到光标所在的字节: 
<code class="example">        :let c = getline(line("."))[col(".") - 1]</code>
<code class="example"></code>
如果字符串的长度小于索引值，结果为空字符串。负索引总是给出空字符串 (原因: 反向
兼容)。用 [-1:] 得到最后一个字节。

如果 expr8 是  <a href="eval.html#List">List</a> ，返回索引值为 expr1 的项目。可用的索引值见  <a href="eval.html#list-index">list-index</a> 。
如果索引越界，产生错误。例如: 
<code class="example">        :let item = mylist[-1]          " 得到最后一个项目</code>
<code class="example"></code>
一般的，如果  <a href="eval.html#List">List</a>  索引大于等于  <a href="eval.html#List">List</a>  的长度，或者比  <a href="eval.html#List">List</a>  的长度更负，产生
错误。


expr8[expr1a : expr1b]  子字符串或子列表                <b class="vimtag"> <a name="expr-[:]">expr-[:]</a> </b>

如果 expr8 是数值或字符串，结果是子字符串，包含第 expr1a 到第 expr1b (包含) 个
字节。expr8 视作字符串，expr1a 和 expr1b 视作数值。这里不识别多字节编码，需用
 <a href="eval.html#byteidx()">byteidx()</a>  来计算索引值。

如果省略 expr1a，用零。如果省略 expr1b，用字符串的长度减一。

可以用负数来从字符串尾部开始计算位置。-1 代表最后一个字符，-2 倒数第二个，依此
类推。

如果索引越界，忽略这些字符。如果 expr1b 小于 expr1a，结果是空字符串。

例如: 
<code class="example">        :let c = name[-1:]              " 字符串最后一个字节</code>
<code class="example">        :let c = name[-2:-2]            " 字符串倒数第二个字节</code>
<code class="example">        :let s = line(".")[4:]          " 从第五个字节到最后</code>
<code class="example">        :let s = s[:-3]                 " 删除最后两个字节</code>

                                                        <b class="vimtag"> <a name="slice">slice</a> </b>
如果 expr8 是  <a href="eval.html#List">List</a> ，结果是新的  <a href="eval.html#List">List</a> ，包含 expr1 和 expr1b 索引指定的项目。
和上面描述的字符串情形类似。另见下面的  <a href="eval.html#sublist">sublist</a> 。例如: 
<code class="example">        :let l = mylist[:3]             " 前四个项目</code>
<code class="example">        :let l = mylist[4:4]            " 单个项目的列表</code>
<code class="example">        :let l = mylist[:]              " 列表的浅备份</code>
<code class="example"></code>
如果 expr8 是  <a href="eval.html#Blob">Blob</a> ，结果是新的  <a href="eval.html#Blob">Blob</a> ，包含从索引 expr1a 到 expr1b 的字节，
闭区间。例如: 
<code class="example">        :let b = 0zDEADBEEF</code>
<code class="example">        :let bs = b[1:2]                " 0zADBE</code>
<code class="example">        :let bs = b[:]                  " 0zDEADBEEF 的备份</code>
<code class="example"></code>
在  <a href="eval.html#Funcref">Funcref</a>  上用 expr8[expr1] 或 expr8[expr1a : expr1b] 出错。

小心命名空间和变量后加冒号的子列表用法引起的混淆: 
<code class="example">        mylist[n:]     " 使用变量 n</code>
<code class="example">        mylist[s:]     " 使用命名空间 s:，报错！</code>
<code class="example"></code>
<code class="example"></code>
expr8.name               <a href="eval.html#Dictionary">Dictionary</a>  的项目             <b class="vimtag"> <a name="expr-entry">expr-entry</a> </b>

如果 expr8 是一个  <a href="eval.html#Dictionary">Dictionary</a>  且后跟句号再跟一个名字，该名字用作  <a href="eval.html#Dictionary">Dictionary</a> 
的键。这相当于: expr8[name]。

该名字必须由字母数字字符组成。这和变量名一样，不过这里可以用数字开始。但不能用
花括号。

句号前后不能用空白。

例如: 
<code class="example">        :let dict = {"one": 1, 2: "two"}</code>
<code class="example">        :echo dict.one          " 显示 "1"</code>
<code class="example">        :echo dict.2            " 显示 "two"</code>
<code class="example">        :echo dict .2           " 因为点号前有空格，报错</code>
<code class="example"></code>
<code class="note">注意</code> 句号也用于字符串连接。要避免混淆，用于字符串连接的句号前后加上空白。


expr8(expr1, ...)        <a href="eval.html#Funcref">Funcref</a>  函数调用

如果 expr8 是  <a href="eval.html#Funcref">Funcref</a>  类型的变量，调用它指向的函数。


expr8-&gt;name([args])     方法调用                        <b class="vimtag"> <a name="method">method</a> </b> <b class="vimtag"> <a name="-%3E">-&gt;</a> </b>
expr8-&gt;<code class="special">{lambda}</code>([args])
                                                        <b class="vimtag"> <a name="E276">E276</a> </b>
对同时作为全局函数存在的方法而言，这等价于: 
<code class="example">        name(expr8 [, args])</code>
也有专用于 "expr8" 类型的方法。

可用于链式调用，把一个方法的结果传给下一个方法: 
<code class="example">        mylist-&gt;filter(filterexpr)-&gt;map(mapexpr)-&gt;sort()-&gt;join()</code>

使用匿名函数的示例: 
<code class="example">        GetPercentage()-&gt;{x -&gt; x * 100}()-&gt;printf('%d%%')</code>

使用 -&gt; 时，先应用  <a href="eval.html#expr7">expr7</a>  操作符，所以: 
<code class="example">        -1.234-&gt;string()</code>
等价于: 
<code class="example">        (-1.234)-&gt;string()</code>
而 <code class="emphasis">不是</code> : 
<code class="example">        -(1.234-&gt;string())</code>

                                                        <b class="vimtag"> <a name="E274">E274</a> </b>
"-&gt;name(" 内部不能包含空白。"-&gt;" 之前和 "(" 之后可有空白，所以可以这样断行: 
<code class="example">        mylist</code>
<code class="example">        \ -&gt;filter(filterexpr)</code>
<code class="example">        \ -&gt;map(mapexpr)</code>
<code class="example">        \ -&gt;sort()</code>
<code class="example">        \ -&gt;join()</code>
<code class="example"></code>
使用匿名函数形式时，} 和 ( 之间不能有空白。


                                                <b class="vimtag"> <a name="expr9">expr9</a> </b>
number
</section><hr class="singleline" /><section class=inner>
number                  数值常数                        <b class="vimtag"> <a name="expr-number">expr-number</a> </b>
                                <b class="vimtag"> <a name="hex-number">hex-number</a> </b> <b class="vimtag"> <a name="octal-number">octal-number</a> </b> <b class="vimtag"> <a name="binary-number">binary-number</a> </b>

十进制、十六进制 (0x 或 0X 开始)、二进制 (0b 或 0B 开始) 和 八进制 (0 开始)。

                                                <b class="vimtag"> <a name="floating-point-format">floating-point-format</a> </b>
浮点数可用两种形式给出:

        [-+]<code class="special">{N}</code>.<code class="special">{M}</code>
        [-+]<code class="special">{N}</code>.<code class="special">{M}</code>[eE][-+]<code class="special">{exp}</code>

<code class="special">{N}</code> 和 <code class="special">{M}</code> 都是数值。<code class="special">{N}</code> 和 <code class="special">{M}</code> 都必须存在，且只能包含数位。
[-+] 意味着有一个可选的正负号。
<code class="special">{exp}</code> 是指数部分，以 10 为基。
只能接受小数点，逗号不行。这和当前的 locale 无关。
<code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

示例:
        123.456
        +0.0001
        55.0
        -0.123
        1.234e03
        1.0E-6
        -3.1416e+88

下面的形式是 <code class="emphasis">非法的</code> :
        3.              <code class="special">{M}</code> 为空
        1e40            <code class="special">{M}</code> 为空

理据:
浮点数引入之前，文本 "123.456" 被解释为两个数值 "123" 和 "456"，转换为字符串，
然后进行连接而生成字符串 "123456"。这被认为没有意义，也没有找到有意使用此特性
的 Vim 脚本，因此我们采纳了这种普遍的浮点数记法，而接受其后向不兼容性。

                                                        <b class="vimtag"> <a name="float-pi">float-pi</a> </b> <b class="vimtag"> <a name="float-e">float-e</a> </b>
可以复制-粘贴的一些常用值: 
<code class="example">        :let pi = 3.14159265359</code>
<code class="example">        :let e  = 2.71828182846</code>
或者，如果不要直接写浮点常量，可用相应的函数，就像这样: 
<code class="example">        :let pi = acos(-1.0)</code>
<code class="example">        :let e  = exp(1.0)</code>

                                                <b class="vimtag"> <a name="floating-point-precision">floating-point-precision</a> </b>
浮点数的精度和取值范围取决于 Vim 编译时使用的库如何理解 "double"。运行时无法改
变。

浮点数  <a href="eval.html#Float">Float</a>  的显示缺省使用 6 位十进制位，类似于 printf("%g", f)。使用
 <a href="eval.html#printf()">printf()</a>  函数时可以指定其它位数。例如: 
<code class="example">        :echo printf('%.15e', atan(1))</code>
        7.853981633974483e-01



string                                  <b class="vimtag"> <a name="string">string</a> </b> <b class="vimtag"> <a name="String">String</a> </b> <b class="vimtag"> <a name="expr-string">expr-string</a> </b> <b class="vimtag"> <a name="E114">E114</a> </b>
</section><hr class="singleline" /><section class=inner>
"string"                字符串常数              <b class="vimtag"> <a name="expr-quote">expr-quote</a> </b>

<code class="note">注意</code> 使用的是双引号。

字符串常数接受以下特殊字符:
\...    三位八进制数 (例如，"\316")
\..     两位八进制数 (必须后跟非数字)
\.      一位八进制数 (必须后跟非数字)
\x..    两位十六进制数指定的字节 (例如，"\x1f")
\x.     一位十六进制数指定的字节 (必须后跟非十六进制数字)
\X..    等同于 \x..
\X.     等同于 \x.
\u....  四位十六进制指定的字符。根据 <a href="options.html#'encoding'">'encoding'</a> 的当前值决定的编码进行存贮 (例
        如，"\u02a4")
\U....  等同于 \u 但接受多达 8 位十六进制数。
\b      退格 <code class="special">&lt;BS&gt;</code>
\e      escape <code class="special">&lt;Esc&gt;</code>
\f      换页 <code class="special">&lt;FF&gt;</code>
\n      换行 <code class="special">&lt;NL&gt;</code>
\r      回车 <code class="special">&lt;CR&gt;</code>
\t      制表 <code class="special">&lt;Tab&gt;</code>
\\      反斜杠
\"      双引号
\<code class="special">&lt;xxx&gt;</code>  "xxx" 命名的特殊字符，例如 "\<code class="special">&lt;C-W&gt;</code>" 代表 <code class="keystroke">CTRL-W</code>。用于映射，0x80 字节被
        转义。
        双引号必须转义: "&lt;M-\"&gt;"。
        不要用 <code class="special">&lt;Char-xxxx&gt;</code> 来得到 utf-8 字符，用上面提到的 \uxxxxx。

<code class="note">注意</code> "\xff" 保存为字节 255，在某些编码中它是不合法的。使用 "\u00ff" 可以按照
<a href="options.html#'encoding'">'encoding'</a> 的当前值保存字符 255。

<code class="note">注意</code> "\000" 和 "\x00" 强制字符串结束。


blob-literal                            <b class="vimtag"> <a name="blob-literal">blob-literal</a> </b> <b class="vimtag"> <a name="E973">E973</a> </b>
</section><hr class="singleline" /><section class=inner>

0z 或 0Z 开头的十六进制序列，字符数目不限。序列必须是偶数位的十六进制字符。例
如: 
<code class="example">        :let b = 0zFF00ED015DAF</code>
<code class="example"></code>
<code class="example"></code>
literal-string                                          <b class="vimtag"> <a name="literal-string">literal-string</a> </b> <b class="vimtag"> <a name="E115">E115</a> </b>
</section><hr class="singleline" /><section class=inner>
<code class="badlink">'string'</code>                字符串常数                      <b class="vimtag"> <a name="expr-'">expr-'</a> </b>

<code class="note">注意</code> 使用的是单引号。

字符串这里按原义出现。不去掉反斜杠，它也没有特殊含义。唯一的特例是两个单引号代
表一个单引号。

单引号字符串有助于模式的使用，因为反斜杠不再需要加倍。以下两个命令等价: 
<code class="example">        if a =~ "\\s*"</code>
<code class="example">        if a =~ '\s*'</code>
<code class="example"></code>
<code class="example"></code>
option                                          <b class="vimtag"> <a name="expr-option">expr-option</a> </b> <b class="vimtag"> <a name="E112">E112</a> </b> <b class="vimtag"> <a name="E113">E113</a> </b>
</section><hr class="singleline" /><section class=inner>
&amp;option                 选项值，如有存在，使用局部值
&amp;g:option               全局选项值
&amp;l:option               局部选项值

例如: 
<code class="example">        echo "tabstop is " . &amp;tabstop</code>
<code class="example">        if &amp;insertmode</code>
<code class="example"></code>
这里可以使用任何选项值。见  <a href="options.html#options">options</a> 。如果指定要使用局部值，但不存在局部于缓冲
区或局部于窗口的选项，则还是使用全局值。


register                                                <b class="vimtag"> <a name="expr-register">expr-register</a> </b> <b class="vimtag"> <a name="@r">@r</a> </b>
</section><hr class="singleline" /><section class=inner>
@r                      寄存器 'r' 的值

结果是命名寄存器的内容，以单个字符串表达。换行符在需要时会被插入。要得到无名寄
存器的内容，使用 @" 或 @@。可用寄存器的相关解释可见  <a href="change.html#registers">registers</a> 。

如果用 '=' 寄存器，你得到表达式自身，而不是它计算的结果。用  <a href="eval.html#eval()">eval()</a>  来进行计
算。


nesting                                                 <b class="vimtag"> <a name="expr-nesting">expr-nesting</a> </b> <b class="vimtag"> <a name="E110">E110</a> </b>
</section><hr class="singleline" /><section class=inner>
(expr1)                 嵌套表达式


environment variable                                    <b class="vimtag"> <a name="expr-env">expr-env</a> </b>
</section><hr class="singleline" /><section class=inner>
$VAR                    环境变量

任何环境变量的字符串值。如果该环境变量没有定义，结果为空字符串。

也可用  <a href="eval.html#getenv()">getenv()</a>  和  <a href="eval.html#setenv()">setenv()</a>  函数，它们支持非字母数字的环境变量名。
可用  <a href="eval.html#environ()">environ()</a>  函数得到包含所有环境变量的字典。


                                                <b class="vimtag"> <a name="expr-env-expand">expr-env-expand</a> </b>
<code class="note">注意</code> 直接使用 $VAR 和使用 expand("$VAR") 有区别。直接使用的形式只能扩展当前
Vim 会话所知的环境变量。使用 expand() 会先尝试当前 Vim 会话所知的环境变量，如
果不成功，则使用外壳扩展该变量。这会变慢，但可以用来扩展只有外壳知道的变量。
例如: 
<code class="example">        :echo $shell</code>
<code class="example">        :echo expand("$shell")</code>
前者可能不会回显任何内容，后者会回显 $shell 变量 (如果你的外壳支持的话)。


internal variable                                       <b class="vimtag"> <a name="expr-variable">expr-variable</a> </b>
</section><hr class="singleline" /><section class=inner>
variable                内部变量
见下面的  <a href="eval.html#internal-variables">internal-variables</a> 。


function call           <b class="vimtag"> <a name="expr-function">expr-function</a> </b> <b class="vimtag"> <a name="E116">E116</a> </b> <b class="vimtag"> <a name="E118">E118</a> </b> <b class="vimtag"> <a name="E119">E119</a> </b> <b class="vimtag"> <a name="E120">E120</a> </b>
</section><hr class="singleline" /><section class=inner>
function(expr1, ...)    函数调用
见下面的  <a href="eval.html#functions">functions</a> 。


lambda expression                               <b class="vimtag"> <a name="expr-lambda">expr-lambda</a> </b> <b class="vimtag"> <a name="lambda">lambda</a> </b>
</section><hr class="singleline" /><section class=inner>
{args -&gt; expr1}         匿名函数表达式

匿名函数表达式创建一个新的无名函数，返回  <a href="eval.html#expr1">expr1</a>  的计算结果。匿名函数表达式和
 <a href="eval.html#user-functions">user-functions</a>  的区别如下:

1. 匿名函数表达式的本体是  <a href="eval.html#expr1">expr1</a>  而不是  <a href="intro.html#Ex">Ex</a>  命令序列。
2. 前缀 "a:" 不用于参数。例如: 
<code class="example">        :let F = {arg1, arg2 -&gt; arg1 - arg2}</code>
<code class="example">        :echo F(5, 2)</code>
        3

参数可选。例如: 
<code class="example">        :let F = {-&gt; 'error function'}</code>
<code class="example">        :echo F()</code>
        error function
                                                        <b class="vimtag"> <a name="closure">closure</a> </b>
匿名函数表达式可能访问外层变量和参数。这通常被称为闭包。下例中匿名函数可以使用
已存在于函数作用域的 "i" 和 "a:arg"。在函数返回后它们依然有效: 
<code class="example">        :function Foo(arg)</code>
<code class="example">        :  let i = 3</code>
<code class="example">        :  return {x -&gt; x + i - a:arg}</code>
<code class="example">        :endfunction</code>
<code class="example">        :let Bar = Foo(4)</code>
<code class="example">        :echo Bar(6)</code>
        5

<code class="note">注意</code> 变量必须在 lambda 定义之前已存在于外部作用域。另见  <a href="eval.html#:func-closure">:func-closure</a> 。

可以这样来检查匿名函数和闭包的支持: 
<code class="example">        if has('lambda')</code>
<code class="example"></code>
示例如何在  <a href="eval.html#sort()">sort()</a> 、 <a href="eval.html#map()">map()</a>  和  <a href="eval.html#filter()">filter()</a>  中使用匿名函数: 
<code class="example">        :echo map([1, 2, 3], {idx, val -&gt; val + 1})</code>
        [2, 3, 4] 
<code class="example">        :echo sort([3,7,2,1,4], {a, b -&gt; a - b})</code>
        [1, 2, 3, 4, 7]

匿名函数表达式也可用于通道、作业和定时器中: 
<code class="example">        :let timer = timer_start(500,</code>
<code class="example">                        \ {-&gt; execute("echo 'Handler called'", "")},</code>
<code class="example">                        \ {'repeat': 3})</code>
        Handler called
        Handler called
        Handler called

<code class="note">注意</code> execute() 是如何用来执行 Ex 命令的。这不怎样好看。


匿名函数表达式使用的内部名形如 '<code class="special">&lt;lambda&gt;</code>42'。如果有关于某匿名函数的错误，可以
用下述命令查看它的定义: 
<code class="example">        :function {'&lt;lambda&gt;42'}</code>
另见:  <a href="eval.html#numbered-function">numbered-function</a> 

</section><hr class="doubleline" /><section class=inner>
<h4>3. 内部变量                                     <b class="vimtag"> <a name="internal-variables">internal-variables</a> </b> <b class="vimtag"> <a name="E461">E461</a> </b></h4>内部变量的名字由字母、数字和 '_' 组成。但不能由数字开始。可以使用花括号，见
 <a href="eval.html#curly-braces-names">curly-braces-names</a> 。

内部变量通过 ":let" 命令建立  <a href="eval.html#:let">:let</a> 。
内部变量通过 ":unlet" 命令显式删除  <a href="eval.html#:unlet">:unlet</a> 。
使用非内部变量的名字或引用已经删除的内部变量会产生错误。

变量有不同的命名空间，根据附加的前缀决定:

                     (无) 函数内: 局部于函数；否则: 全局
 <a href="eval.html#buffer-variable">buffer-variable</a>     b:   局部于当前缓冲区。
 <a href="eval.html#window-variable">window-variable</a>     w:   局部于当前窗口。
 <a href="eval.html#tabpage-variable">tabpage-variable</a>    t:   局部于当前标签页。
 <a href="eval.html#global-variable">global-variable</a>     g:   全局。
 <a href="eval.html#local-variable">local-variable</a>      l:   局部于函数。
 <a href="eval.html#script-variable">script-variable</a>     s:   局部于  <a href="repeat.html#:source">:source</a>  的 Vim 脚本。
 <a href="eval.html#function-argument">function-argument</a>   a:   函数参数 (只限于函数内使用)。
 <a href="eval.html#vim-variable">vim-variable</a>        v:   Vim 预定义的全局变量。

作用域本身可以用作  <a href="eval.html#Dictionary">Dictionary</a> 。例如，要删除所有局部于脚本的变量: 
<code class="example">        :for k in keys(s:)</code>
<code class="example">        :    unlet s:[k]</code>
<code class="example">        :endfor</code>

                                                <b class="vimtag"> <a name="buffer-variable">buffer-variable</a> </b> <b class="vimtag"> <a name="b:var">b:var</a> </b> <b class="vimtag"> <a name="b:">b:</a> </b>
"b:" 开头的变量名局部于当前缓冲区。这样，你可以为每个缓冲区定义不同的 "b:foo"
变量。这种变量在缓冲区被删除时 (:bwipeout 或 :bdelete  <a href="windows.html#:bdelete">:bdelete</a> ) 同时被删除。

预定义了如下的缓冲区局部变量:
                                        <b class="vimtag"> <a name="b:changedtick">b:changedtick</a> </b> <b class="vimtag"> <a name="changetick">changetick</a> </b>
b:changedtick   当前缓冲区的改变次数。每次改变都会递增。撤销命令在此情形下也被
                视作一次改变。写入缓冲区后复位 <a href="options.html#'modified'">'modified'</a> 也算。
                这可用来在缓冲区发生改变时执行一些动作。比如: 
<code class="example">                    :if my_changedtick != b:changedtick</code>
<code class="example">                    : let my_changedtick = b:changedtick</code>
<code class="example">                    : call My_Update()</code>
<code class="example">                    :endif</code>
                不可改变或删除 b:changedtick 变量。

                                                <b class="vimtag"> <a name="window-variable">window-variable</a> </b> <b class="vimtag"> <a name="w:var">w:var</a> </b> <b class="vimtag"> <a name="w:">w:</a> </b>
"w:" 开头的变量名局部于当前窗口。窗口关闭时被删除。

                                                <b class="vimtag"> <a name="tabpage-variable">tabpage-variable</a> </b> <b class="vimtag"> <a name="t:var">t:var</a> </b> <b class="vimtag"> <a name="t:">t:</a> </b>
"t" 开始的变量名局部于当前标签页。标签页关闭时，这些变量被删除。
<code class="notvi">{仅当编译时加入  <a href="various.html#+windows">+windows</a>  特性才有效}</code>

                                                <b class="vimtag"> <a name="global-variable">global-variable</a> </b> <b class="vimtag"> <a name="g:var">g:var</a> </b> <b class="vimtag"> <a name="g:">g:</a> </b>
函数内部，全局变量可以通过 "g:" 访问。如果不提供前缀，会使用函数的局部变量。在
其他地方，如果你想的话。也可以使用 "g:"。

                                                <b class="vimtag"> <a name="local-variable">local-variable</a> </b> <b class="vimtag"> <a name="l:var">l:var</a> </b> <b class="vimtag"> <a name="l:">l:</a> </b>
访问函数的局部变量无需任何前缀。但如果你想要，可以使用 "l:"。不过，如果没有
"l:" 前缀，你可能会和保留的变量名冲突。例如 "count"。它本身指代 "v:count"。但
使用了 "l:count" 你就可以使用同名的局部变量。


                                                <b class="vimtag"> <a name="script-variable">script-variable</a> </b> <b class="vimtag"> <a name="s:var">s:var</a> </b>
Vim 脚本里，可以使用 "s:" 开头的变量。它们不能在脚本之外访问，因而可以称为局部
于脚本的变量。

它们可以用于:
- 载入脚本时执行的命令
- 脚本定义的函数
- 脚本定义的自动命令
- 脚本定义的函数和自动命令里定义的函数和自动命令 (递归)
- 脚本里定义的用户定义命令
但不能用在:
- 该脚本载入的其它脚本
- 映射
- 菜单
- 等等

脚本变量可以用来防止和全局变量名的冲突。看看这个例子: 
<code class="example"></code>
<code class="example">        let s:counter = 0</code>
<code class="example">        function MyCounter()</code>
<code class="example">          let s:counter = s:counter + 1</code>
<code class="example">          echo s:counter</code>
<code class="example">        endfunction</code>
<code class="example">        command Tick call MyCounter()</code>
<code class="example"></code>
你可以从任何脚本里启动 "Tick"，但那个脚本里的 "s:counter" 变量不会被改变，只有
在 "Tick" 定义所在脚本的 "s:counter" 才会。

另一个完成相同功能的例子: 
<code class="example"></code>
<code class="example">        let s:counter = 0</code>
<code class="example">        command Tick let s:counter = s:counter + 1 | echo s:counter</code>
<code class="example"></code>
如果调用函数或者启动用户定义命令，脚本变量的上下文设置为函数和命令定义所在的脚
本。

脚本变量也可用于脚本里定义的函数里定义的函数。例如: 
<code class="example"></code>
<code class="example">        let s:counter = 0</code>
<code class="example">        function StartCounting(incr)</code>
<code class="example">          if a:incr</code>
<code class="example">            function MyCounter()</code>
<code class="example">              let s:counter = s:counter + 1</code>
<code class="example">            endfunction</code>
<code class="example">          else</code>
<code class="example">            function MyCounter()</code>
<code class="example">              let s:counter = s:counter - 1</code>
<code class="example">            endfunction</code>
<code class="example">          endif</code>
<code class="example">        endfunction</code>
<code class="example"></code>
调用 StartCounting() 时，定义 MyCounter() 函数或者递增或者递减计数器。不管
StartCounting() 在哪里调用，s:counter 变量总可以在 MyCounter() 里访问。

如果相同的脚本多次执行，使用的是同一个脚本变量。只要 Vim 还在运行，就保持有
效。这可以用于维护计数: 
<code class="example"></code>
<code class="example">        if !exists("s:counter")</code>
<code class="example">          let s:counter = 1</code>
<code class="example">          echo "脚本首次执行"</code>
<code class="example">        else</code>
<code class="example">          let s:counter = s:counter + 1</code>
<code class="example">          echo "脚本现在执行了 " . s:counter . " 次"</code>
<code class="example">        endif</code>
<code class="example"></code>
<code class="note">注意</code> 这意味着 filetype 插件不能为每个缓冲区提供不同的脚本变量。这时应使用缓冲
区的局部变量  <a href="eval.html#b:var">b:var</a> 。


预定义的 VIM 变量:                              <b class="vimtag"> <a name="vim-variable">vim-variable</a> </b> <b class="vimtag"> <a name="v:var">v:var</a> </b> <b class="vimtag"> <a name="v:">v:</a> </b>
                                                                <b class="vimtag"> <a name="E963">E963</a> </b>
有些变量可以被用户设置，但不能改变类型。

                                        <b class="vimtag"> <a name="v:argv">v:argv</a> </b> <b class="vimtag"> <a name="argv-variable">argv-variable</a> </b>
v:argv          调用 Vim 时的命令行参数。这是字符串列表。首项是 Vim 命令。

                                        <b class="vimtag"> <a name="v:beval_col">v:beval_col</a> </b> <b class="vimtag"> <a name="beval_col-variable">beval_col-variable</a> </b>
v:beval_col     鼠标指针所在的列号，即  <a href="eval.html#v:beval_lnum">v:beval_lnum</a>  行中的字节位置。
                仅当计算 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 选项时有效。

                                        <b class="vimtag"> <a name="v:beval_bufnr">v:beval_bufnr</a> </b> <b class="vimtag"> <a name="beval_bufnr-variable">beval_bufnr-variable</a> </b>
v:beval_bufnr   鼠标指针所在的缓冲区号。仅当计算 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 选项时有效。

                                        <b class="vimtag"> <a name="v:beval_lnum">v:beval_lnum</a> </b> <b class="vimtag"> <a name="beval_lnum-variable">beval_lnum-variable</a> </b>
v:beval_lnum    鼠标指针所在的行号。仅当计算 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 选项时有效。

                                        <b class="vimtag"> <a name="v:beval_text">v:beval_text</a> </b> <b class="vimtag"> <a name="beval_text-variable">beval_text-variable</a> </b>
v:beval_text    鼠标指针所在或之后的文本。通常是一个单词，可用于调试 C 程序。
                此处用到 <a href="options.html#'iskeyword'">'iskeyword'</a>，但也包括此位置之前的句号和 "-&gt;"。如果在
                ']' 上，使用它之前的文本，包括匹配的 '[' 和它之前的单词。如果
                在单行的可视区域上，使用高亮文本。另见  <a href="cmdline.html#%3Ccexpr%3E">&lt;cexpr&gt;</a> 。
                仅当计算 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 选项时有效。

                                        <b class="vimtag"> <a name="v:beval_winnr">v:beval_winnr</a> </b> <b class="vimtag"> <a name="beval_winnr-variable">beval_winnr-variable</a> </b>
v:beval_winnr   鼠标指针所在的窗口号。仅当计算 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 选项时有效。首个
                窗口的编号为零 (这和多数需要窗口编号的地方不同)。

                                        <b class="vimtag"> <a name="v:beval_winid">v:beval_winid</a> </b> <b class="vimtag"> <a name="beval_winid-variable">beval_winid-variable</a> </b>
v:beval_winid   鼠标指针所在的窗口 ID  <a href="windows.html#window-ID">window-ID</a> 。其它类同于 v:beval_winnr。

                                        <b class="vimtag"> <a name="v:char">v:char</a> </b> <b class="vimtag"> <a name="char-variable">char-variable</a> </b>
v:char          计算 <a href="options.html#'formatexpr'">'formatexpr'</a> 时使用的参数和用于带 <code class="special">&lt;expr&gt;</code> 的缩写中输入的字
                符  <a href="map.html#:map-%3Cexpr%3E">:map-&lt;expr&gt;</a> 。
                也用于  <a href="autocmd.html#InsertCharPre">InsertCharPre</a>  和  <a href="autocmd.html#InsertEnter">InsertEnter</a>  事件。

                        <b class="vimtag"> <a name="v:charconvert_from">v:charconvert_from</a> </b> <b class="vimtag"> <a name="charconvert_from-variable">charconvert_from-variable</a> </b>
v:charconvert_from
                要转换的文件字符编码名。只在计算 <a href="options.html#'charconvert'">'charconvert'</a> 选项时有效。

                        <b class="vimtag"> <a name="v:charconvert_to">v:charconvert_to</a> </b> <b class="vimtag"> <a name="charconvert_to-variable">charconvert_to-variable</a> </b>
v:charconvert_to
                转换后的文件字符编码名。只在计算 <a href="options.html#'charconvert'">'charconvert'</a> 选项时有效。

                                        <b class="vimtag"> <a name="v:cmdarg">v:cmdarg</a> </b> <b class="vimtag"> <a name="cmdarg-variable">cmdarg-variable</a> </b>
v:cmdarg        该变量有两个目的:
                1. 文件读写命令的额外参数。目前，它们包括 "++enc=" 和
                   "++ff="。该变量在文件读写命令的自动命令事件激活之前设置。开
                   头有一个空格，以便直接把该变量附加到读写命令之后。<code class="note">注意</code>: 这
                   里不包括 "+cmd" 参数，因为它总要被执行的。
                2. 使用 ":hardcopy" 打印 PostScript 文件时，":hardcopy" 命令的
                   参数。在 <a href="options.html#'printexpr'">'printexpr'</a> 里用得到。

                                        <b class="vimtag"> <a name="v:cmdbang">v:cmdbang</a> </b> <b class="vimtag"> <a name="cmdbang-variable">cmdbang-variable</a> </b>
v:cmdbang       文件读写命令时，和 v:cmdarg 设置的时间类似。如果使用了 "!"，其
                值为 1，不然为 0。<code class="note">注意</code> 它只能用于自动命令。用户命令里可以用
                 <a href="map.html#%3Cbang%3E">&lt;bang&gt;</a> 。

                                <b class="vimtag"> <a name="v:completed_item">v:completed_item</a> </b> <b class="vimtag"> <a name="completed_item-variable">completed_item-variable</a> </b>
v:completed_item
                包含  <a href="insert.html#complete-items">complete-items</a>  的  <a href="eval.html#Dictionary">Dictionary</a> ，用于得到  <a href="autocmd.html#CompleteDone">CompleteDone</a> 
                之后的最近补全。如果补全失败， <a href="eval.html#Dictionary">Dictionary</a>  为空。

                                        <b class="vimtag"> <a name="v:count">v:count</a> </b> <b class="vimtag"> <a name="count-variable">count-variable</a> </b>
v:count         最近的普通模式命令使用的计数。在映射前可用于得到计数。只读。
                例如: 
<code class="example">        :map _x :&lt;C-U&gt;echo "计数为 " . v:count&lt;CR&gt;</code>
                <code class="note">注意</code>: <code class="special">&lt;C-U&gt;</code> 是必要的，它删除紧跟在计数之后 ':' 所给出的行范
                围。
                如果有两个计数，如 "3d2w"，它们进行相乘，如同命令行实际发生的
                那样，等同于 "d6w"。
                也用于计算 <a href="options.html#'formatexpr'">'formatexpr'</a> 选项。
                为了后向兼容，这里也可以用 "count"，除非  <a href="eval.html#scriptversion">scriptversion</a>  为 3
                或更高。

                                        <b class="vimtag"> <a name="v:count1">v:count1</a> </b> <b class="vimtag"> <a name="count1-variable">count1-variable</a> </b>
v:count1        类似于 "v:count"，但没有给出计数时，缺省为 1。

                                                <b class="vimtag"> <a name="v:ctype">v:ctype</a> </b> <b class="vimtag"> <a name="ctype-variable">ctype-variable</a> </b>
v:ctype         运行环境当前的字符 locale 设置。它使得 Vim 脚本能得到当前的
                locale 编码。技术细节: 这就是 LC_CTYPE 的值。如果没有使用
                locale，其值为 "C"。
                该变量不能直接设置，请使用  <a href="mlang.html#:language">:language</a>  命令。
                见  <a href="mlang.html#multi-lang">multi-lang</a> 。

                                        <b class="vimtag"> <a name="v:dying">v:dying</a> </b> <b class="vimtag"> <a name="dying-variable">dying-variable</a> </b>
v:dying         通常为零。如果捕获到某个 "致命" 的 signal，设为 1。如果同时捕
                获到多个 signal，其值相应增加。在自动命令里可以用来检查 Vim
                是否被异常终止。<code class="notvi">{仅限于 Unix}</code>
                例如: 
<code class="example">        :au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif</code>
                <code class="note">备注</code>: 如果 v:dying 为一而同时又捕捉到另一个致命的 signal，不执
                行 VimLeave 自动命令。

                                        <b class="vimtag"> <a name="v:echospace">v:echospace</a> </b> <b class="vimtag"> <a name="echospace-variable">echospace-variable</a> </b>
v:echospace     在屏幕行末行上  <a href="eval.html#:echo">:echo</a>  消息不引发  <a href="message.html#hit-enter-prompt">hit-enter-prompt</a>  最多可用
                的屏幕单元格数目。取决于 <a href="options.html#'showcmd'">'showcmd'</a>、<a href="options.html#'ruler'">'ruler'</a> 和 <a href="options.html#'columns'">'columns'</a>。需要
                检查 <a href="options.html#'cmdheight'">'cmdheight'</a> 看看在末行之上是否有全宽的行存在。

                                        <b class="vimtag"> <a name="v:errmsg">v:errmsg</a> </b> <b class="vimtag"> <a name="errmsg-variable">errmsg-variable</a> </b>
v:errmsg        最近给出的错误信息。该变量可以设置。
                例如: 
<code class="example">        :let v:errmsg = ""</code>
<code class="example">        :silent! next</code>
<code class="example">        :if v:errmsg != ""</code>
<code class="example">        :  ... handle error</code>
                为了后向兼容，这里也可以用 "errmsg"，除非  <a href="eval.html#scriptversion">scriptversion</a>  为 3
                或更高。

                                <b class="vimtag"> <a name="v:errors">v:errors</a> </b> <b class="vimtag"> <a name="errors-variable">errors-variable</a> </b> <b class="vimtag"> <a name="assert-return">assert-return</a> </b>
v:errors        assert 函数找到的错误，如  <a href="testing.html#assert_true()">assert_true()</a> 。
                是一个字符串列表。
                assert 函数在 assert 失败后附加项目。
                返回值说明这一点: 如果有项目加入 v:errors，返回一，不然返回
                零。
                要清空旧的结果: 
<code class="example">        :let v:errors = []</code>
                如果用非列表来设置 v:errors，assert 函数会把它变成空列表。

                                        <b class="vimtag"> <a name="v:event">v:event</a> </b> <b class="vimtag"> <a name="event-variable">event-variable</a> </b>
v:event         包含当前  <a href="autocmd.html#autocommand">autocommand</a>  信息的字典。 <a href="autocmd.html#autocommand">autocommand</a>  结束后该字典
                清空。请参见  <a href="eval.html#dict-identity">dict-identity</a>  来了解如何取得字典独立的备份。

                                        <b class="vimtag"> <a name="v:exception">v:exception</a> </b> <b class="vimtag"> <a name="exception-variable">exception-variable</a> </b>
v:exception     最近捕获且没有完成的例外的值。见  <a href="eval.html#v:throwpoint">v:throwpoint</a>  和
                 <a href="eval.html#throw-variables">throw-variables</a> 。
                例如: 
<code class="example">        :try</code>
<code class="example">        :  throw "oops"</code>
<code class="example">        :catch /.*/</code>
<code class="example">        :  echo "caught" .. v:exception</code>
<code class="example">        :endtry</code>
                输出: "caught oops"。

                                        <b class="vimtag"> <a name="v:false">v:false</a> </b> <b class="vimtag"> <a name="false-variable">false-variable</a> </b>
v:false         取值为零的数值。用于在 JSON 里填入 "false"。见
                 <a href="eval.html#json_encode()">json_encode()</a> 。
                用于字符串时会返回 "v:false"。 
<code class="example">                        echo v:false</code>
<code class="section">                        v:false </code>
                这样 eval() 可以把该字符串解析回相同的值。只读。

                                        <b class="vimtag"> <a name="v:fcs_reason">v:fcs_reason</a> </b> <b class="vimtag"> <a name="fcs_reason-variable">fcs_reason-variable</a> </b>
v:fcs_reason    激活  <a href="autocmd.html#FileChangedShell">FileChangedShell</a>  事件的原因。
                可以在自动命令里用来决定该做什么和/或如何设置 v:fcs_choice。可
                能的值是:
                        deleted         文件不再存在
                        conflict        文件内容、模式或修改时间被改变，而缓冲
                                        区同时被修改
                        changed         文件内容被改变
                        mode            文件模式被改变
                        time            文件修改时间被改变

                                        <b class="vimtag"> <a name="v:fcs_choice">v:fcs_choice</a> </b> <b class="vimtag"> <a name="fcs_choice-variable">fcs_choice-variable</a> </b>
v:fcs_choice     <a href="autocmd.html#FileChangedShell">FileChangedShell</a>  事件激活后该做什么。可以在自动命令里用来告
                诉 Vim 如何处理涉及的缓冲区:
                        reload          重新载入缓冲区 (如果文件已删除，不能工
                                        作)。
                        ask             询问用户该做什么，就像没有自动命令一
                                        样。不过，如果只有修改时间被改变，不做
                                        任何事。
                        &lt;空&gt;            不做任何事。自动命令应该已经处理完毕。
                缺省为空。如果使用别的 (非法的) 值，Vim 的行为就像它为空一样。
                不会有警告信息。

                                        <b class="vimtag"> <a name="v:fname_in">v:fname_in</a> </b> <b class="vimtag"> <a name="fname_in-variable">fname_in-variable</a> </b>
v:fname_in      输入文件名。在计算以下选项时合法:
<code class="section">                        选项            用于 </code>
                        <a href="options.html#'charconvert'">'charconvert'</a>   要转换的文件
                        <a href="options.html#'diffexpr'">'diffexpr'</a>      原始文件
                        <a href="options.html#'patchexpr'">'patchexpr'</a>     原始文件
                        <a href="options.html#'printexpr'">'printexpr'</a>     要打印的文件
                 <a href="autocmd.html#SwapExists">SwapExists</a>  里设为交换文件名。

                                        <b class="vimtag"> <a name="v:fname_out">v:fname_out</a> </b> <b class="vimtag"> <a name="fname_out-variable">fname_out-variable</a> </b>
v:fname_out     输出文件名。只有在计算以下选项时才合法:
<code class="section">                        选项            用于 </code>
                        <a href="options.html#'charconvert'">'charconvert'</a>   生成的转换完成的文件 (*)
                        <a href="options.html#'diffexpr'">'diffexpr'</a>      diff 的结果
                        <a href="options.html#'patchexpr'">'patchexpr'</a>     产生的补丁文件
                (*) 如果用于为写入命令进行转换 (比如，":w file")，等价于
                v:fname_in。如果用于为读入命令进行转换 (比如，":e file")，它是
                一个临时文件名，和 v:fname_in 不同。

                                        <b class="vimtag"> <a name="v:fname_new">v:fname_new</a> </b> <b class="vimtag"> <a name="fname_new-variable">fname_new-variable</a> </b>
v:fname_new     文件新版本的名字。只有在计算 <a href="options.html#'diffexpr'">'diffexpr'</a> 的时候才有效。

                                        <b class="vimtag"> <a name="v:fname_diff">v:fname_diff</a> </b> <b class="vimtag"> <a name="fname_diff-variable">fname_diff-variable</a> </b>
v:fname_diff    比较结果 (或补丁) 的文件名。只有在计算 <a href="options.html#'patchexpr'">'patchexpr'</a> 的时候才有
                效。

                                        <b class="vimtag"> <a name="v:folddashes">v:folddashes</a> </b> <b class="vimtag"> <a name="folddashes-variable">folddashes-variable</a> </b>
v:folddashes    用于 <a href="options.html#'foldtext'">'foldtext'</a>: 反映关闭的折叠的折叠级别的连字符。
                 <a href="eval.html#sandbox">sandbox</a>  里只读。 <a href="fold.html#fold-foldtext">fold-foldtext</a> 

                                        <b class="vimtag"> <a name="v:foldlevel">v:foldlevel</a> </b> <b class="vimtag"> <a name="foldlevel-variable">foldlevel-variable</a> </b>
v:foldlevel     用于 <a href="options.html#'foldtext'">'foldtext'</a>: 关闭的折叠的折叠级别。
                 <a href="eval.html#sandbox">sandbox</a>  里只读。 <a href="fold.html#fold-foldtext">fold-foldtext</a> 

                                        <b class="vimtag"> <a name="v:foldend">v:foldend</a> </b> <b class="vimtag"> <a name="foldend-variable">foldend-variable</a> </b>
v:foldend       用于 <a href="options.html#'foldtext'">'foldtext'</a>: 关闭的折叠的最后一行。
                 <a href="eval.html#sandbox">sandbox</a>  里只读。 <a href="fold.html#fold-foldtext">fold-foldtext</a> 

                                        <b class="vimtag"> <a name="v:foldstart">v:foldstart</a> </b> <b class="vimtag"> <a name="foldstart-variable">foldstart-variable</a> </b>
v:foldstart     用于 <a href="options.html#'foldtext'">'foldtext'</a>: 关闭的折叠的第一行。
                 <a href="eval.html#sandbox">sandbox</a>  里只读。 <a href="fold.html#fold-foldtext">fold-foldtext</a> 

                                        <b class="vimtag"> <a name="v:hlsearch">v:hlsearch</a> </b> <b class="vimtag"> <a name="hlsearch-variable">hlsearch-variable</a> </b>
v:hlsearch      用于指定搜索高亮是否打开的变量。只有在启动 <a href="options.html#'hlsearch'">'hlsearch'</a> 时它的设
                置才有意义，这需要  <a href="various.html#+extra_search">+extra_search</a> 。设置该变量为零相当
                 <a href="pattern.html#:nohlsearch">:nohlsearch</a>  命令，设置为一则相当于 
<code class="example">                        let &amp;hlsearch = &amp;hlsearch</code>
                <code class="note">备注</code> 函数返回时复原其值。 <a href="eval.html#function-search-undo">function-search-undo</a> 。

                                        <b class="vimtag"> <a name="v:insertmode">v:insertmode</a> </b> <b class="vimtag"> <a name="insertmode-variable">insertmode-variable</a> </b>
v:insertmode    用于  <a href="autocmd.html#InsertEnter">InsertEnter</a>  和  <a href="autocmd.html#InsertChange">InsertChange</a>  自动命令事件。取值:
                        i       插入模式
                        r       替换模式
                        v       虚拟替换模式

                                                <b class="vimtag"> <a name="v:key">v:key</a> </b> <b class="vimtag"> <a name="key-variable">key-variable</a> </b>
v:key            <a href="eval.html#Dictionary">Dictionary</a>  里当前项目的键。只有在  <a href="eval.html#map()">map()</a>  和  <a href="eval.html#filter()">filter()</a>  里计
                算表达式时有效。
                只读。

                                                <b class="vimtag"> <a name="v:lang">v:lang</a> </b> <b class="vimtag"> <a name="lang-variable">lang-variable</a> </b>
v:lang          运行环境当前的消息 locale 设置。它使得 Vim 脚本能得到当前使用
                的语言。技术细节: 这就是 LC_MESSAGES 的值。该值和系统有关。
                该变量不能直接设置，请使用  <a href="mlang.html#:language">:language</a>  命令。
                它和  <a href="eval.html#v:ctype">v:ctype</a>  不同，因为消息可能使用不同于字符编码的语言。见
                 <a href="mlang.html#multi-lang">multi-lang</a> 。

                                                <b class="vimtag"> <a name="v:lc_time">v:lc_time</a> </b> <b class="vimtag"> <a name="lc_time-variable">lc_time-variable</a> </b>
v:lc_time       运行环境当前的时间消息 locale 设置。它使得 Vim
                脚本能得到当前使用的语言。技术细节: 这就是 LC_TIME 的值。
                该变量不能直接设置，请使用  <a href="mlang.html#:language">:language</a>  命令。见  <a href="mlang.html#multi-lang">multi-lang</a> 。

                                                <b class="vimtag"> <a name="v:lnum">v:lnum</a> </b> <b class="vimtag"> <a name="lnum-variable">lnum-variable</a> </b>
v:lnum          <a href="options.html#'foldexpr'">'foldexpr'</a>  <a href="fold.html#fold-expr">fold-expr</a> 、<a href="options.html#'formatexpr'">'formatexpr'</a> 和 <a href="options.html#'indentexpr'">'indentexpr'</a> 表达式中
                的行号和 <code class="badlink">'guitablevel'</code> 和 <a href="options.html#'guitabtooltip'">'guitabtooltip'</a> 中的标签页号。只有在
                计算这些表达式时才合法。在  <a href="eval.html#sandbox">sandbox</a>  里时只读。

                                        <b class="vimtag"> <a name="v:mouse_win">v:mouse_win</a> </b> <b class="vimtag"> <a name="mouse_win-variable">mouse_win-variable</a> </b>
v:mouse_win     用  <a href="eval.html#getchar()">getchar()</a>  得到鼠标点击时所在的窗口号。首个窗口的编号为
                1 ，就像  <a href="eval.html#winnr()">winnr()</a>  那样。如果那时没有鼠标点击，该值为零。

                                        <b class="vimtag"> <a name="v:mouse_winid">v:mouse_winid</a> </b> <b class="vimtag"> <a name="mouse_winid-variable">mouse_winid-variable</a> </b>
v:mouse_winid   用  <a href="eval.html#getchar()">getchar()</a>  得到鼠标点击时所在的窗口 ID。如果那时没有鼠标点
                击，该值为零。

                                        <b class="vimtag"> <a name="v:mouse_lnum">v:mouse_lnum</a> </b> <b class="vimtag"> <a name="mouse_lnum-variable">mouse_lnum-variable</a> </b>
v:mouse_lnum    用  <a href="eval.html#getchar()">getchar()</a>  得到鼠标点击时所在的行号。这是文本行号，不是屏
                幕行号。如果那时没有鼠标点击，该值为零。

                                        <b class="vimtag"> <a name="v:mouse_col">v:mouse_col</a> </b> <b class="vimtag"> <a name="mouse_col-variable">mouse_col-variable</a> </b>
v:mouse_col     用  <a href="eval.html#getchar()">getchar()</a>  得到鼠标点击时所在的列号。这是屏幕列号，就像
                 <a href="eval.html#virtcol()">virtcol()</a>  那样。如果那时没有鼠标点击，该值为零。

                                        <b class="vimtag"> <a name="v:none">v:none</a> </b> <b class="vimtag"> <a name="none-variable">none-variable</a> </b> <b class="vimtag"> <a name="None">None</a> </b>
v:none          空字符串。用于在 JSON 里填入空项目。见  <a href="eval.html#json_encode()">json_encode()</a> 。
                用于数值时返回零。
                用于字符串时会返回 "v:none"。 
<code class="example">                        echo v:none</code>
<code class="section">                        v:none </code>
                这样 eval() 可以把该字符串解析回相同的值。只读。

                                        <b class="vimtag"> <a name="v:null">v:null</a> </b> <b class="vimtag"> <a name="null-variable">null-variable</a> </b>
v:null          空字符串。用于在 JSON 里填入 "null"。见  <a href="eval.html#json_encode()">json_encode()</a> 。
                用于数值时返回零。
                用于字符串时会返回 "v:null"。 
<code class="example">                        echo v:null</code>
<code class="section">                        v:null </code>
                这样 eval() 可以把该字符串解析回相同的值。只读。

                                        <b class="vimtag"> <a name="v:oldfiles">v:oldfiles</a> </b> <b class="vimtag"> <a name="oldfiles-variable">oldfiles-variable</a> </b>
v:oldfiles      启动时从  <a href="starting.html#viminfo">viminfo</a>  文件载入的文件名列表。Vim 记住的位置标记所
                在的就是这些文件。列表长度的上限由 <a href="options.html#'viminfo'">'viminfo'</a> 选项的 ' 参数定义
                (缺省是 100)。
                如果不用  <a href="starting.html#viminfo">viminfo</a> ，该列表为空。
                另见  <a href="starting.html#:oldfiles">:oldfiles</a>  和  <a href="cmdline.html#c_%23%3C">c_#&lt;</a> 。
                此列表可修改，但并不影响之后  <a href="starting.html#viminfo">viminfo</a>  文件保存什么。同时，如
                果使用非字符串的值，会有问题。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+viminfo">+viminfo</a>  特性才有效}</code>

                                                    <b class="vimtag"> <a name="v:option_new">v:option_new</a> </b>
v:option_new    选项的新值。执行  <a href="autocmd.html#OptionSet">OptionSet</a>  自动命令时有效。
                                                    <b class="vimtag"> <a name="v:option_old">v:option_old</a> </b>
v:option_old    选项的旧值。执行  <a href="autocmd.html#OptionSet">OptionSet</a>  自动命令时有效。取决于用来设置的
                命令和选项的类型，这可以是旧的局部值，也可以是旧的全局值。
                                                    <b class="vimtag"> <a name="v:option_oldlocal">v:option_oldlocal</a> </b>
v:option_oldlocal
                选项的旧的局部值。执行  <a href="autocmd.html#OptionSet">OptionSet</a>  自动命令时有效。
                                                    <b class="vimtag"> <a name="v:option_oldglobal">v:option_oldglobal</a> </b>
v:option_oldglobal
                选项的旧的全部值。执行  <a href="autocmd.html#OptionSet">OptionSet</a>  自动命令时有效。
                                                    <b class="vimtag"> <a name="v:option_type">v:option_type</a> </b>
v:option_type   设置命令的作用域。执行  <a href="autocmd.html#OptionSet">OptionSet</a>  自动命令时有效。可能为
                "global" 或 "local"
                                                    <b class="vimtag"> <a name="v:option_command">v:option_command</a> </b>
v:option_command
                用于设置选项的命令。执行  <a href="autocmd.html#OptionSet">OptionSet</a>  自动命令时有效。
<code class="section">                        值              选项设置方法   </code>
                        "setlocal"       <a href="options.html#:setlocal">:setlocal</a>  或 ":let l:xxx"
                        "setglobal"      <a href="options.html#:setglobal">:setglobal</a>  或 ":let g:xxx"
                        "set"            <a href="options.html#:set">:set</a>  或  <a href="eval.html#:let">:let</a> 
                        "modeline"       <a href="options.html#modeline">modeline</a> 
                                        <b class="vimtag"> <a name="v:operator">v:operator</a> </b> <b class="vimtag"> <a name="operator-variable">operator-variable</a> </b>
v:operator      普通模式给出的最近的操作符。除了 <code class="special">&lt;g&gt;</code> 或 <code class="special">&lt;z&gt;</code> 开始的命令是两个
                字符外，这是单个字符。最好和  <a href="eval.html#v:prevcount">v:prevcount</a>  和  <a href="eval.html#v:register">v:register</a>  一
                起使用。常常，先中止操作符等待模式，然后使用操作符，例如: 
<code class="example">                        :omap O &lt;Esc&gt;:call MyMotion(v:operator)&lt;CR&gt;</code>
                直到输入下一个操作符之前，该值保持不变。因此不要期待该值会为
                空。
                 <a href="change.html#:delete">:delete</a> 、 <a href="change.html#:yank">:yank</a>  或其它 Ex 命令不改变 v:operator。
                只读。

                                        <b class="vimtag"> <a name="v:prevcount">v:prevcount</a> </b> <b class="vimtag"> <a name="prevcount-variable">prevcount-variable</a> </b>
v:prevcount     倒数第二次的普通模式命令使用的计数，也就是再上一个命令用的
                v:count 的值。可以用来先中止可视模式或操作符等待模式，然后使用
                计数。 
<code class="example">                        :vmap % &lt;Esc&gt;:call MyFilter(v:prevcount)&lt;CR&gt;</code>
                只读。

                                        <b class="vimtag"> <a name="v:profiling">v:profiling</a> </b> <b class="vimtag"> <a name="profiling-variable">profiling-variable</a> </b>
v:profiling     通常为零。开始用 ":profile start" 之后设为一。见  <a href="repeat.html#profiling">profiling</a> 。

                                        <b class="vimtag"> <a name="v:progname">v:progname</a> </b> <b class="vimtag"> <a name="progname-variable">progname-variable</a> </b>
v:progname      包含 Vim 启动时使用的名字 (路径已被去掉)。可以用来为  <a href="starting.html#view">view</a> 、
                 <a href="starting.html#evim">evim</a>  等符号链接到 Vim 的名字提供特殊的设置。
                只读。

                                        <b class="vimtag"> <a name="v:progpath">v:progpath</a> </b> <b class="vimtag"> <a name="progpath-variable">progpath-variable</a> </b>
v:progpath      包含 Vim 启动时使用的命令，使用的形式如果传递给外壳的话会保证
                和当前进程运行相同的 Vim 可执行程序 (如果 $PATH 没变的话)。可
                用于通过  <a href="remote.html#--remote-expr">--remote-expr</a>  给 Vim 服务器发消息。
                要得到完整路径: 
<code class="example">                        echo exepath(v:progpath)</code>
                如果命令使用相对路径，这样就会把相对路径扩展为完整路径，从而可
                在  <a href="editing.html#:cd">:cd</a>  后使用。假定用 "./vim" 启动，返回
                "/home/user/path/to/vim/src/vim"。
                Linux 和其它系统上总是使用完整路径。
                Mac 上可能只是 "vim"，如上所述使用 exepath() 可用来得到完整路
                径。
                MS-Windows 上的可执行文件可能叫做 "vim.exe"，但 v:progpath 中
                不会带上 ".exe"。
                只读。

                                        <b class="vimtag"> <a name="v:register">v:register</a> </b> <b class="vimtag"> <a name="register-variable">register-variable</a> </b>
v:register      当前的普通模式命令使用的寄存器名字 (不管该命令是否使用寄存
                器)，也用于当前执行的普通模式的映射 (用于其中的接受寄存器的自
                定义命令)。
                如果没有特殊指定，使用缺省寄存器 '"'。除非 <a href="options.html#'clipboard'">'clipboard'</a> 包含
                "unamed" 或 "unamedplus"，此时它为 '*' 或 '+'。
                另见  <a href="eval.html#getreg()">getreg()</a>  和  <a href="eval.html#setreg()">setreg()</a> 

                                        <b class="vimtag"> <a name="v:scrollstart">v:scrollstart</a> </b> <b class="vimtag"> <a name="scrollstart-variable">scrollstart-variable</a> </b>
v:scrollstart   指示使屏幕上滚的脚本或函数的字符串。只有在原来为空时才设置，因
                此只记住第一个原因。如果来自输入的命令，设为 "Unknown"。
                可以用来发现你的脚本为什么产生 hit-enter 提示。

                                        <b class="vimtag"> <a name="v:servername">v:servername</a> </b> <b class="vimtag"> <a name="servername-variable">servername-variable</a> </b>
v:servername    如果有的话，注册过的  <a href="remote.html#client-server-name">client-server-name</a>  名字。
                只读。


v:searchforward                 <b class="vimtag"> <a name="v:searchforward">v:searchforward</a> </b> <b class="vimtag"> <a name="searchforward-variable">searchforward-variable</a> </b>
                搜索方向: 正向搜索后为 1，反向搜索后为 0。直接设置最近搜索模式
                会复位此值为正向，见  <a href="change.html#quote%2F">quote/</a> 。
                <code class="note">注意</code> 从函数返回时该值被复原  <a href="eval.html#function-search-undo">function-search-undo</a> 。
                可读写。

                                        <b class="vimtag"> <a name="v:shell_error">v:shell_error</a> </b> <b class="vimtag"> <a name="shell_error-variable">shell_error-variable</a> </b>
v:shell_error   最近一次外壳命令的返回值。如果非零，最近一次外壳命令有错。如果
                为零，则该命令成功返回。这只有在外壳把错误代码返回给 Vim 的时
                候才工作。-1 通常用来告知该命令无法执行。只读。
                例如: 
<code class="example">        :!mv foo bar</code>
<code class="example">        :if v:shell_error</code>
<code class="example">        :  echo '不能把 "foo" 换名为 "bar"!'</code>
<code class="example">        :endif</code>
                为了后向兼容，这里也可以用 "shell_error"，除非  <a href="eval.html#scriptversion">scriptversion</a> 
                为 3 或更高。

                                        <b class="vimtag"> <a name="v:statusmsg">v:statusmsg</a> </b> <b class="vimtag"> <a name="statusmsg-variable">statusmsg-variable</a> </b>
v:statusmsg     最近给出的状态消息。可以设置该变量。

                                        <b class="vimtag"> <a name="v:swapname">v:swapname</a> </b> <b class="vimtag"> <a name="swapname-variable">swapname-variable</a> </b>
v:swapname      只有在执行  <a href="autocmd.html#SwapExists">SwapExists</a>  自动命令时才合法: 找到的交换文件名。只
                读。

                                        <b class="vimtag"> <a name="v:swapchoice">v:swapchoice</a> </b> <b class="vimtag"> <a name="swapchoice-variable">swapchoice-variable</a> </b>
v:swapchoice     <a href="autocmd.html#SwapExists">SwapExists</a>  自动命令可以设置此值，以选择如何处理已有交换文件:
                        'o'     以只读方式打开
                        'e'     仍然编辑
                        'r'     恢复
                        'd'     删除交换文件
                        'q'     退出
                        'a'     中止
                该值应是单个字符的字符串。如果为空，用户会被询问，就像没有
                SwapExists 自动命令那样。缺省为空。

                                        <b class="vimtag"> <a name="v:swapcommand">v:swapcommand</a> </b> <b class="vimtag"> <a name="swapcommand-variable">swapcommand-variable</a> </b>
v:swapcommand   打开文件后执行的普通模式命令。可以用于  <a href="autocmd.html#SwapExists">SwapExists</a>  自动命令，
                用以让另一个 Vim 打开文件并跳转到合适的位置。例如，要跳转到某
                标签，用的值是 ":tag tagname\r"。":edit +cmd file" 用的值是
                ":cmd\r"。

                                <b class="vimtag"> <a name="v:t_TYPE">v:t_TYPE</a> </b> <b class="vimtag"> <a name="v:t_bool">v:t_bool</a> </b> <b class="vimtag"> <a name="t_bool-variable">t_bool-variable</a> </b>
v:t_bool         <a href="eval.html#Boolean">Boolean</a>  的类型值。只读。见:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_channel">v:t_channel</a> </b> <b class="vimtag"> <a name="t_channel-variable">t_channel-variable</a> </b>
v:t_channel      <a href="eval.html#Channel">Channel</a>  的类型值。只读。见:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_dict">v:t_dict</a> </b> <b class="vimtag"> <a name="t_dict-variable">t_dict-variable</a> </b>
v:t_dict         <a href="eval.html#Dictionary">Dictionary</a>  的类型值。只读。见:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_float">v:t_float</a> </b> <b class="vimtag"> <a name="t_float-variable">t_float-variable</a> </b>
v:t_float        <a href="eval.html#Float">Float</a>  的类型值。只读。见:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_func">v:t_func</a> </b> <b class="vimtag"> <a name="t_func-variable">t_func-variable</a> </b>
v:t_func         <a href="eval.html#Funcref">Funcref</a>  的类型值。只读。见:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_job">v:t_job</a> </b> <b class="vimtag"> <a name="t_job-variable">t_job-variable</a> </b>
v:t_job          <a href="eval.html#Job">Job</a>  的类型值。只读。见:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_list">v:t_list</a> </b> <b class="vimtag"> <a name="t_list-variable">t_list-variable</a> </b>
v:t_list         <a href="eval.html#List">List</a>  的类型值。只读。见:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_none">v:t_none</a> </b> <b class="vimtag"> <a name="t_none-variable">t_none-variable</a> </b>
v:t_none         <a href="eval.html#None">None</a>  的类型值。只读。见:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_number">v:t_number</a> </b> <b class="vimtag"> <a name="t_number-variable">t_number-variable</a> </b>
v:t_number       <a href="eval.html#Number">Number</a>  的类型值。只读。见:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_string">v:t_string</a> </b> <b class="vimtag"> <a name="t_string-variable">t_string-variable</a> </b>
v:t_string       <a href="eval.html#String">String</a>  的类型值。只读。见:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_blob">v:t_blob</a> </b> <b class="vimtag"> <a name="t_blob-variable">t_blob-variable</a> </b>
v:t_blob         <a href="eval.html#Blob">Blob</a>  的类型值。只读。见:  <a href="eval.html#type()">type()</a> 

                                <b class="vimtag"> <a name="v:termresponse">v:termresponse</a> </b> <b class="vimtag"> <a name="termresponse-variable">termresponse-variable</a> </b>
v:termresponse  使用  <a href="term.html#t_RV">t_RV</a>  termcap 项目返回的终端的转义序列。Vim 收到 ESC [
                或者 CSI 开始，然后是 '&gt;' 或 '?'，并以一个 'c' 结束，并且其间
                只包含数字和 ';' 的转义序列的时候，会设置该值。
                如果设置该选项，会激活 TermResponse 自动命令事件，这样你就可以
                对终端的应答做出反应。
                新的 xterm 的应答是: "<code class="special">&lt;Esc&gt;</code>[&gt; Pp ; Pv ; Pc c"。 Pp 是终端类型:
                0 代表 vt100，而 1 代表 vt220。 Pv 是补丁号 (因为这是 patch 95
                引入的，补丁号应该总是 95 会更高)。Pc 总是零。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+termresponse">+termresponse</a>  特性才有效}</code>

                                                <b class="vimtag"> <a name="v:termblinkresp">v:termblinkresp</a> </b>
v:termblinkresp 终端用于  <a href="term.html#t_RC">t_RC</a>  termcap 项目的转义序列。用于找出终端光标是否闪
                烁。用于  <a href="terminal.html#term_getcursor()">term_getcursor()</a> 。

                                                <b class="vimtag"> <a name="v:termstyleresp">v:termstyleresp</a> </b>
v:termstyleresp 终端用于  <a href="term.html#t_RS">t_RS</a>  termcap 项目的转义序列。用于找出终端光标的形
                状。用于  <a href="terminal.html#term_getcursor()">term_getcursor()</a> 。

                                                <b class="vimtag"> <a name="v:termrbgresp">v:termrbgresp</a> </b>
v:termrbgresp   终端用于  <a href="term.html#t_RB">t_RB</a>  termcap 项目的转义序列。用于找出终端的背景色，
                见 <a href="options.html#'background'">'background'</a>。

                                                <b class="vimtag"> <a name="v:termrfgresp">v:termrfgresp</a> </b>
v:termrfgresp   终端用于  <a href="term.html#t_RF">t_RF</a>  termcap 项目的转义序列。用于找出终端的前景色。

                                                <b class="vimtag"> <a name="v:termu7resp">v:termu7resp</a> </b>
v:termu7resp    终端用于  <a href="term.html#t_u7">t_u7</a>  termcap 项目的转义序列。用于找出终端如何处理二
                义性宽度字符，见 <a href="options.html#'ambiwidth'">'ambiwidth'</a>。

                                        <b class="vimtag"> <a name="v:testing">v:testing</a> </b> <b class="vimtag"> <a name="testing-variable">testing-variable</a> </b>
v:testing       必须在  <a href="testing.html#test_garbagecollect_now()">test_garbagecollect_now()</a>  之前设置。
                另外，设置时，在 2 秒内不会显示特定的错误信息 (例如
                "<a href="options.html#'dictionary'">'dictionary'</a> option is empty")

                                <b class="vimtag"> <a name="v:this_session">v:this_session</a> </b> <b class="vimtag"> <a name="this_session-variable">this_session-variable</a> </b>
v:this_session  最近载入或者保存的会话文件的文件名  <a href="starting.html#:mksession">:mksession</a> 。可以设置该变
                量。如果没有保存过会话文件，该变量为空。
                为了后向兼容，这里也可以用 "this_session"，除非
                 <a href="eval.html#scriptversion">scriptversion</a>  为 3 或更高。

                                        <b class="vimtag"> <a name="v:throwpoint">v:throwpoint</a> </b> <b class="vimtag"> <a name="throwpoint-variable">throwpoint-variable</a> </b>
v:throwpoint    最近捕获且未完成的例外的抛出位置。输入的命令不会设置此变量。另
                见  <a href="eval.html#v:exception">v:exception</a>  和  <a href="eval.html#throw-variables">throw-variables</a> 。
                例如: 
<code class="example">        :try</code>
<code class="example">        :  throw "oops"</code>
<code class="example">        :catch /.*/</code>
<code class="example">        :  echo "Exception from" v:throwpoint</code>
<code class="example">        :endtry</code>
                输出: "Exception from test.vim, line 2"

                                        <b class="vimtag"> <a name="v:true">v:true</a> </b> <b class="vimtag"> <a name="true-variable">true-variable</a> </b>
v:true          取值为一的数值。用于在 JSON 里填入 "true"。见
                 <a href="eval.html#json_encode()">json_encode()</a> 。
                用于字符串时会返回 "v:true"。 
<code class="example">                        echo v:true</code>
<code class="section">                        v:true </code>
                这样 eval() 可以把该字符串解析回相同的值。只读。

                                                <b class="vimtag"> <a name="v:val">v:val</a> </b> <b class="vimtag"> <a name="val-variable">val-variable</a> </b>
v:val            <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  当前项目的值。只有在计算  <a href="eval.html#map()">map()</a>  和
                 <a href="eval.html#filter()">filter()</a>  里的表达式时才有效。只读。

                                        <b class="vimtag"> <a name="v:version">v:version</a> </b> <b class="vimtag"> <a name="version-variable">version-variable</a> </b>
v:version       Vim 的版本号: 主版本号乘以 100 加上副版本号。5.0 版本对应的是
                500。5.1 版本则是 501。只读。为了后向兼容，这里也可以用
                "version"，除非  <a href="eval.html#scriptversion">scriptversion</a>  为 3 或者更高。
                用  <a href="eval.html#has()">has()</a>  可以检查是否包含某补丁，例如: 
<code class="example">                        if has("patch-7.4.123")</code>
                <code class="note">注意</code> 补丁号和版本有关，5.0 和 5.1 版本都有补丁号 123，但完全不
                同。

                                        <b class="vimtag"> <a name="v:versionlong">v:versionlong</a> </b> <b class="vimtag"> <a name="versionlong-variable">versionlong-variable</a> </b>
v:versionlong   类似于 v:version，但末四位数字包含补丁号。8.1 版本带补丁 123
                的值是 8010123。可以这样用: 
<code class="example">                        if v:versionlong &gt;= 8010123</code>
                不过，如果包含的补丁列表有空档这样不太完美。比如为了安全原因，
                有时旧的版本会打上新近的补丁。用 has() 函数可以确定是否包含某
                补丁。

                                <b class="vimtag"> <a name="v:vim_did_enter">v:vim_did_enter</a> </b> <b class="vimtag"> <a name="vim_did_enter-variable">vim_did_enter-variable</a> </b>
v:vim_did_enter 直到绝大部分的初始化工作做完之前保持为零。在  <a href="autocmd.html#VimEnter">VimEnter</a>  自动命
                令刚刚激活之前，设为一。

                                        <b class="vimtag"> <a name="v:warningmsg">v:warningmsg</a> </b> <b class="vimtag"> <a name="warningmsg-variable">warningmsg-variable</a> </b>
v:warningmsg    最近给出的警告消息。该变量可以设置。

                                        <b class="vimtag"> <a name="v:windowid">v:windowid</a> </b> <b class="vimtag"> <a name="windowid-variable">windowid-variable</a> </b>
v:windowid      运行基于 X11 的任何 GUI，或者在终端运行且 Vim 连接到 X 服务器
                ( <a href="starting.html#-X">-X</a> ) 时，给出窗口号。
                运行 MS-Windows GUI 时，给出窗口的句柄。
                否则该值为零。
                <code class="note">注意</code>: Vim 内部的窗口请用  <a href="eval.html#winnr()">winnr()</a>  或  <a href="eval.html#win_getid()">win_getid()</a> ，见
                 <a href="windows.html#window-ID">window-ID</a> 。

</section><hr class="doubleline" /><section class=inner>
<h4>4. 内建函数                                             <b class="vimtag"> <a name="functions">functions</a> </b></h4>
 <a href="usr_41.html#function-list">function-list</a>  提供了按功能分组的一个函数列表。

(在函数名上使用 <code class="keystroke">CTRL-]</code> 跳转到完整的功能说明。)

<code class="section">用法                            结果    描述    </code>

abs(<code class="special">{expr}</code>)                     浮点或数值  <code class="special">{expr}</code> 的绝对值
acos(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的反余弦值
add(<code class="special">{object}</code>, <code class="special">{item}</code>)           列表或 blob   在 <code class="special">{object}</code> 最后附加 <code class="special">{item}</code>
and(<code class="special">{expr}</code>, <code class="special">{expr}</code>)             数值    按位与
append(<code class="special">{lnum}</code>, <code class="special">{text}</code>)          数值    在第 <code class="special">{lnum}</code> 行下附加 <code class="special">{text}</code>
appendbufline(<code class="special">{expr}</code>, <code class="special">{lnum}</code>, <code class="special">{text}</code>)
                                数值    在缓冲区 <code class="special">{expr}</code> 第 <code class="special">{lnum}</code> 行下附加
                                        <code class="special">{text}</code>
argc([<code class="special">{winid}</code>])                 数值    参数列表的文件数目
argidx()                        数值    参数列表的当前索引
arglistid([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]]) 数值   参数列表的 id
argv(<code class="special">{nr}</code> [, <code class="special">{winid}</code>])          字符串  参数列表第 <code class="special">{nr}</code> 个参数
argv([-1, <code class="special">{winid}</code>])             列表    参数列表
assert_beeps(<code class="special">{cmd}</code>)             数值    断言 <code class="special">{cmd}</code> 产生铃声
assert_equal(<code class="special">{exp}</code>, <code class="special">{act}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{exp}</code> 等于 <code class="special">{act}</code>
assert_exception(<code class="special">{error}</code> [, <code class="special">{msg}</code>])
                                数值    断言 v:exception 中有 <code class="special">{error}</code>
assert_fails(<code class="special">{cmd}</code> [, <code class="special">{error}</code> [, <code class="special">{msg}</code>]])
                                数值    断言 <code class="special">{cmd}</code> 失败
assert_false(<code class="special">{actual}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{actual}</code> 为假
assert_inrange(<code class="special">{lower}</code>, <code class="special">{upper}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{actual}</code> 在指定范围内
assert_match(<code class="special">{pat}</code>, <code class="special">{text}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{pat}</code> 匹配 <code class="special">{text}</code>
assert_notequal(<code class="special">{exp}</code>, <code class="special">{act}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{exp}</code> 不等于 <code class="special">{act}</code>
assert_notmatch(<code class="special">{pat}</code>, <code class="special">{text}</code> [, <code class="special">{msg}</code>])
                                数值    断言 <code class="special">{pat}</code> 不匹配 <code class="special">{text}</code>
assert_report(<code class="special">{msg}</code>)            数值    报告一个测试失败
assert_true(<code class="special">{actual}</code> [, <code class="special">{msg}</code>]) 数值    断言 <code class="special">{actual}</code> 为真
asin(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的反正弦值
atan(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的反正切值
atan2(`<code class="special">{expr}</code>, <code class="special">{expr}</code>)          浮点    <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的反正切值
balloon_gettext()               字符串  气泡的当前文本
balloon_show(<code class="special">{expr}</code>)            空      在气泡内显示<code class="special">{expr}</code>
balloon_split(<code class="special">{msg}</code>)            列表    分割用于的 <code class="special">{msg}</code>
browse(<code class="special">{save}</code>, <code class="special">{title}</code>, <code class="special">{initdir}</code>, <code class="special">{default}</code>)
                                字符串  启动文件请求窗口
browsedir(<code class="special">{title}</code>, <code class="special">{initdir}</code>)   字符串  启动目录请求窗口
bufadd(<code class="special">{name}</code>)                  数值    在缓冲区列表里加入缓冲区
bufexists(<code class="special">{expr}</code>)               数值    如果缓冲区 <code class="special">{expr}</code> 存在则为  <a href="eval.html#TRUE">TRUE</a> 
buflisted(<code class="special">{expr}</code>)               数值    如果缓冲区 <code class="special">{expr}</code> 在列表内则为  <a href="eval.html#TRUE">TRUE</a> 
bufload(<code class="special">{expr}</code>)                 数值    如果还未载入，载入缓冲区 <code class="special">{expr}</code>
bufloaded(<code class="special">{expr}</code>)               数值    如果缓冲区 <code class="special">{expr}</code> 被载入则为  <a href="eval.html#TRUE">TRUE</a> 
bufname([<code class="special">{expr}</code>])               字符串  缓冲区 <code class="special">{expr}</code> 的名字
bufnr([<code class="special">{expr}</code> [, <code class="special">{create}</code>]])    数值    缓冲区 <code class="special">{expr}</code> 的编号
bufwinid(<code class="special">{expr}</code>)                数值    缓冲区 <code class="special">{expr}</code> 的窗口 ID
bufwinnr(<code class="special">{expr}</code>)                数值    缓冲区 <code class="special">{expr}</code> 的窗口号
byte2line(<code class="special">{byte}</code>)               数值    第 <code class="special">{byte}</code> 个字节所在的行号
byteidx(<code class="special">{expr}</code>, <code class="special">{nr}</code>)           数值    <code class="special">{expr}</code> 里第 <code class="special">{nr}</code> 个字符的字节位置
byteidxcomp(<code class="special">{expr}</code>, <code class="special">{nr}</code>)       数值    <code class="special">{expr}</code> 里第 <code class="special">{nr}</code> 个字符的字节位置
call(<code class="special">{func}</code>, <code class="special">{arglist}</code> [, <code class="special">{dict}</code>])
                                可变    调用函数 <code class="special">{func}</code>，使用参数 <code class="special">{arglist}</code>
ceil(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 向上取整
ch_canread(<code class="special">{handle}</code>)            数值    检查是否有可读的内容
ch_close(<code class="special">{handle}</code>)              空      关闭 <code class="special">{handle}</code>
ch_close_in(<code class="special">{handle}</code>)           空      关闭 <code class="special">{handle}</code> 的 in 部分
ch_evalexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])
                                可变    在 JSON <code class="special">{handle}</code> 上执行 <code class="special">{expr}</code>
ch_evalraw(<code class="special">{handle}</code>, <code class="special">{string}</code> [, <code class="special">{options}</code>])
                                可变    在原始 <code class="special">{handle}</code> 上执行 <code class="special">{string}</code>
ch_getbufnr(<code class="special">{handle}</code>, <code class="special">{what}</code>)   数值    获得 <code class="special">{handle}</code>/<code class="special">{what}</code> 的缓冲区号
ch_getjob(<code class="special">{channel}</code>)            作业    获得 <code class="special">{channel}</code> 的相关作业
ch_info(<code class="special">{handle}</code>)               字符串  有关通道 <code class="special">{handle}</code> 的信息
ch_log(<code class="special">{msg}</code> [, <code class="special">{handle}</code>])      空      在通道日志文件中写入 <code class="special">{msg}</code>
ch_logfile(<code class="special">{fname}</code> [, <code class="special">{mode}</code>])  空      开始记录通道活动
ch_open(<code class="special">{address}</code> [, <code class="special">{options}</code>])
                                通道    打开到 <code class="special">{address}</code> 的通道
ch_read(<code class="special">{handle}</code> [, <code class="special">{options}</code>]) 字符串  从 <code class="special">{handle}</code> 读取
ch_readblob(<code class="special">{handle}</code> [, <code class="special">{options}</code>])
                                blob    从 <code class="special">{handle}</code> 读取 blob
ch_readraw(<code class="special">{handle}</code> [, <code class="special">{options}</code>])
                                字符串  从 <code class="special">{handle}</code> 读取原始格式
ch_sendexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])
                                可变    在 JSON <code class="special">{handle}</code> 上发送 <code class="special">{expr}</code>
ch_sendraw(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])
                                可变    在原始 <code class="special">{handle}</code> 上发送 <code class="special">{expr}</code>
ch_setoptions(<code class="special">{handle}</code>, <code class="special">{options}</code>)
                                空      设置 <code class="special">{handle}</code> 的选项
ch_status(<code class="special">{handle}</code> [, <code class="special">{options}</code>])
                                字符串  通道 <code class="special">{handle}</code> 的状态
changenr()                      数值    当前改变号
char2nr(<code class="special">{expr}</code> [, <code class="special">{utf8}</code>])      数值    <code class="special">{expr}</code> 里第一个字符串的 ASCII/UTF8 值
chdir(<code class="special">{dir}</code>)                    数值    改变当前目录
cindent(<code class="special">{lnum}</code>)                 数值    第 <code class="special">{lnum}</code> 行的 C 缩进
clearmatches([<code class="special">{win}</code>])           无      清除所有的匹配
col(<code class="special">{expr}</code>)                     数值    光标或位置标记的列号
complete(<code class="special">{startcol}</code>, <code class="special">{matches}</code>) 无      设置插入模式补全
complete_add(<code class="special">{expr}</code>)            数值    增加补全匹配
complete_check()                数值    补全时检查输入的键
complete_info([<code class="special">{what}</code>])         字典    获得当前补全信息
confirm(<code class="special">{msg}</code> [, <code class="special">{choices}</code> [, <code class="special">{default}</code> [, <code class="special">{type}</code>]]])
                                数值    用户选择的序号
copy(<code class="special">{expr}</code>)                    可变    提供 <code class="special">{expr}</code> 的浅备份
cos(<code class="special">{expr}</code>)                     浮点    <code class="special">{expr}</code> 的余弦值
cosh(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的双曲余弦值
count(<code class="special">{comp}</code>, <code class="special">{expr}</code> [, <code class="special">{ic}</code> [, <code class="special">{start}</code>]])
                                数值    计算 <code class="special">{comp}</code> 里有多少个 <code class="special">{expr}</code>
cscope_connection([<code class="special">{num}</code> , <code class="special">{dbpath}</code> [, <code class="special">{prepend}</code>]])
                                数值    检查 cscope 连接是否存在
cursor(<code class="special">{lnum}</code>, <code class="special">{col}</code> [, <code class="special">{off}</code>])
                                数值    移动光标到 <code class="special">{lnum}</code>，<code class="special">{col}</code>，<code class="special">{off}</code>
debugbreak(<code class="special">{pid}</code>)               数值    中断待调试的进程
cursor(<code class="special">{list}</code>)                  数值    移动光标到 <code class="special">{list}</code> 里的位置
deepcopy(<code class="special">{expr}</code> [, <code class="special">{noref}</code>])    可变    提供 <code class="special">{expr}</code> 的完整备份
delete(<code class="special">{fname}</code> [, <code class="special">{flags}</code>])     数值    删除文件或目录 <code class="special">{fname}</code>
deletebufline(<code class="special">{expr}</code>, <code class="special">{first}</code> [, <code class="special">{last}</code>])
                                数值    删除缓冲区 <code class="special">{expr}</code> 的多行
did_filetype()                  数值    用过 FileType 自动命令事件则为  <a href="eval.html#TRUE">TRUE</a> 
diff_filler(<code class="special">{lnum}</code>)             数值    <code class="special">{lnum}</code> 行之上的 diff 填充行数
diff_hlID(<code class="special">{lnum}</code>, <code class="special">{col}</code>)        数值    <code class="special">{lnum}</code>/<code class="special">{col}</code> 位置的 diff 高亮
empty(<code class="special">{expr}</code>)                   数值    如果 <code class="special">{expr}</code> 为空则为  <a href="eval.html#TRUE">TRUE</a> 
environ()                       字典    返回所有环境变量
escape(<code class="special">{string}</code>, <code class="special">{chars}</code>)       字符串  在 <code class="special">{string}</code> 里用 '\' 转义 <code class="special">{chars}</code>
eval(<code class="special">{string}</code>)                  可变    计算 <code class="special">{string}</code>，返回结果
eventhandler()                  数值    如果在事件处理中则为  <a href="eval.html#TRUE">TRUE</a> 
executable(<code class="special">{expr}</code>)              数值    如果可执行文件 <code class="special">{expr}</code> 存在则为 1
execute(<code class="special">{command}</code>)              字符串  执行 <code class="special">{command}</code> 并取得输出结果
exepath(<code class="special">{expr}</code>)                 字符串  命令 <code class="special">{expr}</code> 的完整路径
exists(<code class="special">{expr}</code>)                  数值    如果 <code class="special">{expr}</code> 存在则为  <a href="eval.html#TRUE">TRUE</a> 
extend(<code class="special">{expr1}</code>, <code class="special">{expr2}</code> [, <code class="special">{expr3}</code>])
                                列表/字典 把 <code class="special">{expr2}</code> 里的项目插入 <code class="special">{expr1}</code>
exp(<code class="special">{expr}</code>)                     浮点    <code class="special">{expr}</code> 的指数函数值
                                        (<code class="vim">译者注</code>: 以 e 为底)
expand(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code>]])
                                可变    扩展 <code class="special">{expr}</code> 里的特殊关键字
expandcmd(<code class="special">{expr}</code>)               字符串  像  <a href="editing.html#:edit">:edit</a>  那样扩展 <code class="special">{expr}</code>
feedkeys(<code class="special">{string}</code> [, <code class="special">{mode}</code>])   数值    给预输入缓冲区加入键序列
filereadable(<code class="special">{file}</code>)            数值    如果 <code class="special">{file}</code> 是个可读文件则为  <a href="eval.html#TRUE">TRUE</a> 
filewritable(<code class="special">{file}</code>)            数值    如果 <code class="special">{file}</code> 是个可写文件则为  <a href="eval.html#TRUE">TRUE</a> 
filter(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)        列表/字典 删除 <code class="special">{expr1}</code> 里 <code class="special">{expr2}</code> 为 0 的项目
finddir(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{count}</code>]])
                                字符串  在 <code class="special">{path}</code> 里寻找目录 <code class="special">{name}</code>
findfile(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{count}</code>]])
                                字符串  在 <code class="special">{path}</code> 里寻找文件 <code class="special">{name}</code>
float2nr(<code class="special">{expr}</code>)                数值    转换浮点数 <code class="special">{expr}</code> 为数值
floor(<code class="special">{expr}</code>)                   浮点    <code class="special">{expr}</code> 向下取整
fmod(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)          浮点    <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的浮点余数
fnameescape(<code class="special">{fname}</code>)            字符串  转义 <code class="special">{fname}</code> 中的特殊字符
fnamemodify(<code class="special">{fname}</code>, <code class="special">{mods}</code>)    字符串  修改文件名
foldclosed(<code class="special">{lnum}</code>)              数值    <code class="special">{lnum}</code> 所在折叠的首行，如果是关闭的话
foldclosedend(<code class="special">{lnum}</code>)           数值    <code class="special">{lnum}</code> 所在折叠的末行，如果是关闭的话
foldlevel(<code class="special">{lnum}</code>)               数值    <code class="special">{lnum}</code> 的折叠级别
foldtext()                      字符串  关闭的折叠显示的行
foldtextresult(<code class="special">{lnum}</code>)          字符串  <code class="special">{lnum}</code> 所在的关闭的折叠的文本
foreground()                    数值    把 Vim 窗口带到前台
funcref(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
                                函数引用  函数 <code class="special">{name}</code> 的引用
function(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
                                函数引用  函数 <code class="special">{name}</code> 的命名引用
garbagecollect([<code class="special">{atexit}</code>])      无      释放内存，打破循环引用
get(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{def}</code>])    可变    得到 <code class="special">{list}</code> 或 <code class="special">{def}</code> 的项目 <code class="special">{idx}</code>
get(<code class="special">{dict}</code>, <code class="special">{key}</code> [, <code class="special">{def}</code>])    可变    得到 <code class="special">{dict}</code> 或 <code class="special">{def}</code> 的项目 <code class="special">{idx}</code>
get(<code class="special">{func}</code>, <code class="special">{what}</code>)             可变    得到函数引用/偏函数 <code class="special">{func}</code> 的属性
getbufinfo([<code class="special">{expr}</code>])            列表    缓冲区信息
getbufline(<code class="special">{expr}</code>, <code class="special">{lnum}</code> [, <code class="special">{end}</code>])
                                列表    缓冲区 <code class="special">{expr}</code> 第 <code class="special">{lnum}</code> 到 <code class="special">{end}</code> 行
getbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
                                可变    缓冲区 <code class="special">{expr}</code> 的变量 <code class="special">{varname}</code>
getchangelist([<code class="special">{expr}</code>])         列表    改变列表项目的列表
getchar([expr])                 数值    让用户输入一个字符
getcharmod()                    数值    最近输入字符的修饰符
getcharsearch()                 字典    最近字符搜索选项
getcmdline()                    字符串  返回当前命令行
getcmdpos()                     数值    返回命令行的光标位置
getcmdtype()                    字符串  返回当前命令行类型
getcmdwintype()                 字符串  返回当前命令行窗口类型
getcompletion(<code class="special">{pat}</code>, <code class="special">{type}</code> [, <code class="special">{filtered}</code>])
                                列表    命令行补全匹配列表
getcurpos()                     列表    光标位置
getcwd([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])   字符串  当前工作目录
getenv(<code class="special">{name}</code>)                  字符串  返回环境变量
getfontname([<code class="special">{name}</code>])           字符串  使用的字体名
getfperm(<code class="special">{fname}</code>)               字符串  文件 <code class="special">{fname}</code> 的文件权限
getfsize(<code class="special">{fname}</code>)               数值    字节计算的文件 <code class="special">{fname}</code> 大小
getftime(<code class="special">{fname}</code>)               数值    文件的最新修改时间
getftype(<code class="special">{fname}</code>)               字符串  文件 <code class="special">{fname}</code> 类型的描述
getimstatus()                   数值    如果 IME 处于激活状态则为  <a href="eval.html#TRUE">TRUE</a> 
getjumplist([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
                                列表    跳转列表项目的列表
getline(<code class="special">{lnum}</code>)                 字符串  当前缓冲区的第 <code class="special">{lnum}</code> 行
getline(<code class="special">{lnum}</code>, <code class="special">{end}</code>)          列表    当前缓冲区第 <code class="special">{lnum}</code> 到 <code class="special">{end}</code> 行
getloclist(<code class="special">{nr}</code> [, <code class="special">{what}</code>])     列表    位置列表项目的列表
getmatches([<code class="special">{win}</code>])             列表    当前匹配的列表
getmousepos()                   字典    最近已知的鼠标位置
getpid()                        数值    Vim 的进程号
getpos(<code class="special">{expr}</code>)                  列表    光标、位置标记等的位置
getqflist([<code class="special">{what}</code>])             列表    quickfix 项目的列表
getreg([<code class="special">{regname}</code> [, 1 [, <code class="special">{list}</code>]]])
                                字符串/列表     寄存器内容
getregtype([<code class="special">{regname}</code>])         字符串  寄存器类型
gettabinfo([<code class="special">{expr}</code>])            列表    标签页列表
gettabvar(<code class="special">{nr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
                                可变    <code class="special">{tabnr}</code> 标签页的 <code class="special">{varname}</code> 变量
gettabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{name}</code> [, <code class="special">{def}</code>])
                                可变    <code class="special">{tabnr}</code> 标签页 <code class="special">{winnr}</code> 窗口的 <code class="special">{name}</code>
gettagstack([<code class="special">{nr}</code>])             字典    获取窗口 <code class="special">{nr}</code> 的标签栈
getwininfo([<code class="special">{winid}</code>])           列表    每个窗口信息的列表
getwinpos([<code class="special">{timeout}</code>])          列表    Vim 窗口以像素计的 X 和 Y 坐标
getwinposx()                    数值    Vim 窗口以像素计的 X 坐标
getwinposy()                    数值    Vim 窗口以像素计的 Y 坐标
getwinvar(<code class="special">{nr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
                                可变    窗口 <code class="special">{expr}</code> 的变量 <code class="special">{varname}</code>
glob(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
                                可变    扩展 <code class="special">{expr}</code> 里的文件通配符
glob2regpat(<code class="special">{expr}</code>)             字符串  转化 glob 模式为搜索模式
globpath(<code class="special">{path}</code>, <code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
                                字符串  在 <code class="special">{path}</code> 所有目录下执行 glob(<code class="special">{expr}</code>)
has(<code class="special">{feature}</code>)                  数值    如果支持特性 <code class="special">{feature}</code> 则为  <a href="eval.html#TRUE">TRUE</a> 
has_key(<code class="special">{dict}</code>, <code class="special">{key}</code>)          数值    如果 <code class="special">{dict}</code> 有项目 <code class="special">{key}</code> 则为  <a href="eval.html#TRUE">TRUE</a> 
haslocaldir([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
                                数值    如果当前窗口执行过  <a href="editing.html#:lcd">:lcd</a>  则为  <a href="eval.html#TRUE">TRUE</a> 
hasmapto(<code class="special">{what}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])
                                数值    如果 <code class="special">{what}</code> 的映射存在则为  <a href="eval.html#TRUE">TRUE</a> 
histadd(<code class="special">{history}</code>,<code class="special">{item}</code>)       字符串  在历史里增加项目
histdel(<code class="special">{history}</code> [, <code class="special">{item}</code>])   字符串  从历史里删除项目
histget(<code class="special">{history}</code> [, <code class="special">{index}</code>])  字符串  得到历史的第 <code class="special">{index}</code> 项
histnr(<code class="special">{history}</code>)               数值    历史里最高的项目号
hlexists(<code class="special">{name}</code>)                数值    如果高亮组 <code class="special">{name}</code> 存在则为  <a href="eval.html#TRUE">TRUE</a> 
hlID(<code class="special">{name}</code>)                    数值    高亮组 <code class="special">{name}</code> 的语法 ID
hostname()                      字符串  Vim 运行的机器名字
iconv(<code class="special">{expr}</code>, <code class="special">{from}</code>, <code class="special">{to}</code>)     字符串  转换 <code class="special">{expr}</code> 的编码
indent(<code class="special">{lnum}</code>)                  数值    第 <code class="special">{lnum}</code> 行的缩进
index(<code class="special">{object}</code>, <code class="special">{expr}</code> [, <code class="special">{start}</code> [, <code class="special">{ic}</code>]])
                                数值    <code class="special">{object}</code> 里出现 <code class="special">{expr}</code> 的项目的索引
input(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{completion}</code>]])
                                字符串  从用户得到输入
inputdialog(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{completion}</code>]])
                                字符串  类似于 input()，但使用 GUI 对话框
inputlist(<code class="special">{textlist}</code>)           数值    让用户从选择列表里挑选
inputrestore()                  数值    恢复预输入
inputsave()                     数值    保存和清除预输入
inputsecret(<code class="special">{prompt}</code> [, <code class="special">{text}</code>]) 字符串  类似于 input()，但隐藏文本
insert(<code class="special">{object}</code>, <code class="special">{item}</code> [, <code class="special">{idx}</code>]) 列表 在 <code class="special">{object}</code> 里插入 <code class="special">{item}</code> [<code class="special">{idx}</code> 之前]
interrupt()                     无      中断脚本执行
invert(<code class="special">{expr}</code>)                  数值    按位取反
isdirectory(<code class="special">{directory}</code>)        数值    如果 <code class="special">{directory}</code> 是目录则为  <a href="eval.html#TRUE">TRUE</a> 
islocked(<code class="special">{expr}</code>)                数值    如果 <code class="special">{expr}</code> 被锁住则为  <a href="eval.html#TRUE">TRUE</a> 
isinf(<code class="special">{expr}</code>)                   数值    决定 <code class="special">{expr}</code> 是否为无限大 (正或负)
isnan(<code class="special">{expr}</code>)                   数值    如果 <code class="special">{expr}</code> 为 NaN 则为  <a href="eval.html#TRUE">TRUE</a> 
items(<code class="special">{dict}</code>)                   列表    <code class="special">{dict}</code> 里的键-值组对
job_getchannel(<code class="special">{job}</code>)           通道    获取 <code class="special">{job}</code> 的通道句柄
job_info([<code class="special">{job}</code>])               字典    获取 <code class="special">{job}</code> 的信息
job_setoptions(<code class="special">{job}</code>, <code class="special">{options}</code>) 无     设置 <code class="special">{job}</code> 选项
job_start(<code class="special">{command}</code> [, <code class="special">{options}</code>])
                                作业    启动作业
job_status(<code class="special">{job}</code>)               字符串  获取 <code class="special">{job}</code> 的状态
job_stop(<code class="special">{job}</code> [, <code class="special">{how}</code>])       数值    停止 <code class="special">{job}</code>
join(<code class="special">{list}</code> [, <code class="special">{sep}</code>])          字符串  连接 <code class="special">{list}</code> 的项目成为一个字符串
js_decode(<code class="special">{string}</code>)             可变    解码 JS 风格的 JSON
js_encode(<code class="special">{expr}</code>)               字符串  编码 JS 风格的 JSON
json_decode(<code class="special">{string}</code>)           可变    解码 JSON
json_encode(<code class="special">{expr}</code>)             字符串  编码 JSON
keys(<code class="special">{dict}</code>)                    列表    <code class="special">{dict}</code> 的所有键
len(<code class="special">{expr}</code>)                     数值    <code class="special">{expr}</code> 的长度
libcall(<code class="special">{lib}</code>, <code class="special">{func}</code>, <code class="special">{arg}</code>)   字符串  调用库 <code class="special">{lib}</code> 的函数 <code class="special">{func}</code>，使用参数
                                        <code class="special">{arg}</code>
libcallnr(<code class="special">{lib}</code>, <code class="special">{func}</code>, <code class="special">{arg}</code>) 数值    同上，但返回数值
line(<code class="special">{expr}</code> [, <code class="special">{winid}</code>])        数值    光标所在、末行或者位置标记所在的行号
line2byte(<code class="special">{lnum}</code>)               数值    行 <code class="special">{lnum}</code> 的字节位置
lispindent(<code class="special">{lnum}</code>)              数值    行 <code class="special">{lnum}</code> 的 Lisp 缩进
list2str(<code class="special">{list}</code> [, <code class="special">{utf8}</code>])     字符串  把 <code class="special">{list}</code> 中的数值转成字符串
listener_add(<code class="special">{callback}</code> [, <code class="special">{buf}</code>])
                                数值    add a callback to listen to changes
listener_flush([<code class="special">{buf}</code>])         无      激活监听器回调
listener_remove(<code class="special">{id}</code>)           无      删除监听器回调
localtime()                     数值    当前时间
log(<code class="special">{expr}</code>)                     浮点    <code class="special">{expr}</code> 的自然对数 (以 e 为底)
log10(<code class="special">{expr}</code>)                   浮点    <code class="special">{expr}</code> 以 10 为底的对数
luaeval(<code class="special">{expr}</code> [, <code class="special">{expr}</code>])      可变    执行  <a href="if_lua.html#Lua">Lua</a>  表达式
map(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)           列表/字典  <code class="special">{expr1}</code> 的每个项目改变为 <code class="special">{expr2}</code>
maparg(<code class="special">{name}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code> [, <code class="special">{dict}</code>]]])
                                字符串/字典
                                        模式 <code class="special">{mode}</code> 的映射 <code class="special">{name}</code> 的右手边
mapcheck(<code class="special">{name}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])
                                字符串  检查匹配 <code class="special">{name}</code> 的映射
match(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])
                                数值    <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 的匹配位置
matchadd(<code class="special">{group}</code>, <code class="special">{pattern}</code> [, <code class="special">{priority}</code> [, <code class="special">{id}</code> [, <code class="special">{dict}</code>]]])
                                数值    用 <code class="special">{group}</code> 高亮 <code class="special">{pattern}</code>
matchaddpos(<code class="special">{group}</code>, <code class="special">{pos}</code> [, <code class="special">{priority}</code> [, <code class="special">{id}</code> [, <code class="special">{dict}</code>]]])
                                数值    <code class="special">{group}</code> 的高亮位置
matcharg(<code class="special">{nr}</code>)                  列表     <a href="pattern.html#:match">:match</a>  的参数
matchdelete(<code class="special">{id}</code> [, <code class="special">{win}</code>])     数值    删除 <code class="special">{id}</code> 指定的匹配
matchend(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])
                                数值    <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 的结束位置
matchlist(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])
                                列表    <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 的匹配和子匹配
matchstr(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])
                                字符串  <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 的第 <code class="special">{count}</code> 个匹配文
                                        本
matchstrpos(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])
                                列表    <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 的第 <code class="special">{count}</code> 个匹配
max(<code class="special">{expr}</code>)                     数值    <code class="special">{expr}</code> 的项目的最大值
min(<code class="special">{expr}</code>)                     数值    <code class="special">{expr}</code> 的项目的最小值
mkdir(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{prot}</code>]])
                                数值    建立目录 <code class="special">{name}</code>
mode([expr])                    字符串  当前编辑模式
mzeval(<code class="special">{expr}</code>)                  可变    计算  <a href="if_mzsch.html#MzScheme">MzScheme</a>  表达式
nextnonblank(<code class="special">{lnum}</code>)            数值    第一个 &gt;= <code class="special">{lnum}</code> 的非空白行的行号
nr2char(<code class="special">{expr}</code> [, <code class="special">{utf8}</code>])      字符串  ASCII/UTF8 值为 <code class="special">{expr}</code> 的单个字符
or(<code class="special">{expr}</code>, <code class="special">{expr}</code>)              数值    按位或
pathshorten(<code class="special">{expr}</code>)             字符串  缩短路径里的目录名
perleval(<code class="special">{expr}</code>)                可变    计算  <a href="if_perl.html#Perl">Perl</a>  表达式
popup_atcursor(<code class="special">{what}</code>, <code class="special">{options}</code>) 数值  在光标附近创建弹出窗口
popup_beval(<code class="special">{what}</code>, <code class="special">{options}</code>)  数值    为 <a href="options.html#'ballooneval'">'ballooneval'</a> 创建弹出窗口
popup_clear()                   无      关闭所有弹出窗口
popup_close(<code class="special">{id}</code> [, <code class="special">{result}</code>])  无      关闭弹出窗口 <code class="special">{id}</code>
popup_create(<code class="special">{what}</code>, <code class="special">{options}</code>) 数值    创建弹出窗口
popup_dialog(<code class="special">{what}</code>, <code class="special">{options}</code>) 数值    创建弹出窗口用作对话框
popup_filter_menu(<code class="special">{id}</code>, <code class="special">{key}</code>)  数值    菜单弹出窗口的过滤
popup_filter_yesno(<code class="special">{id}</code>, <code class="special">{key}</code>) 数值    对话框弹出窗口的过滤
popup_findinfo()                数值    获取信息弹出窗口的窗口 ID
popup_findpreview()             数值    获取预览弹出窗口的窗口 ID
popup_getoptions(<code class="special">{id}</code>)          字典    获取弹出窗口 <code class="special">{id}</code> 的选项
popup_getpos(<code class="special">{id}</code>)              字典    获取弹出窗口 <code class="special">{id}</code> 的位置
popup_hide(<code class="special">{id}</code>)                无      隐藏弹出窗口 <code class="special">{id}</code>
popup_menu(<code class="special">{what}</code>, <code class="special">{options}</code>)   数值    创建弹出窗口用作菜单
popup_move(<code class="special">{id}</code>, <code class="special">{options}</code>)     无      设置弹出窗口 <code class="special">{id}</code> 的位置
popup_notification(<code class="special">{what}</code>, <code class="special">{options}</code>)
                                数值    创建通知弹出窗口
popup_show(<code class="special">{id}</code>)                无      撤销弹出窗口 <code class="special">{id}</code> 的隐藏
popup_setoptions(<code class="special">{id}</code>, <code class="special">{options}</code>)
                                无      设置弹出窗口 <code class="special">{id}</code> 的选项
popup_settext(<code class="special">{id}</code>, <code class="special">{text}</code>)     无      设置弹出窗口 <code class="special">{id}</code> 的文本
pow(<code class="special">{x}</code>, <code class="special">{y}</code>)                   浮点    <code class="special">{x}</code> 的 <code class="special">{y}</code> 次方
prevnonblank(<code class="special">{lnum}</code>)            数值    最后一个 &lt;= <code class="special">{lnum}</code> 的非空白行的行号
printf(<code class="special">{fmt}</code>, <code class="special">{expr1}</code>...)       字符串  排版文本
prompt_setcallback(<code class="special">{buf}</code>, <code class="special">{expr}</code>) 无    设置提示回调函数
prompt_setinterrupt(<code class="special">{buf}</code>, <code class="special">{text}</code>) 无   设置提示中断函数
prompt_setprompt(<code class="special">{buf}</code>, <code class="special">{text}</code>) 无      设置提示文本
prop_add(<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{props}</code>)  无    新增文本属性
prop_clear(<code class="special">{lnum}</code> [, <code class="special">{lnum-end}</code> [, <code class="special">{props}</code>]])
                                无      删除所有文本属性
prop_find(<code class="special">{props}</code> [, <code class="special">{direction}</code>])
                                字典    查找文本属性
prop_list(<code class="special">{lnum}</code> [, <code class="special">{props}</code>)    列表    <code class="special">{lnum}</code> 的文本属性
prop_remove(<code class="special">{props}</code> [, <code class="special">{lnum}</code> [, <code class="special">{lnum-end}</code>]])
                                数值    删除一个文本属性
prop_type_add(<code class="special">{name}</code>, <code class="special">{props}</code>)  无      定义新的文本属性类型
prop_type_change(<code class="special">{name}</code>, <code class="special">{props}</code>)
                                无      改变已有的文本属性类型
prop_type_delete(<code class="special">{name}</code> [, <code class="special">{props}</code>])
                                无      删除文本属性类型
prop_type_get([<code class="special">{name}</code> [, <code class="special">{props}</code>])
                                字典    获取文本属性类型的值
prop_type_list([<code class="special">{props}</code>])       列表    获取文本属性类型的列表
pum_getpos()                    字典    如果可见，pum 的位置和大小
pumvisible()                    数值    弹出窗口是否可见
pyeval(<code class="special">{expr}</code>)                  可变    计算  <a href="if_pyth.html#Python">Python</a>  表达式
py3eval(<code class="special">{expr}</code>)                 可变    计算  <a href="if_pyth.html#python3">python3</a>  表达式
pyxeval(<code class="special">{expr}</code>)                 可变    计算  <a href="if_pyth.html#python_x">python_x</a>  表达式
rand([<code class="special">{expr}</code>])                  数值    得到伪随机数
range(<code class="special">{expr}</code> [, <code class="special">{max}</code> [, <code class="special">{stride}</code>]])
                                列表    从 <code class="special">{expr}</code> 到 <code class="special">{max}</code> 的序列
readdir(<code class="special">{dir}</code> [, <code class="special">{expr}</code>])       列表    <code class="special">{dir}</code> 中 <code class="special">{expr}</code> 所选择的文件名
readfile(<code class="special">{fname}</code> [, <code class="special">{type}</code> [, <code class="special">{max}</code>]])
                                列表    得到文件 <code class="special">{fname}</code> 的行列表
reg_executing()                 字符串  得到执行中的寄存器名
reg_recording()                 字符串  得到记录中寄存器名
reltime([<code class="special">{start}</code> [, <code class="special">{end}</code>]])    列表    得到时间值
reltimefloat(<code class="special">{time}</code>)            浮点数  把时间值转化为浮点数
reltimestr(<code class="special">{time}</code>)              字符串  把时间值转化为字符串
remote_expr(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code> [, <code class="special">{timeout}</code>]])
                                字符串  发送表达式
remote_foreground(<code class="special">{server}</code>)     数值    把 Vim 服务器带到前台
remote_peek(<code class="special">{serverid}</code> [, <code class="special">{retvar}</code>])
                                数值    检查应答字符串
remote_read(<code class="special">{serverid}</code> [, <code class="special">{timeout}</code>])
                                字符串  读入应答字符串
remote_send(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code>])
                                字符串  发送键序列
remote_startserver(<code class="special">{name}</code>)      空      成为服务器 <code class="special">{name}</code>
remove(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{end}</code>]) 可变/列表
                                        从 <code class="special">{list}</code> 里删除项目 <code class="special">{idx}</code>-<code class="special">{end}</code>
remove(<code class="special">{blob}</code>, <code class="special">{idx}</code> [, <code class="special">{end}</code>]) 可变/blob
                                        从 <code class="special">{blob}</code> 里删除字节 <code class="special">{idx}</code>-<code class="special">{end}</code>
remove(<code class="special">{dict}</code>, <code class="special">{key}</code>)           可变    从 <code class="special">{dict}</code> 里删除项目 <code class="special">{key}</code>
rename(<code class="special">{from}</code>, <code class="special">{to}</code>)            数值    换名 (移动) 文件，从 <code class="special">{from}</code> 到 <code class="special">{to}</code>
repeat(<code class="special">{expr}</code>, <code class="special">{count}</code>)         字符串  重复 <code class="special">{expr}</code> <code class="special">{count}</code> 次
resolve(<code class="special">{filename}</code>)             字符串  解析快捷方式对应的文件名
reverse(<code class="special">{list}</code>)                 列表    反转 <code class="special">{list}</code>，直接修改 <code class="special">{list}</code>
round(<code class="special">{expr}</code>)                   浮点    <code class="special">{expr}</code> 四舍五入
rubyeval(<code class="special">{expr}</code>)                可变    计算  <a href="if_ruby.html#Ruby">Ruby</a>  表达式
screenattr(<code class="special">{row}</code>, <code class="special">{col}</code>)        数值    当前光标所在的属性
screenchar(<code class="special">{row}</code>, <code class="special">{col}</code>)        数值    当前光标所在的字符
screenchars(<code class="special">{row}</code>, <code class="special">{col}</code>)       列表    当前光标所在的字符列表
screencol()                     数值    当前光标列
screenpos(<code class="special">{winid}</code>, <code class="special">{lnum}</code>, <code class="special">{col}</code>) 字典  文本字符的屏幕行与列
screenrow()                     数值    当前光标行
screenstring(<code class="special">{row}</code>, <code class="special">{col}</code>)      字符串  当前光标所在的字符串
search(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])
                                数值    搜索 <code class="special">{pattern}</code>
searchdecl(<code class="special">{name}</code> [, <code class="special">{global}</code> [, <code class="special">{thisblock}</code>]])
                                数值    搜索变量声明
searchpair(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code> [...]]])
                                数值    搜索 start/end 对的另一侧
searchpairpos(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code> [...]]])
                                列表    搜索 start/end 队的另一侧
searchpos(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])
                                列表    搜索 <code class="special">{pattern}</code>
server2client(<code class="special">{clientid}</code>, <code class="special">{string}</code>)
                                数值    发送应答字符串
serverlist()                    字符串  得到可用的服务器列表
setbufline(<code class="special">{expr}</code>, <code class="special">{lnum}</code>, <code class="special">{text}</code>)
                                数值    设置缓冲区 <code class="special">{expr}</code> 第 <code class="special">{lnum}</code> 行为
                                        <code class="special">{text}</code>
setbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)
                                空      设置缓冲区 <code class="special">{expr}</code> 的 <code class="special">{varname}</code> 为
                                        <code class="special">{val}</code>
setcharsearch(<code class="special">{dict}</code>)           字典    从 <code class="special">{dict}</code> 设置字符搜索选项
setcmdpos(<code class="special">{pos}</code>)                数值    设置命令行的光标位置
setenv(<code class="special">{name}</code>, <code class="special">{val}</code>)           无      设置环境变量
setfperm(<code class="special">{fname}</code>, <code class="special">{mode}</code>)       数值    设置 <code class="special">{fname}</code> 文件权限为 <code class="special">{mode}</code>
setline(<code class="special">{lnum}</code>, <code class="special">{line}</code>)         数值    设置第 <code class="special">{lnum}</code> 行的内容为 <code class="special">{line}</code>
setloclist(<code class="special">{nr}</code>, <code class="special">{list}</code> [, <code class="special">{action}</code> [, <code class="special">{what}</code>]])
                                数值    用 <code class="special">{list}</code> 修改位置列表
setmatches(<code class="special">{list}</code> [, <code class="special">{win}</code>])    数值    还原匹配列表
setpos(<code class="special">{expr}</code>, <code class="special">{list}</code>)          数值    设置 <code class="special">{expr}</code> 的位置为 <code class="special">{list}</code>
setqflist(<code class="special">{list}</code> [, <code class="special">{action}</code> [, <code class="special">{what}</code>]])
                                数值    用 <code class="special">{list}</code> 修改 quickfix 列表
setreg(<code class="special">{n}</code>, <code class="special">{v}</code> [, <code class="special">{opt}</code>])      数值    设置寄存器的值和类型
settabvar(<code class="special">{nr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>) 无    设置标签页 <code class="special">{nr}</code> 的 <code class="special">{varname}</code> 变量为
                                        <code class="special">{val}</code>
settabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)
                                无      设置标签页 <code class="special">{tabnr}</code> 窗口 <code class="special">{winnr}</code> 的
                                        <code class="special">{varname}</code> 变量为 <code class="special">{val}</code>
settagstack(<code class="special">{nr}</code>, <code class="special">{dict}</code> [, <code class="special">{action}</code>])
                                数值    用 <code class="special">{dict}</code> 修改标签栈
setwinvar(<code class="special">{nr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>) 空    设置窗口 <code class="special">{expr}</code> 的 <code class="special">{varname}</code> 为 <code class="special">{val}</code>
sha256(<code class="special">{string}</code>)                字符串  <code class="special">{string}</code> 的 SHA256 校验码
shellescape(<code class="special">{string}</code> [, <code class="special">{special}</code>])
                                字符串  转义 <code class="special">{string}</code> 以便用作外壳命令的参数
shiftwidth([<code class="special">{col}</code>])             数值    <a href="options.html#'shiftwidth'">'shiftwidth'</a> 的有效值
sign_define(<code class="special">{name}</code> [, <code class="special">{dict}</code>])  数值    定义或更新标号
sign_define(<code class="special">{list}</code>)             列表    定义或更新一列标号
sign_getdefined([<code class="special">{name}</code>])       列表    得到已定义的标号的列表
sign_getplaced([<code class="special">{expr}</code> [, <code class="special">{dict}</code>]])
                                列表    得到已放置的标号的列表
sign_jump(<code class="special">{id}</code>, <code class="special">{group}</code>, <code class="special">{expr}</code>)
                                数值    跳转到标号
sign_place(<code class="special">{id}</code>, <code class="special">{group}</code>, <code class="special">{name}</code>, <code class="special">{expr}</code> [, <code class="special">{dict}</code>])
                                数值    放置标号
sign_placelist(<code class="special">{list}</code>)          列表    放置一列标号
sign_undefine([<code class="special">{name}</code>])         数值    撤销标号的定义
sign_undefine(<code class="special">{list}</code>)           列表    撤销一列标号的定义
sign_unplace(<code class="special">{group}</code> [, <code class="special">{dict}</code>])
                                数值    撤销标号的放置
sign_unplacelist(<code class="special">{list}</code>)        列表    撤销一列标号的放置
simplify(<code class="special">{filename}</code>)            字符串  尽可能简化文件名
sin(<code class="special">{expr}</code>)                     浮点    <code class="special">{expr}</code> 的正弦值
sinh(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的双曲正弦值
sort(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])
                                列表    排序 <code class="special">{list}</code>，用比较函数 <code class="special">{func}</code>
sound_clear()                   无      停止播放所有声音
sound_playevent(<code class="special">{name}</code> [, <code class="special">{callback}</code>])
                                数值    播放事件声音
sound_playfile(<code class="special">{path}</code> [, <code class="special">{callback}</code>])
                                数值    播放声音文件 <code class="special">{path}</code>
sound_stop(<code class="special">{id}</code>)                无      停止播放声音 <code class="special">{id}</code>
soundfold(<code class="special">{word}</code>)               字符串  按发音折叠 <code class="special">{word}</code>
spellbadword()                  字符串  光标所在的拼写错误的单词
spellsuggest(<code class="special">{word}</code> [, <code class="special">{max}</code> [, <code class="special">{capital}</code>]])
                                列表    拼写建议
split(<code class="special">{expr}</code> [, <code class="special">{pat}</code> [, <code class="special">{keepempty}</code>]])
                                列表    从 <code class="special">{pat}</code> 分割的 <code class="special">{expr}</code> 里构造  <a href="eval.html#List">List</a> 
sqrt(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的平方根
srand([<code class="special">{expr}</code>])                 列表    取得  <a href="eval.html#rand()">rand()</a>  的种子
state([<code class="special">{what}</code>])                 字符串  Vim 的当前状态
str2float(<code class="special">{expr}</code>)               浮点    转换字符串为浮点数
str2list(<code class="special">{expr}</code> [, <code class="special">{utf8}</code>])     列表    把 <code class="special">{expr}</code> 的每个字符转换为 ASCII/UTF8
                                        值
str2nr(<code class="special">{expr}</code> [, <code class="special">{base}</code> [, <code class="special">{quoted}</code>]])
                                数值    把字符串转换为数值
strchars(<code class="special">{expr}</code> [, <code class="special">{skipcc}</code>])   数值    <code class="special">{expr}</code> 字符串的字符长度
strcharpart(<code class="special">{str}</code>, <code class="special">{start}</code> [, <code class="special">{len}</code>])
                                字符串  <code class="special">{str}</code> 从 <code class="special">{start}</code> 开始的 <code class="special">{len}</code> 个字符
strdisplaywidth(<code class="special">{expr}</code> [, <code class="special">{col}</code>]) 数值  <code class="special">{expr}</code> 字符串的显示长度
strftime(<code class="special">{format}</code> [, <code class="special">{time}</code>])   字符串  使用指定格式排版时间
strgetchar(<code class="special">{str}</code>, <code class="special">{index}</code>)      数值    从 <code class="special">{str}</code> 取得字符 <code class="special">{index}</code>
stridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])
                                数值    <code class="special">{haystack}</code> 里 <code class="special">{needle}</code> 的位置
string(<code class="special">{expr}</code>)                  字符串  <code class="special">{expr}</code> 值得字符串表示
strlen(<code class="special">{expr}</code>)                  数值    字符串 <code class="special">{expr}</code> 的长度
strpart(<code class="special">{str}</code>, <code class="special">{start}</code> [, <code class="special">{len}</code>])
                                字符串  <code class="special">{str}</code> 从 <code class="special">{start}</code> 开始的 <code class="special">{len}</code> 个字节
strridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])
                                数值    <code class="special">{haystack}</code> 里最后一个 <code class="special">{needle}</code> 的位置
strptime(<code class="special">{format}</code>, <code class="special">{timestring}</code>)
                                数值    把 <code class="special">{timestring}</code> 转换为 unix 时间戳
strtrans(<code class="special">{expr}</code>)                字符串  翻译字符串，使之可以显示
swapinfo(<code class="special">{fname}</code>)               字典    关于交换文件 <code class="special">{fname}</code> 的信息
swapname(<code class="special">{expr}</code>)                字符串  缓冲区 <code class="special">{expr}</code> 的交换文件
strwidth(<code class="special">{expr}</code>)                数值    <code class="special">{expr}</code> 字符串的显示单元长度
submatch(<code class="special">{nr}</code> [, <code class="special">{list}</code>])       字符串/列表
                                        ":s" 或 substitute() 的特定匹配
substitute(<code class="special">{expr}</code>, <code class="special">{pat}</code>, <code class="special">{sub}</code>, <code class="special">{flags}</code>)
                                字符串  <code class="special">{expr}</code> 里的所有 <code class="special">{pat}</code> 被 <code class="special">{sub}</code> 替代
synID(<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{trans}</code>)   数值    <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列所在的语法 ID
synIDattr(<code class="special">{synID}</code>, <code class="special">{what}</code> [, <code class="special">{mode}</code>])
                                字符串  syntax ID <code class="special">{synID}</code> 的 <code class="special">{what}</code> 属性
synIDtrans(<code class="special">{synID}</code>)             数值    <code class="special">{synID}</code> 经过翻译的语法 ID
synconcealed(<code class="special">{lnum}</code>, <code class="special">{col}</code>)     列表    关于隐藏的信息
synstack(<code class="special">{lnum}</code>, <code class="special">{col}</code>)         列表    <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列所在的语法 ID 堆栈
system(<code class="special">{expr}</code> [, <code class="special">{input}</code>])      字符串  外壳命令/过滤 <code class="special">{expr}</code> 的输出
systemlist(<code class="special">{expr}</code> [, <code class="special">{input}</code>])  列表    外壳命令/过滤 <code class="special">{expr}</code> 的输出
tabpagebuflist([<code class="special">{arg}</code>])         列表    标签页里的缓冲区号列表
tabpagenr([<code class="special">{arg}</code>])              数值    当前或最后标签页的编号
tabpagewinnr(<code class="special">{tabarg}</code> [, <code class="special">{arg}</code>]) 数值   标签页里当前窗口的编号
taglist(<code class="special">{expr}</code> [, <code class="special">{filename}</code>])  列表    匹配 <code class="special">{expr}</code> 的标签列表
tagfiles()                      列表    使用的标签文件
tan(<code class="special">{expr}</code>)                     浮点    <code class="special">{expr}</code> 的正切值
tanh(<code class="special">{expr}</code>)                    浮点    <code class="special">{expr}</code> 的双曲正切值
tempname()                      字符串  临时文件的文件名
term_dumpdiff(<code class="special">{filename}</code>, <code class="special">{filename}</code> [, <code class="special">{options}</code>])
                                数值    显示两份截图的差异
term_dumpload(<code class="special">{filename}</code> [, <code class="special">{options}</code>])
                                数值    显示一份屏幕截图
term_dumpwrite(<code class="special">{buf}</code>, <code class="special">{filename}</code> [, <code class="special">{options}</code>])
                                无      为终端窗口的内容进行截图
term_getaltscreen(<code class="special">{buf}</code>)        数值    取得备用屏幕标志位
term_getansicolors(<code class="special">{buf}</code>)       列表    取得 GUI 色彩模式的 ANSI 调色板
term_getattr(<code class="special">{attr}</code>, <code class="special">{what}</code>)    数值    取得 <code class="special">{what}</code> 属性的值
term_getcursor(<code class="special">{buf}</code>)           列表    取得终端光标位置
term_getjob(<code class="special">{buf}</code>)              作业    取得终端关联的作业
term_getline(<code class="special">{buf}</code>, <code class="special">{row}</code>)      字符串  从终端取得一行文本行
term_getscrolled(<code class="special">{buf}</code>)         数值    取得终端的滚动数目
term_getsize(<code class="special">{buf}</code>)             列表    取得终端的大小
term_getstatus(<code class="special">{buf}</code>)           字符串  取得终端的状态
term_gettitle(<code class="special">{buf}</code>)            字符串  取得终端的标题
term_gettty(<code class="special">{buf}</code>, [<code class="special">{input}</code>])   字符串  取得终端的 tty 名
term_list()                     列表    取得终端缓冲区的列表
term_scrape(<code class="special">{buf}</code>, <code class="special">{row}</code>)       列表    取得终端屏幕的某行
term_sendkeys(<code class="special">{buf}</code>, <code class="special">{keys}</code>)    无      给终端发送键序列
term_setapi(<code class="special">{buf}</code>, <code class="special">{expr}</code>)      无      设置  <a href="terminal.html#terminal-api">terminal-api</a>  函数名前缀
term_setansicolors(<code class="special">{buf}</code>, <code class="special">{colors}</code>)
                                无      设置 GUI 色彩模式的 ANSI 调色板
term_setkill(<code class="special">{buf}</code>, <code class="special">{how}</code>)      无      设置停止终端作业的信号值
term_setrestore(<code class="special">{buf}</code>, <code class="special">{command}</code>) 无    设置恢复终端的命令
term_setsize(<code class="special">{buf}</code>, <code class="special">{rows}</code>, <code class="special">{cols}</code>)
                                无      设置终端的大小
term_start(<code class="special">{cmd}</code> [, <code class="special">{options}</code>]) 数值    打开终端窗口并执行作业
term_wait(<code class="special">{buf}</code> [, <code class="special">{time}</code>])     数值    等待屏幕刷新
test_alloc_fail(<code class="special">{id}</code>, <code class="special">{countdown}</code>, <code class="special">{repeat}</code>)
                                空      使内存分配失败
test_autochdir()                空      系统启动中启动 <a href="options.html#'autochdir'">'autochdir'</a>
test_feedinput(<code class="special">{string}</code>)        空      给输入缓冲区增加键序列
test_garbagecollect_now()       空      为测试用，立即释放内存
test_garbagecollect_soon()      空      为测试用，尽快释放内存
test_getvalue(<code class="special">{string}</code>)         可变    得到内部变量的值
test_ignore_error(<code class="special">{expr}</code>)       空      忽略特定的错误
test_null_blob()                blob    用作测试的空值
test_null_channel()             通道    用作测试的空值
test_null_dict()                字典    用作测试的空值
test_null_job()                 作业    用作测试的空值
test_null_list()                列表    用作测试的空值
test_null_partial()             函数引用        用作测试的空值
test_null_string()              字符串  用作测试的空值
test_option_not_set(<code class="special">{name}</code>)     无      复位指示选项已设置的标志位
test_override(<code class="special">{expr}</code>, <code class="special">{val}</code>)    空      Vim 内部覆盖用作测试
test_refcount(<code class="special">{expr}</code>)           数值    得到 <code class="special">{expr}</code> 的引用计数
test_scrollbar(<code class="special">{which}</code>, <code class="special">{value}</code>, <code class="special">{dragging}</code>)
                                无      为测试用，在 GUI 内滚动
test_setmouse(<code class="special">{row}</code>, <code class="special">{col}</code>)     无      为测试用，设置鼠标位置
test_settime(<code class="special">{expr}</code>)            空      用作测试的当前时间
timer_info([<code class="special">{id}</code>])              列表    定时器信息
timer_pause(<code class="special">{id}</code>, <code class="special">{pause}</code>)      空      暂停或继续定时器
timer_start(<code class="special">{time}</code>, <code class="special">{callback}</code> [, <code class="special">{options}</code>])
                                数值    新建定时器
timer_stop(<code class="special">{timer}</code>)             空      停止定时器
timer_stopall()                 空      停止所有定时器
tolower(<code class="special">{expr}</code>)                 字符串  字符串 <code class="special">{expr}</code> 变为小写
toupper(<code class="special">{expr}</code>)                 字符串  字符串 <code class="special">{expr}</code> 变为大写
tr(<code class="special">{src}</code>, <code class="special">{fromstr}</code>, <code class="special">{tostr}</code>)   字符串  把 <code class="special">{src}</code> 里的 <code class="special">{fromstr}</code> 字符翻译为
                                        <code class="special">{tostr}</code> 字符
trim(<code class="special">{text}</code> [, <code class="special">{mask}</code>])         字符串  从 <code class="special">{text}</code> 中删除 <code class="special">{mask}</code> 中的字符
trunc(<code class="special">{expr}</code>)                   浮点    浮点数 <code class="special">{expr}</code> 截断小数点
type(<code class="special">{name}</code>)                    数值    变量 <code class="special">{name}</code> 的类型
undofile(<code class="special">{name}</code>)                字符串  对应 <code class="special">{name}</code> 的撤销文件名
undotree()                      列表    撤销文件树
uniq(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])
                                列表    从列表中删除相邻的重复项
values(<code class="special">{dict}</code>)                  列表    <code class="special">{dict}</code> 的所有值
virtcol(<code class="special">{expr}</code>)                 数值    光标或位置标记的屏幕列
visualmode([expr])              字符串  最近使用的可视模式
wildmenumode()                  数值    <a href="options.html#'wildmenu'">'wildmenu'</a> 模式是否激活
win_execute(<code class="special">{id}</code>, <code class="special">{command}</code> [, <code class="special">{silent}</code>])
                                字符串  在窗口 <code class="special">{id}</code> 执行 <code class="special">{command}</code>
win_findbuf(<code class="special">{bufnr}</code>)            列表    寻找包含 <code class="special">{bufnr}</code> 的窗口
win_getid([<code class="special">{win}</code> [, <code class="special">{tab}</code>]])    数值    得到 <code class="special">{tab}</code> 中 <code class="special">{win}</code> 的窗口 ID
win_gotoid(<code class="special">{expr}</code>)              数值    转到 ID 为 <code class="special">{expr}</code> 的窗口
win_id2tabwin(<code class="special">{expr}</code>)           列表    从窗口 ID 获得标签页与窗口
win_id2win(<code class="special">{expr}</code>)              数值    从窗口 ID 获得窗口号
win_screenpos(<code class="special">{nr}</code>)             列表    得到窗口 <code class="special">{nr}</code> 的屏幕位置
win_splitmove(<code class="special">{nr}</code>, <code class="special">{target}</code> [, <code class="special">{options}</code>])
                                数值    移动窗口 <code class="special">{nr}</code> 成为 <code class="special">{target}</code> 的分割窗口
winbufnr(<code class="special">{nr}</code>)                  数值    窗口 <code class="special">{nr}</code> 的缓冲区号
wincol()                        数值    光标所在的窗口列
winheight(<code class="special">{nr}</code>)                 数值    窗口 <code class="special">{nr}</code> 的高度
winlayout([<code class="special">{tabnr}</code>])            列表    标签页 <code class="special">{tabnr}</code> 的窗口布局
winline()                       数值    光标所在的窗口行
winnr([<code class="special">{expr}</code>])                 数值    当前窗口的编号
winrestcmd()                    字符串  返回恢复窗口大小的命令
winrestview(<code class="special">{dict}</code>)             无      恢复当前窗口的视图
winsaveview()                   字典    保存当前窗口的视图
winwidth(<code class="special">{nr}</code>)                  数值    窗口 <code class="special">{nr}</code> 的宽度
wordcount()                     字典    字节/字符/单词统计
writefile(<code class="special">{object}</code>, <code class="special">{fname}</code> [, <code class="special">{flags}</code>])
                                数值    把行的  <a href="eval.html#Blob">Blob</a>  或  <a href="eval.html#List">List</a>  写到文件
                                        <code class="special">{fname}</code>
xor(<code class="special">{expr}</code>, <code class="special">{expr}</code>)             数值    按位异或

abs(<code class="special">{expr}</code>)                                                     <b class="vimtag"> <a name="abs()">abs()</a> </b>
                返回 <code class="special">{expr}</code> 的绝对值。如果 <code class="special">{expr}</code> 计算结果为浮点数，abs() 返回
                浮点数。如果 <code class="special">{expr}</code> 可以转换为数值，abs() 返回数值。否则报错并
                返回 -1。
                示例: 
<code class="example">                        echo abs(1.456)</code>
                        1.456  
<code class="example">                        echo abs(-5.456)</code>
                        5.456  
<code class="example">                        echo abs(-4)</code>
                        4

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;abs()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


acos(<code class="special">{expr}</code>)                                                    <b class="vimtag"> <a name="acos()">acos()</a> </b>
                返回以弧度表示的 <code class="special">{expr}</code> 的反余弦值，返回值为 [0, pi] 区间内的
                浮点数。
                <code class="special">{expr}</code> 的计算结果必须是 [-1, 1] 区间内的浮点数或数值。
                示例: 
<code class="example">                        :echo acos(0)</code>
                        1.570796 
<code class="example">                        :echo acos(-0.5)</code>
                        2.094395

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;acos()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


add(<code class="special">{object}</code>, <code class="special">{expr}</code>)                                   <b class="vimtag"> <a name="add()">add()</a> </b>
                在  <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a>  <code class="special">{object}</code> 最后附加项目 <code class="special">{expr}</code>。返回新产生的
                 <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a> 。例如: 
<code class="example">                        :let alist = add([1, 2, 3], item)</code>
<code class="example">                        :call add(mylist, "woodstock")</code>
                <code class="note">注意</code> 如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，它被作为单个项目附加进去。
                 <a href="eval.html#extend()">extend()</a>  可以用来连接  <a href="eval.html#List">List</a> 。
                如果 <code class="special">{object}</code> 是  <a href="eval.html#Blob">Blob</a> ，<code class="special">{expr}</code> 必须是个数值。
                 <a href="eval.html#insert()">insert()</a>  可以用来把一个项目加到其它的位置上。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;add(val1)-&gt;add(val2)</code>
<code class="example"></code>
<code class="example"></code>
and(<code class="special">{expr}</code>, <code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="and()">and()</a> </b>
                对两个参数进行按位与。参数须转换为数值。列表、字典或浮点数参数
                会报错。
                示例: 
<code class="example">                        :let flag = and(bits, 0x80)</code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :let flag = bits-&gt;and(0x80)</code>
<code class="example"></code>
<code class="example"></code>
append(<code class="special">{lnum}</code>, <code class="special">{text}</code>)                                  <b class="vimtag"> <a name="append()">append()</a> </b>
                当 <code class="special">{text}</code> 为  <a href="eval.html#List">List</a> : 把每个  <a href="eval.html#List">List</a>  项目作为文本行，附加到当前
                缓冲区第 <code class="special">{lnum}</code> 行之下。
                否则，把 <code class="special">{text}</code> 作为单个文本行，附加于当前缓冲区第 <code class="special">{lnum}</code> 行之
                下。
                <code class="special">{lnum}</code> 可以为零，用于在第一行前插入一行。如果失败 (<code class="special">{lnum}</code> 越
                界)，返回 1，成功则返回 0。例如: 
<code class="example">                        :let failed = append(line('$'), "# THE END")</code>
<code class="example">                        :let failed = append(0, ["Chapter 1", "the beginning"])</code>
<code class="example"></code>
                也可用作列表的  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;append(lnum)</code>
<code class="example"></code>
<code class="example"></code>
appendbufline(<code class="special">{expr}</code>, <code class="special">{lnum}</code>, <code class="special">{text}</code>)                   <b class="vimtag"> <a name="appendbufline()">appendbufline()</a> </b>
                类似于  <a href="eval.html#append()">append()</a> ，但在缓冲区 <code class="special">{expr}</code> 中附加文本。

                此函数只能用于已载入的缓冲区。有必要的话先调用  <a href="eval.html#bufload()">bufload()</a> 。

                <code class="special">{expr}</code> 的用法可见  <a href="eval.html#bufname()">bufname()</a> 。

                <code class="special">{lnum}</code> 的用法和  <a href="eval.html#append()">append()</a>  类似。<code class="note">注意</code> 使用  <a href="eval.html#line()">line()</a>  会用到当前
                缓冲区而不是正在进行附加的那个。
                "$" 用来附加于缓冲区的末尾。

                成功时返回 0，失败则返回 1。

                如果 <code class="special">{expr}</code> 不是合法的缓冲区或 <code class="special">{lnum}</code> 不合法，报错。例如: 
<code class="example">                        :let failed = appendbufline(13, 0, "# THE START")</code>

                也可用作列表的  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;appendbufline(buf, lnum)</code>
<code class="example"></code>
<code class="example"></code>
argc([<code class="special">{winid}</code>])                                         <b class="vimtag"> <a name="argc()">argc()</a> </b>
                返回参数列表的文件数目。见  <a href="editing.html#arglist">arglist</a> 。
                如果 <code class="special">{winid}</code> 未给出，使用当前窗口的参数列表。
                如果 <code class="special">{winid}</code> 是 -1，使用全局参数列表。
                否则，<code class="special">{winid}</code> 指定参数列表所在的窗口: 窗口号或窗口 ID 均可。
                如果 <code class="special">{winid}</code> 参数不合法，返回 -1。

                                                        <b class="vimtag"> <a name="argidx()">argidx()</a> </b>
argidx()        返回参数列表的当前索引。0 是第一个文件。argc() - 1 是最后一
                个。见  <a href="editing.html#arglist">arglist</a> 。

                                                        <b class="vimtag"> <a name="arglistid()">arglistid()</a> </b>
arglistid([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
                返回参数列表 ID，这是一个用来标识正在使用的参数列表的数值。零
                代表全局参数列表。见  <a href="editing.html#arglist">arglist</a> 。
                如果参数非法，返回 -1。

                无参数时，使用当前窗口。
                只提供 <code class="special">{winnr}</code> 时，使用当前标签页的指定窗口。
                同时提供 <code class="special">{winnr}</code> 和 <code class="special">{tabnr}</code> 时，使用指定标签页的指定窗口。
                <code class="special">{winnr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。

                                                        <b class="vimtag"> <a name="argv()">argv()</a> </b>
argv([<code class="special">{nr}</code> [, <code class="special">{winid}</code>])
                返回参数列表第 <code class="special">{nr}</code> 个参数。见  <a href="editing.html#arglist">arglist</a> 。"argv(0)" 是第一个参
                数。例如: 
<code class="example">        :let i = 0</code>
<code class="example">        :while i &lt; argc()</code>
<code class="example">        :  let f = escape(fnameescape(argv(i)), '. ')</code>
<code class="example">        :  exe 'amenu Arg.' . f . ' :e ' . f . '&lt;CR&gt;'</code>
<code class="example">        :  let i = i + 1</code>
<code class="example">        :endwhile</code>
                如果没有 <code class="special">{nr}</code> 参数或 <code class="special">{nr}</code> 为 -1，返回完整的 <code class="special">{arglist}</code> 的
                 <a href="eval.html#List">List</a> 。

                <code class="special">{winid}</code> 参数指定窗口 ID，见  <a href="eval.html#argc()">argc()</a> 。
                关于 Vim 的命令行参数，可见  <a href="eval.html#v:argv">v:argv</a> 。



assert_ 函数文档在这里:  <a href="testing.html#assert-functions-details">assert-functions-details</a> 

asin(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="asin()">asin()</a> </b>
                返回以弧度表示的 <code class="special">{expr}</code> 的反正弦值，返回值为 [-pi/2, pi/2] 区
                间内的浮点数。
                <code class="special">{expr}</code> 的计算结果必须是 [-1, 1] 区间内的浮点数或数值。
                示例: 
<code class="example">                        :echo asin(0.8)</code>
                        0.927295 
<code class="example">                        :echo asin(-0.5)</code>
                        -0.523599

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;asin()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


atan(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="atan()">atan()</a> </b>
                返回 <code class="special">{expr}</code> 反正切的主值，返回值为 [-pi/2, +pi/2] 区间内的弧度
                值浮点数。
                <code class="special">{expr}</code> 计算结果必须为浮点数或数值。
                示例: 
<code class="example">                        :echo atan(100)</code>
                        1.560797 
<code class="example">                        :echo atan(-4.01)</code>
                        -1.326405

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;atan()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

atan2(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                 <b class="vimtag"> <a name="atan2()">atan2()</a> </b>
                返回 <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的反正切值，以弧度计算，返回值为 [-pi,
                +pi] 区间内的浮点数。
                <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 计算结果必须为浮点数或数值。
                示例: 
<code class="example">                        :echo atan2(-1, 1)</code>
                        -0.785398 
<code class="example">                        :echo atan2(1, -1)</code>
                        2.356194

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;atan(1) (译者注: 原文如此)</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

balloon_gettext()                                       <b class="vimtag"> <a name="balloon_gettext()">balloon_gettext()</a> </b>
                返回气泡的当前文本。只用于字符串，不用于列表。

balloon_show(<code class="special">{expr}</code>)                                    <b class="vimtag"> <a name="balloon_show()">balloon_show()</a> </b>
                在气泡中显示 <code class="special">{expr}</code>。GUI 上 <code class="special">{expr}</code> 用作字符串。而终端上 <code class="special">{expr}</code>
                可以是多行的列表。如果 <code class="special">{expr}</code> 不是列表，会用  <a href="eval.html#balloon_split()">balloon_split()</a> 
                进行分割。
                如果 <code class="special">{expr}</code> 为空，删除任何已存在的气泡。

                示例: 
<code class="example">                        func GetBalloonContent()</code>
<code class="example">                           " ... 启动内容的获取过程</code>
<code class="example">                           return ''</code>
<code class="example">                        endfunc</code>
<code class="example">                        set balloonexpr=GetBalloonContent()</code>
<code class="example"></code>
<code class="example">                        func BalloonCallback(result)</code>
<code class="example">                          call balloon_show(a:result)</code>
<code class="example">                        endfunc</code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;balloon_show()</code>

                期待的用法是从 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 启动气泡内容的获取过程。它应调用
                异步方法，然后在其回调中执行 balloon_show()。<a href="options.html#'balloonexpr'">'balloonexpr'</a> 自
                身可返回空字符串或任何占位符。

                如果不能显示气泡，不做任何事，不会报错。
                {仅当编译时加入  <a href="various.html#+balloon_eval">+balloon_eval</a>  或  <code class="badlink">balloon_eval_term</code>  特性才
                有效}

balloon_split(<code class="special">{msg}</code>)                                    <b class="vimtag"> <a name="balloon_split()">balloon_split()</a> </b>
                把 <code class="special">{msg}</code> 分割为用于气泡中显示的多行。分割依据的是当前窗口大
                小，并进行优化以显示调试器的输出。
                返回分割后行的  <a href="eval.html#List">List</a> 。
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;balloon_split()-&gt;balloon_show()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <code class="badlink">balloon_eval_term</code>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="browse()">browse()</a> </b>
browse(<code class="special">{save}</code>, <code class="special">{title}</code>, <code class="special">{initdir}</code>, <code class="special">{default}</code>)
                启动文件请求窗口。只有在 "has("browse")" 返回  <a href="eval.html#TRUE">TRUE</a>  时 (只有
                在一些 GUI 版本里) 才可以。
                输入的字段包括:
                    <code class="special">{save}</code>       <a href="eval.html#TRUE">TRUE</a>  时，选择要写入的文件
                    <code class="special">{title}</code>     请求窗口的标题
                    <code class="special">{initdir}</code>   开始浏览的目录
                    <code class="special">{default}</code>   缺省文件名
                如果按了 "Cancel" 按钮、出错、或者无法浏览，返回空字符串。

                                                        <b class="vimtag"> <a name="browsedir()">browsedir()</a> </b>
browsedir(<code class="special">{title}</code>, <code class="special">{initdir}</code>)
                启动目录请求窗口。只有在 "has("browse")" 返回  <a href="eval.html#TRUE">TRUE</a>  时 (只有
                在一些 GUI 版本里) 才能工作。
                有的系统上不支持目录浏览器，这时使用文件浏览器。此时: 选择要用
                的目录里的文件。
                输入的字段包括:
                    <code class="special">{title}</code>     请求窗口的标题
                    <code class="special">{initdir}</code>   开始浏览的目录
                如果按了 "Cancel" 按钮、出错、或者无法浏览，返回空字符串。

bufadd(<code class="special">{name}</code>)                                          <b class="vimtag"> <a name="bufadd()">bufadd()</a> </b>
                在缓冲区列表中加入名为 <code class="special">{name}</code> 的缓冲区。
                如果对应文件 <code class="special">{name}</code> 的缓冲区已经存在，返回该缓冲区号。否则返回
                新建缓冲区的号。<code class="special">{name}</code> 为空串时，总是建立新缓冲区。
                该缓冲区不置位 <a href="options.html#'buflisted'">'buflisted'</a> 也还未载入。要在缓冲区中增加文件: 
<code class="example">                        let bufnr = bufadd('someName')</code>
<code class="example">                        call bufload(bufnr)</code>
<code class="example">                        call setbufline(bufnr, 1, ['some', 'text'])</code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        let bufnr = 'somename'-&gt;bufadd()</code>
<code class="example"></code>
bufexists(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="bufexists()">bufexists()</a> </b>
                返回数值，如果名为 <code class="special">{expr}</code> 的缓冲区存在的话，返回  <a href="eval.html#TRUE">TRUE</a> 。
                <code class="special">{expr}</code> 参数是数值时，指定缓冲区号。数值零指定当前窗口的轮换缓
                冲区。

                <code class="special">{expr}</code> 参数是字符串时，必须完全匹配指定缓冲区名。该名可以是:
                - 相对于当前目录。
                - 完整路径。
                - <a href="options.html#'buftype'">'buftype'</a> 设为 "nofile" 的缓冲区名。
                - URL 名。
                列表外缓冲区也会被找到。
                <code class="note">注意</code> 帮助文件在  <a href="windows.html#:buffers">:buffers</a>  里列出的是它们的短名字。但
                bufexists() 需要它们的长名字才能找到它们。
                bufexists() 可能报告缓冲区存在，但要使其名字可用于  <a href="windows.html#:buffer">:buffer</a> 
                命令，可能需用到  <a href="eval.html#expand()">expand()</a> 。尤其 MS-Windows 8.3 名字可能形
                如 "c:\DOCUME~1"。
                使用 "bufexists(0)" 可以测试是否存在轮换文件名。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        let exists = 'somename'-&gt;bufexists()</code>

                已废弃的名字: buffer_exists()。         <b class="vimtag"> <a name="buffer_exists()">buffer_exists()</a> </b>

buflisted(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="buflisted()">buflisted()</a> </b>
                返回数值，如果名为 <code class="special">{expr}</code> 的缓冲区在列表内的话 (置位了
                <a href="options.html#'buflisted'">'buflisted'</a> 选项)，返回  <a href="eval.html#TRUE">TRUE</a> 。
                <code class="special">{expr}</code> 参数用法同  <a href="eval.html#bufexists()">bufexists()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        let listed = 'somename'-&gt;buflisted()</code>
<code class="example"></code>
bufload(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="bufload()">bufload()</a> </b>
                确保缓冲区 <code class="special">{expr}</code> 已载入。如果缓冲区名指向已存在的文件，读入该
                文件。否则缓冲区会为空。如果缓冲区已载入，则没有改变。
                如果缓冲区的文件已有交换文件，不会弹出对话框，还是会载入缓冲
                区。
                <code class="special">{expr}</code> 参数的用法类似于  <a href="eval.html#bufexists()">bufexists()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        eval 'somename'-&gt;bufload()</code>
<code class="example"></code>
bufloaded(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="bufloaded()">bufloaded()</a> </b>
                返回数值，如果名为 <code class="special">{expr}</code> 的缓冲区存在且已载入的话 (在窗口显
                示，或者至少被隐藏)，返回  <a href="eval.html#TRUE">TRUE</a> 。
                <code class="special">{expr}</code> 参数用法同  <a href="eval.html#bufexists()">bufexists()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        let loaded = 'somename'-&gt;bufloaded()</code>
<code class="example"></code>
<code class="example"></code>
bufname([<code class="special">{expr}</code>])                                       <b class="vimtag"> <a name="bufname()">bufname()</a> </b>
                返回缓冲区的名字，如同 ":ls" 命令显示的那样。
                如果 <code class="special">{expr}</code> 省略使用当前缓冲区。
                如果 <code class="special">{expr}</code> 参数是数值，指定缓冲区号。数值零代表当前窗口的轮换
                缓冲区。
                如果 <code class="special">{expr}</code> 参数是字符串，它用作  <a href="autocmd.html#file-pattern">file-pattern</a>  来匹配缓冲区名
                字。这里总假设置位 <a href="options.html#'magic'">'magic'</a> 而 <a href="options.html#'cpoptions'">'cpoptions'</a> 为空。如果有超过一个
                匹配，返回空字符串。
                "" 或 "%" 可用来指定当前缓冲区，"#" 指定轮换缓冲区。
                完整的匹配优先，如果没有，也接受在缓冲区名的开始，结束和中间的
                匹配。如果你只愿意接受完整的匹配，在模式的开始放上 "^"，在结尾
                放上 "$"。
                先查找列表内缓冲区。如果列出缓冲区有唯一的匹配，返回之。不然，
                再查找列表外的缓冲区。
                如果 <code class="special">{expr}</code> 是字符串，但你想用作缓冲区号，给它加零可以强制转化
                为数值型: 
<code class="example">                        :echo bufname("3" + 0)</code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        echo bufnr-&gt;bufname()</code>
<code class="example"></code>
                如果缓冲区不存在，或者没有名字，返回空字符串。 
<code class="example">        bufname("#")            轮换缓冲区名</code>
<code class="example">        bufname(3)              缓冲区 3 的名字</code>
<code class="example">        bufname("%")            当前缓冲区名</code>
<code class="example">        bufname("file2")        匹配 "file2" 的缓冲区名。</code>
                                                        <b class="vimtag"> <a name="buffer_name()">buffer_name()</a> </b>
                已废弃的名字: buffer_name()。

                                                        <b class="vimtag"> <a name="bufnr()">bufnr()</a> </b>
bufnr([<code class="special">{expr}</code> [, <code class="special">{create}</code>]])
                返回缓冲区的编号，如同 ":ls" 命令显示的那样。关于 <code class="special">{expr}</code> 的使
                用，见上  <a href="eval.html#bufname()">bufname()</a> 。
                如果不存在符合的缓冲区，返回 -1。或者，如果提供了 <code class="special">{create}</code> 参
                数而且非零，建立一个新的列表外缓冲区，并返回其编号。例如: 
<code class="example">                        let newbuf = bufnr('Scratch001', 1)</code>
                这里空名会使用当前缓冲区。要创建新缓冲区可用  <a href="eval.html#bufadd()">bufadd()</a>  带空
                名。

                bufnr("$") 是最后一个缓冲区: 
<code class="example">                        :let last_buffer = bufnr("$")</code>
                返回数值，即最大的已有的缓冲区的编号。<code class="note">注意</code> 较小的编号不一定都
                对应存在的缓冲区，因为 ":bwipeout" 可能永久地删除了部分的缓冲
                区。用 bufexists() 可以测试缓冲区是否存在。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        echo bufref-&gt;bufnr()</code>

                已废弃的名字: buffer_number()。         <b class="vimtag"> <a name="buffer_number()">buffer_number()</a> </b>
                                                        <b class="vimtag"> <a name="last_buffer_nr()">last_buffer_nr()</a> </b>
                bufnr("$") 已废弃的名字: last_buffer_nr()。

bufwinid(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="bufwinid()">bufwinid()</a> </b>
                返回数值，带缓冲区 <code class="special">{expr}</code> 相关的第一个窗口的  <a href="windows.html#window-ID">window-ID</a> 。
                <code class="special">{expr}</code> 的用法见上述  <a href="eval.html#bufname()">bufname()</a> 。 如果缓冲区 <code class="special">{expr}</code> 不存在或没
                有对应窗口，返回 -1。示例: 
<code class="example"></code>
<code class="example">        echo "A window containing buffer 1 is " . (bufwinid(1))</code>

                只处理当前标签页。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        FindBuffer()-&gt;bufwinid()</code>
<code class="example"></code>
bufwinnr(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="bufwinnr()">bufwinnr()</a> </b>
                和  <a href="eval.html#bufwinid()">bufwinid()</a>  类似，但返回窗口号而不是  <a href="windows.html#window-ID">window-ID</a> 。
                如果缓冲区 <code class="special">{expr}</code> 不存在或者没有对应的窗口，返回 -1。例如: 
<code class="example"></code>
<code class="example">        echo "包含缓冲区 1 的窗口是 " . (bufwinnr(1))</code>
<code class="example"></code>
                该编号可用于  <a href="windows.html#CTRL-W_w">CTRL-W_w</a>  和 ":wincmd w"  <a href="windows.html#:wincmd">:wincmd</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        FindBuffer()-&gt;bufwinnr()</code>
<code class="example"></code>
byte2line(<code class="special">{byte}</code>)                                       <b class="vimtag"> <a name="byte2line()">byte2line()</a> </b>
                返回当前缓冲区第 <code class="special">{byte}</code> 个字节所在的行号。取决于当前缓冲区的
                <a href="options.html#'fileformat'">'fileformat'</a> 选项，这可以包括不同的换行符。第一个字符的字节编
                号为 1。
                另见  <a href="eval.html#line2byte()">line2byte()</a> 、 <a href="motion.html#go">go</a>  和  <a href="motion.html#:goto">:goto</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetOffset()-&gt;byte2line()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+byte_offset">+byte_offset</a>  特性才有效}</code>

byteidx(<code class="special">{expr}</code>, <code class="special">{nr}</code>)                                   <b class="vimtag"> <a name="byteidx()">byteidx()</a> </b>
                返回字符串 <code class="special">{expr}</code> 里第 <code class="special">{nr}</code> 个字符的字节位置。零代表第一个字
                符，此时返回零。
                该函数只对多字节字符有用，不然返回值总是等于 <code class="special">{nr}</code>。
                组合字符不单独计数，其字节长度加到其前导的基础字符上。要将组合
                字符分别计数，见下  <a href="eval.html#byteidxcomp()">byteidxcomp()</a> 。例如: 
<code class="example">                        echo matchstr(str, ".", byteidx(str, 3))</code>
                显示第四个字符。另一个方法也能达到相同的效果: 
<code class="example">                        let s = strpart(str, byteidx(str, 3))</code>
<code class="example">                        echo strpart(s, 0, byteidx(s, 1))</code>
                另见  <a href="eval.html#strgetchar()">strgetchar()</a>  和  <a href="eval.html#strcharpart()">strcharpart()</a> 。

                如果字符数不足 <code class="special">{nr}</code>，返回 -1。
                如果刚好 <code class="special">{nr}</code> 个字符，返回字符串的字节长度。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;byteidx(idx)</code>
<code class="example"></code>
byteidxcomp(<code class="special">{expr}</code>, <code class="special">{nr}</code>)                                       <b class="vimtag"> <a name="byteidxcomp()">byteidxcomp()</a> </b>
                类似于 byteidx()，但组合字符作为一个单独的字符计算。示例: 
<code class="example">                        let s = 'e' . nr2char(0x301)</code>
<code class="example">                        echo byteidx(s, 1)</code>
<code class="example">                        echo byteidxcomp(s, 1)</code>
<code class="example">                        echo byteidxcomp(s, 2)</code>
                第一个和第三个 echo 返回 3 ('e' 加上组合字符是 3 个字节)，第二
                个 echo 返回 1 ('e' 是一个字节)。
                只有当 <a href="options.html#'encoding'">'encoding'</a> 设为某种 Unicode 编码时，才会和 byteidx() 有
                所不同。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;byteidxcomp(idx)</code>
<code class="example"></code>
call(<code class="special">{func}</code>, <code class="special">{arglist}</code> [, <code class="special">{dict}</code>])                      <b class="vimtag"> <a name="call()">call()</a> </b> <b class="vimtag"> <a name="E699">E699</a> </b>
                调用函数 <code class="special">{func}</code>，使用  <a href="eval.html#List">List</a>  <code class="special">{arglist}</code> 项目作为参数。
                <code class="special">{func}</code> 可以是  <a href="eval.html#Funcref">Funcref</a>  或函数名。
                a:firstline 和 a:lastline 设为当前行。
                返回调用的函数的结果。
                <code class="special">{dict}</code> 用于为函数指定 "dict" 属性。其目的是设置局部变量
                "self"。 <a href="eval.html#Dictionary-function">Dictionary-function</a> 

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFunc()-&gt;call([arg, arg], dict)</code>
<code class="example"></code>
ceil(<code class="special">{expr}</code>)                                                    <b class="vimtag"> <a name="ceil()">ceil()</a> </b>
                返回浮点数，即大于等于 <code class="special">{expr}</code> 的最小整数 (向上取整)。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        echo ceil(1.456)</code>
                        2.0  
<code class="example">                        echo ceil(-5.456)</code>
                        -5.0  
<code class="example">                        echo ceil(4.0)</code>
                        4.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;ceil()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

ch_ 函数文档在这里:  <a href="channel.html#channel-functions-details">channel-functions-details</a> 

changenr()                                              <b class="vimtag"> <a name="changenr()">changenr()</a> </b>
                返回最近改变的编号。这和  <a href="undo.html#:undolist">:undolist</a>  显示的编号相同，可用于
                 <a href="undo.html#:undo">:undo</a>  命令。
                如果发生了改变，返回的是此改变的编号。在重做以后，返回的是重做
                的改变的编号。在撤销以后，返回撤销的改变的编号减一。

char2nr(<code class="special">{expr}</code> [, <code class="special">{utf8}</code>])                                      <b class="vimtag"> <a name="char2nr()">char2nr()</a> </b>
                返回 <code class="special">{expr}</code> 第一个字符的数值结果。例如: 
<code class="example">                        char2nr(" ")            返回 32</code>
<code class="example">                        char2nr("ABC")          返回 65</code>
                如果 <code class="special">{utf8}</code> 省略或为零，使用当前的 <a href="options.html#'encoding'">'encoding'</a>。比如对 "utf-8"
                来说: 
<code class="example">                        char2nr("Ã¡")           返回 225</code>
<code class="example">                        char2nr("Ã¡"[0])        返回 195</code>
                如果 <code class="special">{utf8}</code> 为 1，则总视为 utf-8 字符。
                组合字符是一个单独的字符。
                 <a href="eval.html#nr2char()">nr2char()</a>  是它的逆操作。
                要把字符串转换为字符数值的列表: 
<code class="example">                    let str = "ABC"</code>
<code class="example">                    let list = map(split(str, '\zs'), {_, val -&gt; char2nr(val)})</code>
                结果是: [65, 66, 67]

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetChar()-&gt;char2nr()</code>
<code class="example"></code>
chdir(<code class="special">{dir}</code>)                                            <b class="vimtag"> <a name="chdir()">chdir()</a> </b>
                切换当前工作目录为 <code class="special">{dir}</code>。目录改变的作用域取决于当前窗口的目
                录:
                        - 如果当然窗口有局部于窗口的目录 ( <a href="editing.html#:lcd">:lcd</a> )，则改变局部
                          于窗口的目录。
                        - 否则，如果当前标签页有局部目录 ( <a href="editing.html#:tcd">:tcd</a> )，则改变局部
                          于标签页的目录。
                        - 否则，返回全局目录。
                如果成功，返回上次的工作目录。把它传给另一个 chdir() 会恢复上
                次目录。
                如果失败，返回空串。

                示例: 
<code class="example">                        let save_dir = chdir(newdir)</code>
<code class="example">                        if save_dir != ""</code>
<code class="example">                           " ... 做点事</code>
<code class="example">                           call chdir(save_dir)</code>
<code class="example">                        endif</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetDir()-&gt;chdir()</code>

cindent(<code class="special">{lnum}</code>)                                         <b class="vimtag"> <a name="cindent()">cindent()</a> </b>
                得到第 <code class="special">{lnum}</code> 行根据 C 缩进规则应有的缩进距离，见 <a href="options.html#'cindent'">'cindent'</a>。
                缩进的计算以空格计，因而和 <a href="options.html#'tabstop'">'tabstop'</a> 的值是有关系的。<code class="special">{lnum}</code> 的
                使用方式和  <a href="eval.html#getline()">getline()</a>  相同。
                如果 <code class="special">{lnum}</code> 非法或者 Vim 编译时不带  <a href="various.html#+cindent">+cindent</a>  特性，返回 -1。
                见  <a href="indent.html#C-indenting">C-indenting</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;cindent()</code>
<code class="example"></code>
clearmatches([<code class="special">{win}</code>])                                   <b class="vimtag"> <a name="clearmatches()">clearmatches()</a> </b>
                清除之前  <a href="eval.html#matchadd()">matchadd()</a>  和  <a href="pattern.html#:match">:match</a>  命令为当前窗口定义的匹配。
                如果给出 <code class="special">{win}</code>，使用指定窗口号或窗口 ID 的窗口而不是当前窗口。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWin()-&gt;clearmatches()</code>

                                                        <b class="vimtag"> <a name="col()">col()</a> </b>
col(<code class="special">{expr}</code>)     返回数值，即 <code class="special">{expr}</code> 给定的列位置的字节索引。可接受的位置是:
                    .       光标位置
                    $       光标行的行尾 (返回光标行的字节数加 1)
                    'x      位置标记 x 的位置 (如果该位置标记没有设置，返回 0)
                    v       可视模式下: 可视区域的开始位置 (光标是结束位置)。
                            如果不在可视模式下，返回当前光标位置。和  <a href="motion.html#'%3C">'&lt;</a>  不同
                            的是，会被立即更新。
                另外，<code class="special">{expr}</code> 可以是 [lnum, col]: 包含行号和列号的  <a href="eval.html#List">List</a> 。常用
                于指定列号为 "$" 以得到特定行的末列列号。如果 "lnum" 或 "col"
                超出范围，col() 返回零。
                要得到行号用  <a href="eval.html#line()">line()</a> 。两者都要用  <a href="eval.html#getpos()">getpos()</a> 。
                要得到屏幕列的位置，用  <a href="eval.html#virtcol()">virtcol()</a> 。
                <code class="note">注意</code> 只能使用当前文件的位置标记。
                例如: 
<code class="example">                        col(".")                光标所在列</code>
<code class="example">                        col("$")                光标行的长度加 1</code>
<code class="example">                        col("'t")               位置标记 t 的列号</code>
<code class="example">                        col("'" . markname)     等于 markname 的位置标记的列号</code>
                第一列为 1。0 用来返回错误。
                大写位置标记的对应列可能在另一个缓冲区中。
                如果激活了 <a href="options.html#'virtualedit'">'virtualedit'</a> 并且如果光标在行尾之后的话，计算光标
                位置得到的列号比实际的多 1。可用来在插入模式得到列数: 
<code class="example">                        :imap &lt;F2&gt; &lt;C-O&gt;:let save_ve = &amp;ve&lt;CR&gt;</code>
<code class="example">                                \&lt;C-O&gt;:set ve=all&lt;CR&gt;</code>
<code class="example">                                \&lt;C-O&gt;:echo col(".") . "\n" &lt;Bar&gt;</code>
<code class="example">                                \let &amp;ve = save_ve&lt;CR&gt;</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPos()-&gt;col()</code>


complete(<code class="special">{startcol}</code>, <code class="special">{matches}</code>)                 <b class="vimtag"> <a name="complete()">complete()</a> </b> <b class="vimtag"> <a name="E785">E785</a> </b>
                设置插入模式补全的匹配。
                只能用于插入模式。需要使用 <code class="keystroke">CTRL-R</code> = 的映射 (见  <a href="insert.html#i_CTRL-R">i_CTRL-R</a> )。不
                能在 <code class="keystroke">CTRL-O</code> 之后或者在表达式映射里使用。
                <code class="special">{startcol}</code> 是行内待补全文本开始的字节偏移。直到光标为止的文本
                就是原始的文本，它将要被匹配所替代。用 col('.') 会得到空串。而
                "col('.') - 1" 将用匹配替换单个字符。
                <code class="special">{matches}</code> 必须是  <a href="eval.html#List">List</a> 。每个  <a href="eval.html#List">List</a>  项目是一个匹配。
                 <a href="insert.html#complete-items">complete-items</a>  说明可能的项目类型。
                <code class="note">注意</code> 调用此函数后，你不应插入任何使补全停止的内容。
                用 <code class="keystroke">CTRL-N</code> 和 <code class="keystroke">CTRL-P</code> 选择匹配，就像普通的插入模式补全那样。如果
                指定，会出现弹出菜单，见  <a href="insert.html#ins-completion-menu">ins-completion-menu</a> 。
                示例: 
<code class="example">        inoremap &lt;F5&gt; &lt;C-R&gt;=ListMonths()&lt;CR&gt;</code>
<code class="example"></code>
<code class="example">        func! ListMonths()</code>
<code class="example">          call complete(col('.'), ['January', 'February', 'March',</code>
<code class="example">                \ 'April', 'May', 'June', 'July', 'August', 'September',</code>
<code class="example">                \ 'October', 'November', 'December'])</code>
<code class="example">          return ''</code>
<code class="example">        endfunc</code>
                此例并不很有用，但可以说明功能。<code class="note">注意</code>这里返回空串，以免插入零。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetMatches()-&gt;complete(col('.'))</code>
<code class="example"></code>
complete_add(<code class="special">{expr}</code>)                            <b class="vimtag"> <a name="complete_add()">complete_add()</a> </b>
                把 <code class="special">{expr}</code> 加到匹配的列表里。只能用于 <a href="options.html#'completefunc'">'completefunc'</a> 选项指定的
                函数里。
                返回 0 代表失败 (空字符串或者内存不足)，1 代表加入了匹配，2 代
                表匹配已经在列表里。
                 <a href="insert.html#complete-functions">complete-functions</a>  解释 <code class="special">{expr}</code>。它和 <a href="options.html#'omnifunc'">'omnifunc'</a> 应该返回的列
                表中单个项目相同。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMoreMatches()-&gt;complete_add()</code>
<code class="example"></code>
<code class="example">                                                        *complete_info()*</code>
complete_info([<code class="special">{what}</code>])
                返回关于插入模式补全信息的字典。见  <a href="insert.html#ins-completion">ins-completion</a> 。
                项目是:
                   mode         当前补全模式名的字符串。
                                可用值见  <a href="eval.html#complete_info_mode">complete_info_mode</a> 。
                   pum_visible  如果弹出菜单可见则为  <a href="eval.html#TRUE">TRUE</a> 。
                                见  <a href="eval.html#pumvisible()">pumvisible()</a> 。
                   items        补全匹配的列表。每个项目是包含项目 "word"、
                                "abbr"、"menu"、"kind"、"info" 和 "user_data"
                                的字典。
                                见  <a href="insert.html#complete-items">complete-items</a> 。
                   selected     选中项目的索引。首个索引为零。如果没有选中的项
                                目则索引为 -1 (只显示输入的文本)
                   inserted     插入的字符串。[尚未实现]

                                                        <b class="vimtag"> <a name="complete_info_mode">complete_info_mode</a> </b>
                mode 值是:
                   ""                不在补全模式中
                   "keyword"         关键字补全  <a href="insert.html#i_CTRL-X_CTRL-N">i_CTRL-X_CTRL-N</a> 
                   "ctrl_x"          则按了 <code class="keystroke">CTRL-X</code>  <a href="insert.html#i_CTRL-X">i_CTRL-X</a> 
                   "whole_line"      整行  <a href="insert.html#i_CTRL-X_CTRL-L">i_CTRL-X_CTRL-L</a> 
                   "files"           文件名  <a href="insert.html#i_CTRL-X_CTRL-F">i_CTRL-X_CTRL-F</a> 
                   "tags"            标签  <a href="insert.html#i_CTRL-X_CTRL-]">i_CTRL-X_CTRL-]</a> 
                   "path_defines"    定义补全  <a href="insert.html#i_CTRL-X_CTRL-D">i_CTRL-X_CTRL-D</a> 
                   "path_patterns"   头文件补全  <a href="insert.html#i_CTRL-X_CTRL-I">i_CTRL-X_CTRL-I</a> 
                   "dictionary"      字典  <a href="insert.html#i_CTRL-X_CTRL-K">i_CTRL-X_CTRL-K</a> 
                   "thesaurus"       同义词词典  <a href="insert.html#i_CTRL-X_CTRL-T">i_CTRL-X_CTRL-T</a> 
                   "cmdline"         Vim 命令行  <a href="insert.html#i_CTRL-X_CTRL-V">i_CTRL-X_CTRL-V</a> 
                   "function"        用户定义补全  <a href="insert.html#i_CTRL-X_CTRL-U">i_CTRL-X_CTRL-U</a> 
                   "omni"            全能补全  <a href="insert.html#i_CTRL-X_CTRL-O">i_CTRL-X_CTRL-O</a> 
                   "spell"           拼写建议  <a href="insert.html#i_CTRL-X_s">i_CTRL-X_s</a> 
                   "eval"             <a href="eval.html#complete()">complete()</a>  补全
                   "unknown"         其它内部模式

                如果提供可选的 <code class="special">{what}</code> 列表参数，只返回 <code class="special">{what}</code> 中列出的项目。
                <code class="special">{what}</code> 中不支持的项目被安静地跳过。

                要得到弹出菜单的位置和大小，可见  <a href="eval.html#pum_getpos()">pum_getpos()</a> 。也可通过
                 <a href="autocmd.html#CompleteChanged">CompleteChanged</a>  事件中的  <a href="eval.html#v:event">v:event</a>  得到。

                示例: 
<code class="example">                        " 取得所有项目</code>
<code class="example">                        call complete_info()</code>
<code class="example">                        " 只要 'mode'</code>
<code class="example">                        call complete_info(['mode'])</code>
<code class="example">                        " 只要 'mode' 和 'pum_visible'</code>
<code class="example">                        call complete_info(['mode', 'pum_visible'])</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetItems()-&gt;complete_info()</code>


complete_check()                                <b class="vimtag"> <a name="complete_check()">complete_check()</a> </b>
                寻找补全匹配时，检查输入的键。如果寻找匹配需要一定时间时有用。
                如果匹配的搜索被中止，返回  <a href="eval.html#TRUE">TRUE</a> 。否则返回零。
                只能用于 <a href="options.html#'completefunc'">'completefunc'</a> 选项指定的函数里。

                                                <b class="vimtag"> <a name="confirm()">confirm()</a> </b>
confirm(<code class="special">{msg}</code> [, <code class="special">{choices}</code> [, <code class="special">{default}</code> [, <code class="special">{type}</code>]]])
                confirm() 提供用户一个对话框，从中可以作出选择。返回选择的序
                号。第一个选择为 1。
                <code class="note">注意</code>: confirm() 只有在编译时加入对话框支持才存在，见
                 <a href="various.html#+dialog_con">+dialog_con</a>  和  <a href="various.html#+dialog_gui">+dialog_gui</a> 。
                在  <a href="gui_w32.html#dialog">dialog</a>  里显示 <code class="special">{msg}</code> 消息，并提供可能的选择 <code class="special">{choices}</code>。如
                果 <code class="special">{choices}</code> 不存在或者为空，使用 "&amp;OK" (经过翻译)。
                <code class="special">{msg}</code> 是字符串，'\n' 用来包含换行符。在有些系统上该字符串在放
                不下时被回绕，但并非所有系统都如此。
                <code class="special">{choices}</code> 是一个字符串，用 '\n' 分隔各个选择，例如 
<code class="example">                        confirm("Save changes?", "&amp;Yes\n&amp;No\n&amp;Cancel")</code>
                '&amp;' 之后的字符提供该选择的快捷键。这样，你可以输入 'c' 来选择
                "Cancel"。快捷键不一定是第一个字符: 
<code class="example">                        confirm("file has been modified", "&amp;Save\nSave &amp;All")</code>
                控制台里，每个选择的第一个字符用作缺省的快捷键。
                可选的 <code class="special">{default}</code> 参数是用户按 <code class="special">&lt;CR&gt;</code> 使用的选择号。设定 1 使得第
                一个选项成为缺省，如果是 0，则不设定任何缺省。如果不提供
                <code class="special">{default}</code>，假设为 1。

                可选的 <code class="special">{type}</code> 参数指定对话框的类型。只有在 GTK、Mac、Motif 和
                Win32 GUI 上才用得上，它用以指定图标。可以取的值是: "Error"、
                "Question"、 "Info"、 "Warning" 或 "Generic"。只有第一个字符是
                重要的。如果忽略 <code class="special">{type}</code>，使用 "Generic"。

                如果用户用 <code class="special">&lt;Esc&gt;</code>、<code class="keystroke">CTRL-C</code> 或者别的合法的中断键中止对话框，
                confirm() 返回 0。

                一个例子: 
<code class="example">   :let choice = confirm("你要吃什么？", "&amp;苹果\n&amp;桔子\n&amp;香蕉", 2)</code>
<code class="example">   :if choice == 0</code>
<code class="example">   :    echo "快下定决心！"</code>
<code class="example">   :elseif choice == 3</code>
<code class="example">   :    echo "好吃"</code>
<code class="example">   :else</code>
<code class="example">   :    echo "我本人喜欢香蕉。"</code>
<code class="example">   :endif</code>
                GUI 的对话框使用按钮。按钮的排放方式取决于 <a href="options.html#'guioptions'">'guioptions'</a> 里的
                'v' 标志位。如果包含该标志位，按钮总是竖排的。不然，confirm()
                试图把按钮放在一行里。如果放不下，那么还是使用竖排的方式。在有
                的系统上，无论如何总是使用横排。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        BuildMessage()-&gt;confirm("&amp;Yes\n&amp;No")</code>

                                                        <b class="vimtag"> <a name="copy()">copy()</a> </b>
copy(<code class="special">{expr}</code>)    构造 <code class="special">{expr}</code> 的备份。对数值和字符串而言，这和直接使用 <code class="special">{expr}</code>
                并无不同。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，建立一个浅备份。这意味着，原来的  <a href="eval.html#List">List</a> 
                可以被改变，而不会影响新建的备份。反之亦然。不过，其中的项目只
                有一份，所以修改项目同时修改两个  <a href="eval.html#List">List</a>  的内容。
                 <a href="eval.html#Dictionary">Dictionary</a>  的复制和  <a href="eval.html#List">List</a>  类似。
                另见  <a href="eval.html#deepcopy()">deepcopy()</a> 。
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;copy()</code>
<code class="example"></code>
cos(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="cos()">cos()</a> </b>
                返回浮点数，即以弧度测量的 <code class="special">{expr}</code> 的余弦值。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        :echo cos(100)</code>
                        0.862319 
<code class="example">                        :echo cos(-4.01)</code>
                        -0.646043

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;cos()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


cosh(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="cosh()">cosh()</a> </b>
                返回 <code class="special">{expr}</code> 的双曲余弦值，返回值为 [1, inf] 区间内的浮点数。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        :echo cosh(0.5)</code>
                        1.127626 
<code class="example">                        :echo cosh(-0.5)</code>
                        -1.127626

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;cosh()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


count(<code class="special">{comp}</code>, <code class="special">{expr}</code> [, <code class="special">{ic}</code> [, <code class="special">{start}</code>]])                      <b class="vimtag"> <a name="count()">count()</a> </b>
                返回  <a href="eval.html#String">String</a> 、 <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  <code class="special">{comp}</code> 里值为 <code class="special">{expr}</code> 的
                项目出现的次数。

                如果给出 <code class="special">{start}</code>，从该索引指定的项目开始。<code class="special">{start}</code> 只能用于
                 <a href="eval.html#List">List</a> 。

                如果给出 <code class="special">{ic}</code> 并且为  <a href="eval.html#TRUE">TRUE</a> ，忽略大小写。

                <code class="special">{comp}</code> 为字符串时返回 <code class="special">{expr}</code> 不重叠的出现次数。<code class="special">{expr}</code> 为空串时
                返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;count(val)</code>

                                                        <b class="vimtag"> <a name="cscope_connection()">cscope_connection()</a> </b>
cscope_connection([<code class="special">{num}</code> , <code class="special">{dbpath}</code> [, <code class="special">{prepend}</code>]])
                检查  <a href="if_cscop.html#cscope">cscope</a>  连接是否存在。如果没有参数，则函数返回:
                        0，如果 cscope 不存在 (编译没有带该特性)，或者不存在
                           cscope 连接；
                        1，如果至少有一个 cscope 连接。

                如果指定了参数，那么 <code class="special">{num}</code> 的值指定如何检查 cscope 连接存在与
                否的方式:

<code class="section">                <code class="special">{num}</code>   存在检查的方式描述 </code>
                -----   ------------------------------
                0       等同于无参数 (例如，"cscope_connection()")。
                1       忽略 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 的字符串部分匹配。
                2       忽略 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 的字符串完整匹配。
                3       使用 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 和 <code class="special">{prepend}</code> 的字符串部
                        分匹配。
                4       使用 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 和 <code class="special">{prepend}</code> 的字符串完
                        整匹配。

                <code class="note">注意</code>: 所有的字符串比较都对大小写敏感！

                示例。假定我们有如下设置 (":cs show" 的输出): 
<code class="example"></code>
<code class="example">  # pid    database name                        prepend path</code>
<code class="example">  0 27664  cscope.out                           /usr/local</code>

<code class="section">                启动方式                                           返回值 </code>
                ----------                                      ---------- 
<code class="example">                cscope_connection()                                     1</code>
<code class="example">                cscope_connection(1, "out")                             1</code>
<code class="example">                cscope_connection(2, "out")                             0</code>
<code class="example">                cscope_connection(3, "out")                             0</code>
<code class="example">                cscope_connection(3, "out", "local")                    1</code>
<code class="example">                cscope_connection(4, "out")                             0</code>
<code class="example">                cscope_connection(4, "out", "local")                    0</code>
<code class="example">                cscope_connection(4, "cscope.out", "/usr/local")        1</code>

cursor(<code class="special">{lnum}</code>, <code class="special">{col}</code> [, <code class="special">{off}</code>])                         <b class="vimtag"> <a name="cursor()">cursor()</a> </b>
cursor(<code class="special">{list}</code>)
                把光标定位在第 <code class="special">{lnum}</code> 行的第 <code class="special">{col}</code> 列 (字节计数)。第一列为 1。

                如果只有一个参数 <code class="special">{list}</code>，它被看作带两个、三个或四个参数的
                 <a href="eval.html#List">List</a> :
                        [<code class="special">{lnum}</code>, <code class="special">{col}</code>]
                        [<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{off}</code>]
                        [<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{off}</code>, <code class="special">{curswant}</code>]
                和  <a href="eval.html#getpos()">getpos()</a>  和  <a href="eval.html#getcurpos()">getcurpos()</a>  的返回值类似，但没有第一项。

                不改变跳转表。
                如果 <code class="special">{lnum}</code> 超过缓冲区的行数，光标定位在缓冲区的末行。
                如果 <code class="special">{lnum}</code> 为零，光标留在当前行。
                如果 <code class="special">{col}</code> 超过该行的字节数，光标定位在该行的最后一个字符上。
                如果 <code class="special">{col}</code> 为零，光标留在当前列。
                如果 <code class="special">{curswant}</code> 给出，它被用于设置垂直移动的首选列，否则使用
                <code class="special">{col}</code>。

                如果使用 <a href="options.html#'virtualedit'">'virtualedit'</a>，<code class="special">{off}</code> 指定从该字符开始以屏幕列计算的偏
                移。例如，在制表里或者在最后一个字符之后的某个位置。
                如果定位成功，返回 0，否则返回 -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCursorPos()-&gt;cursor()</code>
<code class="example"></code>
debugbreak(<code class="special">{pid}</code>)                                       <b class="vimtag"> <a name="debugbreak()">debugbreak()</a> </b>
                专用于中断待调试的程序。给进程 <code class="special">{uid}</code> 发送 SIGTRAP。其它进程的
                行为未指定。见  <a href="terminal.html#terminal-debugger">terminal-debugger</a> 。
                <code class="notvi">{仅适用于 MS-Windows}</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPid()-&gt;debugbreak()</code>
<code class="example"></code>
deepcopy(<code class="special">{expr}</code> [, <code class="special">{noref}</code>])                            <b class="vimtag"> <a name="deepcopy()">deepcopy()</a> </b> <b class="vimtag"> <a name="E698">E698</a> </b>
                构造 <code class="special">{expr}</code> 的备份。对数值和字符串而言，这和直接使用 <code class="special">{expr}</code>
                并无不同。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，建立一个完整的备份。这意味着，原来的
                 <a href="eval.html#List">List</a>  可以被改变，而不会影响新建的备份。反之亦然。如果某个项
                目是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> ，递归地建立它的备份。这样，备份里
                项目的修改也不会影响到原来  <a href="eval.html#List">List</a>  的内容。
                 <a href="eval.html#Dictionary">Dictionary</a>  的复制和  <a href="eval.html#List">List</a>  类似。
                如果省略 <code class="special">{noref}</code> 或为零，包含的  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  只复制
                一次。所有指向它的引用指向此一备份。如果 <code class="special">{noref}</code> 设为 1，每次
                 <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  的出现会导致建立一个新的备份。这意味着
                循环引用会使得 deepcopy() 失败。
                                                                <b class="vimtag"> <a name="E724">E724</a> </b>
                嵌套可达 100 层。如果有指向较高层的引用，<code class="special">{noref}</code> 为 1 的深备份
                会失败。
                另见  <a href="eval.html#copy()">copy()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetObject()-&gt;deepcopy()</code>
<code class="example"></code>
delete(<code class="special">{fname}</code> [, <code class="special">{flags}</code>])                                     <b class="vimtag"> <a name="delete()">delete()</a> </b>
                无 <code class="special">{flags}</code> 或 <code class="special">{flags}</code> 为空: 删除名为 <code class="special">{fname}</code> 的文件。<code class="special">{fname}</code>
                是符号链接也可以。

                如果 <code class="special">{flags}</code> 是 "d": 删除名为 <code class="special">{fname}</code> 的目录。如果目录 <code class="special">{fname}</code>
                非空会失败。

                如果 <code class="special">{flags}</code> 是 "rf": 递归删除名为 <code class="special">{fname}</code> 的目录和其下的所有
                文件。 <code class="emphasis">要小心</code> ！
                <code class="note">备注</code>: 在 MS-Windows 上不能删除正在使用的目录。

                符号链接本身被删除，而不是它链接到的文件。

                返回类型为数值。如果成功删除文件，返回 0，如果删除失败或部分失
                败，返回 -1。

                从  <a href="eval.html#List">List</a>  里删除项目请用  <a href="eval.html#remove()">remove()</a> 。
                要删除缓冲区的行用  <a href="change.html#:delete">:delete</a>  或  <a href="eval.html#deletebufline()">deletebufline()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;delete()</code>
<code class="example"></code>
deletebufline(<code class="special">{expr}</code>, <code class="special">{first}</code> [, <code class="special">{last}</code>])               <b class="vimtag"> <a name="deletebufline()">deletebufline()</a> </b>
                删除缓冲区 <code class="special">{expr}</code> 中 <code class="special">{first}</code> 到 <code class="special">{last}</code> (闭区间) 的文本行。
                如果省略 <code class="special">{last}</code>，只删除第 <code class="special">{first}</code> 行。
                成功时返回 0，失败时返回 1。

                此函数只能用于已载入的缓冲区。有必要的话先调用  <a href="eval.html#bufload()">bufload()</a> 。

                <code class="special">{expr}</code> 的用法见上述的  <a href="eval.html#bufname()">bufname()</a> 。

                <code class="special">{first}</code> 和 <code class="special">{last}</code> 的用法类似于  <a href="eval.html#getline()">getline()</a> 。<code class="note">注意</code>  <a href="eval.html#line()">line()</a>  指定
                当前缓冲区。"$" 指定缓冲区 <code class="special">{expr}</code> 的末行。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;deletebufline(1)</code>

                                                        <b class="vimtag"> <a name="did_filetype()">did_filetype()</a> </b>
did_filetype()  如果执行自动命令时，激活 FileType 事件至少一次，则返回
                 <a href="eval.html#TRUE">TRUE</a> 。可以用于防止在检测文件类型的脚本里再次激活 FileType 事
                件。 <a href="autocmd.html#FileType">FileType</a> 
                如果用过 ":setf FALLBACK"，返回  <a href="eval.html#FALSE">FALSE</a> 。
                如果编辑另外一个文件，该计数被复位，因而这只能检查 FileType 事
                件是否在当前缓冲区里激活过。它允许开始编辑另一个缓冲区的自动命
                令设置 <a href="options.html#'filetype'">'filetype'</a> 并载入语法文件。

diff_filler(<code class="special">{lnum}</code>)                                     <b class="vimtag"> <a name="diff_filler()">diff_filler()</a> </b>
                返回第 <code class="special">{lnum}</code> 行之上的填充行的数目。
                这些是在另一个进行比较的窗口里在此位置插入的行。这些填充行在屏
                幕上显示，但缓冲区里并不存在。
                <code class="special">{lnum}</code> 的用法类似于  <a href="eval.html#getline()">getline()</a> 。所以 "." 是当前行，"'m" 是位
                置标记 m，等等。
                如果当前窗口不处于比较模式，返回 0。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;diff_filler()</code>
<code class="example"></code>
diff_hlID(<code class="special">{lnum}</code>, <code class="special">{col}</code>)                                <b class="vimtag"> <a name="diff_hlID()">diff_hlID()</a> </b>
                返回比较模式下行 <code class="special">{lnum}</code> 和列 <code class="special">{col}</code> (字节位置) 所在的高亮 ID。
                如果当前行没有差异，返回零。
                <code class="special">{lnum}</code> 的用法类似于  <a href="eval.html#getline()">getline()</a> 。所以 "." 是当前行，"'m" 是位
                置标记 m，等等。
                最左列的 <code class="special">{col}</code> 为 1，第一行的 <code class="special">{lnum}</code> 为 1。
                高亮 ID 可以用于  <a href="eval.html#synIDattr()">synIDattr()</a> ，以得到高亮对应的语法信息。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;diff_hlID(col)</code>
environ()                                               <b class="vimtag"> <a name="environ()">environ()</a> </b>
                返回所有的环境变量构成的字典。可以这样检查某个环境变量是否存
                在: 
<code class="example">                        :echo has_key(environ(), 'HOME')</code>
                <code class="note">注意</code> 变量名可以是驼峰式 (CamelCase) 的，要忽略大小写，可以这
                样: 
<code class="example">                        :echo index(keys(environ()), 'HOME', 0, 1) != -1</code>
<code class="example"></code>
<code class="example"></code>
empty(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="empty()">empty()</a> </b>
                如果 <code class="special">{expr}</code> 为空，返回数值 1，否则返回 0。
                -  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  没有项目时为空。
                -  <a href="eval.html#String">String</a>  的长度为零时为空。
                -  <a href="eval.html#Number">Number</a>  或  <a href="eval.html#Float">Float</a>  的值为零时为空。
                -  <a href="eval.html#v:false">v:false</a> 、 <a href="eval.html#v:none">v:none</a>  和  <a href="eval.html#v:null">v:null</a>  为空， <a href="eval.html#v:true">v:true</a>  不是。
                - 启动失败的  <a href="eval.html#Job">Job</a>  为空。
                - 己关闭的  <a href="eval.html#Channel">Channel</a>  为空。
                -  <a href="eval.html#Blob">Blob</a>  的长度为零时为空。

                如果  <a href="eval.html#List">List</a>  很大，这比把长度和零比较要快得多。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;empty()</code>
<code class="example"></code>
escape(<code class="special">{string}</code>, <code class="special">{chars}</code>)                               <b class="vimtag"> <a name="escape()">escape()</a> </b>
                在 <code class="special">{string}</code> 里用反斜杠转义 <code class="special">{chars}</code> 里的字符。例如: 
<code class="example">                        :echo escape('c:\program files\vim', ' \')</code>
                返回: 
<code class="example">                        c:\\program\ files\\vim</code>
                另见  <a href="eval.html#shellescape()">shellescape()</a>  和  <a href="eval.html#fnameescape()">fnameescape()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;escape(' \')</code>

                                                        <b class="vimtag"> <a name="eval()">eval()</a> </b>
eval(<code class="special">{string}</code>)  计算 <code class="special">{string}</code> 并返回其结果。这对把  <a href="eval.html#string()">string()</a>  的结果转换为原来
                的值尤其有用。适用于数值、浮点数、字符串、blob 和它们的复合类
                型。也可用于指向已有函数的  <a href="eval.html#Funcref">Funcref</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        argv-&gt;join()-&gt;eval()</code>
<code class="example"></code>
eventhandler()                                          <b class="vimtag"> <a name="eventhandler()">eventhandler()</a> </b>
                如果在事件处理中则返回 1。此时，Vim 在等待用户输入一个字符的时
                候被中断，比如，在 Vim 上拖放了一个文件。这也意味着此时不能使
                用交互的命令。如果不是，返回零。

executable(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="executable()">executable()</a> </b>
                本函数检查名字由 <code class="special">{expr}</code> 指定的可执行文件存在与否。<code class="special">{expr}</code> 必须
                是程序不带任何参数的名字。
                executable() 使用 $PATH 的值和/或程序的普通的搜索路径。
                                                        <b class="vimtag"> <a name="PATHEXT">PATHEXT</a> </b>
                MS-Windows 上，可以可选地包含 ".exe"、".bat" 等。为此，
                $PATHEXT 里的扩展名会被尝试。这样，如果 "foo.exe" 不存在，可能
                会找到 "foo.exe.bat"。如果没有设置 $PATHEXT，使用的是
                ".exe;.com;.bat;.cmd"。$PATHEXT 里可以使用单独的句号，以尝试没
                有扩展名的名字。如果 <a href="options.html#'shell'">'shell'</a> 看起来像 Unix 外壳，那么也尝试没
                有扩展名的名字。
                MS-Windows 上，只检查是否文件存在且不是目录，并不检查它是否真
                的可以执行。
                MS-Windows 上，和 Vim 在同一目录的可执行文件总能找到。因为这个
                目录加到了 $PATH 里，执行应该也没有问题  <a href="os_win32.html#win32-PATH">win32-PATH</a> 。
                返回数值:
                        1       存在
                        0       不存在
                        -1      此系统中没有实现
                 <a href="eval.html#exepath()">exepath()</a>  可用于获取可执行文件的完整路径。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCommand()-&gt;executable()</code>
<code class="example"></code>
execute(<code class="special">{command}</code> [, <code class="special">{silent}</code>])                                 <b class="vimtag"> <a name="execute()">execute()</a> </b>
                执行 Ex 命令或命令序列，返回结果为字符串。
                <code class="special">{command}</code> 可以是字符串或列表。如果是列表，逐行执行命令。
                等价于: 
<code class="example">                        redir =&gt; var</code>
<code class="example">                        {command}</code>
<code class="example">                        redir END</code>

                可选的 <code class="special">{silent}</code> 参数可取以下的值:
                        ""              不用  <a href="various.html#:silent">:silent</a> 
                        "silent"        用  <a href="various.html#:silent">:silent</a> 
                        "silent!"       用  <a href="various.html#:silent!">:silent!</a> 
                缺省是 "silent"。<code class="note">注意</code> 用 "silent!" 时，和  <a href="various.html#:redir">:redir</a>  不同，错误
                被忽略。使用外部命令时，屏幕可能会搞乱，可用  <a href="eval.html#system()">system()</a>  代替。
                                                        <b class="vimtag"> <a name="E930">E930</a> </b>
                <code class="special">{command}</code> 里不可用  <a href="various.html#:redir">:redir</a> 。

                要得到行的列表，在结果上用  <a href="eval.html#split()">split()</a> : 
<code class="example">                        split(execute('args'), "\n")</code>
<code class="example"></code>
                要在非当前窗口的其它窗口中执行命令，用  <a href="eval.html#win_execute()">win_execute()</a> 。

                递归调用时，内层的输出结果不包含在外层的结果里。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCommand()-&gt;execute()</code>
<code class="example"></code>
exepath(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="exepath()">exepath()</a> </b>
                如果 <code class="special">{expr}</code> 是可执行文件并且是绝对路径、相对路径或可在 $PATH
                是找到，返回完整路径。
                <code class="note">注意</code> 如果 <code class="special">{expr}</code> 以 "./" 开始，使用当前路径，这对 Vim 可能是个
                问题: 
<code class="example">                        echo exepath(v:progpath)</code>
                如果 <code class="special">{expr}</code> 在 $PATH 里找不到，或者不可执行，返回空字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCommand()-&gt;exepath()</code>

                                                        <b class="vimtag"> <a name="exists()">exists()</a> </b>
exists(<code class="special">{expr}</code>)  返回数值，如果 <code class="special">{expr}</code> 被定义，返回  <a href="eval.html#TRUE">TRUE</a> ，不然返回零。

                要检查某特性是否支持，用  <a href="eval.html#has()">has()</a> 。
                要检查文件是否存在，用  <a href="eval.html#filereadable()">filereadable()</a> 。

                <code class="special">{expr}</code> 参数是字符串，可以使用以下选择之一:
                        &amp;option-name    Vim 选项 (只检查是否存在，而不是是否工
                                        作)
                        +option-name    能工作的 Vim 选项。
                        $ENVNAME        环境变量 (也可以通过和空字符串比较完
                                        成)
                        *funcname       内建函数 (见  <a href="eval.html#functions">functions</a> ) 或者用户定义
                                        的函数 (见  <a href="eval.html#user-functions">user-functions</a> )。也可用于
                                        指向函数引用的变量。
                        varname         内部变量 (见  <a href="eval.html#internal-variables">internal-variables</a> )。也
                                        适用于  <a href="eval.html#curly-braces-names">curly-braces-names</a> 、
                                         <a href="eval.html#Dictionary">Dictionary</a>  项目、 <a href="eval.html#List">List</a>  项目等等。
                                        小心计算索引时可能会因为非法的表达式产
                                        生错误信息。例如: 
<code class="example">                                           :let l = [1, 2, 3]</code>
<code class="example">                                           :echo exists("l[5]")</code>
                                           0 
<code class="example">                                           :echo exists("l[xx]")</code>
                                           E121: Undefined variable: xx
                                           0

                        :cmdname        Ex 命令: 内建命令、用户命令或者命令修
                                        饰符  <a href="map.html#:command">:command</a> 。
                                        返回:
                                        1  匹配命令的开始
                                        2  完整匹配命令
                                        3  匹配多个用户命令
                                        要检查命令是否支持，检查返回值是否为
                                        2。
                        :2match          <a href="pattern.html#:2match">:2match</a>  命令。
                        :3match          <a href="pattern.html#:3match">:3match</a>  命令。
                        #event          符合此事件的自动命令
                        #event#pattern  符合此事件和此模式的自动命令 (模式按本
                                        义出现，和自动命令的模式逐字符比较)
                        #group          存在自动命令组
                        #group#event    在该组里定义并符合此事件的自动命令。
                        #group#event#pattern
                                        为该组定义、符合事件和模式的自动命令。
                        ##event         支持此事件的自动命令。

                例如: 
<code class="example">                        exists("&amp;shortname")</code>
<code class="example">                        exists("$HOSTNAME")</code>
<code class="example">                        exists("*strftime")</code>
<code class="example">                        exists("*s:MyFunc")</code>
<code class="example">                        exists("bufcount")</code>
<code class="example">                        exists(":Make")</code>
<code class="example">                        exists("#CursorHold")</code>
<code class="example">                        exists("#BufReadPre#*.gz")</code>
<code class="example">                        exists("#filetypeindent")</code>
<code class="example">                        exists("#filetypeindent#FileType")</code>
<code class="example">                        exists("#filetypeindent#FileType#*")</code>
<code class="example">                        exists("##ColorScheme")</code>
                符号 (&amp;/$/*/#) 和名字之间不能有空格。
                名字之后不能有附加字符，虽然现在有一些情况下会忽略这些字符，但
                将来的检查可能更严格。所以不要依赖此行为！
                可以通过的例子: 
<code class="example">                        exists(":make")</code>
                 <code class="emphasis">不</code> 能通过的例子: 
<code class="example">                        exists(":make install")</code>
<code class="example"></code>
                <code class="note">注意</code> 参数必须是字符串，不是变量的名字本身。例如: 
<code class="example">                        exists(bufcount)</code>
                不检查 "bufcount" 变量是否存在，而是提取 "bufcount" 的值，并检
                查其 (根据此处的语法) 是否存在。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Varname()-&gt;exists()</code>
<code class="example"></code>
exp(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="exp()">exp()</a> </b>
                返回 <code class="special">{expr}</code> 的指数函数值，返回值为 [0, inf] 区间内的浮点数。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        :echo exp(2)</code>
                        7.389056 
<code class="example">                        :echo exp(-1)</code>
                        0.367879

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;exp()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


expand(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code>]])                           <b class="vimtag"> <a name="expand()">expand()</a> </b>
                扩展 <code class="special">{expr}</code> 里的通配符和下列特殊关键字。
                <a href="options.html#'wildignorecase'">'wildignorecase'</a> 此处适用。

                如果给出 <code class="special">{list}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，返回列表。否则返回的是字符串，且
                如果返回多个匹配，以 <code class="special">&lt;NL&gt;</code> 字符分隔 [<code class="note">备注</code>: 5.0 版本使用空格。但
                是文件名如果也包含空格就会有问题]。

                如果扩展失败，返回空字符串。如果 <code class="special">{expr}</code> 以 '%'，'#' 或 '&lt;' 开
                始，不返回不存在的文件名。详见下。

                如果 <code class="special">{expr}</code> 以 '%'、'#' 或 '&lt;' 开始，以类似于
                 <a href="cmdline.html#cmdline-special">cmdline-special</a>  变量的方式扩展，包括相关的修饰符。这里是一个
                简短的小结:

                        %               当前文件名
                        #               轮换文件名
                        #n              轮换文件名 n
                        <code class="special">&lt;cfile&gt;</code>         光标所在的文件名
                        <code class="special">&lt;afile&gt;</code>         自动命令文件名
                        <code class="special">&lt;abuf&gt;</code>          自动命令缓冲区号 (以字符串形式出现！)
                        <code class="special">&lt;amatch&gt;</code>        自动命令匹配的名字
                        <code class="special">&lt;sfile&gt;</code>         载入的脚本文件或函数名
                        <code class="special">&lt;slnum&gt;</code>         载入脚本文件行号或函数行号
                        <code class="special">&lt;sflnum&gt;</code>        载入脚本文件行号，即使在函数中亦然
                        <code class="special">&lt;cword&gt;</code>         光标所在的单词
                        <code class="special">&lt;cWORD&gt;</code>         光标所在的字串 (WORD)
                        <code class="special">&lt;client&gt;</code>        最近收到的消息的 <code class="special">{clientid}</code>
                                         <a href="eval.html#server2client()">server2client()</a> 
                修饰符:
                        :p              扩展为完整的路径
                        :h              头部 (去掉最后一个部分)
                        :t              尾部 (只保留最后一个部分)
                        :r              根部 (去掉一个扩展名)
                        :e              只有扩展名

                例如: 
<code class="example">                        :let &amp;tags = expand("%:p:h") . "/tags"</code>
                <code class="note">注意</code> 扩展 '%'、'#' 或者 '&lt;' 开头的字符串的时候，其后的文本被忽
                略。这样 <code class="emphasis">不</code> 行: 
<code class="example">                        :let doesntwork = expand("%:h.bak")</code>
                应该这样: 
<code class="example">                        :let doeswork = expand("%:h") . ".bak"</code>
                还要 <code class="note">注意</code> 扩展 "<code class="special">&lt;cfile&gt;</code>" 和其它形式只能返回被引用的文件名，而
                不会进一步扩展。如果 "<code class="special">&lt;cfile&gt;</code>" 是 "~/.cshrc"，你需要执行另一个
                expand() 把 "~/" 扩展为主目录的路径: 
<code class="example">                        :echo expand(expand("&lt;cfile&gt;"))</code>

                变量名和其后的修饰符之间不能有空白。 <a href="eval.html#fnamemodify()">fnamemodify()</a>  函数可以用
                来修改普通的文件名。

                使用 '%' 或 '#' 但当前或轮换文件名没有定义的时候，使用空字符
                串。在无名缓冲区使用 "%:p"  生成当前目录，后加一个 '/'。

                如果 <code class="special">{expr}</code> 不以 '%'、'#' 或 '&lt;' 开始，它以命令行上的文件名那
                样被扩展。使用 <a href="options.html#'suffixes'">'suffixes'</a> 和 <a href="options.html#'wildignore'">'wildignore'</a>，除非给出可选的
                <code class="special">{nosuf}</code> 参数而且为  <a href="eval.html#TRUE">TRUE</a> 。
                这里可以有不存在的文件的名字。"**" 项目可以用来在目录树里查找
                。例如，要寻找当前目录及其下目录的所有的 "README": 
<code class="example">                        :echo expand("**/README")</code>

                expand() 也可用来扩展变量和只有外壳知道的环境变量。但这会很
                慢，因为需要使用外壳才能进行扩展。见  <a href="eval.html#expr-env-expand">expr-env-expand</a> 。
                扩展后的变量还是被当作文件名的列表处理。如果不能扩展环境变量，
                保留其不变。这样， ":echo expand('$FOOBAR')" 返回的还是
                "$FOOBAR"。

                 <a href="eval.html#glob()">glob()</a>  说明如何找到存在的文件。 <a href="eval.html#system()">system()</a>  说明如何得到外部命
                令的原始输出。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Getpattern()-&gt;expand()</code>
<code class="example"></code>
expandcmd(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="expandcmd()">expandcmd()</a> </b>
                像  <a href="editing.html#:edit">:edit</a>  这样的 Ex 命令那样扩展 <code class="special">{expr}</code> 里的特殊项目。在
                <code class="special">{expr}</code> 的所有位置像  <a href="eval.html#expand()">expand()</a>  那样扩展特殊关键字，也扩展环境
                变量。"~user" 和 "~/path" 只在开始处被扩展。
                返回扩展后的字符串。示例: 
<code class="example">                        :echo expandcmd('make %&lt;.o')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCommand()-&gt;expandcmd()</code>

extend(<code class="special">{expr1}</code>, <code class="special">{expr2}</code> [, <code class="special">{expr3}</code>])                    <b class="vimtag"> <a name="extend()">extend()</a> </b>
                <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 必须都是  <a href="eval.html#List">List</a>  或者都是  <a href="eval.html#Dictionary">Dictionary</a> 。

                如果都是  <a href="eval.html#List">List</a> : 把 <code class="special">{expr2}</code> 附加到 <code class="special">{expr1}</code> 之后。
                如果给出 <code class="special">{expr3}</code>，把 <code class="special">{expr2}</code> 里的项目加到 <code class="special">{expr1}</code> 的第 <code class="special">{expr3}</code>
                个项目之前。如果 <code class="special">{expr3}</code> 为零，插在第一个项目之前。如果
                <code class="special">{expr3}</code> 等于 len(<code class="special">{expr1}</code>)，那么 <code class="special">{expr2}</code> 会附加在最后。
                例如: 
<code class="example">                        :echo sort(extend(mylist, [7, 5]))</code>
<code class="example">                        :call extend(mylist, [2, 3], 1)</code>
                如果 <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 是同一个列表，复制的项目数等于列表原来
                的长度。例如，如果 <code class="special">{expr}</code> 为 1，则复制列表首值 N 次 (N 是列表
                原来的长度)。
                用  <a href="eval.html#add()">add()</a>  把一个项目加入列表。要连接两个列表成为一个新列表，
                用 + 操作符: 
<code class="example">                        :let newlist = [1, 2, 3] + [4, 5]</code>

                如果都是  <a href="eval.html#Dictionary">Dictionary</a> : 把 <code class="special">{expr2}</code> 里的所有项目加入 <code class="special">{expr1}</code>。
                如果 <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 包含相同的键，那么 <code class="special">{expr3}</code> 决定应该怎
                么做:
                <code class="special">{expr3}</code> = "keep": 保持 <code class="special">{expr1}</code> 的值
                <code class="special">{expr3}</code> = "force": 使用 <code class="special">{expr2}</code> 的值
                <code class="special">{expr3}</code> = "error": 给出错误信息                         <b class="vimtag"> <a name="E737">E737</a> </b>
                如果省略 <code class="special">{expr3}</code>，假设使用 "force"。

                只要 <code class="special">{expr2}</code> 非空，<code class="special">{expr1}</code> 就被改变。如果需要，给 <code class="special">{expr1}</code> 先做
                个备份。
                <code class="special">{expr2}</code> 保持不变。
                如果 <code class="special">{expr1}</code> 被锁住且 <code class="special">{expr2}</code> 非空，操作失败。
                返回 <code class="special">{expr1}</code>。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;extend(otherlist)</code>
<code class="example"></code>
<code class="example"></code>
feedkeys(<code class="special">{string}</code> [, <code class="special">{mode}</code>])                           <b class="vimtag"> <a name="feedkeys()">feedkeys()</a> </b>
                将 <code class="special">{string}</code> 里的字符放在队列里等候处理，就像它们来自映射或者用
                户输入一样。

                缺省它们加在预输入 (typeahead) 缓冲区的尾端，所以如果
                仍然在执行映射，这些字符会出现在映射内容之后。用 'i' 标志位则
                插入位置在其它字符之前，这样，它们在映射其它字符之前就会执行。

                该函数不会等待 <code class="special">{string}</code> 包含的键处理完毕。

                <code class="special">{string}</code> 如果要包含特殊键，可以使用双引号和 "\..." 记法
                 <a href="eval.html#expr-quote">expr-quote</a> 。例如，feedkeys("\<code class="special">&lt;CR&gt;</code>") 会模拟 <code class="special">&lt;Enter&gt;</code> 键击。但
                feedkeys('\<code class="special">&lt;CR&gt;</code>') 却实际压入五个字符。
                一个可能有用的特殊代码是 <code class="special">&lt;Ignore&gt;</code>，它会结束等待字符输入而不做
                任何事。                                <b class="vimtag"> <a name="%3CIgnore%3E">&lt;Ignore&gt;</a> </b>

                <code class="special">{mode}</code> 是字符串，包含以下字符标志位:
                'm'     对键重映射。缺省。如果不给出 <code class="special">{mode}</code>，键会经过重映射。
                'n'     不对键重映射。
                't'     像用户输入那样处理键；如果不包含，像来自映射一样处理。
                        这会影响撤销、打开折叠等行为。
                'L'     底层输入。只用于 Unix 或 GUI。键的使用就像来自终端那
                        样。不使用其它标志位。          <b class="vimtag"> <a name="E980">E980</a> </b>
                'i'     插入字符串而不是附加 (见上)。
                'x'     执行命令，直至预输入为空为止。和 ":normal!" 类似。可以
                        不带 'x' 执行 feedkeys() 数次，然后一次性执行带 'x' 的
                        (可以只带空 <code class="special">{string}</code>) 来执行所有的输入。<code class="note">注意</code> Vim 退出
                        插入模式时行为就如同按了 <code class="special">&lt;Esc&gt;</code> 那样，以避免在脚本可以
                        继续前等待字符键入的阻塞情况。
                        <code class="note">注意</code> 你执行命令时调用了 feedkeys()，会导致递归调用，而
                        所有的预输入会被最后的那个调用消耗。
                '!'     使用 'x' 时不停止插入模式。可用于使定时器稍晚点才退出
                        插入状态的测试环境。对测试 CursorHoldI 有用。

                返回值总为 0。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetInput()-&gt;feedkeys()</code>
<code class="example"></code>
filereadable(<code class="special">{file}</code>)                                    <b class="vimtag"> <a name="filereadable()">filereadable()</a> </b>
                返回数值，如果名为 <code class="special">{file}</code> 的文件存在且可读，则为  <a href="eval.html#TRUE">TRUE</a> 。如果
                <code class="special">{file}</code> 不存在，或者是一个目录，返回  <a href="eval.html#FALSE">FALSE</a> 。<code class="special">{file}</code> 可以是任何
                返回字符串的表达式。
                如果你不关心文件是否可读，可用  <a href="eval.html#glob()">glob()</a> 。
                按本义使用 <code class="special">{file}</code>，你可能需要先扩展通配符: 
<code class="example">                        echo filereadable('~/.vimrc')</code>
<code class="example">                        0</code>
<code class="example">                        echo filereadable(expand('~/.vimrc'))</code>
<code class="example">                        1</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;filereadable()</code>
                                                        <b class="vimtag"> <a name="file_readable()">file_readable()</a> </b>
                已废弃的名字: file_readable()。


filewritable(<code class="special">{file}</code>)                                    <b class="vimtag"> <a name="filewritable()">filewritable()</a> </b>
                返回数值，如果名为 <code class="special">{file}</code> 的文件存在且可写，则为 1。如果
                <code class="special">{file}</code> 不存在，或者不可写，返回 0。如果 <code class="special">{file}</code> 是一个目录但是
                可写，返回 2。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;filewriteable()</code>
<code class="example"></code>
<code class="example"></code>
filter(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                <b class="vimtag"> <a name="filter()">filter()</a> </b>
                <code class="special">{expr1}</code> 必须是  <a href="eval.html#List">List</a>  或者  <a href="eval.html#Dictionary">Dictionary</a> 。
                对 <code class="special">{expr1}</code> 里的每个项目计算 <code class="special">{expr2}</code>，如果结果为零，从该  <a href="eval.html#List">List</a> 
                或  <a href="eval.html#Dictionary">Dictionary</a>  里删除该项目。
                <code class="special">{expr2}</code> 必须是  <a href="eval.html#string">string</a>  或  <a href="eval.html#Funcref">Funcref</a> 。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#string">string</a> ，<code class="special">{expr2}</code> 内的  <a href="eval.html#v:val">v:val</a>  包含当前项目的
                值。 <a href="eval.html#Dictionary">Dictionary</a>  中  <a href="eval.html#v:key">v:key</a>  包含当前项目的键。 <a href="eval.html#List">List</a>  中
                 <a href="eval.html#v:key">v:key</a>  包含当前项目的索引。
                例如: 
<code class="example">                        call filter(mylist, 'v:val !~ "OLD"')</code>
                删除所有出现 "OLD" 的项目。 
<code class="example">                        call filter(mydict, 'v:key &gt;= 8')</code>
                删除所有键小于 8 的值。 
<code class="example">                        call filter(var, 0)</code>
                删除所有的值，从而清除该  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#Funcref">Funcref</a> ，它必须接受两个参数:
                        1. 当前项目的键或索引。
                        2. 当前项目的值。
                如果该项目应保留，此函数必须返回  <a href="eval.html#TRUE">TRUE</a> 。
                例如要保留列表中奇数项目: 
<code class="example">                        func Odd(idx, val)</code>
<code class="example">                          return a:idx % 2 == 1</code>
<code class="example">                        endfunc</code>
<code class="example">                        call filter(mylist, function('Odd'))</code>
                使用  <a href="eval.html#lambda">lambda</a>  会更短: 
<code class="example">                        call filter(myList, {idx, val -&gt; idx * val &lt;= 42})</code>
                如果不用 "val"，可以不写: 
<code class="example">                        call filter(myList, {idx -&gt; idx % 2 == 1})</code>

                该操作是原位操作 (直接在输入上修改)。要想不更动  <a href="eval.html#List">List</a>  或
                 <a href="eval.html#Dictionary">Dictionary</a> ，先建立备份: 
<code class="example">                        :let l = filter(copy(mylist), 'v:val =~ "KEEP"')</code>
<code class="example"></code>
                返回 <code class="special">{expr1}</code>，经过过滤的  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。如果执行
                <code class="special">{expr2}</code> 有错，不再处理 <code class="special">{expr1}</code> 的其余项目。<code class="special">{expr2}</code> 是函数引用
                时，忽略函数里的错误，除非该函数用 "abort" 标志位定义。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;filter(expr2)</code>
<code class="example"></code>
finddir(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{count}</code>]])                          <b class="vimtag"> <a name="finddir()">finddir()</a> </b>
                在 <code class="special">{path}</code> 里查找目录 <code class="special">{name}</code>。支持向下和向上的递归目录搜索。
                <code class="special">{path}</code> 的语法参见  <a href="editing.html#file-searching">file-searching</a> 。
                返回第一个找到的路径。如果找到的
                路径在当前目录之下，返回相对路径。否则，返回完整路径。
                如果省略 <code class="special">{path}</code>，使用 <a href="options.html#'path'">'path'</a>。
                如果给出可选的 <code class="special">{count}</code>，寻找 <code class="special">{path}</code> 里 <code class="special">{name}</code> 第 <code class="special">{count}</code> 次出
                现，而不是第一次。
                如果 <code class="special">{count}</code> 为负，返回所有的匹配的列表。
                这和 ex 命令  <a href="editing.html#:find">:find</a>  非常类似。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+file_in_path">+file_in_path</a>  特性才有效}</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;finddir()</code>
<code class="example"></code>
findfile(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{count}</code>]])                         <b class="vimtag"> <a name="findfile()">findfile()</a> </b>
                类似于  <a href="eval.html#finddir()">finddir()</a> ，不过寻找文件而不是目录。
                使用 <a href="options.html#'suffixesadd'">'suffixesadd'</a>。
                例如: 
<code class="example">                        :echo findfile("tags.vim", ".;")</code>
                从当前文件所在的目录开始往上搜索，直到找到文件 "tags.vim" 为
                止。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;findfile()</code>
<code class="example"></code>
float2nr(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="float2nr()">float2nr()</a> </b>
                返回数值，即 <code class="special">{expr}</code> 省略小数点部分的结果。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                如果 <code class="special">{expr}</code> 的值超出  <a href="eval.html#Number">Number</a>  的范围，结果为 0x7fffffff 或
                -0x7fffffff (有 64-位 数值支持时，则为 0x7fffffffffffffff 或
                -0x7fffffffffffffff)。而 NaN 转换为 -0x80000000 (有64-位数
                值支持时，则为 -0x8000000000000000)。
                示例: 
<code class="example">                        echo float2nr(3.95)</code>
                        3  
<code class="example">                        echo float2nr(-23.45)</code>
                        -23  
<code class="example">                        echo float2nr(1.0e100)</code>
                        2147483647  (或 9223372036854775807) 
<code class="example">                        echo float2nr(-1.0e150)</code>
                        -2147483647 (或 -9223372036854775807) 
<code class="example">                        echo float2nr(1.0e-100)</code>
                        0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;float2nr()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


floor(<code class="special">{expr}</code>)                                                   <b class="vimtag"> <a name="floor()">floor()</a> </b>
                返回浮点数，即小于等于 <code class="special">{expr}</code> 的最大整数 (向下取整)。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        echo floor(1.856)</code>
                        1.0  
<code class="example">                        echo floor(-5.456)</code>
                        -6.0  
<code class="example">                        echo floor(4.0)</code>
                        4.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;floor()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


fmod(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                  <b class="vimtag"> <a name="fmod()">fmod()</a> </b>
                返回 <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的余数，该除法可能实际无法表达出来。选
                择某整数 i，返回 <code class="special">{expr1}</code> - i * <code class="special">{expr2}</code>，使得如果 <code class="special">{expr2}</code> 非
                零，结果和 <code class="special">{expr1}</code> 同号而绝对值小于 <code class="special">{expr2}</code> 的绝对值。如果
                <code class="special">{expr2}</code> 为零，返回零。返回值为浮点数。
                <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        :echo fmod(12.33, 1.22)</code>
                        0.13 
<code class="example">                        :echo fmod(-12.33, 1.22)</code>
                        -0.13

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;fmod(1.22)</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


fnameescape(<code class="special">{string}</code>)                                   <b class="vimtag"> <a name="fnameescape()">fnameescape()</a> </b>
                转义 <code class="special">{string}</code> 以便用作命令的文件名参数。有特殊意义的字符，如
                '%' 和 '|'，会用反斜杠转义。
                多数系统上，会转义的字符是 " \t\n*?[{`$\\%#'\"|!&lt;"。在反斜杠可
                以出现在文件名中的系统上，此字符集取决于 <a href="options.html#'isfname'">'isfname'</a>。
                也转义出现在开头的 '+' 和 '&gt;' 字符 ( <a href="editing.html#:edit">:edit</a>  和  <a href="editing.html#:write">:write</a>  之后有
                特殊意义)，还有单个出现的 "-" ( <a href="editing.html#:cd">:cd</a>  之后有特殊意义)。
                示例: 
<code class="example">                        :let fname = '+some str%nge|name'</code>
<code class="example">                        :exe "edit " . fnameescape(fname)</code>
                则会执行: 
<code class="example">                        edit \+some\ str\%nge\|name</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;fnameescape()</code>
<code class="example"></code>
fnamemodify(<code class="special">{fname}</code>, <code class="special">{mods}</code>)                            <b class="vimtag"> <a name="fnamemodify()">fnamemodify()</a> </b>
                根据 <code class="special">{mods}</code> 修改文件名 <code class="special">{fname}</code>。<code class="special">{mods}</code> 是一个字符序列组成的字
                符串，就像命令行上使用的文件名那样。见  <a href="cmdline.html#filename-modifiers">filename-modifiers</a> 。
                例如: 
<code class="example">                        :echo fnamemodify("main.c", ":p:h")</code>
                返回: 
<code class="example">                        /home/mool/vim/vim/src</code>
                <code class="note">注意</code>: 环境变量不能用于 <code class="special">{fname}</code>，需要先用  <a href="eval.html#expand()">expand()</a>  扩展。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;fnamemodify(':p:h')</code>
<code class="example"></code>
foldclosed(<code class="special">{lnum}</code>)                                      <b class="vimtag"> <a name="foldclosed()">foldclosed()</a> </b>
                返回数值，如果行 <code class="special">{lnum}</code> 在关闭的折叠中，返回该折叠开始的行号。
                如果行 <code class="special">{lnum}</code> 不在关闭的折叠中，返回 -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;foldclosed()</code>
<code class="example"></code>
foldclosedend(<code class="special">{lnum}</code>)                                   <b class="vimtag"> <a name="foldclosedend()">foldclosedend()</a> </b>
                返回数值，如果行 <code class="special">{lnum}</code> 在关闭的折叠中，返回该折叠结束的行号。
                如果行 <code class="special">{lnum}</code> 不在关闭的折叠中，返回 -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;foldclosedend()</code>
<code class="example"></code>
foldlevel(<code class="special">{lnum}</code>)                                       <b class="vimtag"> <a name="foldlevel()">foldlevel()</a> </b>
                返回数值，当前缓冲区第 <code class="special">{lnum}</code> 行的折叠级别。如果在嵌套的折叠
                里，返回最深的那层。如果行 <code class="special">{lnum}</code> 没有折叠，返回零。这和折叠是
                打开还是关闭无关。在更新折叠时 (在 <a href="options.html#'foldexpr'">'foldexpr'</a> 里)，如果折叠还
                在更新而相应的折叠级别未知，返回 -1。一个特例是前一行的级别通
                常总是知道的。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;foldlevel()</code>

                                                        <b class="vimtag"> <a name="foldtext()">foldtext()</a> </b>
foldtext()      返回关闭的折叠所显示的行。这是 <a href="options.html#'foldtext'">'foldtext'</a> 选项使用的缺省函数，
                而且也只应该在计算 <a href="options.html#'foldtext'">'foldtext'</a> 时使用。它使用  <a href="eval.html#v:foldstart">v:foldstart</a> 、
                 <a href="eval.html#v:foldend">v:foldend</a>  和  <a href="eval.html#v:folddashes">v:folddashes</a>  变量。
                返回的字符串看起来像: 
<code class="example">                        +-- 45 lines: abcdef</code>
                开头的连字符的数目取决于折叠级别。"45" 是折叠的行数。"abcdef"
                是折叠第一个非空白行的文本。开头的空白、"//" 和 "/*" 还有
                <a href="options.html#'foldmarker'">'foldmarker'</a> 和 <a href="options.html#'commentstring'">'commentstring'</a> 选项的文本都被去除。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+folding">+folding</a>  特性才有效}</code>

foldtextresult(<code class="special">{lnum}</code>)                                  <b class="vimtag"> <a name="foldtextresult()">foldtextresult()</a> </b>
                返回行 <code class="special">{lnum}</code> 所在的关闭的折叠显示的文本。在合适的上下文里计算
                <a href="options.html#'foldtext'">'foldtext'</a>。
                如果 <code class="special">{lnum}</code> 没有关闭的折叠，返回空字符串。
                <code class="special">{lnum}</code> 的用法类似于  <a href="eval.html#getline()">getline()</a> 。所以 "." 是当前行，"'m" 是位
                置标记 m，等等。
                可用于输出折叠文本，例如，到 HTML 格式。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+folding">+folding</a>  特性才有效}</code>


                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;foldtextresult()</code>

                                                        <b class="vimtag"> <a name="foreground()">foreground()</a> </b>
foreground()    把 Vim 窗口带到前台。用于从客户发送到 Vim 服务器的时候。
                 <a href="eval.html#remote_send()">remote_send()</a> 
                在 Win32 系统上，可能不行，操作系统并不总能允许窗口把自己带到
                前台。这时应使用  <a href="eval.html#remote_foreground()">remote_foreground()</a> 。
                {仅当使用 Win32、Athena、Motif 和 GTK GUI 版本和 Win32 控制台
                版本时才有效}

                                                <b class="vimtag"> <a name="funcref()">funcref()</a> </b>
funcref(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
                类似于  <a href="eval.html#function()">function()</a> ，但返回的函数引用通过引用来查找函数，而不
                是名字。如果函数 <code class="special">{name}</code> 之后被重定义，这很有意义。

                和  <a href="eval.html#function()">function()</a>  不同，<code class="special">{name}</code> 必须是已经定义的用户函数。自动载
                入函数也可以。<code class="special">{name}</code> 不能是内建函数。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFuncname()-&gt;funcref([arg])</code>

                                        <b class="vimtag"> <a name="function()">function()</a> </b> <b class="vimtag"> <a name="E700">E700</a> </b> <b class="vimtag"> <a name="E922">E922</a> </b> <b class="vimtag"> <a name="E923">E923</a> </b>
function(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
                返回指向函数 <code class="special">{name}</code> 的  <a href="eval.html#Funcref">Funcref</a>  变量。<code class="special">{name}</code> 可以是用户定义的
                函数或者内部函数的名字。

                <code class="special">{name}</code> 可以是函数引用或偏函数。如果是偏函数，会使用其保存的字
                典，而不接受 <code class="special">{dict}</code> 参数。例如: 
<code class="example">                        let FuncWithArg = function(dict.Func, [arg])</code>
<code class="example">                        let Broken = function(dict.Func, [arg], dict)</code>

                使用函数引用时，通过 <code class="special">{name}</code> 查找函数，即使以后被重定义了亦然。
                要保留相同的函数，用  <a href="eval.html#funcref()">funcref()</a> 。

                提供 <code class="special">{arglist}</code> 或 <code class="special">{dict}</code> 则会建立偏函数。这意味着参数列表和/或
                字典会存放在函数引用里，并在调用函数引用时使用。

                参数被传递到函数里，在其它参数之前，但在来自  <a href="eval.html#method">method</a>  的参数之
                后。例如: 
<code class="example">                        func Callback(arg1, arg2, name)</code>
<code class="example">                        ...</code>
<code class="example">                        let Partial = function('Callback', ['one', 'two'])</code>
<code class="example">                        ...</code>
<code class="example">                        call Partial('name')</code>
                函数的调用就类似于: 
<code class="example">                        call Callback('one', 'two', 'name')</code>
<code class="example"></code>
                用  <a href="eval.html#method">method</a>  的话: 
<code class="example">                        func Callback(one, two, three)</code>
<code class="example">                        ...</code>
<code class="example">                        let Partial = function('Callback', ['two'])</code>
<code class="example">                        ...</code>
<code class="example">                        eval 'one'-&gt;Partial('three')</code>
                函数的调用就类似于: 
<code class="example">                        call Callback('one', 'two', 'three')</code>
<code class="example"></code>
                function() 调用可以嵌套，来给函数引用加入更多的参数。额外的参
                数附加于参数列表之后。如: 
<code class="example">                        func Callback(arg1, arg2, name)</code>
<code class="example">                        ...</code>
<code class="example">                        let Func = function('Callback', ['one'])</code>
<code class="example">                        let Func2 = function(Func, ['two'])</code>
<code class="example">                        ...</code>
<code class="example">                        call Func2('name')</code>
                函数的调用就类似于: 
<code class="example">                        call Callback('one', 'two', 'name')</code>
<code class="example"></code>
                字典只对 "dict" 函数的调用有用。该情况下，<code class="special">{dict}</code> 作为 "self"
                传入。例如: 
<code class="example">                        function Callback() dict</code>
<code class="example">                           echo "called for " . self.name</code>
<code class="example">                        endfunction</code>
<code class="example">                        ...</code>
<code class="example">                        let context = {"name": "example"}</code>
<code class="example">                        let Func = function('Callback', context)</code>
<code class="example">                        ...</code>
<code class="example">                        call Func()     " 会回显: called for example</code>
                如果不需额外参数，function() 是没有必要的。这两者等价: 
<code class="example">                        let Func = function('Callback', context)</code>
<code class="example">                        let Func = context.Callback</code>
<code class="example"></code>
                可以合并参数列表和字典: 
<code class="example">                        function Callback(arg1, count) dict</code>
<code class="example">                        ...</code>
<code class="example">                        let context = {"name": "example"}</code>
<code class="example">                        let Func = function('Callback', ['one'], context)</code>
<code class="example">                        ...</code>
<code class="example">                        call Func(500)</code>
                函数的调用就类似于: 
<code class="example">                        call context.Callback('one', 500)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFuncname()-&gt;function([arg])</code>
<code class="example"></code>
<code class="example"></code>
garbagecollect([<code class="special">{atexit}</code>])                              <b class="vimtag"> <a name="garbagecollect()">garbagecollect()</a> </b>
                清理不再使用但有循环引用的  <a href="eval.html#List">List</a>  、 <a href="eval.html#Dictionary">Dictionary</a> 、 <a href="eval.html#Channel">Channel</a>  和
                 <a href="eval.html#Job">Job</a> 。

                几乎没有需要调用这个函数，因为 Vim 内存不足或者 <a href="options.html#'updatetime'">'updatetime'</a>
                之后等待用户按键时会自动执行此功能。没有循环引用的项目总是在不
                再使用的时候就被立即释放了。
                可用于删除很大的  <a href="eval.html#List">List</a>  和/或  <a href="eval.html#Dictionary">Dictionary</a>  而且有循环引用的时
                候，尤其是在要运行很长时间的脚本里。

                如果可选的 <code class="special">{atexit}</code> 参数为一，并且之前还没做过的话，Vim 即使在
                退出时也会执行垃圾回收。可用于检查内存泄漏。

                垃圾清理不是立即进行的，它会等待安全的时机，就是等待用户输入字
                符的时候。要强制立即进行垃圾清理，可用
                 <a href="testing.html#test_garbagecollect_now()">test_garbagecollect_now()</a> 。

get(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{default}</code>])                        <b class="vimtag"> <a name="get()">get()</a> </b>
                获取  <a href="eval.html#List">List</a>  <code class="special">{list}</code> 的第 <code class="special">{idx}</code> 个项目。如果不存在此项目，返回
                <code class="special">{default}</code>。如果省略 <code class="special">{default}</code>，返回零。
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;get(idx)</code>
get(<code class="special">{blob}</code>, <code class="special">{idx}</code> [, <code class="special">{default}</code>])
                获取  <a href="eval.html#Blob">Blob</a>  <code class="special">{blob}</code> 的第 <code class="special">{idx}</code> 个字节。如果不存在此字节，返回
                <code class="special">{default}</code>。如果省略 <code class="special">{default}</code>，返回 -1。
get(<code class="special">{dict}</code>, <code class="special">{key}</code> [, <code class="special">{default}</code>])
                获取  <a href="eval.html#Dictionary">Dictionary</a>  <code class="special">{dict}</code> 键为 <code class="special">{key}</code> 的项目。如果不存在此项目，
                返回 <code class="special">{default}</code>。如果省略 <code class="special">{default}</code>，返回零。有用的例子: 
<code class="example">                        let val = get(g:, 'var_name', 'default')</code>
                如果 g:var_name 存在，返回它的值，如果不存在返回 <code class="badlink">'default'</code>。
get(<code class="special">{func}</code>, <code class="special">{what}</code>)
                获取 函数引用 <code class="special">{func}</code> 的项目。<code class="special">{what}</code> 的可能值是:
                        "name"  函数名
                        "func"  函数
                        "dict"  字典
                        "args"  参数列表

                                                        <b class="vimtag"> <a name="getbufinfo()">getbufinfo()</a> </b>
getbufinfo([<code class="special">{expr}</code>])
getbufinfo([<code class="special">{dict}</code>])
                获取字典列表形式的缓冲区信息。

                不带参数则返回关于所有缓冲区的信息。

                只给出字典参数时，返回匹配相关条件的缓冲区。<code class="special">{dict}</code> 中可指定以
                下键值:
                        buflisted       只包含在列表内的缓冲区。
                        bufloaded       只包含已载入的缓冲区。
                        bufmodified     只包含修改过的缓冲区。

                否则，<code class="special">{expr}</code> 指定特定的单个缓冲区并返回其信息。<code class="special">{expr}</code> 的用法见
                上述  <a href="eval.html#bufname()">bufname()</a> 。如果找到缓冲区，返回的列表有一个项目。不然
                返回空列表。

                每个返回的列表项目是带有以下项目的字典:
                        bufnr           缓冲区号。
                        changed         若缓冲区已修改则为 TRUE。
                        changedtick     缓冲区作过的改动次数。
                        hidden          若缓冲区隐藏则为 TRUE。
                        lastused        缓冲区最近修改时间， <a href="eval.html#localtime()">localtime()</a>  那样
                                        的以秒计的时间戳。
                                        <code class="notvi">{仅当编译时加入  <a href="various.html#+viminfo">+viminfo</a>  特性才有效}</code>
                        listed          若缓冲区在列表内，则为 TRUE。
                        lnum            缓冲区的当前行号。
                        linecount       缓冲区行数 (仅当缓冲区载入后才有效)
                        loaded          若缓冲区已载入则为 TRUE。
                        name            缓冲区文件的完整列表。
                        signs           缓冲区内放置的标号的列表。
                                        每个列表项目是以下项目的字典:
                                            id    标号的识别符
                                            lnum  行号
                                            name  标号名
                        variables       缓冲区局部变量的字典的引用。
                        windows         显示此缓冲区的所有  <a href="windows.html#window-ID">window-ID</a>  的列表
                        popups          显示此缓冲区的弹出窗口  <a href="windows.html#window-ID">window-ID</a>  的
                                        列表

                示例: 
<code class="example">                        for buf in getbufinfo()</code>
<code class="example">                            echo buf.name</code>
<code class="example">                        endfor</code>
<code class="example">                        for buf in getbufinfo({'buflisted':1})</code>
<code class="example">                            if buf.changed</code>
<code class="example">                                ....</code>
<code class="example">                            endif</code>
<code class="example">                        endfor</code>

                要获取缓冲区局部选项，可用: 
<code class="example">                        getbufvar({bufnr}, '&amp;option_name')</code>
<code class="example"></code>

                                                        <b class="vimtag"> <a name="getbufline()">getbufline()</a> </b>
getbufline(<code class="special">{expr}</code>, <code class="special">{lnum}</code> [, <code class="special">{end}</code>])
                返回 <code class="special">{expr}</code> 缓冲区的第 <code class="special">{lnum}</code> 到 <code class="special">{end}</code> (包含) 行的  <a href="eval.html#List">List</a> 。如
                果省略 <code class="special">{end}</code>，返回只有一行 <code class="special">{lnum}</code> 的  <a href="eval.html#List">List</a> 。

                <code class="special">{expr}</code> 的用法见上述  <a href="eval.html#bufname()">bufname()</a> 。

                <code class="special">{lnum}</code> 和 <code class="special">{end}</code> 可以使用 "$" 来表示缓冲区的最后一行。除此以
                外，必须用数值。

                如果 <code class="special">{lnum}</code> 小于 1 或大于缓冲区的行数，返回空  <a href="eval.html#List">List</a> 。

                如果 <code class="special">{end}</code> 大于缓冲区的行数，就把它当成缓冲区的行数。如果
                <code class="special">{end}</code> 在 <code class="special">{lnum}</code> 之前，返回空  <a href="eval.html#List">List</a> 。

                此函数只能用于已经载入的缓冲区。未载入或不存在的缓冲区总是返回
                空  <a href="eval.html#List">List</a> 。

                例如: 
<code class="example">                        :let lines = getbufline(bufnr("myfile"), 1, "$")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufnr()-&gt;getbufline(lnum)</code>
<code class="example"></code>
getbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])                          <b class="vimtag"> <a name="getbufvar()">getbufvar()</a> </b>
                返回缓冲区 <code class="special">{expr}</code> 里的选项或者局部变量 <code class="special">{varname}</code> 的值。<code class="note">注意</code> 必
                须使用不带 "b:" 的名字。
                如果 <code class="special">{varname}</code> 为空，返回包含所有缓冲区局部变量的字典。
                如果 <code class="special">{varname}</code> 为 "&amp;"，返回包含所有缓冲区局部选项的字典。
                否则，如果 <code class="special">{varname}</code> 以 "&amp;" 开始，返回单个缓冲区局部选项值。
                也可用于全局或者局部于缓冲区的选项，但不能用于全局或者局部于窗
                口的变量，还有局部于窗口的选项。
                <code class="special">{expr}</code> 的用法见上述  <a href="eval.html#bufname()">bufname()</a> 。
                如果缓冲区或者变量不存在，返回 <code class="special">{def}</code> 或空字符串。不会有错误消
                息。
                示例: 
<code class="example">                        :let bufmodified = getbufvar(1, "&amp;mod")</code>
<code class="example">                        :echo "todo myvar = " . getbufvar("todo", "myvar")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufnr()-&gt;getbufvar(varname)</code>

getchangelist([<code class="special">{expr}</code>])                                 <b class="vimtag"> <a name="getchangelist()">getchangelist()</a> </b>
                返回缓冲区 <code class="special">{expr}</code> 里的  <a href="motion.html#changelist">changelist</a> 。<code class="special">{expr}</code> 的用法见上述
                 <a href="eval.html#bufname()">bufname()</a> 。缓冲区 <code class="special">{expr}</code> 不存在时返回空列表。

                返回列表包含两个项目: 包含改变位置的列表以及在该列表中的当前位
                置。改变位置列表的每个项目是包含以下内容的字典:
                        col             列号
                        coladd          用于 <a href="options.html#'virtualedit'">'virtualedit'</a> 的列偏移
                        lnum            行号
                如果缓冲区 <code class="special">{expr}</code> 是当前缓冲区，当前位置指的是在列表中的位置。
                如果是其它缓冲区，它设为列表的长度。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufnr()-&gt;getchangelist()</code>
<code class="example"></code>
getchar([expr])                                         <b class="vimtag"> <a name="getchar()">getchar()</a> </b>
                从用户或输入流中提取单个字符。
                如果忽略 <code class="special">[expr]</code>，等待直到有字符输入为止。
                如果 <code class="special">[expr]</code> 为 0，只有在有字符可用时才取得字符，否则返回零。
                如果 <code class="special">[expr]</code> 为 1，只检查是否有字符可用，并不消耗该字符。如果没
                                  有字符，返回零。

                如果省略 <code class="special">[expr]</code> 或者 <code class="special">[expr]</code> 为零，返回整个字符或者特殊键。如果
                是单个字符，以数值形式返回。用 nr2char() 把它转化成字符串。否
                则返回经过编码的字符构成的字符串。如果是特殊键，返回以 0x80
                (十进制: 128) 开始的一串字节构成的字符串。它和字符串 "\<code class="special">&lt;Key&gt;</code>"
                等值，例如 "\<code class="special">&lt;Left&gt;</code>"。如果用带修饰符 (Shift，Control， Alt) 的
                字符而字符本身不包含该修饰符时，返回值也用字符串类型。

                如果 <code class="special">[expr]</code> 为 0 并已键入 Esc，会有短暂的延迟，以便 Vim 有机会
                判断是否是转义序序列的开始。

                如果 <code class="special">[expr]</code> 为 1，只返回第一个字节。如果是单字节字符，返回的就
                是该字符自身的数值形式。用 nr2char() 把它转化为字符串。

                getcharmod() 可用于得到附加的修饰符。

                用户点击鼠标时，返回鼠标事件。所在的位置可以在  <a href="eval.html#v:mouse_col">v:mouse_col</a> 、
                 <a href="eval.html#v:mouse_lnum">v:mouse_lnum</a>  、 <code class="badlink">v:mosue_winid</code>  和  <a href="eval.html#v:mouse_win">v:mouse_win</a>  里找到。
                也可用  <a href="eval.html#getmousepos()">getmousepos()</a> 。下例用通常的处理方法定位鼠标: 
<code class="example">                        let c = getchar()</code>
<code class="example">                        if c == "\&lt;LeftMouse&gt;" &amp;&amp; v:mouse_win &gt; 0</code>
<code class="example">                          exe v:mouse_win . "wincmd w"</code>
<code class="example">                          exe v:mouse_lnum</code>
<code class="example">                          exe "normal " . v:mouse_col . "|"</code>
<code class="example">                        endif</code>

                使用括号内粘贴模式时，只返回首个字符。粘贴文本其余部分被丢弃。
                 <a href="term.html#xterm-bracketed-paste">xterm-bracketed-paste</a> 。

                这里没有提示，你需要想办法告诉用户，需要输入一个字符。
                字符不通过映射。
                键码被替换。因而，用户输入 <code class="special">&lt;Del&gt;</code> 键时，你得到 <code class="special">&lt;Del&gt;</code> 的键码，而
                不是原始的字符序列。比如: 
<code class="example">                        getchar() == "\&lt;Del&gt;"</code>
<code class="example">                        getchar() == "\&lt;S-Left&gt;"</code>
                下例重新定义 "f"，使它忽略大小写: 
<code class="example">                        :nmap f :call FindChar()&lt;CR&gt;</code>
<code class="example">                        :function FindChar()</code>
<code class="example">                        :  let c = nr2char(getchar())</code>
<code class="example">                        :  while col('.') &lt; col('$') - 1</code>
<code class="example">                        :    normal l</code>
<code class="example">                        :    if getline('.')[col('.') - 1] ==? c</code>
<code class="example">                        :      break</code>
<code class="example">                        :    endif</code>
<code class="example">                        :  endwhile</code>
<code class="example">                        :endfunction</code>

                也可能收到模拟字符，例如  <a href="autocmd.html#%3CCursorHold%3E">&lt;CursorHold&gt;</a> 。通常你想忽略之跳到下
                个字符: 
<code class="example">                        :function GetKey()</code>
<code class="example">                        :  let c = getchar()</code>
<code class="example">                        :  while c == "\&lt;CursorHold&gt;"</code>
<code class="example">                        :    let c = getchar()</code>
<code class="example">                        :  endwhile</code>
<code class="example">                        :  return c</code>
<code class="example">                        :endfunction</code>
<code class="example"></code>
getcharmod()                                            <b class="vimtag"> <a name="getcharmod()">getcharmod()</a> </b>
                返回数值，反映最近用 getchar() 或其它方式输入字符的修饰符状
                态。这些值可以相加:
                        2       Shift
                        4       Control
                        8       Alt (Meta)
                        16      Meta (当和 ALT 不同时)
                        32      鼠标双击
                        64      鼠标三击
                        96      鼠标四击 (== 32 + 64)
                        128     Command (仅限于 Macintosh)
                只有没有包含字符本身的修饰符被返回。因而，Shift-a 产生没有修饰
                符的 "A"。

getcharsearch()                                         <b class="vimtag"> <a name="getcharsearch()">getcharsearch()</a> </b>
                以 <code class="special">{dict}</code> 形式返回当前字符搜索信息，带有以下项目:

                    char        上次字符搜索 ( <a href="motion.html#t">t</a> 、 <a href="motion.html#f">f</a> 、 <a href="motion.html#T">T</a>  或  <a href="motion.html#F">F</a> ) 使用的字
                                符；空字符串代表没有字符搜索进行过
                    forward     字符搜索的方向；1 为正向，0 为反向
                    until       字符搜索的类型；1 为  <a href="motion.html#t">t</a>  为  <a href="motion.html#T">T</a>  字符搜索，0 为
                                 <a href="motion.html#f">f</a>  或  <a href="motion.html#F">F</a>  字符搜索

                可用于使  <a href="motion.html#;">;</a>  和  <a href="motion.html#,">,</a>  永远进行正向/反向搜索而不管上次字符搜索的
                方向: 
<code class="example">                        :nnoremap &lt;expr&gt; ; getcharsearch().forward ? ';' : ','</code>
<code class="example">                        :nnoremap &lt;expr&gt; , getcharsearch().forward ? ',' : ';'</code>
                另见  <a href="eval.html#setcharsearch()">setcharsearch()</a> 。

getcmdline()                                            <b class="vimtag"> <a name="getcmdline()">getcmdline()</a> </b>
                返回当前命令行。只有在编辑命令行时有效，所以必须在
                 <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或  <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  里使用。
                例如: 
<code class="example">                        :cmap &lt;F7&gt; &lt;C-\&gt;eescape(getcmdline(), ' \')&lt;CR&gt;</code>
                另见  <a href="eval.html#getcmdtype()">getcmdtype()</a> 、 <a href="eval.html#getcmdpos()">getcmdpos()</a>  和  <a href="eval.html#setcmdpos()">setcmdpos()</a> 。
                输入密码或用  <a href="eval.html#inputsecret()">inputsecret()</a>  时返回空串。

getcmdpos()                                     <b class="vimtag"> <a name="getcmdpos()">getcmdpos()</a> </b>
                返回命令行的字节计算的光标位置。第一列为 1。
                只有在编辑命令行时有效，所以必须在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或
                 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  或表达式映射里使用。
                不然，返回 0。
                另见  <a href="eval.html#getcmdtype()">getcmdtype()</a> 、 <a href="eval.html#setcmdpos()">setcmdpos()</a>  和  <a href="eval.html#getcmdline()">getcmdline()</a> 。

getcmdtype()                                            <b class="vimtag"> <a name="getcmdtype()">getcmdtype()</a> </b>
                返回当前命令行类型。可能的返回值是:
                    :   普通 Ex 命令
                    &gt;   调试模式命令  <a href="repeat.html#debug-mode">debug-mode</a> 
                    /   正向搜索命令
                    ?   反向搜索命令
                    @    <a href="eval.html#input()">input()</a>  命令
                    -    <a href="insert.html#:insert">:insert</a>  或  <a href="insert.html#:append">:append</a>  命令
                    =    <a href="insert.html#i_CTRL-R_%20">i_CTRL-R_=</a> 
                只能在编辑命令行时调用，因而必须在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或
                 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  或表达式映射里使用。
                否则，返回空字符串。
                另见  <a href="eval.html#getcmdpos()">getcmdpos()</a> 、 <a href="eval.html#setcmdpos()">setcmdpos()</a>  和  <a href="eval.html#getcmdline()">getcmdline()</a> 。

getcmdwintype()                                         <b class="vimtag"> <a name="getcmdwintype()">getcmdwintype()</a> </b>
                返回当前  <a href="cmdline.html#command-line-window">command-line-window</a>  类型。可能的返回值和
                 <a href="eval.html#getcmdtype()">getcmdtype()</a>  相同。如果不在命令行窗口内，返回空字符串。

getcompletion(<code class="special">{pat}</code>, <code class="special">{type}</code> [, <code class="special">{filtered}</code>])             <b class="vimtag"> <a name="getcompletion()">getcompletion()</a> </b>
                返回命令行补全匹配列表。<code class="special">{type}</code> 指定类型。支持以下的匹配类型:

                arglist         参数列表中的文件名
                augroup         自动命令组
                buffer          缓冲区名
                behave          :behave 子选项
                color           色彩方案
                command         Ex 命令 (及参数)
                compiler        编译器
                cscope           <a href="if_cscop.html#:cscope">:cscope</a>  子选项
                diff_buffer      <a href="diff.html#:diffget">:diffget</a>  和  <a href="diff.html#:diffput">:diffput</a>  补全
                dir             目录名
                environment     环境变量名
                event           自动命令事件
                expression      Vim 表达式
                file            文件和目录名
                file_in_path     <a href="options.html#'path'">'path'</a>  中的文件和目录名
                filetype        文件类型名  <a href="options.html#'filetype'">'filetype'</a> 
                function        函数名
                help            帮助主题
                highlight       高亮组
                history         :history 子选项
                locale          locale 名 (可见 locale -a 的输出)
                mapclear        缓冲区参数
                mapping         映射名
                menu            菜单
                messages         <a href="message.html#:messages">:messages</a>  子选项
                option          选项
                packadd         可选包  <a href="repeat.html#pack-add">pack-add</a>  名
                shellcmd        外壳命令
                sign             <a href="sign.html#:sign">:sign</a>  子选项
                syntax          语法文件名  <a href="options.html#'syntax'">'syntax'</a> 
                syntime          <a href="syntax.html#:syntime">:syntime</a>  子选项
                tag             标签
                tag_listfiles   标签、文件名
                user            用户名
                var             用户变量

                如果 <code class="special">{pat}</code> 为空串，返回所有匹配。否则只返回匹配 <code class="special">{pat}</code> 的项目。
                关于 <code class="special">{pat}</code> 中特殊字符的使用，见  <a href="editing.html#wildcards">wildcards</a> 。

                如果可选的 <code class="special">{filtered}</code> 标志位设为 1，应用 <a href="options.html#'wildignore'">'wildignore'</a> 来过滤结
                果。否则返回所有匹配。<a href="options.html#'wildignorecase'">'wildignorecase'</a> 选项则总是有效。

                如果没有匹配，返回空列表。如果 <code class="special">{type}</code> 为非法值，报错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPattern()-&gt;getcompletion('color')</code>

                                                        <b class="vimtag"> <a name="getcurpos()">getcurpos()</a> </b>
getcurpos()     返回光标位置。类似于 getpos('.')，但包含在列表中一个额外的项
                目:
<code class="section">                    [bufnum, lnum, col, off, curswant] </code>
                "curswant" 数值是垂直移动光标时的首选列。另见  <a href="eval.html#getpos()">getpos()</a> 。

                可用于保存和恢复光标位置: 
<code class="example">                        let save_cursor = getcurpos()</code>
<code class="example">                        移动光标</code>
<code class="example">                        call setpos('.', save_cursor)</code>
                <code class="note">注意</code> 这只适用于同一窗口内的移动。要恢复更多状态，见
                 <a href="eval.html#winrestview()">winrestview()</a> 。
                                                        <b class="vimtag"> <a name="getcwd()">getcwd()</a> </b>
getcwd([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
                返回字符串，当前工作目录的名字。

                有 <code class="special">{winr}</code> 则返回当前标签页的该窗口的本地当前目录。<code class="special">{winr}</code> 可以
                是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                <code class="special">{winr}</code> 为 -1 时返回全局工作目录名。另见  <a href="eval.html#haslocaldir()">haslocaldir()</a> 。

                有 <code class="special">{winr}</code> 和 <code class="special">{tabnr}</code> 则返回指定标签页和窗口的本地当前目录。如
                果 <code class="special">{winnr}</code> 为 -1，返回指定标签页的当前目录。
                如果 <code class="special">{winr}</code> 为零使用当前窗口。如果 <code class="special">{tabnr}</code> 为零使用当前标签
                页。
                无参数时，返回当前窗口的工作目录。
                如果参数非法，返回空串。

                示例: 
<code class="example">                        " 返回当前窗口的工作目录</code>
<code class="example">                        :echo getcwd()</code>
<code class="example">                        :echo getcwd(0)</code>
<code class="example">                        :echo getcwd(0, 0)</code>
<code class="example">                        " 返回标签页 2 中的窗口 3 的工作目录</code>
<code class="example">                        :echo getcwd(3, 2)</code>
<code class="example">                        " 返回全局工作目录</code>
<code class="example">                        :echo getcwd(-1)</code>
<code class="example">                        " 返回标签页 3 的工作目录</code>
<code class="example">                        :echo getcwd(-1, 3)</code>
<code class="example">                        " 返回当前标签页的工作目录</code>
<code class="example">                        :echo getcwd(-1, 0)</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;getcwd()</code>

getenv(<code class="special">{name}</code>)                                          <b class="vimtag"> <a name="getenv()">getenv()</a> </b>
                返回环境变量 <code class="special">{name}</code> 的值。
                如果该变量不存在返回  <a href="eval.html#v:null">v:null</a> 。这和变量设为空串时不同，不过有
                的系统把空值解读为删除了的变量。另见  <a href="eval.html#expr-env">expr-env</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetVarname()-&gt;getenv()</code>
<code class="example"></code>
getfontname([<code class="special">{name}</code>])                                   <b class="vimtag"> <a name="getfontname()">getfontname()</a> </b>
                如果没有参数，返回使用的正常字体的名字，也就是 Normal 高亮组
                 <a href="syntax.html#hl-Normal">hl-Normal</a>  使用的。
                如果带了参数，检查 <code class="special">{name}</code> 是否合法的字体名。如果不是，返回空字
                符串。否则，返回实际的字体名，或者如果 GUI 不支持取得真正的名
                字，返回 <code class="special">{name}</code>。
                只有在 GUI 运行的时候才能用，所以不能用于你的 vimrc 和 gvimrc
                文件。用  <a href="autocmd.html#GUIEnter">GUIEnter</a>  自动命令可以在 GUI 刚开始之后使用此函数。
                <code class="note">注意</code> GTK GUI 接受任何字体名，所以不会检查名字是否合法。

getfperm(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getfperm()">getfperm()</a> </b>
                返回字符串，给定文件 <code class="special">{fname}</code> 的读、写、执行权限。
                如果 <code class="special">{fname}</code> 不存在或者它所在的目录无法读取，返回空字符串。
                返回值的形式是 "rwxrwxrwx"，其中每组 "rwx" 标志位分别代表文件
                所有者、文件所属组和其它用户的权限。如果用户没有某权限，相应的
                标志位被字符串 "-" 代替。例如: 
<code class="example">                        :echo getfperm("/etc/passwd")</code>
<code class="example">                        :echo getfperm(expand("~/.vimrc"))</code>
                希望它会 (从安全角度而言) 显示字符串 "rw-r--r--" 或者甚至
                "rw-------"。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;getfperm()</code>

                要设置权限，可用  <a href="eval.html#setfperm()">setfperm()</a> 。

getfsize(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getfsize()">getfsize()</a> </b>
                返回数值，文件 <code class="special">{fname}</code> 以字节数计算的大小。
                如果 <code class="special">{fname}</code> 是目录，返回 0。
                如果找不到文件 <code class="special">{fname}</code>，返回 -1。
                如果 <code class="special">{fname}</code> 文件过大，超出了 Vim 的数值的范围，返回 -2。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;getfsize()</code>
<code class="example"></code>
getftime(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getftime()">getftime()</a> </b>
                返回数值，给定文件 <code class="special">{fname}</code> 的最新修改时间。该时间为 1970 年 1
                月 1 日开始计算的秒数，可以传给 strftime()。
                另见  <a href="eval.html#localtime()">localtime()</a>  和  <a href="eval.html#strftime()">strftime()</a> 。
                如果找不到文件 <code class="special">{fname}</code>，返回 -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;getftime()</code>
<code class="example"></code>
getftype(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getftype()">getftype()</a> </b>
                返回字符串，给定文件 <code class="special">{fname}</code> 的文件类型的描述。
                如果 <code class="special">{fname}</code> 不存在，返回空字符串。
                下表列出各种不同文件类型的返回值:
                        普通文件                "file"
                        目录                    "dir"
                        符号链接                "link"
                        块设备                  "bdev"
                        字符设备                "cdev"
                        套接字                  "socket"
                        FIFO                    "fifo"
                        其它                    "other"
                例如: 
<code class="example">                        getftype("/home")</code>
                <code class="note">注意</code> 只有在能支持的系统上才会返回 "link" 这样的类型。有的系统
                只支持 "dir" 和 "file"。MS-Windows 上目录的符号链接返回 "dir"
                而不是 "link"。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;getftype()</code>
<code class="example"></code>
getimstatus()                                           <b class="vimtag"> <a name="getimstatus()">getimstatus()</a> </b>
                返回数值，IME 状态激活时为  <a href="eval.html#TRUE">TRUE</a> 。
                见 <a href="options.html#'imstatusfunc'">'imstatusfunc'</a>。

getjumplist([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])                      <b class="vimtag"> <a name="getjumplist()">getjumplist()</a> </b>
                返回指定窗口的  <a href="motion.html#jumplist">jumplist</a> 。

                无参数时使用当前窗口。
                如果只带 <code class="special">{winnr}</code>，使用当前标签页的指定窗口。
                <code class="special">{winnr}</code> 也可以是  <a href="windows.html#window-ID">window-ID</a> 。
                有 <code class="special">{winr}</code> 和 <code class="special">{tabnr}</code> 则返回指定标签页的指定窗口。

                返回列表包含两个项目: 包含跳转位置的列表以及在该列表中的最近使
                用的跳转位置号。跳转位置列表的每个项目是包含以下内容的字典:
                        bufnr           缓冲区号
                        col             列号
                        coladd          用于 <a href="options.html#'virtualedit'">'virtualedit'</a> 的列偏移
                        filename        文件名，如有的话
                        lnum            行号

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;getjumplist()</code>
<code class="example"></code>
                                                        <b class="vimtag"> <a name="getline()">getline()</a> </b>
getline(<code class="special">{lnum}</code> [, <code class="special">{end}</code>])
                如果没有 <code class="special">{end}</code>，返回字符串，即当前缓冲区第 <code class="special">{lnum}</code> 行文本。
                例如: 
<code class="example">                        getline(1)</code>
                如果 <code class="special">{lnum}</code> 是不以数字开始的字符串，调用  <a href="eval.html#line()">line()</a>  来把该字符串
                转化成数值。要得到光标所在的行: 
<code class="example">                        getline(".")</code>
                如果 <code class="special">{lnum}</code> 小于 1 或者大于缓冲区的总行数，返回空字符串。

                如果给出 <code class="special">{end}</code>，返回  <a href="eval.html#List">List</a> ，其中每个项目是当前缓冲区从 <code class="special">{lnum}</code>
                到 <code class="special">{end}</code> (包含) 范围的一行。
                <code class="special">{end}</code> 的用法同 <code class="special">{lnum}</code>。
                安静地忽略不存在的行。
                如果 <code class="special">{end}</code> 在 <code class="special">{lnum}</code> 之前，返回空  <a href="eval.html#List">List</a> 。
                例如: 
<code class="example">                        :let start = line('.')</code>
<code class="example">                        :let end = search("^$") - 1</code>
<code class="example">                        :let lines = getline(start, end)</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ComputeLnum()-&gt;getline()</code>
<code class="example"></code>
                要获取其它缓冲区的文本行，见  <a href="eval.html#getbufline()">getbufline()</a> 。

getloclist(<code class="special">{nr}</code> [, <code class="special">{what}</code>])                             <b class="vimtag"> <a name="getloclist()">getloclist()</a> </b>
                返回列表，包含窗口 <code class="special">{nr}</code> 的位置列表的所有项目。<code class="special">{nr}</code> 可以是窗口
                号或  <a href="windows.html#window-ID">window-ID</a> 。如果 <code class="special">{nr}</code> 为 0，使用当前窗口。

                如果是位置列表窗口，返回其显示的位置列表。如果窗口号 <code class="special">{nr}</code> 非
                法，返回空列表。其它的情况和  <a href="eval.html#getqflist()">getqflist()</a>  相同。

                如果提供了可选的 <code class="special">{what}</code> 字典参数，以字典形式返回 <code class="special">{what}</code> 列出的
                项目。关于 <code class="special">{what}</code> 支持的项目，可参考  <a href="eval.html#getqflist()">getqflist()</a> 。

                除了  <a href="eval.html#getqflist()">getqflist()</a>  的 <code class="special">{what}</code> 支持的项目以外， <a href="eval.html#getloclist()">getloclist()</a>  还
                支持以下项目:

                        filewinid       用于显示来自位置列表的文件的窗口的
                                        id。只有当调用来自位置列表窗口时此域才
                                        可用。详见
                                         <a href="quickfix.html#location-list-file-window">location-list-file-window</a> 。

getmatches([<code class="special">{win}</code>])                                     <b class="vimtag"> <a name="getmatches()">getmatches()</a> </b>
                返回之前  <a href="eval.html#matchadd()">matchadd()</a>  和  <a href="pattern.html#:match">:match</a>  命令为当前窗口定义的所有匹配
                组成的列表  <a href="eval.html#List">List</a> 。  <a href="eval.html#getmatches()">getmatches()</a>  常和  <a href="eval.html#setmatches()">setmatches()</a>  组合使
                用，因为  <a href="eval.html#setmatches()">setmatches()</a>  可以恢复  <a href="eval.html#getmatches()">getmatches()</a>  保存的匹配列
                表。
                示例: 
<code class="example">                        :echo getmatches()</code>
                        [{<code class="badlink">'group'</code>: <code class="badlink">'MyGroup1'</code>, <code class="badlink">'pattern'</code>: <code class="badlink">'TODO'</code>,
                        <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 1}, {<code class="badlink">'group'</code>: <code class="badlink">'MyGroup2'</code>,
                        <code class="badlink">'pattern'</code>: <code class="badlink">'FIXME'</code>, <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 2}] 
<code class="example">                        :let m = getmatches()</code>
<code class="example">                        :call clearmatches()</code>
<code class="example">                        :echo getmatches()</code>
                        [] 
<code class="example">                        :call setmatches(m)</code>
<code class="example">                        :echo getmatches()</code>
                        [{<code class="badlink">'group'</code>: <code class="badlink">'MyGroup1'</code>, <code class="badlink">'pattern'</code>: <code class="badlink">'TODO'</code>,
                        <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 1}, {<code class="badlink">'group'</code>: <code class="badlink">'MyGroup2'</code>,
                        <code class="badlink">'pattern'</code>: <code class="badlink">'FIXME'</code>, <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 2}] 
<code class="example">                        :unlet m</code>

getmousepos()                                           <b class="vimtag"> <a name="getmousepos()">getmousepos()</a> </b>
                返回鼠标最近已知位置的字典。可用于鼠标点击的映射或弹出窗口的过
                滤。项目是:
                        screenrow       屏幕行
                        screencol       屏幕列
                        winid           点击所在的窗口 ID
                        winrow          "winid" 里的行
                        wincol          "winid" 里的列
                        line            "winid" 里的文本内容行
                        column          "winid" 里的文本列
                所有的数值从 1 开始。

                如果鼠标不在窗口上，比如在命令行里，则只有 "screenrow" 和
                "screencol" 是合法的，其它的值均为零。

                如果鼠标在窗口底下的状态行上或窗口右侧的垂直分割线上，"line"
                和 "column" 的值为零。

                如果位置在文本之后，那么 "column" 是文本以字节计的长度。

                如果鼠标在弹出窗口上，使用该窗口。


                使用  <a href="eval.html#getchar()">getchar()</a>  时，Vim 变量  <a href="eval.html#v:mouse_lnum">v:mouse_lnum</a> 、 <a href="eval.html#v:mouse_col">v:mouse_col</a>  和
                 <a href="eval.html#v:mouse_winid">v:mouse_winid</a>  也能提供相应的这些值。

                                                        <b class="vimtag"> <a name="getpid()">getpid()</a> </b>
getpid()        返回数值，即 Vim 进程的进程号。Unix 和 MS-Windows 上这是个唯一
                的数值，直到 Vim 退出为止。

                                                        <b class="vimtag"> <a name="getpos()">getpos()</a> </b>
getpos(<code class="special">{expr}</code>)  得到 <code class="special">{expr}</code> 的位置。可用的 <code class="special">{expr}</code> 的值见  <a href="eval.html#line()">line()</a> 。要得到光标
                位置，见  <a href="eval.html#getcurpos()">getcurpos()</a> 。
                返回  <a href="eval.html#List">List</a> ，包含四个数值:
                    [bufnum, lnum, col, off]
                "bufnum" 为零，除非使用了 '0 或 'A 这样的位置标记，这时它是此
                位置标记所在的缓冲区号。
                "lnum" 和 "col" 是缓冲区里的位置。第一列为 1。
                除非使用了 <a href="options.html#'virtualedit'">'virtualedit'</a>。"off" 值为零，这是从对应字符开始位置
                的以屏幕列计的位移。例如，在制表之中或最后一个字符之后的某个位
                置。
                <code class="note">注意</code> '&lt; 和 '&gt; 和可视模式有关: "V" (可视行模式) 时 '&lt; 的列为
                零，'&gt; 的列为一大数。
                可以用来保存和恢复光标位置: 
<code class="example">                        let save_a_mark = getpos("'a")</code>
<code class="example">                        ...</code>
<code class="example">                        call setpos("'a", save_a_mark)</code>
                另见  <a href="eval.html#getcurpos()">getcurpos()</a>  和  <a href="eval.html#setpos()">setpos()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMark()-&gt;getpos()</code>
<code class="example"></code>
<code class="example"></code>
getqflist([<code class="special">{what}</code>])                                     <b class="vimtag"> <a name="getqflist()">getqflist()</a> </b>
                返回列表，包含所有当前 quickfix 错误。列表的每个项目是包含以下
                项目的字典:
                        bufnr   有此文件名的缓冲区号，bufname() 得到缓冲区名
                        module  模块名
                        lnum    缓冲区里的行号 (第一行是 1)
                        col     列号 (第一列是 1)
                        vcol     <a href="eval.html#TRUE">TRUE</a> : "col" 是可视列
                                 <a href="eval.html#FALSE">FALSE</a> : "col" 是字节位置
                        nr      错误号
                        pattern 用于定位错误的搜索模式
                        text    错误描述
                        type    错误类型，'E'、'1' 等。
                        valid    <a href="eval.html#TRUE">TRUE</a> : 能识别该错误信息

                如果没有错误列表或者它为空，返回空列表。quickfix 列表项目如果
                包含不存在的缓冲区号，返回的 "bufnr" 置为零。

                应用: 在多个文件里寻找模式的匹配，并对之进行处理: 
<code class="example">                        :vimgrep /theword/jg *.c</code>
<code class="example">                        :for d in getqflist()</code>
<code class="example">                        :   echo bufname(d.bufnr) ':' d.lnum '=' d.text</code>
<code class="example">                        :endfor</code>

                如果提供了可选的 <code class="special">{what}</code> 字典参数，以字典形式返回 <code class="special">{what}</code> 列出的
                项目。<code class="special">{what}</code> 支持以下字符串项目:
                        changedtick      <a href="quickfix.html#quickfix-changedtick">quickfix-changedtick</a>  列表改变的总数
                        context 获取  <a href="quickfix.html#quickfix-context">quickfix-context</a> 
                        efm     解析 "lines" 时使用的 errorformat。如果没有给
                                出，使用 <a href="options.html#'errorformat'">'errorformat'</a> 选项值。
                        id      获取 quickfix 列表  <a href="quickfix.html#quickfix-ID">quickfix-ID</a>  说明的信息。
                                零代表当前列表或 "nr" 指定的列表
                        idx     由 <code class="badlink">'id'</code> 或 <code class="badlink">'nr'</code> 指定的 quickfix 列表中当前项目
                                的索引。
                                见  <a href="quickfix.html#quickfix-index">quickfix-index</a> 
                        items   获取 quickfix 列表的项目
                        lines   用 <a href="options.html#'efm'">'efm'</a> 解析文本行列表并返回其结果项目。只支
                                持  <a href="eval.html#List">List</a>  类型。不修改当前 quickfix 列表。见
                                 <a href="quickfix.html#quickfix-parse">quickfix-parse</a> 。
                        nr      获取关于指定 quickfix 列表的信息；零代表当前
                                quickfix 列表，"$" 代表最后的 quickfix 列表
                        qfbufnr quickfix 窗口显示的缓冲区号。quickfix 缓冲区不
                                存在时返回 0。见  <a href="quickfix.html#quickfix-buffer">quickfix-buffer</a> 。
                        size    quickfix 列表的项目总数
                        title   获取列表标题  <a href="quickfix.html#quickfix-title">quickfix-title</a> 
                        winid   获取 quickfix  <a href="windows.html#window-ID">window-ID</a> 
                        all     上述所有的 quickfix 属性
                忽略 <code class="special">{what}</code> 中非字符串项。要获取某个特定项之值，先设为零。
                如果不给出 "nr"，使用当前 quickfix 列表。
                同时给出 "nr" 和非零 "id" 时，使用 "id" 指定的列表。
                要取得 quickfix 栈的列表数目，在 <code class="special">{what}</code> 中设置 <code class="badlink">'nr'</code> 为 "$"。返
                回字典中的 "nr" 值会告诉你 quickfix 的栈大小。
                如果给出 "lines"，忽略除 "efm" 外的所有其它项。返回的字典包
                含 "items" 项，给出所有项目的列表。

                返回字典包含以下项目:
                        changedtick      <a href="quickfix.html#quickfix-changedtick">quickfix-changedtick</a>  列表改变的总数
                        context quickfix 列表的上下文，见  <a href="quickfix.html#quickfix-context">quickfix-context</a> 
                                如果不存在，设为 ""。
                        id      quickfix 列表 ID  <a href="quickfix.html#quickfix-ID">quickfix-ID</a> 。如果不存在，设
                                为 0。
                        idx     列表中当前项目的索引。如果不存在，设为 0。
                        items   quickfix 列表的项目。如果不存在，设为空列表。
                        nr      quickfix 列表号。如果不存在，设为 0
                        qfbufnr quickfix 窗口显示的缓冲区号。如果不存在，设为
                                0。
                        size    quickfix 列表的项数。如果不存在，设为 0。
                        title   quickfix 列表标题文本。如果不存在，设为 ""。
                        winid   quickfix  <a href="windows.html#window-ID">window-ID</a> 。如果不存在，设为 0

                示例 (另见  <a href="quickfix.html#getqflist-examples">getqflist-examples</a> ): 
<code class="example">                        :echo getqflist({'all': 1})</code>
<code class="example">                        :echo getqflist({'nr': 2, 'title': 1})</code>
<code class="example">                        :echo getqflist({'lines' : ["F1:10:L10"]})</code>

getreg([<code class="special">{regname}</code> [, 1 [, <code class="special">{list}</code>]]])                    <b class="vimtag"> <a name="getreg()">getreg()</a> </b>
                返回字符串，寄存器 <code class="special">{regname}</code> 的内容。例如: 
<code class="example">                        :let cliptext = getreg('*')</code>
                如果 <code class="special">{regname}</code> 对应的寄存器没有设过，返回空串。

                getreg('=') 返回最近一次表达式寄存器计算的返回值 (用于映射)。
                getreg('=', 1) 返回表达式自身，以便用  <a href="eval.html#setreg()">setreg()</a>  恢复。对于其
                它寄存器，这个额外的参数被忽略，所以给出此参数总是无妨。

                如果 <code class="special">{list}</code> 给出且为  <a href="eval.html#TRUE">TRUE</a> ，改变返回值为列表。每个列表项是一
                个文本行。如果你在意寄存器内可能存在的零字节，可以用这种形式:
                不用第三个参数时 NL 和零字节都用 NL 表示 (见
                 <a href="pattern.html#NL-used-for-Nul">NL-used-for-Nul</a> ) 。
                如果 <code class="special">{regname}</code> 对应的寄存器没有设过，返回空列表。

                如果没有指定 <code class="special">{regname}</code>，使用  <a href="eval.html#v:register">v:register</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRegname()-&gt;getreg()</code>
<code class="example"></code>
<code class="example"></code>
getregtype([<code class="special">{regname}</code>])                                 <b class="vimtag"> <a name="getregtype()">getregtype()</a> </b>
                返回字符串，寄存器 <code class="special">{regname}</code> 的类型。
                该值会是以下可能之一:
                    "v"                  <a href="motion.html#characterwise">characterwise</a>  (面向字符) 的文本
                    "V"                  <a href="motion.html#linewise">linewise</a>  (面向行) 的文本
                    "&lt;<code class="keystroke">CTRL-V</code>&gt;<code class="special">{width}</code>"    <a href="visual.html#blockwise-visual">blockwise-visual</a>  (面向列块) 的文本
                    ""                  空或者未知的寄存器
                &lt;<code class="keystroke">CTRL-V</code>&gt; 是一个字符，其值为 0x16。
                如果没有指定 <code class="special">{regname}</code>，使用  <a href="eval.html#v:register">v:register</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRegname()-&gt;getregtype()</code>
<code class="example"></code>
gettabinfo([<code class="special">{arg}</code>])                                     <b class="vimtag"> <a name="gettabinfo()">gettabinfo()</a> </b>
                如果没指定 <code class="special">{arg}</code>，返回列表，包含所有标签页的信息。每个列表项是
                字典。
                否则，<code class="special">{arg}</code> 指定标签页号，返回关于该标签页的信息。如果该标志页
                不存在，返回空列表。

                每个列表项是包含以下项目的字典:
                        tabnr           标签页号
                        variables       包含标签页局部变量的字典的引用
                        windows         标签页中的  <a href="windows.html#window-ID">window-ID</a>  列表。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabnr()-&gt;gettabinfo()</code>
<code class="example"></code>
gettabvar(<code class="special">{tabnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])                         <b class="vimtag"> <a name="gettabvar()">gettabvar()</a> </b>
                得到标签页 <code class="special">{tabnr}</code> 的标签页局部变量 <code class="special">{varname}</code> 的值。 <a href="eval.html#t:var">t:var</a> 
                标签页的编号从一开始。
                如果 <code class="special">{varname}</code> 为空，返回包含所有标签页局部变量的字典。
                <code class="note">注意</code> 必须使用不带 "t:" 的名字。
                如果标签页或者变量不存在，返回 <code class="special">{def}</code> 或空字符串。不会有错误消
                息。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabnr()-&gt;gettabvar(varname)</code>
<code class="example"></code>
gettabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])             <b class="vimtag"> <a name="gettabwinvar()">gettabwinvar()</a> </b>
                得到标签页 <code class="special">{tabnr}</code> 的窗口 <code class="special">{winnr}</code> 的窗口局部变量 <code class="special">{varname}</code> 的
                值。
                如果 <code class="special">{varname}</code> 为 "&amp;"，返回包含所有窗口局部选项的字典。
                否则，如果 <code class="special">{varname}</code> 以 "&amp;" 打头，得到窗口局部选项的值。
                如果 <code class="special">{varname}</code> 为空，返回一个包含所有窗口局部变量的字典。
                <code class="note">注意</code> <code class="special">{varname}</code> 必须为不带 "w:" 的名字。
                标签页的编号从一开始。当前标签页可用  <a href="eval.html#getwinvar()">getwinvar()</a> 。
                <code class="special">{winnr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{winnr}</code> 为零，使用当前窗口。
                也可用于全局或者局部于缓冲区或局部于窗口的选项，但不能用于全局
                或者局部于缓冲区的变量。
                如果标签页、窗口或者变量不存在，返回 <code class="special">{def}</code> 或空字符串。不会有
                错误消息。
                例如: 
<code class="example">                        :let list_is_on = gettabwinvar(1, 2, '&amp;list')</code>
<code class="example">                        :echo "myvar = " . gettabwinvar(3, 1, 'myvar')</code>

                要得到所有窗口局部变量，可用: 
<code class="example">                        gettabwinvar({tabnr}, {winnr}, '&amp;')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabnr()-&gt;gettabwinvar(winnr, varname)</code>
<code class="example"></code>
gettagstack([<code class="special">{nr}</code>])                                     <b class="vimtag"> <a name="gettagstack()">gettagstack()</a> </b>
                返回字典，窗口 <code class="special">{nr}</code> 的标签栈。
                <code class="special">{nr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果没有给出 <code class="special">{nr}</code>，使用当前窗口。
                如果窗口 <code class="special">{nr}</code> 不存在，返回空字典。

                返回字典包含如下项目:
                        curidx          栈的当前索引。如果在栈顶，设为
                                        (length + 1)。栈底的索引为 1。
                        items           栈中的项目列表。每个项目是包含下述项的
                                        字典。
                        length          栈中的项目数。

                栈中的每个项目是以下项的字典:
                        bufnr           当前跳转的缓冲区号
                        from            标签跳转之前的光标位置。 <a href="eval.html#getpos()">getpos()</a>  说
                                        明返回列表的格式。
                        matchnr         当前的匹配标签号。用于同一名字有多个匹
                                        配标签的时候。
                        tagname         标签名

                 <a href="tagsrch.html#tagstack">tagstack</a>  说明标签栈的更多信息。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;gettagstack()</code>
<code class="example"></code>
getwininfo([<code class="special">{winid}</code>])                                   <b class="vimtag"> <a name="getwininfo()">getwininfo()</a> </b>
                返回窗口信息，返回值是字典的列表。

                如果给出 <code class="special">{winid}</code>，返回给定 ID 的窗口的信息。如果窗口不存在，返
                回空列表。

                如果没有给出 <code class="special">{winid}</code>，返回所有标签页的所有窗口的信息。

                每个列表项是包含以下项目的字典:
                        botline         最近显示的缓冲区行
                        bufnr           窗口中的缓冲区号
                        height          窗口高度 (不计窗口工具条 winbar)
                        loclist         1 如果显示了位置列表
                                        <code class="notvi">{仅当加入  <a href="various.html#+quickfix">+quickfix</a>  特性才有效}</code>
                        quickfix        1 如果是 quickfix 或位置列表窗口
                                        <code class="notvi">{仅当加入  <a href="various.html#+quickfix">+quickfix</a>  特性才有效}</code>
                        terminal        1 如果是终端窗口
                                        <code class="notvi">{仅当加入  <a href="various.html#+terminal">+terminal</a>  特性才有效}</code>
                        tabnr           标签页号
                        topline         首个显示的缓冲区行
                        variables       包含窗口局部变量的字典的引用
                        width           窗口宽度
                        winbar          1 如果窗口有工具条，0 反之
                        wincol          窗口最左侧屏幕列，
                                         <a href="eval.html#win_screenpos()">win_screenpos()</a>  中的 col
                        winid            <a href="windows.html#window-ID">window-ID</a> 
                        winnr           窗口号
                        winrow          窗口最顶侧屏幕行，
                                         <a href="eval.html#win_screenpos()">win_screenpos()</a>  中的 row`

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;getwininfo()</code>
<code class="example"></code>
getwinpos([<code class="special">{timeout}</code>])                                  <b class="vimtag"> <a name="getwinpos()">getwinpos()</a> </b>
                返回两个数值组成的列表，即  <a href="eval.html#getwinposx()">getwinposx()</a>  和  <a href="eval.html#getwinposy()">getwinposy()</a>  结
                果的混合:
                        [x-pos, y-pos]
                <code class="special">{timeout}</code> 可用于以毫秒计的等待终端反馈的超时。省略时缺省为 100
                毫秒。远程终端可用更长的超时。
                如果取值小于 10 且在指定时限内没有收到反馈，返回如果有的上次报
                告的位置。可用于轮询位置并在同时并发做其它的事: 
<code class="example">                        while 1</code>
<code class="example">                          let res = getwinpos(1)</code>
<code class="example">                          if res[0] &gt;= 0</code>
<code class="example">                            break</code>
<code class="example">                          endif</code>
<code class="example">                          " 干些话</code>
<code class="example">                        endwhile</code>


                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTimeout()-&gt;getwinpos()</code>

                                                        <b class="vimtag"> <a name="getwinposx()">getwinposx()</a> </b>
getwinposx()    返回数值，即 GUI Vim 窗口以像素计从左起算的 X 坐标。也适用于
                xterm (100 毫秒超时)。
                如果该信息得不到，返回 -1。
                返回值可用于 ":winpos"。

                                                        <b class="vimtag"> <a name="getwinposy()">getwinposy()</a> </b>
getwinposy()    返回数值，即 GUI Vim 窗口以像素计从顶部起算的 Y 坐标。也适用于
                xterm (100 毫秒超时)。
                如果该信息得不到，返回 -1。
                返回值可用于 ":winpos"。

getwinvar(<code class="special">{winnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])                         <b class="vimtag"> <a name="getwinvar()">getwinvar()</a> </b>
                类似于  <a href="eval.html#gettabwinvar()">gettabwinvar()</a> ，只用当前标签页。
                例如: 
<code class="example">                        :let list_is_on = getwinvar(2, '&amp;list')</code>
<code class="example">                        :echo "myvar = " . getwinvar(1, 'myvar')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;getwinvar(varname)</code>
<code class="example"></code>
glob(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])              <b class="vimtag"> <a name="glob()">glob()</a> </b>
                扩展 <code class="special">{expr}</code> 里的文件通配符。 <a href="editing.html#wildcards">wildcards</a>  说明其中特殊字符的使用
                方法。

                除非给出可选的 <code class="special">{nosuf}</code> 参数且为  <a href="eval.html#TRUE">TRUE</a> ，应用 <a href="options.html#'suffixes'">'suffixes'</a> 和
                <a href="options.html#'wildignore'">'wildignore'</a> 选项: 跳过匹配任何 <a href="options.html#'wildignore'">'wildignore'</a> 模式的名字，而
                <a href="options.html#'suffixes'">'suffixes'</a> 影响匹配结果的排序。
                <a href="options.html#'wildignorecase'">'wildignorecase'</a> 则总是适用。

                如果给出 <code class="special">{list}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，返回列表，包含所有匹配的文件。使
                用列表的优点是可以正确得到包含换行符的文件名。
                否则返回的是字符串，且如果返回多个匹配，以 <code class="special">&lt;NL&gt;</code> 字符分隔。

                如果扩展失败，返回空字符串或空列表。

                扩展结果不包含不存在文件的名字。仅当符号链接指向已存在文件时才
                会包含在扩展结果内。但若给出了 <code class="special">{alllinks}</code> 参数且为  <a href="eval.html#TRUE">TRUE</a> ，则
                包含所有符号链接。

                多数系统上，可以用反引号从外部命令得到文件名。例如: 
<code class="example">                        :let tagfiles = glob("`find . -name tags -print`")</code>
<code class="example">                        :let &amp;tags = substitute(tagfiles, "\n", ",", "g")</code>
                反引号包围的程序的输出结果必须每个项目一行。项目内部可以使用空
                格。

                特殊 Vim 变量的扩展见  <a href="eval.html#expand()">expand()</a> 。 <a href="eval.html#system()">system()</a>  说明如何得到外部
                命令的原始输出。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;glob()</code>
<code class="example"></code>
glob2regpat(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="glob2regpat()">glob2regpat()</a> </b>
                转换 glob() 所用有文件模式为搜索模式。结果可用来匹配包含文件名
                的字符串。例如 
<code class="example">                        if filename =~ glob2regpat('Make*.mak')</code>
                等价于: 
<code class="example">                        if filename =~ '^Make.*\.mak$'</code>
                如果 <code class="special">{expr}</code> 为空串，返回值是 "^$"，匹配空串。
                <code class="note">备注</code> 结果与所用系统有关。MS-Windows 上反斜杠通常用作路径分隔
                符。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;glob2regpat()</code>
                                                                <b class="vimtag"> <a name="globpath()">globpath()</a> </b>
globpath(<code class="special">{path}</code>, <code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
                在 <code class="special">{path}</code> 的所有目录下的 <code class="special">{expr}</code> 执行 glob() 并连接所有的返回结
                果。例如: 
<code class="example">                        :echo globpath(&amp;rtp, "syntax/c.vim")</code>

                <code class="special">{path}</code> 是逗号分隔的目录名的列表。每个目录名都附加在 <code class="special">{expr}</code> 之
                前，然后如同  <a href="eval.html#glob()">glob()</a>  那样被扩展。必要的话，插入路径分隔符。
                要在目录名字里加上逗号，可以使用反斜杠转义。<code class="note">注意</code> 在 MS-Windows
                上目录的最后可能有一个反斜杠。如果你要在后面加上逗号进行分隔，
                先把反斜杠去掉。
                如果某个目录下的扩展失败，不会有错误信息。

                除非给出可选的 <code class="special">{nosuf}</code> 参数且为  <a href="eval.html#TRUE">TRUE</a> ，应用 <a href="options.html#'suffixes'">'suffixes'</a> 和
                <a href="options.html#'wildignore'">'wildignore'</a> 选项: 跳过匹配任何 <a href="options.html#'wildignore'">'wildignore'</a> 模式的名字，而
                <a href="options.html#'suffixes'">'suffixes'</a> 影响匹配结果的排序。

                如果给出 <code class="special">{list}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，返回匹配文件的列表。列表的好处是
                会正确处理包含换行符的文件名，否则返回字符串，有多个匹配时，以
                <code class="special">&lt;NL&gt;</code> 字符分隔。例如: 
<code class="example">                        :echo globpath(&amp;rtp, "syntax/c.vim", 0, 1)</code>

                <code class="special">{alllinks}</code> 的用法和  <a href="eval.html#glob()">glob()</a>  相同。

                可以用 "**" 项目来搜索目录树。例如，寻找在 <a href="options.html#'runtimepath'">'runtimepath'</a> 和它
                之下所有目录里的 "README.txt" 文件: 
<code class="example">                        :echo globpath(&amp;rtp, "**/README.txt")</code>
                不支持向上搜索和 "**" 的深度限制，所以 <a href="options.html#'path'">'path'</a> 的使用不一定总能
                正确工作。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetExpr()-&gt;globpath(&amp;rtp)</code>

                                                        <b class="vimtag"> <a name="has()">has()</a> </b>
has(<code class="special">{feature}</code>)  返回数值，如果支持特性 <code class="special">{feature}</code> 则为 1，不然为零。
                <code class="special">{feature}</code> 参数是字符串。见下面的  <a href="eval.html#feature-list">feature-list</a> 。
                另见  <a href="eval.html#exists()">exists()</a> 。


has_key(<code class="special">{dict}</code>, <code class="special">{key}</code>)                                  <b class="vimtag"> <a name="has_key()">has_key()</a> </b>
                返回数值，如果  <a href="eval.html#Dictionary">Dictionary</a>  <code class="special">{dict}</code> 有键为 <code class="special">{key}</code> 的项目则为 1，
                不然为零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mydict-&gt;has_key(key)</code>
<code class="example"></code>
haslocaldir([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])                      <b class="vimtag"> <a name="haslocaldir()">haslocaldir()</a> </b>
                返回数值:
                    1   如果窗口用  <a href="editing.html#:lcd">:lcd</a>  设置过局部目录
                    2   如果标签页用  <a href="editing.html#:tcd">:tcd</a>  设置过局部目录
                    0   其它。

                无参数时使用当前窗口。
                有 <code class="special">{winr}</code> 则使用当前标签页的该窗口。
                有 <code class="special">{winr}</code> 和 <code class="special">{tabnr}</code> 则使用指定标签页的该窗口。
                <code class="special">{winr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{winnr}</code> 为 -1，它被忽略，只使用标签页。
                如果参数非法，返回 0。
                Examples: 
<code class="example">                        if haslocaldir() == 1</code>
<code class="example">                          " 窗口的局部目录情况</code>
<code class="example">                        elseif haslocaldir() == 2</code>
<code class="example">                          " 标签页的局部目录情况</code>
<code class="example">                        else</code>
<code class="example">                          " 全局目录情况</code>
<code class="example">                        endif</code>
<code class="example"></code>
<code class="example">                        " 当前窗口</code>
<code class="example">                        :echo haslocaldir()</code>
<code class="example">                        :echo haslocaldir(0)</code>
<code class="example">                        :echo haslocaldir(0, 0)</code>
<code class="example">                        " 当前标签页的窗口 n</code>
<code class="example">                        :echo haslocaldir(n)</code>
<code class="example">                        :echo haslocaldir(n, 0)</code>
<code class="example">                        " 标签页 m 的窗口 n</code>
<code class="example">                        :echo haslocaldir(n, m)</code>
<code class="example">                        " 标签页 m</code>
<code class="example">                        :echo haslocaldir(-1, m)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;haslocaldir()</code>
<code class="example"></code>
hasmapto(<code class="special">{what}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])                  <b class="vimtag"> <a name="hasmapto()">hasmapto()</a> </b>
                返回数值，如果存在某映射，其右边的表达式 (被映射到的部分) 的某
                处包含 <code class="special">{what}</code>，并且该映射在 <code class="special">{mode}</code> 指定的模式下存在，返回 1。
                如果提供 <code class="special">{abbr}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，使用缩写而不是映射。不要忘记指定
                插入和/或命令行模式。
                同时检查全局映射和局部于当前缓冲区的映射以寻找匹配。
                如果没有匹配的映射，返回 0。
                <code class="special">{mode}</code> 识别下列字符:
                        n       普通模式
                        v       可视和选择模式
                        x       可视模式
                        s       选择模式
                        o       操作符等待模式
                        i       插入模式
                        l       Language-Argument ("r"、 "f"、"t" 等等) 模式
                        c       命令行模式
                如果没有提供 <code class="special">{mode}</code>，使用 "nvo"。

                该函数可用于检查是否存在映射到 Vim 脚本的某个函数的映射。例
                如: 
<code class="example">                        :if !hasmapto('\ABCdoit')</code>
<code class="example">                        :   map &lt;Leader&gt;d \ABCdoit</code>
<code class="example">                        :endif</code>
                这样，到 "\ABCdoit" 的映射只有在到 "\ABCdoit" 的映射还不存在的
                时候才会进行。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRHS()-&gt;hasmapto()</code>
<code class="example"></code>
histadd(<code class="special">{history}</code>, <code class="special">{item}</code>)                              <b class="vimtag"> <a name="histadd()">histadd()</a> </b>
                把字符串 <code class="special">{item}</code> 加到历史 <code class="special">{history}</code> 里。后者可以是:
                                                        <b class="vimtag"> <a name="hist-names">hist-names</a> </b>
                        "cmd"    或 ":"   命令行历史
                        "search" 或 "/"   搜索模式历史
                        "expr"   或 "="   输入表达式历史
                        "input"  或 "@"   输入行历史
                        "debug"  或 "&gt;"   调试命令历史
                        空                当前或最后使用的历史
                <code class="special">{history}</code> 字符串无须是完整名字，一个字符就够了。
                如果 <code class="special">{item}</code> 已经在历史里存在，它会被调整位置，从而成为最新的一
                项。
                返回结果为数值: 如果操作成功则为 1，不然返回 0。

                例如: 
<code class="example">                        :call histadd("input", strftime("%Y %b %d"))</code>
<code class="example">                        :let date=input("Enter date: ")</code>
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetHistory()-&gt;histadd('search')</code>
<code class="example"></code>
histdel(<code class="special">{history}</code> [, <code class="special">{item}</code>])                           <b class="vimtag"> <a name="histdel()">histdel()</a> </b>
                清除 <code class="special">{history}</code>，换而言之，删除它所有的项目。 <a href="eval.html#hist-names">hist-names</a>  解释
                <code class="special">{history}</code> 的所有可能值。

                如果 <code class="special">{item}</code> 计算结果为字符串，它被看作正规表达式。从历史里删除
                所有匹配该模式的项目 (如果有的话)。
                必须匹配大小写，除非使用 "\c"  <a href="pattern.html#%2F\c">/\c</a> 。
                如果 <code class="special">{item}</code> 的计算结果为数值，它被解释为索引值，见
                 <a href="cmdline.html#:history-indexing">:history-indexing</a> 。如果该索引存在，删除相应的项目。

                返回结果为数值: 如果操作成功则为 1，不然返回 0。

                例如:
                清除表达式寄存器历史: 
<code class="example">                        :call histdel("expr")</code>

                删除所有 "*" 开始的搜索历史: 
<code class="example">                        :call histdel("/", '^\*')</code>

                下面三者是等价的: 
<code class="example">                        :call histdel("search", histnr("search"))</code>
<code class="example">                        :call histdel("search", -1)</code>
<code class="example">                        :call histdel("search", '^'.histget("search", -1).'$')</code>

                要删除最后的搜索模式，并在 "n" 命令和 <a href="options.html#'hlsearch'">'hlsearch'</a> 里使用倒数第
                二个模式: 
<code class="example">                        :call histdel("search", -1)</code>
<code class="example">                        :let @/ = histget("search", -1)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetHistory()-&gt;histdel()</code>
<code class="example"></code>
histget(<code class="special">{history}</code> [, <code class="special">{index}</code>])                          <b class="vimtag"> <a name="histget()">histget()</a> </b>
                返回字符串，即 <code class="special">{history}</code> 历史的第 <code class="special">{index}</code> 项。 <a href="eval.html#hist-names">hist-names</a>  解
                释 <code class="special">{history}</code> 的所有可能值，而  <a href="cmdline.html#:history-indexing">:history-indexing</a>  解释
                <code class="special">{index}</code>。如果没有这个项目，返回空字符串。如果忽略 <code class="special">{index}</code>，返
                回历史里最近使用的项目。

                例如:
                重做历史里的倒数第二个搜索 
<code class="example">                        :execute '/' . histget("search", -2)</code>
<code class="example"></code>
                定义 Ex 命令 ":H <code class="special">{num}</code>"，以重新执行  <a href="cmdline.html#:history">:history</a>  输出的第 <code class="special">{num}</code>
                项。 
<code class="example">                        :command -nargs=1 H execute histget("cmd", 0+&lt;args&gt;)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetHistory()-&gt;histget()</code>

histnr(<code class="special">{history}</code>)                                       <b class="vimtag"> <a name="histnr()">histnr()</a> </b>
                返回当前项目在 <code class="special">{history}</code> 里的编号。 <a href="eval.html#hist-names">hist-names</a>  解释 <code class="special">{history}</code>
                的所有可能值。
                如果有错，返回 -1。

                例如: 
<code class="example">                        :let inp_index = histnr("expr")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetHistory()-&gt;histnr()</code>

hlexists(<code class="special">{name}</code>)                                        <b class="vimtag"> <a name="hlexists()">hlexists()</a> </b>
                返回数值。只要名为 <code class="special">{name}</code> 的高亮组用某种方法定义过，返回非零。
                不一定要为该组定义过高亮属性。一些语法项目可能已经使用该组。
                                                        <b class="vimtag"> <a name="highlight_exists()">highlight_exists()</a> </b>
                已废弃的名字: highlight_exists()。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;hlexists()</code>

                                                        <b class="vimtag"> <a name="hlID()">hlID()</a> </b>
hlID(<code class="special">{name}</code>)    返回数值，即名为 <code class="special">{name}</code> 的高亮组的 ID。如果该高亮组不存在，返
                回零。
                可用于提取高亮组的信息。比如，要得到 "Comment" 组的背景颜色: 
<code class="example">        :echo synIDattr(synIDtrans(hlID("Comment")), "bg")</code>
                                                        <b class="vimtag"> <a name="highlightID()">highlightID()</a> </b>
                已废弃的名字: highlightID()。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;hlID()</code>
<code class="example"></code>
hostname()                                              <b class="vimtag"> <a name="hostname()">hostname()</a> </b>
                返回字符串，即 Vim 运行的机器名字。超过 256 字符串长度的机器名
                被截短。

iconv(<code class="special">{expr}</code>, <code class="special">{from}</code>, <code class="special">{to}</code>)                             <b class="vimtag"> <a name="iconv()">iconv()</a> </b>
                返回字符串，即文本 <code class="special">{expr}</code> 从 <code class="special">{from}</code> 编码转到 <code class="special">{to}</code> 编码以后的文
                本。
                如果转换完全失败，返回空字符串。如果部分字符无法转换，以 "?"
                代替之。
                编码名字可以是任何 iconv() 库函数接受的名字，见
                ":!man 3 iconv"。
                大多数转换需要 Vim 编译时加入  <a href="various.html#+iconv">+iconv</a>  特性。不然，只支持
                UTF-8 和 latin1 的相互转换。
                这可以用来显示包含特殊字符的消息。不管 <a href="options.html#'encoding'">'encoding'</a> 设为何值，总
                可以用 UTF-8 书写消息，然后使用: 
<code class="example">                        echo iconv(utf8_str, "utf-8", &amp;enc)</code>
                <code class="note">注意</code> Vim 使用 UTF-8 进行所有的 Unicode 编码，从/到 UCS-2 的转
                换都自动转为 UTF-8。你不能在字符串里使用 UCS-2，因为那里有 NUL
                字节。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;iconv('latin1', 'utf-8')</code>

                                                        <b class="vimtag"> <a name="indent()">indent()</a> </b>
indent(<code class="special">{lnum}</code>)  返回数值，第 <code class="special">{lnum}</code> 行的缩进距离。缩进的计算以空格计，因而它和
                <a href="options.html#'tabstop'">'tabstop'</a> 的值是有关系的。<code class="special">{lnum}</code> 的使用方式和  <a href="eval.html#getline()">getline()</a>  相
                同。
                如果 <code class="special">{lnum}</code> 非法，返回 -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;indent()</code>
<code class="example"></code>
index(<code class="special">{object}</code>, <code class="special">{expr}</code> [, <code class="special">{start}</code> [, <code class="special">{ic}</code>]])                    <b class="vimtag"> <a name="index()">index()</a> </b>
                如果 <code class="special">{object}</code> 为  <a href="eval.html#List">List</a> ，返回值等于 <code class="special">{expr}</code> 的最小项目索引。这
                里不进行自动转换，字符串 "4" 不同于数值 4，数值 4 也不等同于浮
                点数 4.0。<a href="options.html#'ignorecase'">'ignorecase'</a> 的值此处也不适用，大小写不忽略。

                如果 <code class="special">{object}</code> 为  <a href="eval.html#Blob">Blob</a> ，返回字节值等于 <code class="special">{expr}</code> 的最小索引。

                如果给出 <code class="special">{start}</code>，从索引为 <code class="special">{start}</code> 的项目开始寻找 (可以为负，
                指定相对于尾部的项目)。
                如果给出 <code class="special">{ic}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，忽略大小写。否则，必须匹配大小写。
                如果在 <code class="special">{object}</code> 里找不到 <code class="special">{expr}</code>，返回 -1。
                示例: 
<code class="example">                        :let idx = index(words, "the")</code>
<code class="example">                        :if index(numbers, 123) &gt;= 0</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetObject()-&gt;index(what)</code>
<code class="example"></code>
input(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{completion}</code>]])             <b class="vimtag"> <a name="input()">input()</a> </b>
                返回字符串，即用户在命令行上的输入内容，可以为任何值。参数
                <code class="special">{prompt}</code> 或者是一个提示字符串，或者是一个空白字符串 (没有提
                示)。'\n' 可以在提示里使用，以开始新行。
                该提示使用  <a href="eval.html#:echohl">:echohl</a>  设置的高亮。
                输入方法和命令行相似，也使用相同的编辑命令和映射。但 input()
                输入的行使用另外的历史。
                示例: 
<code class="example">                        :if input("咖啡还是啤酒？") == "啤酒"</code>
<code class="example">                        :  echo "干杯！"</code>
<code class="example">                        :endif</code>

                如果给出可选的 <code class="special">{text}</code> 参数，它被用作缺省的回答，就像是用户输入
                的那样。例如: 
<code class="example">                        :let color = input("Color? ", "white")</code>
<code class="example"></code>
                可选的 <code class="special">{completion}</code> 参数指定输入支持的补全类型。如果不给出，不
                使用补全。支持的补全类型和用户定义命令用 "-complete=" 参数能给
                出的类型相同。详情见  <a href="map.html#:command-completion">:command-completion</a> 。例如: 
<code class="example">                        let fname = input("File: ", "", "file")</code>

                <code class="note">注意</code>: 在只能运行于 GUI 模式的版本里 (比如 Win32 GUI)，此函数不
                能在启动文件里使用。
                <code class="note">注意</code>: input() 在映射里调用时，它会消耗该映射余下的字符，因为映
                射的处理就像那些字符被键盘输入一样。在 input() 前使用
                 <a href="eval.html#inputsave()">inputsave()</a>  然后在 input() 输入之后  <a href="eval.html#inputrestore()">inputrestore()</a>  可以避
                免这一点。另一个方法是避免在映射的后面提供任何字符，比如，使用
                 <a href="eval.html#:execute">:execute</a>  或  <a href="various.html#:normal">:normal</a> 。

                使用映射的例子: 
<code class="example">                        :nmap \x :call GetFoo()&lt;CR&gt;:exe "/" . Foo&lt;CR&gt;</code>
<code class="example">                        :function GetFoo()</code>
<code class="example">                        :  call inputsave()</code>
<code class="example">                        :  let g:Foo = input("enter search pattern: ")</code>
<code class="example">                        :  call inputrestore()</code>
<code class="example">                        :endfunction</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPrompt()-&gt;input()</code>
<code class="example"></code>
inputdialog(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{cancelreturn}</code>]])             <b class="vimtag"> <a name="inputdialog()">inputdialog()</a> </b>
                类似于  <a href="eval.html#input()">input()</a> ，但如果运行 GUI 且支持文本对话框，弹出一个对
                话框窗口来输入文本。
                例如: 
<code class="example">                   :let n = inputdialog("value for shiftwidth", shiftwidth())</code>
<code class="example">                   :if n != ""</code>
<code class="example">                   :  let &amp;sw = n</code>
<code class="example">                   :endif</code>
                如果对话框被取消，返回 <code class="special">{cancelreturn}</code>。如果忽略，返回空字符
                串。
                输入 <code class="special">&lt;Enter&gt;</code> 和按 OK 按钮相同。按 <code class="special">&lt;Esc&gt;</code> 和按 Cancel 按钮相同。
                <code class="note">备注</code>: 不支持命令行补全。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPrompt()-&gt;inputdialog()</code>
<code class="example"></code>
inputlist(<code class="special">{textlist}</code>)                                   <b class="vimtag"> <a name="inputlist()">inputlist()</a> </b>
                <code class="special">{textlist}</code> 必须是字符串的  <a href="eval.html#List">List</a> 。显示此  <a href="eval.html#List">List</a> ，每个字符串一
                行。用户得到提示要输入一个数值，返回此值。
                用户也可以用鼠标点击项目来进行选择。第一个字符串返回 0。在第一
                个项目之上点击返回负数。在提示行上点击返回 <code class="special">{textlist}</code> 的长度加
                一。
                确保 <code class="special">{textlist}</code> 不超过 <a href="options.html#'lines'">'lines'</a> 个项目，否则无法使用。建议把项
                目编号放在每个字符串的开始处，并在第一项上加上提示。例如: 
<code class="example">                        let color = inputlist(['Select color:', '1. red',</code>
<code class="example">                                \ '2. green', '3. blue'])</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetChoices()-&gt;inputlist()</code>
<code class="example"></code>
inputrestore()                                          <b class="vimtag"> <a name="inputrestore()">inputrestore()</a> </b>
                恢复前一个  <a href="eval.html#inputsave()">inputsave()</a>  保存的预输入。应该和  <a href="eval.html#inputsave()">inputsave()</a>  调
                用的次数相同，不过调用更多次也无妨。
                如果没有可以恢复的，返回 1，不然返回 0。

inputsave()                                             <b class="vimtag"> <a name="inputsave()">inputsave()</a> </b>
                保存预输入 (也包括映射的) 并清除之，使得下一个提示能从用户得到
                输入。在提示之后应该跟上配套的 inputrestore()。可以多次使用，
                此时应该有同样多次的 inputrestore() 调用。
                如果内存不足，返回 1，不然返回 0。

inputsecret(<code class="special">{prompt}</code> [, <code class="special">{text}</code>])                        <b class="vimtag"> <a name="inputsecret()">inputsecret()</a> </b>
                该函数和  <a href="eval.html#input()">input()</a>  函数类似，但有两个例外:
                a) 用户的应答显示为一串星号 ("*")，从而输入可以保密，还有
                b) 用户的应答不会记录在输入  <a href="cmdline.html#history">history</a>  栈中。
                返回字符串，即用户在命令行上根据提示输入的应答。
                <code class="note">备注</code>: 不支持命令行补全。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPrompt()-&gt;inputsecret()</code>
<code class="example"></code>
insert(<code class="special">{object}</code>, <code class="special">{item}</code> [, <code class="special">{idx}</code>])                      <b class="vimtag"> <a name="insert()">insert()</a> </b>
                如果 <code class="special">{object}</code> 为  <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a> ，在开始处插入 <code class="special">{item}</code>。

                如果指定 <code class="special">{idx}</code>，<code class="special">{item}</code> 的插入位置在索引 <code class="special">{idx}</code> 之前。如果
                <code class="special">{idx}</code> 为零，插入在第一个项目之前，和省略 <code class="special">{idx}</code> 效果相同。也可
                用负的 <code class="special">{idx}</code>，见  <a href="eval.html#list-index">list-index</a> 。-1 插入在最后一个项目之前。
                返回新产生的  <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a> 。例如: 
<code class="example">                        :let mylist = insert([2, 3, 5], 1)</code>
<code class="example">                        :call insert(mylist, 4, -1)</code>
<code class="example">                        :call insert(mylist, 6, len(mylist))</code>
                用  <a href="eval.html#add()">add()</a>  可以更简单的完成最后一个例子。
                <code class="note">注意</code> 如 <code class="special">{item}</code> 是  <a href="eval.html#List">List</a> ，它被作为单个项目来插入。  <a href="eval.html#extend()">extend()</a> 
                用来连接多个  <a href="eval.html#List">List</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;insert(item)</code>
<code class="example"></code>
interrupt()                                             <b class="vimtag"> <a name="interrupt()">interrupt()</a> </b>
                中断脚本的执行。它或多或少像用户按了 <code class="keystroke">CTRL-C</code> 一样。多数命令不再
                执行，控制权还给用户。可用于中止较底层如自动命令等的执行。
                如: 
<code class="example">                :function s:check_typoname(file)</code>
<code class="example">                :   if fnamemodify(a:file, ':t') == '['</code>
<code class="example">                :       echomsg 'Maybe typo'</code>
<code class="example">                :       call interrupt()</code>
<code class="example">                :   endif</code>
<code class="example">                :endfunction</code>
<code class="example">                :au BufWritePre * call s:check_typoname(expand('&lt;amatch&gt;'))</code>
<code class="example"></code>
invert(<code class="special">{expr}</code>)                                          <b class="vimtag"> <a name="invert()">invert()</a> </b>
                按位取反。参数须转换为数值。列表、字典或浮点数参数会报错。
                示例: 
<code class="example">                        :let bits = invert(bits)</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :let bits = bits-&gt;invert()</code>
<code class="example"></code>
isdirectory(<code class="special">{directory}</code>)                                <b class="vimtag"> <a name="isdirectory()">isdirectory()</a> </b>
                返回数值，如果名为 <code class="special">{directory}</code> 的目录存在，返回  <a href="eval.html#TRUE">TRUE</a> 。如果
                <code class="special">{directory}</code> 不存在或者不是目录，返回  <a href="eval.html#FALSE">FALSE</a> 。<code class="special">{directory}</code> 可以
                是任何表达式，最终用作字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;isdirectory()</code>
<code class="example"></code>
isinf(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="isinf()">isinf()</a> </b>
                如果 <code class="special">{expr}</code> 是正无穷大返回 1，负无穷大返回 -1，否则返回 0。 
<code class="example">                        :echo isinf(1.0 / 0.0)</code>
                        1 
<code class="example">                        :echo isinf(-1.0 / 0.0)</code>
                        -1

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;isinf()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

islocked(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="islocked()">islocked()</a> </b> <b class="vimtag"> <a name="E786">E786</a> </b>
                返回数值，如果 <code class="special">{expr}</code> 是某个加锁的变量名，返回  <a href="eval.html#TRUE">TRUE</a> 。
                <code class="special">{expr}</code> 必须是变量名、 <a href="eval.html#List">List</a>  项目，或  <a href="eval.html#Dictionary">Dictionary</a>  项目，不是变
                量本身！例如: 
<code class="example">                        :let alist = [0, ['a', 'b'], 2, 3]</code>
<code class="example">                        :lockvar 1 alist</code>
<code class="example">                        :echo islocked('alist')         " 1</code>
<code class="example">                        :echo islocked('alist[1]')      " 0</code>
<code class="example"></code>
                如果 <code class="special">{expr}</code> 是不存在的变量，得到错误信息。用  <a href="eval.html#exists()">exists()</a>  可以检
                查它是否存在。

isnan(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="isnan()">isnan()</a> </b>
                如果 <code class="special">{expr}</code> 是值为 NaN 的浮点数，返回  <a href="eval.html#TRUE">TRUE</a> 。 
<code class="example">                        echo isnan(0.0 / 0.0)</code>
                        1

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;isnan()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

items(<code class="special">{dict}</code>)                                           <b class="vimtag"> <a name="items()">items()</a> </b>
                返回  <a href="eval.html#List">List</a> ，<code class="special">{dict}</code> 的所有键-值组对。每个  <a href="eval.html#List">List</a>  项目是两个项
                目的列表: <code class="special">{dict}</code> 项目的键和此项目的值。 <a href="eval.html#List">List</a>  项目的顺序不定。
                另见  <a href="eval.html#keys()">keys()</a>  和  <a href="eval.html#values()">values()</a> 。
                示例: 
<code class="example">                        for [key, value] in items(mydict)</code>
<code class="example">                           echo key . ': ' . value</code>
<code class="example">                        endfor</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mydict-&gt;items()</code>
<code class="example"></code>
job_ 函数文档在这里:  <a href="channel.html#job-functions-details">job-functions-details</a> 


join(<code class="special">{list}</code> [, <code class="special">{sep}</code>])                                  <b class="vimtag"> <a name="join()">join()</a> </b>
                连接所有 <code class="special">{list}</code> 项目成为字符串。
                如果指定 <code class="special">{sep}</code>，该分隔符出现在项目之间。如果省略 <code class="special">{sep}</code>，用单个
                空格。
                <code class="note">注意</code> 尾部不加 <code class="special">{sep}</code>。如果你坚持要加入: 
<code class="example">                        let lines = join(mylist, "\n") . "\n"</code>
                字符串项目照原样使用。用类似  <a href="eval.html#string()">string()</a>  的方式把  <a href="eval.html#List">List</a>  和
                 <a href="eval.html#Dictionary">Dictionary</a>  转化为字符串。
                逆函数是  <a href="eval.html#split()">split()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;join()</code>
<code class="example"></code>
js_decode(<code class="special">{string}</code>)                                     <b class="vimtag"> <a name="js_decode()">js_decode()</a> </b>
                和  <a href="eval.html#json_decode()">json_decode()</a>  类似，但有以下区别:
                - 对象键名不需用引号括起。
                - 字符串可以用单引号括起。
                - 接受数组的空项目 (两个逗句之间)，返回 v:none 项目。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ReadObject()-&gt;js_decode()</code>
<code class="example"></code>
js_encode(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="js_encode()">js_encode()</a> </b>
                和  <a href="eval.html#json_encode()">json_encode()</a>  类似，但有以下区别:
                - 对象键名不用引号括起。
                - 数组里的 v:none 项目生成逗号之间的空项目。
                例如，Vim 对象:
<code class="section">                        [1,v:none,{"one":1},v:none] </code>
                会被编码为:
<code class="section">                        [1,,<code class="special">{one:1}</code>,,] </code>
                而 json_encode() 会生成:
<code class="section">                        [1,null,{"one":1},null] </code>
                对 Javscript，这种编码也是合法的。但比 JSON 更高效，尤其是使用
                有可选项目的数组时。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetObject()-&gt;js_encode()</code>
<code class="example"></code>
json_decode(<code class="special">{string}</code>)                                   <b class="vimtag"> <a name="json_decode()">json_decode()</a> </b>
                解析 JSON 格式的字符串，返回等价的 Vim 值。见  <a href="eval.html#json_encode()">json_encode()</a> 
                了解 JSON 和 Vim 值的关系。
                解码是容错的:
                - 忽略数组和对象拖尾的逗号，例如 "[1, 2, ]" 等同 "[1, 2]"。
                - 对象中接受整数键，如 <code class="special">{1:2}</code> 和 {"1":2} 相同。
                - 识别更多浮点数，例如 "1." 相当于 "1.0"，而 "001.2" 相当于
                  "1.2"。接受特殊浮点值 "Infinity"、"-Infinity" 和 "NaN" (大小
                  写无关)。
                - 忽略整数值前导零，例如 "012" 相当于 "12"，而 "-012" 相当于
                  "-12"。
                - 按本义名 null、true 或 false 的大小写无关，例如 "NULL" 相当
                  于 "null"，"True" 相当于 "true"。
                - 接受字符串中不转义的控制字符 U+0000 到 U+001F，例如 " "
                  (字符串中的制表符) 相当于 "\t"。
                - 接受空或只有空白组成的 JSON 表达式，生成 v:none。
                - 忽略非法的两字符转义序列中的反斜杠，例如 "\a" 解码为 "a"。
                - JSON 字符串中正确的代理对正常应是 12 字符的序列，如
                  "\uD834\uDD1E"，但 json_decode() 安静地接受截断的代理对，例
                  如 "\uD834" 或 "\uD834\u"。
                                                                <b class="vimtag"> <a name="E938">E938</a> </b>
                对象里的重复键值，虽然在 rfc7159 中合法，便不被 json_decode()
                接受，因为转换结果必须是合法的 Vim 类型，例如，这样不行:
                {"a":"b", "a":"c"}

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ReadObject()-&gt;json_decode()</code>
<code class="example"></code>
json_encode(<code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="json_encode()">json_encode()</a> </b>
                对 <code class="special">{expr}</code> 进行 JSON 编码，返回字符串。
                编码格式在此指定:
                https://tools.ietf.org/html/rfc7159.html
                Vim 值的转换如下:
                    <a href="eval.html#Number">Number</a>              十进制数
                    <a href="eval.html#Float">Float</a>               浮点数
                   Float nan            "NaN"
                   Float inf            "Infinity"
                   Float -inf           "-Infinity"
                    <a href="eval.html#String">String</a>              双引号括起 (可为 null)
                    <a href="eval.html#Funcref">Funcref</a>             不接受，报错
                    <a href="eval.html#List">List</a>                作为数组 (可为 null)；若递归使用: []
                    <a href="eval.html#Dict">Dict</a>                作为对象 (可为 null)；若递归使用: <code class="special">{}</code>
                    <a href="eval.html#Blob">Blob</a>                作为一个个字节组成的数组
                   v:false              "false"
                   v:true               "true"
                   v:none               "null"
                   v:null               "null"
                <code class="note">备注</code> NaN 和 Infinity 作为值传递。这在 JSON 标准里没有提到，但
                若干实现支持。如果不支持，可能会报错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetObject()-&gt;json_encode()</code>
<code class="example"></code>
keys(<code class="special">{dict}</code>)                                            <b class="vimtag"> <a name="keys()">keys()</a> </b>
                返回  <a href="eval.html#List">List</a> ，<code class="special">{dict}</code> 的所有键。 <a href="eval.html#List">List</a>  项目的顺序不定。另见
                 <a href="eval.html#items()">items()</a>  和  <a href="eval.html#values()">values()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mydict-&gt;keys()</code>
<code class="example"></code>
                                                        <b class="vimtag"> <a name="len()">len()</a> </b> <b class="vimtag"> <a name="E701">E701</a> </b>
len(<code class="special">{expr}</code>)     返回数值，参数的长度。
                如果 <code class="special">{expr}</code> 为字符串或数值，返回它使用的字节数，和  <a href="eval.html#strlen()">strlen()</a> 
                相同。
                如果 <code class="special">{expr}</code> 为  <a href="eval.html#List">List</a> ，返回  <a href="eval.html#List">List</a>  的项目数量。
                如果 <code class="special">{expr}</code> 为  <a href="eval.html#Blob">Blob</a> ，返回字节数。
                如果 <code class="special">{expr}</code> 为  <a href="eval.html#Dictionary">Dictionary</a> ，返回  <a href="eval.html#Dictionary">Dictionary</a>  的项目数量。
                否则给出错误。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;len()</code>
<code class="example"></code>
                                                <b class="vimtag"> <a name="libcall()">libcall()</a> </b> <b class="vimtag"> <a name="E364">E364</a> </b> <b class="vimtag"> <a name="E368">E368</a> </b>
libcall(<code class="special">{libname}</code>, <code class="special">{funcname}</code>, <code class="special">{argument}</code>)
                在运行库 <code class="special">{libname}</code> 里调用函数 <code class="special">{funcname}</code> 并给出单个参数
                <code class="special">{argument}</code>。
                这可以用于调用库里的函数，尤其是 Vim 里用到的那些。因为只能使
                用单个参数，所以可以调用的标准库函数相当有限。
                结果是函数返回的字符串。如果函数返回 NULL，在 Vim 里会以空字符
                串 "" 出现。
                如果函数返回数值，请使用  <a href="eval.html#libcallnr()">libcallnr()</a> ！
                如果 <code class="special">{argument}</code> 是数值，它以 int 类型传给函数；如果 <code class="special">{argument}</code>
                是字符串，它以 null 结尾的字符串类型传入。
                在  <a href="starting.html#restricted-mode">restricted-mode</a>  里，该函数不能运行。

                libcall() 允许你写自己的 Vim <code class="badlink">'插件'</code> 扩展，而无须重新编译程序。
                它并 <code class="emphasis">不</code> 是用来调用系统函数的一个方法！如果你试图这么做，Vim 很
                有可能会崩溃。

                Win32 上，你写的函数必须在 DLL 里提供，而且必须使用普通的 C 调
                用惯例 ( <code class="emphasis">不是</code>  Windows 系统 DLL 使用的 Pascal 惯例)。函数必须
                只能接受单个参数，或者是字符指针，或者是长整数，而且必须返回字
                符指针或者 NULL。返回的字符指针必须指向在函数返回之后仍然指向
                合法的内存 (比如 DLL 的静态区域)。如果指向分配的区域，那么内存
                会发生泄漏。在函数里使用静态缓冲区应该可以，在 DLL 卸载时会被
                释放。

                警 告: 如果函数返回不合法的指针，Vim 会崩溃！如果函数返回数值
                也会发生同样的问题，因为 Vim 把它当作指针看待。
                Win32 系统上，<code class="special">{libname}</code> 必须是不带 ".DLL" 后缀的 DLL 文件名。
                只有 DLL 不在常见的位置的时候，才需要指定完整的路径名。
                Unix 上: 如果编译你自己的插件，记住目标代码必须生成位置无关代
                码 (<code class="badlink">'PIC'</code>)。
                {仅当使用 Win32 和一些 Unix 版本且带有  <a href="various.html#+libcall">+libcall</a>  特性时才有
                效}
                例如: 
<code class="example">                        :echo libcall("libc.so", "getenv", "HOME")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetValue()-&gt;libcall("libc.so", "getenv")</code>

                                                        <b class="vimtag"> <a name="libcallnr()">libcallnr()</a> </b>
libcallnr(<code class="special">{libname}</code>, <code class="special">{funcname}</code>, <code class="special">{argument}</code>)
                和  <a href="eval.html#libcall()">libcall()</a>  类似，但函数返回 int，而不是字符串。
                {仅当使用 Win32 和一些 Unix 版本且带有  <a href="various.html#+libcall">+libcall</a>  特性时才有
                效}
                例如: 
<code class="example">                        :echo libcallnr("/usr/lib/libc.so", "getpid", "")</code>
<code class="example">                        :call libcallnr("libc.so", "printf", "Hello World!\n")</code>
<code class="example">                        :call libcallnr("libc.so", "sleep", 10)</code>

                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetValue()-&gt;libcallnr("libc.so", "printf")</code>


line(<code class="special">{expr}</code> [, <code class="special">{winid}</code>])                                <b class="vimtag"> <a name="line()">line()</a> </b>
                返回数值，即 <code class="special">{expr}</code> 给定的文件位置的行号。可接受的位置是:
                    .       光标位置
                    $       缓冲区的最后一行
                    'x      位置标记 x 的位置 (如果该位置标记没有设置，返回 0)
                    w0      当前窗口可见部分的首行 (如果显示不刷新，如安静 Ex
                            模式下，则为一)
                    w$      当前窗口可见部分的末行 (如果无行可见，返回比 w0 小
                            一的值)
                    v       可视模式下: 可视区域的开始行 (光标是结束位置)。
                            如果不在可视模式下，返回当前光标位置。和  <a href="motion.html#'%3C">'&lt;</a>  不同
                            的是，会被立即更新。
                <code class="note">注意</code> 可以使用其它文件的位置标记。此时行号应用于那个缓冲区。
                要得到列号用  <a href="eval.html#col()">col()</a> 。两者都要可用  <a href="eval.html#getpos()">getpos()</a> 。
                给出可选的 <code class="special">{winid}</code> 参数时，从该窗口取值而不是当前窗口。
                例如: 
<code class="example">                        line(".")               光标所在的行号</code>
<code class="example">                        line(".", winid)        同上，但取自窗口 "winid"</code>
<code class="example">                        line("'t")              位置标记 t 的行号</code>
<code class="example">                        line("'" . marker)      名为 marker 的位置标记的行号</code>

                要在打开文件后跳转到最近已知的位置，见  <a href="usr_05.html#last-position-jump">last-position-jump</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetValue()-&gt;line()</code>
<code class="example"></code>
line2byte(<code class="special">{lnum}</code>)                                       <b class="vimtag"> <a name="line2byte()">line2byte()</a> </b>
                返回当前缓冲区第 <code class="special">{lnum}</code> 行从缓冲区开始计算的字节数。这里包括换
                行符，但它具体的值取决于当前缓冲区的 <a href="options.html#'fileformat'">'fileformat'</a> 选项，第一行
                返回 1。这和 <a href="options.html#'encoding'">'encoding'</a> 有关但忽略 <a href="options.html#'fileencoding'">'fileencoding'</a>。
                这也可以用来得到最后一行之后的 "那行" 的字节计数: 
<code class="example">                        line2byte(line("$") + 1)</code>
                这就等于缓冲区大小加 1。如果 <a href="options.html#'fileencoding'">'fileencoding'</a> 为空则等于文件大小
                加 1。
                如果 <code class="special">{lnum}</code> 非法或者编译时关闭了  <a href="various.html#+byte_offset">+byte_offset</a>  特性，返回
                -1。另见  <a href="eval.html#byte2line()">byte2line()</a> 、 <a href="motion.html#go">go</a>  和  <a href="motion.html#:goto">:goto</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;line2byte()</code>
<code class="example"></code>
lispindent(<code class="special">{lnum}</code>)                                      <b class="vimtag"> <a name="lispindent()">lispindent()</a> </b>
                得到第 <code class="special">{lnum}</code> 行根据 lisp 缩进规则应有的缩进距离，见 <a href="options.html#'lisp'">'lisp'</a>。
                缩进的计算以空格计，因而和 <a href="options.html#'tabstop'">'tabstop'</a> 的值是有关系的。
                <code class="special">{lnum}</code> 的使用方式和  <a href="eval.html#getline()">getline()</a>  相同。
                如果 <code class="special">{lnum}</code> 非法或者 Vim 编译时不带  <a href="various.html#+lispindent">+lispindent</a>  特性，返回
                -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;lispindent()</code>
<code class="example"></code>
list2str(<code class="special">{list}</code> [, <code class="special">{utf8}</code>])                             <b class="vimtag"> <a name="list2str()">list2str()</a> </b>
                把 <code class="special">{list}</code> 中的每个数值转换为字符，并连接成字符串。例如: 
<code class="example">                        list2str([32])          返回 " "</code>
<code class="example">                        list2str([65, 66, 67])  返回 "ABC"</code>
                也可以这样实现 (慢): 
<code class="example">                        join(map(list, {nr, val -&gt; nr2char(val)}), '')</code>
                 <a href="eval.html#str2list()">str2list()</a>  是逆操作。

                <code class="special">{utf8}</code> 省略或为零时，使用当前 <a href="options.html#'encoding'">'encoding'</a>。
                <code class="special">{utf8}</code> 为 1 时，总是返回 utf-8 字符。
                使用 utf-8 时，组合字符正常工作: 
<code class="example">                        list2str([97, 769])     返回 "aÌ"</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetList()-&gt;list2str()</code>
<code class="example"></code>
listener_add(<code class="special">{callback}</code> [, <code class="special">{buf}</code>])                      <b class="vimtag"> <a name="listener_add()">listener_add()</a> </b>
                添加缓冲区 <code class="special">{buf}</code> 有改动时会被执行的回调函数。
                <code class="special">{buf}</code> 可以是缓冲区名或号。它可接受的值见  <a href="eval.html#bufname()">bufname()</a> 。省略
                <code class="special">{buf}</code> 时使用当前缓冲区。
                返回唯一的 ID，可传递给  <a href="eval.html#listener_remove()">listener_remove()</a> 。

                <code class="special">{callback}</code> 调用时带五个参数:
                    a:bufnr     发生改动的缓冲区
                    a:start     改动发生的首行行号
                    a:end       改动区域之下的首行行号
                    a:added     增加的行数，如果删除行则为负数
                    a:changes   关于改动细节的项目列表

                示例: 
<code class="example">            func Listener(bufnr, start, end, added, changes)</code>
<code class="example">              echo 'lines ' .. a:start .. ' until ' .. a:end .. ' changed'</code>
<code class="example">            endfunc</code>
<code class="example">            call listener_add('Listener', bufnr)</code>
<code class="example"></code>
                此列表不能修改。a:changes 的每个项目是带以下项的字典:
                    lnum        改动的首行行号
                    end         改动区域之下的首行行号
                    added       增加的行数，如果删除行则为负数
                    col         "lnum" 中受改动影响的首列；如果未知或整行都受
                                影响则为一；这是字节计数，首个字符的值为一。
                插入新行时，值为:
                    lnum        在该行之上加入了新行
                    end         等于 "lnum"
                    added       插入的行数
                    col         1
                删除行时，值为:
                    lnum        首个删除行
                    end         删除发生之前首 (<code class="vim">译者注</code>: 应为末？) 个删除行之下
                                的那行
                    added       负数，删除的行数
                    col         1
                行发生改动时:
                    lnum        首个改动行
                    end         最后改动行之下的那行
                    added       0
                    col         改动发生的首列，或 1

                依改动发生的次序列出项目，这样最近发生的改动在最后。行号在回调
                发生时是合法的，但之后的改动可能使之非法，所以保存它们以备后用
                是不可行的。

                在屏幕刚刚刷新前调用 <code class="special">{callback}</code>，此后调用  <a href="eval.html#listener_flush()">listener_flush()</a> 
                或进行影响行的数目的改动会使得改动列表里的行号变成非法。

                <code class="special">{callback}</code> 调用时文本被锁定，见  <a href="eval.html#textlock">textlock</a> 。如果需要改动缓冲
                区，使用定时器可以在之后某时进行需要的改动  <a href="eval.html#timer_start()">timer_start()</a> 。

                缓冲区初次载入时不调用 <code class="special">{callback}</code>。 <a href="autocmd.html#BufReadPost">BufReadPost</a>  自动命令事件
                可用来处理缓冲区的初始文本。
                缓冲区被卸载时也不调用 <code class="special">{callback}</code>， <a href="autocmd.html#BufUnload">BufUnload</a>  自动事件可用于
                此。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetBuffer()-&gt;listener_add(callback)</code>
<code class="example"></code>
listener_flush([<code class="special">{buf}</code>])                                 <b class="vimtag"> <a name="listener_flush()">listener_flush()</a> </b>
                调用缓冲区 <code class="special">{buf}</code> 的监听器回调。如果没有待处理的改动则不调用回
                调。

                <code class="special">{buf}</code> 可以是缓冲区名或号。它可接受的值见  <a href="eval.html#bufname()">bufname()</a> 。省略
                <code class="special">{buf}</code> 时使用当前缓冲区。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;listener_flush()</code>
<code class="example"></code>
listener_remove(<code class="special">{id}</code>)                                   <b class="vimtag"> <a name="listener_remove()">listener_remove()</a> </b>
                删除之前用 listener_add() 加的监听器。
                如果 <code class="special">{id}</code> 找不到返回零，<code class="special">{id}</code> 已删除时返回一。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetListenerId()-&gt;listener_remove()</code>
<code class="example"></code>
localtime()                                             <b class="vimtag"> <a name="localtime()">localtime()</a> </b>
                返回当前时间，以 1970 年 1 月 1 日开始的秒数计算。另见
                 <a href="eval.html#strftime()">strftime()</a> 、 <a href="eval.html#strptime()">strptime()</a>  和  <a href="eval.html#getftime()">getftime()</a> 。

log(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="log()">log()</a> </b>
                返回浮点数，即浮点数 <code class="special">{expr}</code> 的自然对数 (即以 e 为底)。
                <code class="special">{expr}</code> 计算结果必须为 (0, inf] 区间内的浮点数或数值。
                示例: 
<code class="example">                        :echo log(10)</code>
                        2.302585 
<code class="example">                        :echo log(exp(5))</code>
                        5.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;log()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

log10(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="log10()">log10()</a> </b>
                返回浮点数，即浮点数 <code class="special">{expr}</code> 以 10 为底的对数。
                <code class="special">{expr}</code> 计算结果必须为浮点数或数值。
                示例: 
<code class="example">                        :echo log10(1000)</code>
                        3.0 
<code class="example">                        :echo log10(0.01)</code>
                        -2.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;log10()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

luaeval(<code class="special">{expr}</code> [, <code class="special">{expr}</code>])                                      <b class="vimtag"> <a name="luaeval()">luaeval()</a> </b>
                执行 Lua 表达式 <code class="special">{expr}</code> 并把结果转换为 Vim 数据结构。第二个
                <code class="special">{expr}</code> 指定在第一个 <code class="special">{expr}</code> 里可以使用的额外参数，可以 _A 形式
                访问。
                字符串原样返回。
                布尔值对象转换为数值。
                vim 编译时带  <a href="various.html#+float">+float</a>  特性时，数值转换为  <a href="eval.html#Float">Float</a> ，否则作为数值
                型返回。
                vim.eval() 得到的字典和列表以原样返回。
                 <a href="if_lua.html#lua-luaeval">lua-luaeval</a>  有更多详情。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;luaeval()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+lua">+lua</a>  特性才有效}</code>

map(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                   <b class="vimtag"> <a name="map()">map()</a> </b>
                <code class="special">{expr1}</code> 必须是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。
                <code class="special">{expr1}</code> 里的每个项目被 <code class="special">{expr2}</code> 的计算结果替代。<code class="special">{expr2}</code> 必须是
                 <a href="eval.html#string">string</a>  或  <a href="eval.html#Funcref">Funcref</a> 。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#string">string</a> ，<code class="special">{expr2}</code> 内的  <a href="eval.html#v:val">v:val</a>  包含当前项目的
                值。 <a href="eval.html#Dictionary">Dictionary</a>  中  <a href="eval.html#v:key">v:key</a>  包含当前项目的键。 <a href="eval.html#List">List</a>  中
                 <a href="eval.html#v:key">v:key</a>  包含当前项目的索引。
                例如: 
<code class="example">                        :call map(mylist, '"&gt; " . v:val . " &lt;"')</code>
                "mylist" 里的每个项目之前放上 "&gt; "，而之后放上 " &lt;"。

                <code class="note">注意</code> <code class="special">{string}</code> 是表达式的计算结果，而它本身又用作表达式。通常，
                最好用  <a href="eval.html#literal-string">literal-string</a>  来避免反斜杠加倍。当然，你仍然需要加倍
                ' 引号。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#Funcref">Funcref</a> ，它必须接受两个参数:
                        1. 当前项目的键或索引。
                        2. 当前项目的值。
                函数必须返回项目的新值。例如要改变每个值为 "键-值": 
<code class="example">                        func KeyValue(key, val)</code>
<code class="example">                          return a:key . '-' . a:val</code>
<code class="example">                        endfunc</code>
<code class="example">                        call map(myDict, function('KeyValue'))</code>
                使用  <a href="eval.html#lambda">lambda</a>  会更短: 
<code class="example">                        call map(myDict, {key, val -&gt; key . '-' . val})</code>
                如果不用 "val"，可以不写: 
<code class="example">                        call map(myDict, {key -&gt; 'item: ' . key})</code>
                如果不用 "key"，可以使用短名: 
<code class="example">                        call map(myDict, {_, val -&gt; 'item: ' . val})</code>

                本操作是原位操作 (直接在输入上修改)。要想不更动  <a href="eval.html#List">List</a>  或
                 <a href="eval.html#Dictionary">Dictionary</a> ，先建立备份: 
<code class="example">                        :let tlist = map(copy(mylist), ' v:val . "\t"')</code>
<code class="example"></code>
                返回 <code class="special">{expr1}</code>，经过过滤的  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。如果执行
                <code class="special">{expr2}</code> 有错，不再处理 <code class="special">{expr1}</code> 的其余项目。<code class="special">{expr2}</code> 是函数引用
                时，忽略函数里的错误，除非该函数用 "abort" 标志位定义。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;map(expr2)</code>
<code class="example"></code>
maparg(<code class="special">{name}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code> [, <code class="special">{dict}</code>]]])                 <b class="vimtag"> <a name="maparg()">maparg()</a> </b>
                当 <code class="special">{dict}</code> 省略或为零，返回模式 <code class="special">{mode}</code> 名为 <code class="special">{name}</code> 的映射的右手
                边 (rhs)。返回字符串中的特殊字符用和 ":map" 命令输出的同样方式
                进行翻译。

                如果没有名为 <code class="special">{name}</code> 的映射，返回 "<code class="special">&lt;Nop&gt;</code>"。

                <code class="special">{name}</code> 可包含特殊键名，一如 ":map" 命令。

                <code class="special">{mode}</code> 可以使用下列字符串之一:
                        "n"     普通模式
                        "v"     可视模式 (包括选择)
                        "o"     操作符等待模式
                        "i"     插入模式
                        "c"     命令行模式
                        "s"     选择模式
                        "x"     可视模式
                        "l"     语言映射  <a href="map.html#language-mapping">language-mapping</a> 
                        "t"     终端-作业
                        ""      普通、可视和操作符等待模式。
                如果没有提供 <code class="special">{mode}</code>，使用 "" 指定的模式。

                如果提供 <code class="special">{abbr}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，使用缩写而不是映射。

                如果提供 <code class="special">{dict}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，返回字典，包含关于映射的所有信
                息。有如下项目:
                  "lhs"      映射的 <code class="special">{lhs}</code>。
                  "rhs"      映射的 <code class="special">{rhs}</code>，保持输入原样。
                  "silent"   1 若是  <a href="map.html#:map-silent">:map-silent</a>  映射，否则为 0。
                  "noremap"  1 若是映射的 <code class="special">{rhs}</code> 不能再映射。
                  "expr"     1 若是表达式映射 ( <a href="map.html#:map-%3Cexpr%3E">:map-&lt;expr&gt;</a> )。
                  "buffer"   1 若是缓冲区本地映射 ( <a href="map.html#:map-local">:map-local</a> )。
                  "mode"     映射定义使用的模式。除了以上提到的模式以外，还会
                             使用:
                             " "     普通、可视和操作符等待模式
                             "!"     插入和命令行模式
                                     ( <a href="map.html#mapmode-ic">mapmode-ic</a> )
                  "sid"      脚本局部 ID，用于 <code class="special">&lt;sid&gt;</code> 映射 ( <a href="map.html#%3CSID%3E">&lt;SID&gt;</a> )。
                  "lnum"     "sid" 中的行号，如果未知则为零。
                  "nowait"   不等待其它更长的映射。( <a href="map.html#:map-%3Cnowait%3E">:map-&lt;nowait&gt;</a> )。

                先检查局部于当前缓冲区的映射，然后再检查全局映射。
                此函数可以用来给键映射。如果已经映射过，还可以使用原来映射的内
                容。大意: 
<code class="example">                        exe 'nnoremap &lt;Tab&gt; ==' . maparg('&lt;Tab&gt;', 'n')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetKey()-&gt;maparg('n')</code>
<code class="example"></code>
mapcheck(<code class="special">{name}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])                  <b class="vimtag"> <a name="mapcheck()">mapcheck()</a> </b>
                检查是否有模式 <code class="special">{mode}</code> 下匹配 <code class="special">{name}</code> 的映射。 <a href="eval.html#maparg()">maparg()</a>  说明
                <code class="special">{mode}</code> 和 <code class="special">{name}</code> 里的特殊键名。
                如果提供 <code class="special">{abbr}</code> 且为  <a href="eval.html#TRUE">TRUE</a> ，使用缩写而不是映射。
                匹配在映射名以 <code class="special">{name}</code> 开始或者映射名等于 <code class="special">{name}</code> 的开始部分时候
                发生。

<code class="section">                        匹配映射        "a"     "ab"    "abc" </code>
                   mapcheck("a")        是      是       是
                   mapcheck("abc")      是      是       是
                   mapcheck("ax")       是      否       否
                   mapcheck("b")        否      否       否

                和 maparg() 的差别是，mapcheck() 查找匹配 <code class="special">{name}</code> 的映射，而
                maparg() 只查找名字完全符合 <code class="special">{name}</code> 的映射。
                如果没有 <code class="special">{name}</code> 开始的映射，返回空字符串。如果有一个，返回该映
                射的右手边。如果有多个，返回其中某一个的右手边。如果该右手边为
                空，返回 "<code class="special">&lt;Nop&gt;</code>"。
                先检查局部于当前缓冲区的映射，然后再检查全局映射。
                该函数用于检查是否可以无二义性地添加映射。例如: 
<code class="example">        :if mapcheck("_vv") == ""</code>
<code class="example">        :   map _vv :set guifont=7x13&lt;CR&gt;</code>
<code class="example">        :endif</code>
                就避免了在已有 "_v" 或者 "_vvv" 映射的时候添加 "_vv" 映射。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetKey()-&gt;mapcheck('n')</code>
<code class="example"></code>
match(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])                    <b class="vimtag"> <a name="match()">match()</a> </b>
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，返回匹配 <code class="special">{pat}</code> 的第一个项目的索引。每个
                项目用作字符串， <a href="eval.html#List">List</a>  和  <a href="eval.html#Dictionary">Dictionary</a>  使用回显的形式。

                否则，<code class="special">{expr}</code> 用作字符串。返回数值，给出 <code class="special">{expr}</code> 里 <code class="special">{pat}</code> 匹配的
                (字节计算的偏移量) 位置。

                在第一个字符或  <a href="eval.html#List">List</a>  项目上的匹配返回零。若无匹配，返回 -1。
                要得到子匹配，见  <a href="eval.html#matchlist()">matchlist()</a> 。

                例如: 
<code class="example">                        :echo match("testing", "ing")   " 返回 4</code>
<code class="example">                        :echo match([1, 'x'], '\a')     " 返回 1</code>
                 <a href="eval.html#string-match">string-match</a>  说明如何使用 <code class="special">{pat}</code>。
                                                                <b class="vimtag"> <a name="strpbrk()">strpbrk()</a> </b>
                Vim 没有 strpbrk() 函数。但你可以这么做: 
<code class="example">                        :let sepidx = match(line, '[.,;: \t]')</code>
                                                                <b class="vimtag"> <a name="strcasestr()">strcasestr()</a> </b>
                Vim 没有 strcasestr() 函数。但你可以在模式里加入 "\c" 以忽略大
                小写: 
<code class="example">                        :let idx = match(haystack, '\cneedle')</code>

                如果给出 <code class="special">{start}</code>，搜索从字符串的字节位置 <code class="special">{start}</code> 或  <a href="eval.html#List">List</a>  索
                引为 <code class="special">{start}</code> 的项目开始。
                不过，结果仍然从第一个字符/项目开始算起。比如: 
<code class="example">                        :echo match("testing", "ing", 2)</code>
                返回结果是 "4"。 
<code class="example">                        :echo match("testing", "ing", 4)</code>
                返回结果还是 "4"。 
<code class="example">                        :echo match("testing", "t", 2)</code>
                返回 "3"。
                对字符串而言，如果 <code class="special">{start}</code> &gt; 0，其行为就像该字符串在 <code class="special">{start}</code>
                个字节后开始，因而 "^" 会从 <code class="special">{start}</code> 开始匹配。如果给出 <code class="special">{count}</code>
                时则不是如此，此时忽略 <code class="special">{start}</code> 字节前的匹配 (有一点复杂，这是
                为了后向兼容)。
                对字符串而言，如果 <code class="special">{start}</code> &lt; 0，它被置为 0。对列表而言，此索引
                从尾部起算。
                如果 <code class="special">{start}</code> 越界 (字符串 <code class="special">{start}</code> &gt; strlen(<code class="special">{expr}</code>)，而  <a href="eval.html#List">List</a> 
                <code class="special">{start}</code> &gt; len(<code class="special">{expr}</code>))，返回 -1。

                如果给出 <code class="special">{count}</code>，使用第 <code class="special">{count}</code> 个匹配。如果字符串里找到一个
                匹配，下一匹配从此匹配之后一个字符开始寻找。所以下例返回 1: 
<code class="example">                        echo match("testing", "..", 0, 2)</code>
                 <a href="eval.html#List">List</a>  里，搜索从下一个项目开始。
                <code class="note">注意</code> 如果加入 <code class="special">{count}</code>，<code class="special">{start}</code> 使用的方式有所改变。见上。

                 <a href="pattern.html#pattern">pattern</a>  说明可以接受的模式。
                <a href="options.html#'ignorecase'">'ignorecase'</a> 选项用来设定模式是否忽略大小写。 <code class="emphasis">不</code> 使用
                <a href="options.html#'smartcase'">'smartcase'</a>。匹配总是假定置位了 <a href="options.html#'magic'">'magic'</a> 而 <a href="options.html#'cpoptions'">'cpoptions'</a> 为空。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetList()-&gt;match('word')</code>

                                <b class="vimtag"> <a name="matchadd()">matchadd()</a> </b> <b class="vimtag"> <a name="E798">E798</a> </b> <b class="vimtag"> <a name="E799">E799</a> </b> <b class="vimtag"> <a name="E801">E801</a> </b> <b class="vimtag"> <a name="E957">E957</a> </b>
matchadd(<code class="special">{group}</code>, <code class="special">{pattern}</code> [, <code class="special">{priority}</code> [, <code class="special">{id}</code> [, <code class="special">{dict}</code>]]])
                定义模式 (一个 "匹配")， 在当前窗口用高亮组 <code class="special">{group}</code> 高亮。返回
                标识号 (ID)， <a href="eval.html#matchdelete()">matchdelete()</a>  可用该 ID 来删除匹配。该 ID 是和
                窗口绑定的。
                匹配是大小写敏感和带魔术的，但大小写敏感性和魔术性在 <code class="special">{pattern}</code>
                里可被显式关闭。不使用 <a href="options.html#'magic'">'magic'</a>、<a href="options.html#'smartcase'">'smartcase'</a> 和
                <a href="options.html#'ignorecase'">'ignorecase'</a> 选项。
                "Conceal" 值是特别的，它使匹配被隐藏。

                可选的 <code class="special">{priority}</code> 参数指定匹配的优先级。高优先级的匹配的高亮会
                否决低优先级匹配的高亮。优先级用整数指定 (负整数也无不可)。如
                果未指定 <code class="special">{priority}</code> 参数，缺省优先级为 10。<a href="options.html#'hlsearch'">'hlsearch'</a> 的优先级
                为零，这样所有正优先级的匹配都可以否决它。语法高亮 (见
                <a href="options.html#'syntax'">'syntax'</a>) 采用不同的机制，无论选择的优先级如何，匹配总会否决语
                法的高亮。

                可选的 <code class="special">{id}</code> 参数请求特定的匹配 ID。如果指定的 ID 已用，报错，
                并不加入该匹配。ID 用正整数指定 (不含零)。ID 1、2 和 3 分别为
                 <a href="pattern.html#:match">:match</a> 、 <a href="pattern.html#:2match">:2match</a>  和  <a href="pattern.html#:3match">:3match</a>  命令保留。如果 <code class="special">{id}</code> 未指定或
                为 -1， <a href="eval.html#matchadd()">matchadd()</a>  自动选择一个可用的 ID。

                可选的 <code class="special">{dict}</code> 参数允许更多定制。目前，可用来指定特定于匹配的隐
                藏字符，使用  <a href="syntax.html#hl-Conceal">hl-Conceal</a>  高亮匹配来显示。该字典有以下成员:

                        conceal     显示的特殊字符，而非匹配 (只用于
                                     <a href="syntax.html#hl-Conceal">hl-Conceal</a>  高亮匹配，见  <a href="syntax.html#:syn-cchar">:syn-cchar</a> )
                        window      不使用当前窗口，而使用指定窗口号或窗口 ID
                                    的其它窗口。

                匹配的数目不限， <a href="pattern.html#:match">:match</a>  诸命令则有此局限。

                示例: 
<code class="example">                        :highlight MyGroup ctermbg=green guibg=green</code>
<code class="example">                        :let m = matchadd("MyGroup", "TODO")</code>
                要删除该模式: 
<code class="example">                        :call matchdelete(m)</code>
<code class="example"></code>
                用  <a href="eval.html#getmatches()">getmatches()</a>  可以得到  <a href="eval.html#matchadd()">matchadd()</a>  和  <a href="pattern.html#:match">:match</a>  定义的匹配
                列表。 <a href="eval.html#clearmatches()">clearmatches()</a>  可一次删除所有的匹配。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetGroup()-&gt;matchadd('TODO')</code>

                                                        <b class="vimtag"> <a name="matchaddpos()">matchaddpos()</a> </b>
matchaddpos(<code class="special">{group}</code>, <code class="special">{pos}</code> [, <code class="special">{priority}</code> [, <code class="special">{id}</code> [, <code class="special">{dict}</code>]]])
                和  <a href="eval.html#matchadd()">matchadd()</a>  相同，但需要位置列表 <code class="special">{pos}</code> 而非匹配模式。比
                 <a href="eval.html#matchadd()">matchadd()</a>  更快，因为无需处理正规表达式并设置缓冲区行边界以
                重画屏幕。主要用于需要快速增加或删除匹配的场合，如匹配括号的高
                亮。

                <code class="special">{pos}</code> 列表包含以下项目之一:
                - 数值。该行整行被高亮。首行的行号为 1。
                - 单个数值的列表。如 <code class="special">[23]</code>。该行整行被高亮。
                - 包含两个数值的列表，如 [23, 11]。前面的数是行号，后面的是列
                  号 (首列为 1，必须对应  <a href="eval.html#col()">col()</a>  返回的字节索引)。此位置的字符
                  被高亮。
                - 包含三个数值的列表，如 [23, 11, 3]。同上，但第三个数给出高亮
                  字节计的长度。

                最多可有 8 个位置。

                示例: 
<code class="example">                        :highlight MyGroup ctermbg=green guibg=green</code>
<code class="example">                        :let m = matchaddpos("MyGroup", [[23, 24], 34])</code>
                模式的删除: 
<code class="example">                        :call matchdelete(m)</code>
<code class="example"></code>
                 <a href="eval.html#matchaddpos()">matchaddpos()</a>  加入的匹配在  <a href="eval.html#getmatches()">getmatches()</a>  返回时带有项目
                "pos1"、"pos2"，等等，其值为 <code class="special">{pos}</code> 项目提供的列表。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetGroup()-&gt;matchaddpos([23, 11])</code>
<code class="example"></code>
matcharg(<code class="special">{nr}</code>)                                                  <b class="vimtag"> <a name="matcharg()">matcharg()</a> </b>
                选择 <code class="special">{nr}</code> 号匹配的项目，它们分别用  <a href="pattern.html#:match">:match</a> 、 <a href="pattern.html#:2match">:2match</a>  或
                 <a href="pattern.html#:3match">:3match</a>  命令设置。
                返回两个项目的  <a href="eval.html#List">List</a> :
                        使用的高亮组名
                        使用的模式。
                如果 <code class="special">{nr}</code> 不是 1、2 或 3，返回空  <a href="eval.html#List">List</a> 。
                如果没有匹配的项目，返回 ['', '']。
                这用来保存和恢复  <a href="pattern.html#:match">:match</a> 。
                用  <a href="pattern.html#:match">:match</a>  命令高亮的匹配限于三个。 <a href="eval.html#matchadd()">matchadd()</a>  无此限制。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMatch()-&gt;matcharg()</code>
<code class="example"></code>
matchdelete(<code class="special">{id}</code> [, <code class="special">{win}</code>)                     <b class="vimtag"> <a name="matchdelete()">matchdelete()</a> </b> <b class="vimtag"> <a name="E802">E802</a> </b> <b class="vimtag"> <a name="E803">E803</a> </b>
                删除之前用  <a href="eval.html#matchadd()">matchadd()</a>  或  <a href="pattern.html#:match">:match</a>  诸命令定义的 ID 为 <code class="special">{id}</code> 的
                匹配。如果成功，返回 0，不然返回 -1。示例见  <a href="eval.html#matchadd()">matchadd()</a> 。
                 <a href="eval.html#clearmatches()">clearmatches()</a>  可一次删除所有的匹配。
                如果指定 <code class="special">{win}</code>，使用指定窗口号或窗口 ID 的窗口而不是当前窗口。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMatch()-&gt;matchdelete()</code>
<code class="example"></code>
matchend(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])                 <b class="vimtag"> <a name="matchend()">matchend()</a> </b>
                和  <a href="eval.html#match()">match()</a>  相同，但返回匹配之后的第一个字符的位置。比如: 
<code class="example">                        :echo matchend("testing", "ing")</code>
                返回 "7"。
                                                        <b class="vimtag"> <a name="strspn()">strspn()</a> </b> <b class="vimtag"> <a name="strcspn()">strcspn()</a> </b>
                Vim 没有 strspn() 或 strcspn() 函数，但可用 matchend() 实现: 
<code class="example">                        :let span = matchend(line, '[a-zA-Z]')</code>
<code class="example">                        :let span = matchend(line, '[^a-zA-Z]')</code>
                不过没有匹配时，它返回 -1。

                如果给出 <code class="special">{start}</code>，和  <a href="eval.html#match()">match()</a>  里的用法相同。 
<code class="example">                        :echo matchend("testing", "ing", 2)</code>
                返回 "7"。 
<code class="example">                        :echo matchend("testing", "ing", 5)</code>
                返回 "-1"。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，结果和  <a href="eval.html#match()">match()</a>  相同。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;matchend('word')</code>
<code class="example"></code>
matchlist(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])                <b class="vimtag"> <a name="matchlist()">matchlist()</a> </b>
                和  <a href="eval.html#match()">match()</a>  相同，但返回  <a href="eval.html#List">List</a> 。列表第一项是匹配的字符串，和
                 <a href="eval.html#matchstr()">matchstr()</a>  返回值相同。其后的项目是子匹配，类似
                 <a href="change.html#:substitute">:substitute</a>  的 "\1"、"\2" 等。如果某个可选的子匹配不匹配，用
                空字符串代替。例如: 
<code class="example">                        echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')</code>
                返回: [<a href="options.html#'acd'">'acd'</a>, 'a', '', 'c', 'd', '', '', '', '', '']
                如果没有匹配，返回空列表。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetList()-&gt;matchlist('word')</code>
<code class="example"></code>
matchstr(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])                 <b class="vimtag"> <a name="matchstr()">matchstr()</a> </b>
                和  <a href="eval.html#match()">match()</a>  相同，但返回匹配的字符串。例如: 
<code class="example">                        :echo matchstr("testing", "ing")</code>
                返回 "ing"。
                如果没有匹配，返回 ""。
                如果给出 <code class="special">{start}</code>，它和  <a href="eval.html#match()">match()</a>  里的用法相同。 
<code class="example">                        :echo matchstr("testing", "ing", 2)</code>
                返回 "ing"。 
<code class="example">                        :echo matchstr("testing", "ing", 5)</code>
                返回 ""。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，返回匹配的项目。其类型不改变，因而不一
                定是字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;matchstr('word')</code>
<code class="example"></code>
matchstrpos(<code class="special">{expr}</code>, <code class="special">{pat}</code> [, <code class="special">{start}</code> [, <code class="special">{count}</code>]])              <b class="vimtag"> <a name="matchstrpos()">matchstrpos()</a> </b>
                和  <a href="eval.html#matchstr()">matchstr()</a>  相同，但返回匹配的字符串和匹配的始末位置。例
                如: 
<code class="example">                        :echo matchstrpos("testing", "ing")</code>
                返回 ["ing", 4, 7]。
                如果没有匹配，返回 ["", -1, -1]。
                如果给出 <code class="special">{start}</code>，它和  <a href="eval.html#match()">match()</a>  里的用法相同。 
<code class="example">                        :echo matchstrpos("testing", "ing", 2)</code>
                返回 ["ing", 4, 7]。 
<code class="example">                        :echo matchstrpos("testing", "ing", 5)</code>
                返回 ["", -1, -1]。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，返回匹配项目，<code class="special">{pat}</code> 匹配的首个项目的索
                引，匹配的开始位置和结束位置。 
<code class="example">                        :echo matchstrpos([1, '__x'], '\a')</code>
                返回 ["x", 1, 2, 3]。
                不改变类型，不必然是字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;matchstrpos('word')</code>

                                                        <b class="vimtag"> <a name="max()">max()</a> </b>
max(<code class="special">{expr}</code>)     返回 <code class="special">{expr}</code> 所有项目的最大值。
                <code class="special">{expr}</code> 可以是列表或字典。如果是字典，返回字典中所有值的最大
                值。
                如果 <code class="special">{expr}</code> 不是列表或字典，或者其中某个项目不能用作数值，出
                错。空  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;max()</code>
<code class="example"></code>
                                                        <b class="vimtag"> <a name="min()">min()</a> </b>
min(<code class="special">{expr}</code>)     返回 <code class="special">{expr}</code> 所有项目的最小值。
                <code class="special">{expr}</code> 可以是列表或字典。如果是字典，返回字典中所有值的最小
                值。
                如果 <code class="special">{expr}</code> 不是列表或字典，或者其中某个项目不能用作数值，出
                错。空  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;min()</code>
<code class="example"></code>
                                                        <b class="vimtag"> <a name="mkdir()">mkdir()</a> </b> <b class="vimtag"> <a name="E739">E739</a> </b>
mkdir(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{prot}</code>]])
                建立目录 <code class="special">{name}</code>。

                如果 <code class="special">{path}</code> 为 "p"，必要时建立中间的目录。否则它必须是 ""。

                如果给出 <code class="special">{prot}</code>，它用于设置新目录的权限。缺省为 0755
                (rwxr-xr-x: 用户自己可读写，其它人可读)。用 0700 使其它人不可
                读。这只用于 <code class="special">{name}</code> 的最后部分。所以，如果建立 /tmp/foo/bar，
                /tmp/foo 创建时的权限是 0755。
                示例: 
<code class="example">                        :call mkdir($HOME . "/tmp/foo/bar", "p", 0700)</code>
<code class="example"></code>
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                如果目录已存在且传递了 "p" 标志位，不报错 (从补丁 8.0.1708
                起)。如果没有 "p" 位就会失败。

                此函数返回数值，如果调用成功则为 1，如果目录创建失败或部分失败
                则为 0。

                不一定在所有系统上都可用。要检查这一点，使用: 
<code class="example">                        :if exists("*mkdir")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;mkdir()</code>

                                                        <b class="vimtag"> <a name="mode()">mode()</a> </b>
mode([expr])    返回指示当前模式的字符串。
                如果指定 <code class="special">[expr]</code> 并且其值为非零的数值或非空的字符串
                ( <a href="eval.html#non-zero-arg">non-zero-arg</a> )，返回完整模式，不然，返回第一个字母。
                另见  <a href="eval.html#state()">state()</a> 。

                   n        普通模式，终端-普通
                   no       操作符等待模式
                   nov      操作符等待模式 (强制面向字符  <a href="motion.html#o_v">o_v</a> )
                   noV      操作符等待模式 (强制面向行  <a href="motion.html#o_V">o_V</a> )
                   no<code class="keystroke">CTRL-v</code> 操作符等待模式 (强制面向列块  <a href="motion.html#o_CTRL-V">o_CTRL-V</a> )；
                                <code class="keystroke">CTRL-V</code> 是单个字符
                   niI       <a href="insert.html#Insert-mode">Insert-mode</a>  用  <a href="insert.html#i_CTRL-O">i_CTRL-O</a>  进入的普通模式
                   niR       <a href="insert.html#Replace-mode">Replace-mode</a>  用  <a href="insert.html#i_CTRL-O">i_CTRL-O</a>  进入的普通模式
                   niV       <a href="insert.html#Virtual-Replace-mode">Virtual-Replace-mode</a>  用  <a href="insert.html#i_CTRL-O">i_CTRL-O</a>  进入的普通模
                            式
                   v        面向字符的可视模式
                   V        面向行的可视模式
                   <code class="keystroke">CTRL-V</code>   面向列块的可视模式
                   s        面向字符的选择模式
                   S        面向行的选择模式
                   <code class="keystroke">CTRL-S</code>   面向列块的选择模式
                   i        插入模式
                   ic       插入模式补全  <a href="insert.html#compl-generic">compl-generic</a> 
                   ix       插入模式  <a href="insert.html#i_CTRL-X">i_CTRL-X</a>  补全
                   R        替换模式  <a href="change.html#R">R</a> 
                   Rc       替换模式补全  <a href="insert.html#compl-generic">compl-generic</a> 
                   Rv       虚拟替换模式  <a href="change.html#gR">gR</a> 
                   Rx       替换模式  <a href="insert.html#i_CTRL-X">i_CTRL-X</a>  补全
                   c        命令行编辑模式
                   cv       Vim Ex 模式  <a href="intro.html#gQ">gQ</a> 
                   ce       普通 Ex 模式  <a href="intro.html#Q">Q</a> 
                   r        输入回车的提示
                   rm       -- more -- 提示
                   r?        <a href="editing.html#:confirm">:confirm</a>  等等的询问
                   !        执行外壳或外部命令时
                   t        终端-作业模式: 键入传给作业
                可用于 <a href="options.html#'statusline'">'statusline'</a> 选项或  <a href="eval.html#remote_expr()">remote_expr()</a> 。在其它的多数地方，
                它总是返回 "c" 或 "n"。
                <code class="note">注意</code>将来可能会加入更多模式和更多特定模式。最好不要比较整个字符
                串而只比较开头的字符 (一或多个)。
                另见  <a href="eval.html#visualmode()">visualmode()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        DoFull()-&gt;mode()</code>
<code class="example"></code>
mzeval(<code class="special">{expr}</code>)                                                  <b class="vimtag"> <a name="mzeval()">mzeval()</a> </b>
                计算 MzScheme 表达式 <code class="special">{expr}</code> 并返回计算结果，转换为 Vim 本身的
                数据结构。
                数值和字符串返回本身。
                组对 (pair) (包含列表 (list) 和非常规列表 (improper list)) 和
                向量 (vector) 以 Vim  <a href="eval.html#List">List</a>  形式返回。
                哈希表 (hash table) 以 Vim  <a href="eval.html#Dictionary">Dictionary</a>  形式返回，其键转换成字
                符串。
                所有其它类型依 display 函数调用的结果转换为字符串。
                示例: 
<code class="example">                    :mz (define l (list 1 2 3))</code>
<code class="example">                    :mz (define h (make-hash)) (hash-set! h "list" l)</code>
<code class="example">                    :echo mzeval("l")</code>
<code class="example">                    :echo mzeval("h")</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;mzeval()</code>

                <code class="notvi">{仅当编译时带  <a href="various.html#+mzscheme">+mzscheme</a>  特性才有效}</code>

nextnonblank(<code class="special">{lnum}</code>)                                    <b class="vimtag"> <a name="nextnonblank()">nextnonblank()</a> </b>
                返回第一个从 <code class="special">{lnum}</code> 开始的非空白行的行号。例如: 
<code class="example">                        if getline(nextnonblank(1)) =~ "Java"</code>
                如果 <code class="special">{lnum}</code> 非法或者在从该行开始都没有非空白行，返回零。
                另见  <a href="eval.html#prevnonblank()">prevnonblank()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;nextnonblank()</code>
<code class="example"></code>
nr2char(<code class="special">{expr}</code> [, <code class="special">{utf8}</code>])                              <b class="vimtag"> <a name="nr2char()">nr2char()</a> </b>
                返回单个字符组成的字符串，该字符的数值为 <code class="special">{expr}</code>。例如: 
<code class="example">                        nr2char(64)             返回 "@"</code>
<code class="example">                        nr2char(32)             返回 " "</code>
                如果 <code class="special">{utf8}</code> 省略或为零，使用当前的 <a href="options.html#'encoding'">'encoding'</a>。比如对 "utf-8"
                来说: 
<code class="example">                        nr2char(300)            返回带有弓形的 I</code>
                如果 <code class="special">{utf8}</code> 为 1，则总返回 utf-8 字符。
                <code class="note">注意</code> 文件里的 NUL 字符须用 nr2char(10) 指定。因为 Vim 用换行符
                来表示 NUL。真正的 NUL 是 nr2char(0)，而它会终结字符串，因而返
                回空串。
                要把字符值的列表转换为字符串: 
<code class="example">                    let list = [65, 66, 67]</code>
<code class="example">                    let str = join(map(list, {_, val -&gt; nr2char(val)}), '')</code>
                结果是: "ABC"

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetNumber()-&gt;nr2char()</code>
<code class="example"></code>
or(<code class="special">{expr}</code>, <code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="or()">or()</a> </b>
                对两个参数进行按位或。参数须转换为数值。列表、字典或浮点数参数
                会报错。
                示例: 
<code class="example">                        :let bits = or(bits, 0x80)</code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :let bits = bits-&gt;or(0x80)</code>
<code class="example"></code>
<code class="example"></code>
pathshorten(<code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="pathshorten()">pathshorten()</a> </b>
                缩短路径 <code class="special">{expr}</code> 里的目录名，返回其结果。路径的尾部，即文件名，
                保持不变。路径的其余部分被缩短为单个字符。保持每个部分引导的
                '~' 和 '.' 字符不变。例如: 
<code class="example">                        :echo pathshorten('~/.vim/autoload/myfile.vim')</code>
<code class="section">                        ~/.v/a/myfile.vim </code>
                该路径实际存在与否并不相干。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetDirectories()-&gt;pathshorten()</code>
<code class="example"></code>
perleval(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="perleval()">perleval()</a> </b>
                在标量上下文计算 Perl 表达式 <code class="special">{expr}</code>，返回结果转换为 Vim 数据结
                构。如果其值不能转换，返回 Perl 表示的字符串形式。
                <code class="note">备注</code>: 如果要数组或哈希表，<code class="special">{expr}</code> 必须返回它们的引用。
                例如: 
<code class="example">                        :echo perleval('[1 .. 4]')</code>
                        [1, 2, 3, 4]

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;perleval()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+perl">+perl</a>  特性才有效}</code>


popup_ 函数文档在这里:  <a href="popup.html#popup-functions">popup-functions</a> 。


pow(<code class="special">{x}</code>, <code class="special">{y}</code>)                                           <b class="vimtag"> <a name="pow()">pow()</a> </b>
                返回浮点数，即 <code class="special">{x}</code> 的 <code class="special">{y}</code> 次方。
                <code class="special">{x}</code> 和 <code class="special">{y}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        :echo pow(3, 3)</code>
                        27.0 
<code class="example">                        :echo pow(2, 16)</code>
                        65536.0 
<code class="example">                        :echo pow(32, 0.20)</code>
                        2.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;pow(3)</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

prevnonblank(<code class="special">{lnum}</code>)                                    <b class="vimtag"> <a name="prevnonblank()">prevnonblank()</a> </b>
                返回第一个 <code class="special">{lnum}</code> 所在或之上的非空白行的行号。例如: 
<code class="example">                        let ind = indent(prevnonblank(v:lnum - 1))</code>
                如果 <code class="special">{lnum}</code> 非法或者在该行和它之前都没有非空白行，返回零。
                另见  <a href="eval.html#nextnonblank()">nextnonblank()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetLnum()-&gt;prevnonblank()</code>
<code class="example"></code>
printf(<code class="special">{fmt}</code>, <code class="special">{expr1}</code> ...)                              <b class="vimtag"> <a name="printf()">printf()</a> </b>
                返回 <code class="special">{fmt}</code> 指定的字符串，其中每个 "%" 项目被它们对应的参数排版
                后的形式取代。例如: 
<code class="example">                        printf("%4d: E%d %.30s", lnum, errno, msg)</code>
                可能的返回结果:
<code class="section">                        "  99: E42 asdfasdfasdfasdfasdfasdfasdfas" </code>

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        Compute()-&gt;printf("result: %d")</code>
<code class="example"></code>
                常用的项目有:
                  %s    字符串
                  %6S   右对齐到 6 个显示单元的字符串
                  %6s   右对齐到 6 个字节的字符串
                  %.9s  截短到 9 个字节的字符串
                  %c    单个字节
                  %d    十进制数
                  %5d   十进制数，用空格补足到 5 个字符
                  %x    十六进制数
                  %04x  十六进制数，用 0 补足到 4 个字符
                  %X    十六进制数，用大写字母的十六进制字母
                  %o    八进制数
                  %08b  二进制数，用 0 补足到 8 个字符
                  %f    浮点数，形如 12.23、inf、-inf 或 nan
                  %F    浮点数，形如 12.23、INF、-INF 或 NAN
                  %e    浮点数，形如 1.23e3、inf、-inf 或 nan
                  %E    浮点数，形如 1.23E3、INF、-INF 或 NAN
                  %g    浮点数，根据不同的值，使用合适的 %f 或 %e
                  %G    浮点数，根据不同的值，使用合适的 %F 或 %E
                  %%    % 字符本身

                转换规格说明以 '%' 开始，以转换类型结束。所有其它的字符按原样
                复制到结果中。

                "%" 开始转换规格说明。其后的参数依序如下:

                        %  <code class="special">[flags]</code>  [field-width]  [.precision]  type

                flags
                        零或多个下面的标志位:

                    #         转换值为 "替换形式"。对 c、d 和 s 转换，此选项无
                              效。对 o 转换，增加数值的精度，使得输出字符串的
                              第一个字符总是 0 (除非打印零值，且显式地使用精度
                              0)。
                              对 b 和 B 转换，非零值在前面加上字符串 "0b" (B
                              转换用 "0B")。
                              对 x 和 X 转换，非零值在前面加上字符串 "0x" (X
                              转换用 "0X")。

                    0 (零)    以 0 填充。对所有的转换，左侧用 0 而非空格填充。
                              如果对数值的转换给出精度 (d、b、B、o、x 和 X)，
                              忽略 0 标志位。

                    -         负域宽度标志位；转换后的值被左对齐到域边界上。该
                              值右侧用空格填充，而不是在左侧用空格或 0 填充。
                              如果两个标志位同时给出，- 否决 0。

                    ' ' (空格)  带符号转换 (d) 产生的正数左侧加上空格。

                    +         带符号转换产生的数值之前总加上符号。如果两个标志
                              位同时给出，+ 否决空格。

                field-width
                        可选的十进制数位字符串，指定最小的字段宽度。如果转换后
                        的值的字节数小于字段宽度，在左侧 (或右侧，如果给定左对
                        齐标志位的话) 用空格填充到字段宽度。

                .precision
                        可选的精度，形式为句号 '.' 后跟一个可选的数位字符串。
                        如果省略了数位字符串，假设精度为零。
                        它给出 d、o、x 和 X 转换显示的最小数位数量，或 s 转换
                        显示的字符串的字节的最大数量。
                        对浮点数而言，指定小数点后的数位个数。

                type
                        指定要进行的转换类型的单个字符，见下。

                字段宽度、精度 (两者都有亦可) 可以用星号 '*' 代替数位字符串。
                此情形下，一个数值参数指定字段宽度或精度。负的字段宽度被理解为
                带左对齐的标志位后跟一个正数字段宽度；负的精度被理解为就像不存
                在一样。例如: 
<code class="example">                        :echo printf("%d: %.*s", nr, width, line)</code>
                限制 "line" 文本的长度为 "width" 个字节。

                转换标识符和它们的含义如下:

                                <b class="vimtag"> <a name="printf-d">printf-d</a> </b> <b class="vimtag"> <a name="printf-b">printf-b</a> </b> <b class="vimtag"> <a name="printf-B">printf-B</a> </b> <b class="vimtag"> <a name="printf-o">printf-o</a> </b>
                                <b class="vimtag"> <a name="printf-x">printf-x</a> </b> <b class="vimtag"> <a name="printf-X">printf-X</a> </b>
                dbBoxX  数值参数被转换为带符号十进制 (d)，无符号二进制 (b 和
                        B)、无符号八进制 (o) 或无符号十六进制 (x 和 X) 记法。x
                        转换用字母 "abcdef"；X 转换用 "ABCDEF" 字母。
                        如果提供了精度，它给出必须出现的数位的最少数目；如果转
                        换后的值需要更少的数位，左侧用 0 填充。
                        任何情况下数值字段都不会被不存在或者更小的字段宽度所截
                        短；如果转换的结果宽于字段宽度，字段被扩展，以包含转换
                        后的结果。
                        'h' 修饰符指示参数为 16 位。
                        'l' 修饰符指示参数为 32 位。
                        'L' 修饰符指示参数为 64 位。
                        通常这些修饰符不怎么有用。如果类型可从参数推知，修饰符
                        被忽略。

                i       d 的别名
                D       ld 的别名
                U       lu 的别名
                O       lo 的别名

                                                        <b class="vimtag"> <a name="printf-c">printf-c</a> </b>
                c       数值参数被转换为字节，写入产生的字符。

                                                        <b class="vimtag"> <a name="printf-s">printf-s</a> </b>
                s       使用字符串参数的文本。如果指定精度，使用不多于给定数目
                        的字节数。
                        如果参数不是字符串型，使用 ":echo" 相同的格式自动转换
                        到文本。
                                                        <b class="vimtag"> <a name="printf-S">printf-S</a> </b>
                S       使用字符串参数的文本。如果指定精度，使用不多于给定数目
                        的显示单元数。

                                                        <b class="vimtag"> <a name="printf-f">printf-f</a> </b> <b class="vimtag"> <a name="E807">E807</a> </b>
                f F     浮点数参数被转换为形如 123.456 的字符串。精度指定小数
                        点后面的位数。如果精度为零，则省略小数点本身。如果未指
                        定精度，缺省为 6。那个很大很大的数 (超出返回或除以零的
                        结果) 用 %f 显示 "inf" 或 "-inf" (%F 则显示 INF 或
                        -INF)。
                        "0.0 / 0.0" 用 %f 显示 "nan" (%F 显示 NAN)。
                        示例: 
<code class="example">                                echo printf("%.2f", 12.115)</code>
                                12.12
                        <code class="note">注意</code> 截断方式取决于系统库。如不确定，使用  <a href="eval.html#round()">round()</a> 。

                                                        <b class="vimtag"> <a name="printf-e">printf-e</a> </b> <b class="vimtag"> <a name="printf-E">printf-E</a> </b>
                e E     浮点数参数被转换为形如 1.234e+03 或用 'E' 的话
                        1.234E+03 的字符串。精度指定小数点后面的位数，和 'f'
                        一样。

                                                        <b class="vimtag"> <a name="printf-g">printf-g</a> </b> <b class="vimtag"> <a name="printf-G">printf-G</a> </b>
                g G     如果浮点数参数在 0.001 (含) 和 10000000.0 (不含) 之
                        间，则其转换同 'f'，不然，'g' 同 'e' 而 'G' 同 'E'。如
                        果未指定精度，除了小数点之后的那个零以外，不显示多余的
                        零和 '+' 负号。因而，10000000.0 显示为 1.0e7。

                                                        <b class="vimtag"> <a name="printf-%">printf-%</a> </b>
                %       写入 '%'。不转换参数。这里完整的转换规格说明是 "%%"。

                如果期待数值参数，字符串参数也被接受并自动转换。
                如果期待浮点数或字符串参数，数值参数也被接受并自动转换。
                其它参数类型产生错误信息。

                                                        <b class="vimtag"> <a name="E766">E766</a> </b> <b class="vimtag"> <a name="E767">E767</a> </b>
                <code class="special">{exprN}</code> 参数的数量必须和 "%" 项目的数量完全匹配。不论参数不足
                还是过多，都会给出错误。至多可用 18 个参数。


prompt_setcallback(<code class="special">{buf}</code>, <code class="special">{expr}</code>)                       <b class="vimtag"> <a name="prompt_setcallback()">prompt_setcallback()</a> </b>
                设置缓冲区 <code class="special">{buf}</code> 的提示回调为 <code class="special">{expr}</code>。<code class="special">{expr}</code> 为空串时删除回
                调。只对 <a href="options.html#'buftype'">'buftype'</a> 为 "prompt" 的 <code class="special">{buf}</code> 有效。

                按下回车时触发本回调。此时当前缓冲区总是提示缓冲区。在回调触发
                前，会加入一行新的提示行，因此，触发该回调的提示行会是倒数第二
                行。
                如果回调要为缓冲区增加新文本，必须在最后一行之前插入，因为那是
                当前提示所在的位置，此操作可以异步进行。
                回调调用时所带的一个参数是提示行输入的文本。如果用户直接按了回
                车，这会是一个空串。
                示例: 
<code class="example">                   call prompt_setcallback(bufnr(), function('s:TextEntered'))</code>
<code class="example">                   func s:TextEntered(text)</code>
<code class="example">                     if a:text == 'exit' || a:text == 'quit'</code>
<code class="example">                       stopinsert</code>
<code class="example">                       close</code>
<code class="example">                     else</code>
<code class="example">                       call append(line('$') - 1, 'Entered: "' . a:text . '"')</code>
<code class="example">                       " 复位 'modified'，这样缓冲区才可以被关闭。</code>
<code class="example">                       set nomodified</code>
<code class="example">                     endif</code>
<code class="example">                   endfunc</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;prompt_setcallback(callback)</code>
<code class="example"></code>
<code class="example"></code>
prompt_setinterrupt(<code class="special">{buf}</code>, <code class="special">{expr}</code>)                      <b class="vimtag"> <a name="prompt_setinterrupt()">prompt_setinterrupt()</a> </b>
                设置缓冲区 <code class="special">{buf}</code> 的回调为 <code class="special">{expr}</code>。<code class="special">{expr}</code> 为空串时删除回调。只
                对 <a href="options.html#'buftype'">'buftype'</a> 为 "prompt" 的 <code class="special">{buf}</code> 有效。

                插入模式按 <code class="keystroke">CTRL-C</code> 时触发本回调。不设置回调会使 Vim 退出插入模
                式，就和其它缓冲区一样。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;prompt_setinterrupt(callback)</code>
<code class="example"></code>
prompt_setprompt(<code class="special">{buf}</code>, <code class="special">{text}</code>)                         <b class="vimtag"> <a name="prompt_setprompt()">prompt_setprompt()</a> </b>
                设置缓冲区 <code class="special">{buf}</code> 的提示文本为 <code class="special">{text}</code>。<code class="special">{text}</code> 多数会以空格结
                尾。
                结果只对 <a href="options.html#'buftype'">'buftype'</a> 为 "prompt" 的 <code class="special">{buf}</code> 可见。示例: 
<code class="example">                        call prompt_setprompt(bufnr(), 'command: ')</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBuffer()-&gt;prompt_setprompt('command: ')</code>
<code class="example"></code>
prop_ 函数文档在这里:  <a href="textprop.html#text-prop-functions">text-prop-functions</a> 。

pum_getpos()                                            <b class="vimtag"> <a name="pum_getpos()">pum_getpos()</a> </b>
                如果弹出菜单 (见  <a href="insert.html#ins-completion-menu">ins-completion-menu</a> ) 不可见，返回空
                 <a href="eval.html#Dictionary">Dictionary</a> ，不然，返回带以下键的  <a href="eval.html#Dictionary">Dictionary</a> :
                        height          可见项目数
                        width           屏幕单元格数
                        row             顶部屏幕行号 (0 为初行)
                        col             最左侧屏幕列号 (0 为初列)
                        size            项目总数
                        scrollbar       如果滚动条为可见则为  <a href="eval.html#TRUE">TRUE</a> 

                这里的值和  <a href="autocmd.html#CompleteChanged">CompleteChanged</a>  发生时  <a href="eval.html#v:event">v:event</a>  的一样。

pumvisible()                                            <b class="vimtag"> <a name="pumvisible()">pumvisible()</a> </b>
                如果弹出菜单可见，返回非零，不然返回零。见
                 <a href="insert.html#ins-completion-menu">ins-completion-menu</a> 。
                可以用来避免一些会删除弹出菜单的动作。

py3eval(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="py3eval()">py3eval()</a> </b>
                计算 Python 表达式 <code class="special">{expr}</code> 并返回计算结果，转换为 Vim 本身的数
                据结构。
                数值和字符串返回本身 (字符串经过复制，Unicode 字符串还须额外用
                <a href="options.html#'encoding'">'encoding'</a> 转换)。
                列表返回 Vim  <a href="eval.html#List">List</a>  类型。
                字典返回 Vim  <a href="eval.html#Dictionary">Dictionary</a>  类型，键值转换为字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;py3eval()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+python3">+python3</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="E858">E858</a> </b> <b class="vimtag"> <a name="E859">E859</a> </b>
pyeval(<code class="special">{expr}</code>)                                          <b class="vimtag"> <a name="pyeval()">pyeval()</a> </b>
                计算 Python 表达式 <code class="special">{expr}</code> 并返回计算结果，转换为 Vim 本身的数
                据结构。
                数值和字符串返回本身 (字符串经过复制)。
                列表返回 Vim  <a href="eval.html#List">List</a>  类型。
                字典返回 Vim  <a href="eval.html#Dictionary">Dictionary</a>  类型，出现非字符串的键值报错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;pyeval()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+python">+python</a>  特性才有效}</code>

pyxeval(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="pyxeval()">pyxeval()</a> </b>
                计算 Python 表达式 <code class="special">{expr}</code> 并返回计算结果，转换为 Vim 本身的数
                据结构。
                使用 Python 2 或 3，见  <a href="if_pyth.html#python_x">python_x</a>  和 <a href="options.html#'pyxversion'">'pyxversion'</a>。
                另见:  <a href="eval.html#pyeval()">pyeval()</a> 、 <a href="eval.html#py3eval()">py3eval()</a> 

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;pyxeval()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+python">+python</a>  或  <a href="various.html#+python3">+python3</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="E726">E726</a> </b> <b class="vimtag"> <a name="E727">E727</a> </b>
range(<code class="special">{expr}</code> [, <code class="special">{max}</code> [, <code class="special">{stride}</code>]])                            <b class="vimtag"> <a name="range()">range()</a> </b>
                返回数值的  <a href="eval.html#List">List</a> :
                - 如果只有指定 <code class="special">{expr}</code>: [0, 1, ..., <code class="special">{expr}</code> - 1]
                - 如果指定了 <code class="special">{max}</code>: [<code class="special">{expr}</code>, <code class="special">{expr}</code> + 1, ..., <code class="special">{max}</code>]
                - 如果指定了 <code class="special">{stride}</code>: [<code class="special">{expr}</code>, <code class="special">{expr}</code> + <code class="special">{stride}</code>, ...,
                  <code class="special">{max}</code>] (每次给 <code class="special">{expr}</code> 递增 <code class="special">{stride}</code>，但不会产生超过 <code class="special">{max}</code> 的
                  值)。
                如果最大值比开始值小一，返回空列表。如果更小，报错。
                例如: 
<code class="example">                        range(4)                " [0, 1, 2, 3]</code>
<code class="example">                        range(2, 4)             " [2, 3, 4]</code>
<code class="example">                        range(2, 9, 3)          " [2, 5, 8]</code>
<code class="example">                        range(2, -2, -1)        " [2, 1, 0, -1, -2]</code>
<code class="example">                        range(0)                " []</code>
<code class="example">                        range(2, 0)             " 出错！</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetExpr()-&gt;range()</code>


rand([<code class="special">{expr}</code>])                                          <b class="vimtag"> <a name="rand()">rand()</a> </b>
                用 <code class="special">{expr}</code> 作为种子，返回 xoshiro128** 算法产生的伪随机数。返回
                数值是 32 位的，为了统一起见，即使是 64 位系统上也是。
                可由  <a href="eval.html#srand()">srand()</a>  初始化 <code class="special">{expr}</code> ，rand() 会进行更新。如果省略
                <code class="special">{expr}</code>，使用并更新一个内部的种子值。

                示例: 
<code class="example">                        :echo rand()</code>
<code class="example">                        :let seed = srand()</code>
<code class="example">                        :echo rand(seed)</code>
<code class="example">                        :echo rand(seed) % 16  " 随机数 0 - 15</code>

                                                        <b class="vimtag"> <a name="readdir()">readdir()</a> </b>
readdir(<code class="special">{directory}</code> [, <code class="special">{expr}</code>])
                返回 <code class="special">{directory}</code> 中的文件和目录名的列表。如果不需要复杂的处
                理，如限制匹配的数目等等，也可用  <a href="eval.html#glob()">glob()</a> 。

                <code class="special">{expr}</code> 省略时包含所有的项目。
                如果给出 <code class="special">{expr}</code>，计算其值决定如何处理:
                        如果 <code class="special">{expr}</code> 结果为 -1， 不处理后续的项目。
                        如果 <code class="special">{expr}</code> 结果为 0，不把本项加入列表。
                        如果 <code class="special">{expr}</code> 结果为 1，把本项加入列表。
                每次计算 <code class="special">{expr}</code> 时  <a href="eval.html#v:val">v:val</a>  设为项目名。
                <code class="special">{expr}</code> 如果是函数，把名字作为参数传递。
                例如，要得到 ".txt" 结尾的文件列表: 
<code class="example">                  readdir(dirname, {n -&gt; n =~ '.txt$'})</code>
                要跳隐藏和备份文件: 
<code class="example">                  readdir(dirname, {n -&gt; n !~ '^\.\|\~$'})</code>
<code class="example"></code>
                要想得到目录树: 
<code class="example">                  function! s:tree(dir)</code>
<code class="example">                      return {a:dir : map(readdir(a:dir),</code>
<code class="example">                      \ {_, x -&gt; isdirectory(x) ?</code>
<code class="example">                      \          {x : s:tree(a:dir . '/' . x)} : x})}</code>
<code class="example">                  endfunction</code>
<code class="example">                  echo s:tree(".")</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetDirName()-&gt;readdir()</code>

                                                        <b class="vimtag"> <a name="readfile()">readfile()</a> </b>
readfile(<code class="special">{fname}</code> [, <code class="special">{type}</code> [, <code class="special">{max}</code>]])
                读入文件 <code class="special">{fname}</code> 并返回  <a href="eval.html#List">List</a> 。，文件每行一项。在 NL 字符处断
                开行。以 CR 分隔的 Macintosh 文件会返回单个长行 (除非某处出现
                了 NL)。
                所有的 NUL 字符被 NL 字符替代。
                如果 <code class="special">{type}</code> 包含 "b"，使用二进制模式:
                - 如果末行以 NL 结尾，附加额外的一个空列表项。
                - 不删除 CR 字符。
                如果 <code class="special">{type}</code> 包含 "B"，返回  <a href="eval.html#Blob">Blob</a> ，包含未经修改的文件二进制数
                据。
                否则:
                - NL 之前的 CR 字符被删除。
                - 末行是否以 NL 结尾没有影响。
                - <a href="options.html#'encoding'">'encoding'</a> 如是 Unicode 编码，删除文本可能有的 UTF-8 字节顺
                  序标识。
                如果给出 <code class="special">{max}</code>，指定读入的最大行数。可用于只想检查文件开始十行
                这样的场合: 
<code class="example">                        :for line in readfile(fname, '', 10)</code>
<code class="example">                        :  if line =~ 'Date' | echo line | endif</code>
<code class="example">                        :endfor</code>
                如果 <code class="special">{max}</code> 为负，返回从文件尾部起算 -<code class="special">{max}</code> 行，有多少算多少。
                如果 <code class="special">{max}</code> 为零，返回空列表。
                <code class="note">注意</code> 如果没有 <code class="special">{max}</code>，把整个文件读到内存。
                也要 <code class="note">注意</code> 这里不识别编码。如果需要，把文件读到缓冲区里。
                如果文件不能打开，给出错误信息，并返回空列表。
                另见  <a href="eval.html#writefile()">writefile()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFileName()-&gt;readfile()</code>
<code class="example"></code>
reg_executing()                                         <b class="vimtag"> <a name="reg_executing()">reg_executing()</a> </b>
                返回在执行中的单个字母寄存器名。如果没有在执行的寄存器，返回空
                串。见  <a href="repeat.html#@">@</a> 。

reg_recording()                                         <b class="vimtag"> <a name="reg_recording()">reg_recording()</a> </b>
                返回在记录中的单个字母寄存器名。如果没有在记录的寄存器，返回空
                串。见  <a href="repeat.html#q">q</a> 。

reltime([<code class="special">{start}</code> [, <code class="special">{end}</code>]])                            <b class="vimtag"> <a name="reltime()">reltime()</a> </b>
                返回代表时间值的项目。项目的格式取决于不同的系统。可以把它传递
                给  <a href="eval.html#reltimestr()">reltimestr()</a>  来转换为字符串，或  <a href="eval.html#reltimefloat()">reltimefloat()</a>  来转换为
                浮点数。
                没有参数，返回当前时间。
                带一个参数，返回参数指定的时间以来的时间。
                带两个参数，返回 <code class="special">{start}</code> 和 <code class="special">{end}</code> 之间跨越的时间。
                <code class="special">{start}</code> 和 <code class="special">{end}</code> 参数必须是 reltime() 返回的值。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetStart()-&gt;reltime()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>

reltimefloat(<code class="special">{time}</code>)                            <b class="vimtag"> <a name="reltimefloat()">reltimefloat()</a> </b>
                返回代表 <code class="special">{time}</code> 的时间值的浮点数。
                示例: 
<code class="example">                        let start = reltime()</code>
<code class="example">                        call MyFunction()</code>
<code class="example">                        let seconds = reltimefloat(reltime(start))</code>
                参见 reltimestr() 关于开销的注释。
                另见  <a href="repeat.html#profiling">profiling</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        reltime(start)-&gt;reltimefloat()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>

reltimestr(<code class="special">{time}</code>)                              <b class="vimtag"> <a name="reltimestr()">reltimestr()</a> </b>
                返回字符串，代表 <code class="special">{time}</code> 的时间值。
                形式是秒数、句号和毫秒数。例如: 
<code class="example">                        let start = reltime()</code>
<code class="example">                        call MyFunction()</code>
<code class="example">                        echo reltimestr(reltime(start))</code>
                <code class="note">注意</code> 命令本身额外的开销也计算在时间里。时间的准确度取决于系
                统。
                返回结果包含引导的空格，使字符串能很好地对齐。如果你不需要，用
                split() 可以删掉。 
<code class="example">                        echo split(reltimestr(reltime(start)))[0]</code>
                另见  <a href="repeat.html#profiling">profiling</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        reltime(start)-&gt;reltimestr()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="remote_expr()">remote_expr()</a> </b> <b class="vimtag"> <a name="E449">E449</a> </b>
remote_expr(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code> [, <code class="special">{timeout}</code>]])
                发送 <code class="special">{string}</code> 到 <code class="special">{server}</code>。该发送的字符串是一个表达式，而返回
                的是远端执行的结果。这个结果必然是字符串或  <a href="eval.html#List">List</a> 。 <a href="eval.html#List">List</a>  被转
                换成字符串，转换方法是把项目用换行符连接起来 (末项之后没有)，
                就像用 join(expr, "\n") 那样。
                如果给出 <code class="special">{idvar}</code> 且非空，将 <code class="special">{serverid}</code> 保存在以它命令的变量
                里，此后的  <a href="eval.html#remote_read()">remote_read()</a>  需要使用此值。
                如果给出 <code class="special">{timeout}</code>，在给定的秒数后读取超时。否则，使用 600 秒
                超时。
                另见  <a href="remote.html#clientserver">clientserver</a>   <a href="autocmd.html#RemoteReply">RemoteReply</a> 。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                <code class="note">注意</code>: 任何错误会在本地产生错误信息，但返回的结果只是一个空字符
                串。

                在全局命名空间中计算变量，而和当前激活的函数无关。调试模式例
                外，此时会计算局部于函数的变量和参数。

                例如: 
<code class="example">                        :echo remote_expr("gvim", "2+2")</code>
<code class="example">                        :echo remote_expr("gvim1", "b:current_syntax")</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerName()-&gt;remote_expr(expr)</code>
<code class="example"></code>
remote_foreground(<code class="special">{server}</code>)                             <b class="vimtag"> <a name="remote_foreground()">remote_foreground()</a> </b>
                把名为 <code class="special">{server}</code> 的 Vim 服务器带到前台。
                这类似于: 
<code class="example">                        remote_expr({server}, "foreground()")</code>
                Win32 系统除外。那里，客户端完成实际的工作。因为操作系统不
                总能允许服务器把自己带到前台。
                <code class="note">注意</code>: 如果窗口最小化，并不恢复之，foreground() 会这么做。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerName()-&gt;remote_foreground()</code>
<code class="example"></code>
                {仅可用在 Win32、Athena、Motif 和 GTK 的 GUI 版本和 Win32 的控
                制台版本}


remote_peek(<code class="special">{serverid}</code> [, <code class="special">{retvar}</code>])            <b class="vimtag"> <a name="remote_peek()">remote_peek()</a> </b>
                如果 <code class="special">{serverid}</code> 有可用的字符串，返回正数。如果指定了
                <code class="special">{retvar}</code>，复制任何应答字符串到 <code class="special">{retvar}</code> 指定的变量。<code class="special">{retvar}</code>
                必须是一个用来指定变量名的字符串。
                如果没有可用的应答，返回 0。
                如果出错，返回 -1。
                另见  <a href="remote.html#clientserver">clientserver</a> 。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                示例: 
<code class="example">                        :let repl = ""</code>
<code class="example">                        :echo "PEEK: ".remote_peek(id, "repl").": ".repl</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerId()-&gt;remote_peek()</code>
<code class="example"></code>
remote_read(<code class="special">{serverid}</code>, [<code class="special">{timeout}</code>])                    <b class="vimtag"> <a name="remote_read()">remote_read()</a> </b>
                返回从 <code class="special">{serverid}</code> 发送的存在时间最长的应答，并删除之。除非给出
                以秒计的 <code class="special">{timeout}</code>，该调用会等待直到有应答为止。
                另见  <a href="remote.html#clientserver">clientserver</a> 。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                例如: 
<code class="example">                        :echo remote_read(id)</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerId()-&gt;remote_read()</code>

                                                        <b class="vimtag"> <a name="remote_send()">remote_send()</a> </b> <b class="vimtag"> <a name="E241">E241</a> </b>
remote_send(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code>])
                发送 <code class="special">{string}</code> 到 <code class="special">{server}</code>。发送的字符串是输入键的序列。函数立
                即返回。Vim 的服务器端不对键进行映射  <a href="map.html#:map">:map</a> 。
                如果给出 <code class="special">{idvar}</code>，将 <code class="special">{serverid}</code> 保存在以它命令的变量里，此后的
                remote_read() 需要使用此值。
                另见  <a href="remote.html#clientserver">clientserver</a>   <a href="autocmd.html#RemoteReply">RemoteReply</a> 。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>

                <code class="note">注意</code>: 任何错误会在服务器端报告，从而影响那里的显示。
                例如: 
<code class="example">                :echo remote_send("gvim", ":DropAndReply ".file, "serverid").</code>
<code class="example">                 \ remote_read(serverid)</code>
<code class="example"></code>
<code class="example">                :autocmd NONE RemoteReply *</code>
<code class="example">                 \ echo remote_read(expand("&lt;amatch&gt;"))</code>
<code class="example">                :echo remote_send("gvim", ":sleep 10 | echo ".</code>
<code class="example">                 \ 'server2client(expand("&lt;client&gt;"), "HELLO")&lt;CR&gt;')</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerName()-&gt;remote_send(keys)</code>

                                        <b class="vimtag"> <a name="remote_startserver()">remote_startserver()</a> </b> <b class="vimtag"> <a name="E941">E941</a> </b> <b class="vimtag"> <a name="E942">E942</a> </b>
remote_startserver(<code class="special">{name}</code>)
                成为服务器 <code class="special">{name}</code>。如果已作为服务器运行，也即  <a href="eval.html#v:servername">v:servername</a> 
                不为空时此操作失败。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        ServerName()-&gt;remote_startserver()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>

remove(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{end}</code>])                         <b class="vimtag"> <a name="remove()">remove()</a> </b>
                没有 <code class="special">{end}</code>: 删除  <a href="eval.html#List">List</a>  <code class="special">{list}</code> 里索引为 <code class="special">{idx}</code> 的项目并返回之。
                有 <code class="special">{end}</code>: 删除从 <code class="special">{idx}</code> 到 <code class="special">{end}</code> (闭区间) 的项目，并返回这些项
                目的列表。如果 <code class="special">{idx}</code> 指向和 <code class="special">{end}</code> 相同的项目，返回单个项目的列
                表。如果 <code class="special">{end}</code> 指向 <code class="special">{idx}</code> 之前的项目，报错。
                 <a href="eval.html#list-index">list-index</a>  说明 <code class="special">{idx}</code> 和 <code class="special">{end}</code> 可能的取值。
                例如: 
<code class="example">                        :echo "last item: " . remove(mylist, -1)</code>
<code class="example">                        :call remove(mylist, 0, 9)</code>

                用  <a href="eval.html#delete()">delete()</a>  来删除文件。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;remove(idx)</code>
<code class="example"></code>
remove(<code class="special">{blob}</code>, <code class="special">{idx}</code> [, <code class="special">{end}</code>])
                没有 <code class="special">{end}</code>: 删除  <a href="eval.html#Blob">Blob</a>  <code class="special">{blob}</code> 里索引为 <code class="special">{idx}</code> 的字节并返回之。
                有 <code class="special">{end}</code>: 删除从 <code class="special">{idx}</code> 到 <code class="special">{end}</code> (闭区间) 的字节，并返回这些字
                节构成的的  <a href="eval.html#Blob">Blob</a> 。如果 <code class="special">{idx}</code> 指向和 <code class="special">{end}</code> 相同的字节，返回单
                个字节构成的  <a href="eval.html#Blob">Blob</a> 。如果 <code class="special">{end}</code> 指向 <code class="special">{idx}</code> 之前的字节，报错。
                示例: 
<code class="example">                        :echo "last byte: " . remove(myblob, -1)</code>
<code class="example">                        :call remove(mylist, 0, 9)</code>
<code class="example"></code>
remove(<code class="special">{dict}</code>, <code class="special">{key}</code>)
                删除 <code class="special">{dict}</code> 里键为 <code class="special">{key}</code> 的项目并返回其值。例如: 
<code class="example">                        :echo "removed " . remove(dict, "one")</code>
                如果 <code class="special">{dict}</code> 里没有键 <code class="special">{key}</code>，报错。

rename(<code class="special">{from}</code>, <code class="special">{to}</code>)                                    <b class="vimtag"> <a name="rename()">rename()</a> </b>
                把文件名 <code class="special">{from}</code> 换成 <code class="special">{to}</code>。这也可用来在文件系统间移动文件。返
                回数值，如果文件成功换名，返回零，如果换名失败，返回非零。
                <code class="note">注意</code> 如果 <code class="special">{to}</code> 已存在，它被覆盖且没有提示。
                该函数在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetOldName()-&gt;rename(newname)</code>
<code class="example"></code>
repeat(<code class="special">{expr}</code>, <code class="special">{count}</code>)                                 <b class="vimtag"> <a name="repeat()">repeat()</a> </b>
                重复 <code class="special">{expr}</code> <code class="special">{count}</code> 次，并返回连接后的结果。例如: 
<code class="example">                        :let separator = repeat('-', 80)</code>
                如果 <code class="special">{count}</code> 为零或负，返回空。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a>  类型，返回连接 <code class="special">{expr}</code> <code class="special">{count}</code> 次的结果。
                例如: 
<code class="example">                        :let longlist = repeat(['a', 'b'], 3)</code>
                返回 ['a', 'b', 'a', 'b', 'a', 'b']。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;repeat(count)</code>
<code class="example"></code>
resolve(<code class="special">{filename}</code>)                                     <b class="vimtag"> <a name="resolve()">resolve()</a> </b> <b class="vimtag"> <a name="E655">E655</a> </b>
                在 MS-Windows 上，如果 <code class="special">{filename}</code> 是一个快捷方式 (.lnk 文件)，
                返回简化的快捷方式指向的路径。当 <code class="special">{filename}</code> 为符号链接或连接点
                (junction point) 时，返回目的地的完整路径。如果该连接
                (junction) 的目的地已被删除，返回 <code class="special">{filename}</code>。
                在 Unix 上，反复分析 <code class="special">{filename}</code> 的所有路径部分的符号链接的真正
                路径，直到返回最简化的结果为止。为了处理循环链接的问题，符号链
                接的分析在 100 次叠代之后停止。
                在其它系统上，返回简化了的 <code class="special">{filename}</code>。
                简化的工作通过  <a href="eval.html#simplify()">simplify()</a>  完成。
                resolve() 保留指向当前目录的首个路径部分 (保证结果仍然是相对路
                径名)，也保留出现在尾部的路径分隔符。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;resolve()</code>
<code class="example"></code>
reverse(<code class="special">{object}</code>)                                       <b class="vimtag"> <a name="reverse()">reverse()</a> </b>
                反转 <code class="special">{object}</code> 项目的顺序，直接对 <code class="special">{object}</code> 进行原位修改。
                <code class="special">{object}</code> 可以是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a> 。
                返回 <code class="special">{object}</code>。
                如果你不想修改，先构建一个备份: 
<code class="example">                        :let revlist = reverse(copy(mylist))</code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;reverse()</code>
<code class="example"></code>
round(<code class="special">{expr}</code>)                                                   <b class="vimtag"> <a name="round()">round()</a> </b>
                返回浮点数，即最接近于 <code class="special">{expr}</code> 的整数。如果 <code class="special">{expr}</code> 在两个整数的
                正中间，使用 (<code class="vim">译者注</code>: 绝对值) 较大 (远离零的) 那个。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        echo round(0.456)</code>
                        0.0  
<code class="example">                        echo round(4.5)</code>
                        5.0 
<code class="example">                        echo round(-4.5)</code>
                        -5.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;round()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

rubyeval(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="rubyeval()">rubyeval()</a> </b>
                计算 Ruby 表达式 <code class="special">{expr}</code> 并返回计算结果，转换为 Vim 本身的数
                据结构。
                数值、浮点数和字符串返回本身 (字符串经过复制)。
                数值返回 Vim  <a href="eval.html#List">List</a>  类型。
                哈希表返回 Vim  <a href="eval.html#Dictionary">Dictionary</a>  类型。
                其它对象返回它们 "Object#to_s" 方法返回的字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRubyExpr()-&gt;rubyeval()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+ruby">+ruby</a>  特性才有效}</code>

screenattr(<code class="special">{row}</code>, <code class="special">{col}</code>)                                        <b class="vimtag"> <a name="screenattr()">screenattr()</a> </b>
                类似于  <a href="eval.html#screenchar()">screenchar()</a> ，但返回属性。是个相当任意的值，只可用于
                和其他位置的属性进行比较。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRow()-&gt;screenattr(col)</code>
<code class="example"></code>
screenchar(<code class="special">{row}</code>, <code class="special">{col}</code>)                                        <b class="vimtag"> <a name="screenchar()">screenchar()</a> </b>
                返回数值，即屏幕 [row, col] 位置的字符。可用于任何可能的屏幕
                位置，包括状态行，窗口分隔符和命令行。左上位置的行列号都为一。
                返回字符不包括组合字符。双字节编码可能只返回第一个字节。
                主要用于调试。
                行号或列号越界时返回 -1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRow()-&gt;screenchar(col)</code>
<code class="example"></code>
screenchars(<code class="special">{row}</code>, <code class="special">{col}</code>)                                       <b class="vimtag"> <a name="screenchars()">screenchars()</a> </b>
                返回数值列表。第一个数值和  <a href="eval.html#screenchar()">screenchar()</a>  返回的相同。其后的数
                值是附加于基础字符之上的组合字符。
                主要用于测试。
                如果 row 或 col 超出范围返回空列表。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRow()-&gt;screenchars(col)</code>
<code class="example"></code>
screencol()                                                     <b class="vimtag"> <a name="screencol()">screencol()</a> </b>
                返回数值，即当前光标的屏幕列号。最左列的列号为 1。
                主要用于调试。

                <code class="note">注意</code>: 总是返回当前屏幕列，所以直接用于命令 (例如 ":echo
                screencol()") 时会返回命令行内的列号，其在命令执行时永远为 1。
                要得到文件中的光标位置，可用下面这些映射: 
<code class="example">                        nnoremap &lt;expr&gt; GG ":echom ".screencol()."\n"</code>
<code class="example">                        nnoremap &lt;silent&gt; GG :echom screencol()&lt;CR&gt;</code>

screenpos(<code class="special">{winid}</code>, <code class="special">{lnum}</code>, <code class="special">{col}</code>)                               <b class="vimtag"> <a name="screenpos()">screenpos()</a> </b>
                返回字典，窗口 <code class="special">{winid}</code> 在缓冲区行 <code class="special">{lnum}</code> 和列 <code class="special">{col}</code> 上的文本字
                符的屏幕位置。<code class="special">{col}</code> 是从一开始的字节索引。
                字典有以下成员:
                        row     屏幕行
                        col     首个屏幕列
                        endcol  末尾屏幕列
                        curscol 光标所在屏幕列
                如果指定位置不可见，所有的值均为零。
                当字符占据多于一个屏幕单元格时，"endcol" 和 "col" 的值会不同。
                例如制表符的 "col" 可能是 1 而 "eolcol" 会是 8。
                "curscol" 值是光标会放置的地方。对于制表符而言会和 "endcol" 相
                同。而对双宽字符来说，就会为 "col" 相同。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;screenpos(lnum, col)</code>
<code class="example"></code>
screenrow()                                                     <b class="vimtag"> <a name="screenrow()">screenrow()</a> </b>
                返回数值，即当前光标的屏幕行号。最顶行的行号为 1。
                主要用于调试。
                代为替代，也可用  <a href="eval.html#winline()">winline()</a> 。

                <code class="note">注意</code>: 和  <a href="eval.html#screencol()">screencol()</a>  的限制相同。

screenstring(<code class="special">{row}</code>, <code class="special">{col}</code>)                                      <b class="vimtag"> <a name="screenstring()">screenstring()</a> </b>
                返回字符串，包含在屏幕位置 [row, col] 上的基本字符和任何组合字
                符。类似于  <a href="eval.html#screenchars()">screenchars()</a> ，但返回字符组成的字符串。
                主要用于测试。
                如果行或列超出范围，返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetRow()-&gt;screenstring(col)</code>
<code class="example"></code>
search(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])      <b class="vimtag"> <a name="search()">search()</a> </b>
                搜索正规表达式模式 <code class="special">{pattern}</code>。搜索从光标位置 (用  <a href="eval.html#cursor()">cursor()</a>  可
                以得到) 开始。

                如果找到了匹配，返回其所在的行号。
                如果找不到匹配，返回 0 并且光标位置不改变。不会给出错误信息。

                <code class="special">{flags}</code> 是字符串，可以包含以下字符标志位:
                'b'     反向 (Backward) 搜索，而不是正向搜索
                'c'     接受光标 (Cursor) 位置上的匹配
                'e'     移到匹配的尾部 (End)
                'n'     不 (Not) 移动光标
                'p'     返回匹配的子模式 (Pattern) 号 (见下)
                's'     在光标上次的位置上设置 (Set) ' 位置标记
                'w'     在文件尾部处回绕 (Wrap) 到文件开始处
                'W'     不在文件尾部处回绕 (Wrap)
                'z'     从光标列开始搜索而不是第零 (Zero) 列
                如果 'w' 和 'W' 都没有给出，根据 <a href="options.html#'wrapscan'">'wrapscan'</a> 选项决定。

                如果提供 's' 标志位，只有在光标移动的时候才设置 ' 位置标记。
                's' 标志位不能和 'n' 标志位一起使用。

                适用 <a href="options.html#'ignorecase'">'ignorecase'</a>、<a href="options.html#'smartcase'">'smartcase'</a> 和 <a href="options.html#'magic'">'magic'</a> 标志位。

                如果没给出 'z' 标志位，搜索总是从第零列开始，然后跳过光标之前
                的匹配。如果 <a href="options.html#'cpo'">'cpo'</a> 中有 'c' 标志位，下次搜索从匹配之后的位置开
                始。没有 'c' 标志位则下次搜索从光标之后一列开始。

                如果给出 <code class="special">{stopline}</code> 参数，搜索在搜索完该行后结束。可用于限制搜
                索在给出的行范围内。例如: 
<code class="example">                        let match = search('(', 'b', line("w0"))</code>
<code class="example">                        let end = search('END', '', line("w$"))</code>
                如果使用了 <code class="special">{stopline}</code> 且非零，隐含意味着搜索不会在文件尾回绕。
                零就相当于没给出该参数。

                如果给出 <code class="special">{timeout}</code> 参数，搜索在超过给出的毫秒数后中止。这样，
                如果 <code class="special">{timeout}</code> 为 500，搜索在半秒钟后中止。该值不能为负。
                零就相当于没给出该参数。
                <code class="notvi">{仅当在编译时加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="search()-sub-match">search()-sub-match</a> </b>
                如果有 'p' 标志位，返回值比第一个匹配的 \(\) 里的子模式的编号
                多一。如果所有子模式都不匹配但整个模式匹配，返回一。
                要得到列号，使用  <a href="eval.html#searchpos()">searchpos()</a> 。

                光标定位在匹配的文本上，除非使用了 'n' 标志位。

                示例 (遍历参数列表里的所有文件): 
<code class="example">                    :let n = 1</code>
<code class="example">                    :while n &lt;= argc()      " 循环遍历参数列表的每个文件</code>
<code class="example">                    :  exe "argument " . n</code>
<code class="example">                    :  " 从文件最后一个字符开始并回绕，这样第一个搜索可以找到</code>
<code class="example">                    :  " 文件开始的匹配</code>
<code class="example">                    :  normal G$</code>
<code class="example">                    :  let flags = "w"</code>
<code class="example">                    :  while search("foo", flags) &gt; 0</code>
<code class="example">                    :    s/foo/bar/g</code>
<code class="example">                    :    let flags = "W"</code>
<code class="example">                    :  endwhile</code>
<code class="example">                    :  update               " 如果修改过，写入文件</code>
<code class="example">                    :  let n = n + 1</code>
<code class="example">                    :endwhile</code>

                使用一些标志位的示例: 
<code class="example">                    :echo search('\&lt;if\|\(else\)\|\(endif\)', 'ncpe')</code>
                这会在光标之下或之后寻找关键字 "if"、"else" 和 "endif"。因为有
                'p' 标志位，会根据找到的是哪 个关键字返回 1、2 或 3，如果找不
                到会返回 0。如果光标在行的第一个单词上:
<code class="section">                    if (foo == 0) | let foo = foo + 1 | endif </code>
                此函数返回 1。没有 'c' 标志位的话，函数会找到 "endif" 并返回
                3。如果没有 'e' 标志位且光标在 "if" 的 "f" 上也会同样如此。'n'
                标志位告诉函数不移动光标。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPattern()-&gt;search()</code>
<code class="example"></code>
searchdecl(<code class="special">{name}</code> [, <code class="special">{global}</code> [, <code class="special">{thisblock}</code>]])                 <b class="vimtag"> <a name="searchdecl()">searchdecl()</a> </b>
                搜索 <code class="special">{name}</code> 的声明。

                如果 <code class="special">{global}</code> 参数非零，使用  <a href="pattern.html#gD">gD</a>  的工作方式，寻找文件的第一个
                匹配。否则使用  <a href="pattern.html#gd">gd</a>  的工作方式，寻找函数里的第一个匹配。

                如果 <code class="special">{thisblock}</code> 参数非零，忽略光标位置前结束的 <code class="special">{}</code> 块里的匹
                配。可以避免只有在别的作用域里才有效的变量声明。

                移动光标到找到的匹配上。
                返回零代表成功，非零代表失败。
                例如: 
<code class="example">                        if searchdecl('myvar') == 0</code>
<code class="example">                           echo getline('.')</code>
<code class="example">                        endif</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetName()-&gt;searchdecl()</code>

                                                        <b class="vimtag"> <a name="searchpair()">searchpair()</a> </b>
searchpair(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code>
                                [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]]])
                搜索嵌套的 start-end 组对的匹配。这可以用来查找匹配 "if" 的
                "endif"。在这里面的其它的 if/endif 组对被忽略。搜索从光标开
                始。缺省正向搜索，在 <code class="special">{flags}</code> 里包含 'b' 的时候反向搜索。
                如果找到一个匹配，光标移动到那里并返回行号。如果没有匹配，
                返回 0 或者 -1，光标不移动。不会给出错误信息。

                <code class="special">{start}</code>、<code class="special">{middle}</code> 和 <code class="special">{end}</code> 都是模式，见  <a href="pattern.html#pattern">pattern</a> 。它们不能包
                含 \( \) 对，但可以使用 \%( \)。如果 <code class="special">{middle}</code> 非空，在相应的方
                向试图寻找它 (如果找到，停留在哪里)，但在嵌套的 start-end 组对
                里面的不算。一个典型的应用是: 
<code class="example">                        searchpair('\&lt;if\&gt;', '\&lt;else\&gt;', '\&lt;endif\&gt;')</code>
                如果 <code class="special">{middle}</code> 为空，跳过 "else"。

                <code class="special">{flags}</code> 'b'、'c'、'n'、's'、'w' 和 'W' 的使用方式和  <a href="eval.html#search()">search()</a> 
                类似。此外，还可用:
                'r'     重复 (Repeat) 直到没有更多匹配位置；会找到最外层的组
                        对。隐含 'W' 标志位。
                'm'     返回匹配 (Match) 的数目而不是匹配的行号；使用 'r' 时会
                        &gt; 1。
                <code class="note">备注</code>: 最好使用 'W' 标志位，避免在文件尾回绕。

                如果找到 <code class="special">{start}</code>、<code class="special">{middle}</code> 或 <code class="special">{end}</code> 的匹配，计算 <code class="special">{skip}</code> 表达
                式，此时假定光标定位在匹配的开始处。如果返回零，该匹配被跳过。
                比如，可能是出现在注释里的匹配。
                如果 <code class="special">{skip}</code> 不提供或者为空，接受每一个匹配。如果计算 <code class="special">{skip}</code> 时
                出现错误，搜索被中止，并返回 -1。
                <code class="special">{skip}</code> 可以是字符串、匿名函数、函数引用或偏函数。其它类型会报
                错。

                <code class="special">{stopline}</code> 和 <code class="special">{timeout}</code> 见  <a href="eval.html#search()">search()</a> 。

                使用 <a href="options.html#'ignorecase'">'ignorecase'</a> 的值。忽略 <a href="options.html#'magic'">'magic'</a>，使用模式时假设它总是置位
                的。

                搜索从准确的光标处开始。根据搜索方向，寻找从下一个字符开始的
                <code class="special">{start}</code>、<code class="special">{middle}</code> 或 <code class="special">{end}</code>。比如: 
<code class="example">                        if 1</code>
<code class="example">                          if 2</code>
<code class="example">                          endif 2</code>
<code class="example">                        endif 1</code>
                如果从 "if 2" 开始且光标在 "i" 上并正向搜索，找到的是
                "endif 2"。如果刚好在 "if 2" 之前开始，找到的是 "endif 1"。因
                为先找到的了 "if 2"，而它被认为是嵌套的 if/endif，以 "if 2"
                开始，以 "endif 2" 结束。
                如果反向搜索且 <code class="special">{end}</code> 多于一个字符，在模式的最后加上 "\zs" 可能
                有用，这样光标在 end 匹配的中间某位置的时候，仍然可以找到匹配
                的 start 匹配。

                例如，要找到 Vim 脚本里的 "endif" 命令: 
<code class="example"></code>
<code class="example">        :echo searchpair('\&lt;if\&gt;', '\&lt;el\%[seif]\&gt;', '\&lt;en\%[dif]\&gt;', 'W',</code>
<code class="example">                        \ 'getline(".") =~ "^\\s*\""')</code>
<code class="example"></code>
                光标必须在要寻找匹配的 "if" 之上或之后。<code class="note">注意</code> 单引号字符串的使
                用，它避免了反斜杠的麻烦。skip 表达式只用来发现行首的注释，命
                令之后的不行。另外，一行中间的单词 "en" 或 "if" 也被认为是匹
                配。
                另一个例子，搜索匹配 "}" 的 "{": 
<code class="example"></code>
<code class="example">        :echo searchpair('{', '', '}', 'bW')</code>
<code class="example"></code>
                只需要光标在需要匹配的 "}" 之上或之前就可以了。要拒绝语法高亮
                识别为字符串的匹配: 
<code class="example"></code>
<code class="example">        :echo searchpair('{', '', '}', 'bW',</code>
<code class="example">             \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')</code>

                                                        <b class="vimtag"> <a name="searchpairpos()">searchpairpos()</a> </b>
searchpairpos(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code>
                                [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]]])
                和  <a href="eval.html#searchpair()">searchpair()</a>  相同，但返回  <a href="eval.html#List">List</a> ，包含匹配的行号和列号。
                 <a href="eval.html#List">List</a>  的第一个元素是行号，而第二个元素是匹配所在的列位置的字
                节位置。如果没有匹配，返回 [0, 0]。 
<code class="example"></code>
<code class="example">                        :let [lnum,col] = searchpairpos('{', '', '}', 'n')</code>

                 <a href="tips.html#match-parens">match-parens</a>  提供一个更复杂更有用的例子。

searchpos(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])   <b class="vimtag"> <a name="searchpos()">searchpos()</a> </b>
                和  <a href="eval.html#search()">search()</a>  相同，但返回  <a href="eval.html#List">List</a> ，包含匹配的行号和列号。
                 <a href="eval.html#List">List</a>  的第一个元素是行号，而第二个元素是匹配所在的列位置的字
                节位置。如果没有匹配，返回 [0, 0]。
                例如: 
<code class="example">        :let [lnum, col] = searchpos('mypattern', 'n')</code>
<code class="example"></code>
                如果给出 'p' 标志位，返回值里有一个附加项目，包含匹配的子模式
                号  <a href="eval.html#search()-sub-match">search()-sub-match</a> 。例如: 
<code class="example">        :let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')</code>
                此例中如果找到小写字母  <a href="pattern.html#%2F\l">/\l</a>  "submatch" 为 2，如果找到大写字母
                 <a href="pattern.html#%2F\u">/\u</a>  则为 3。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPattern()-&gt;searchpos()</code>
<code class="example"></code>
server2client(<code class="special">{clientid}</code>, <code class="special">{string}</code>)                     <b class="vimtag"> <a name="server2client()">server2client()</a> </b>
                发送应答字符串到 <code class="special">{clientid}</code>。最近刚发送过字符串的 <code class="special">{clientid}</code>
                可以通过 expand("<code class="special">&lt;client&gt;</code>") 得到。
                <code class="notvi">{仅当在编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                <code class="note">备注</code>:
                该 id 应在接受下一个命令前保存。也就是，在接收命令返回之前 (译
                者注: 似应为 "之后") 和任何等待输入的命令之前。
                另见  <a href="remote.html#clientserver">clientserver</a> 。
                示例: 
<code class="example">                        :echo server2client(expand("&lt;client&gt;"), "HELLO")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetClientId()-&gt;server2client(string)</code>

serverlist()                                    <b class="vimtag"> <a name="serverlist()">serverlist()</a> </b>
                返回可用的服务器名字列表，每行一个。如果没有服务器或者该信息
                无法得到，返回空字符串。另见  <a href="remote.html#clientserver">clientserver</a> 。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                示例: 
<code class="example">                        :echo serverlist()</code>

setbufline(<code class="special">{expr}</code>, <code class="special">{lnum}</code>, <code class="special">{text}</code>)                      <b class="vimtag"> <a name="setbufline()">setbufline()</a> </b>
                设置缓冲区 <code class="special">{expr}</code> 的第 <code class="special">{lnum}</code> 行为 <code class="special">{text}</code>。相当于为指定缓冲区
                调用  <a href="eval.html#setline()">setline()</a> 。

                此函数只能用于已载入的缓冲区。有必要的话先调用  <a href="eval.html#bufload()">bufload()</a> 。

                要插入行可用  <a href="eval.html#appendbufline()">appendbufline()</a> 。
                清除 <code class="special">{lnum}</code> 中的任何文本属性。

                <code class="special">{text}</code> 可以是字符串，用来设置单行文本，也可以是字符串列表，用
                来设置多行文本。如果列表范围超出末行之下，则添加额外的行。

                <code class="special">{expr}</code> 的用法可见上述  <a href="eval.html#bufname()">bufname()</a> 。

                <code class="special">{lnum}</code> 的用法类似于  <a href="eval.html#setline()">setline()</a> 。
                如果 <code class="special">{lnum}</code> 正好在末行之下，在末行之下添加 <code class="special">{text}</code>。

                如果 <code class="special">{expr}</code> 不是合法缓冲区、缓冲区未载入、或 <code class="special">{lnum}</code> 不合法，返
                回 1。成功时返回 0。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetText()-&gt;setbufline(buf, lnum)</code>
<code class="example"></code>
setbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)                     <b class="vimtag"> <a name="setbufvar()">setbufvar()</a> </b>
                设置缓冲区 <code class="special">{expr}</code> 的选项或局部变量 <code class="special">{varname}</code> 的值为 <code class="special">{val}</code>。
                也可用于全局或者局部于窗口的选项，但不能用于全局或者局部于窗口
                的变量。
                如果设置局部于窗口的选项，全局值不会改变。
                <code class="special">{expr}</code> 的使用方式见上  <a href="eval.html#bufname()">bufname()</a> 。
                <code class="note">注意</code>必须使用不带 "b:" 的变量名。
                示例: 
<code class="example">                        :call setbufvar(1, "&amp;mod", 1)</code>
<code class="example">                        :call setbufvar("todo", "myvar", "foobar")</code>
                该命令在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetValue()-&gt;setbufvar(buf, varname)</code>
<code class="example"></code>
setcharsearch(<code class="special">{dict}</code>)                                   <b class="vimtag"> <a name="setcharsearch()">setcharsearch()</a> </b>
                用 <code class="special">{dict}</code> 设置当前字符搜索信息，带有以下项目:

                    char        下次  <a href="motion.html#,">,</a>  或  <a href="motion.html#;">;</a>  命令使用的字符；空字符串清除字
                                符搜索
                    forward     字符搜索的方向；1 为正向，0 为反向
                    until       字符搜索的类型；1 为  <a href="motion.html#t">t</a>  为  <a href="motion.html#T">T</a>  字符搜索，0 为
                                 <a href="motion.html#f">f</a>  或  <a href="motion.html#F">F</a>  字符搜索

                可用于在脚本中保存/恢复用户的字符搜索: 
<code class="example">                        :let prevsearch = getcharsearch()</code>
<code class="example">                        :" 执行改写用户搜索的命令</code>
<code class="example">                        :call setcharsearch(prevsearch)</code>
                另见  <a href="eval.html#getcharsearch()">getcharsearch()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        SavedSearch()-&gt;setcharsearch()</code>
<code class="example"></code>
setcmdpos(<code class="special">{pos}</code>)                                        <b class="vimtag"> <a name="setcmdpos()">setcmdpos()</a> </b>
                设置命令行的光标位置到字节位置 <code class="special">{pos}</code>。第一个位置为 1。
                用  <a href="eval.html#getcmdpos()">getcmdpos()</a>  得到当前的位置。
                只有在编辑命令行时有效，所以必须在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a> 、 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a> 
                或带 '=' 的  <a href="cmdline.html#c_CTRL-R_CTRL-R">c_CTRL-R_CTRL-R</a>  里使用。对于  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  和带
                '=' 的  <a href="cmdline.html#c_CTRL-R_CTRL-R">c_CTRL-R_CTRL-R</a> ，在命令行设为表达式的内容之后才设置位
                置。对于  <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a> ，在计算表达式之后但在插入返回的文本之前
                设置位置。
                如果数值太大，光标放在行尾。如果小于 1，结果没有定义。
                如果成功，返回 0，如果不在编辑命令行，返回 1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPos()-&gt;setcmdpos()</code>
<code class="example"></code>
setenv(<code class="special">{name}</code>, <code class="special">{val}</code>)                                           <b class="vimtag"> <a name="setenv()">setenv()</a> </b>
                设置环境变量 <code class="special">{name}</code> 值为 <code class="special">{val}</code>。
                如果 <code class="special">{val}</code> 为  <a href="eval.html#v:null">v:null</a> ，删除该环境变量。
                另见  <a href="eval.html#expr-env">expr-env</a> 。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetPath()-&gt;setenv('PATH')</code>
<code class="example"></code>
setfperm(<code class="special">{fname}</code>, <code class="special">{mode}</code>)                               <b class="vimtag"> <a name="setfperm()">setfperm()</a> </b> <b class="vimtag"> <a name="chmod">chmod</a> </b>
                设置 <code class="special">{fname}</code> 的文件权限为 <code class="special">{mode}</code>。
                <code class="special">{mode}</code> 必须是 9 个字符的字符串。形如 "rwxrwxrwx"，每组 "rwx"
                标志位代表着，按次序，文件拥有者、文件所属组和其他用户的权限。
                '-' 字符代表关闭权限，其他字符代表打开。不支持多字节字符。

                例如 "rw-r-----" 意味着用户可读写，组只读，其他不可访问。
                "xx-x-----" 作用相同。

                返回非零代表成功，零代表失败。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;setfperm(mode)</code>

                要读取权限可见  <a href="eval.html#getfperm()">getfperm()</a> 。


setline(<code class="special">{lnum}</code>, <code class="special">{text}</code>)                                 <b class="vimtag"> <a name="setline()">setline()</a> </b>
                设置当前缓冲区第 <code class="special">{lnum}</code> 行的内容为 <code class="special">{text}</code>。要插入新行，用
                 <a href="eval.html#append()">append()</a> 。要设置其它缓冲区的行，可用  <a href="eval.html#setbufline()">setbufline()</a> 。清除
                <code class="special">{lnum}</code> 中的任何文本属性。

                <code class="special">{lnum}</code> 的用法同  <a href="eval.html#getline()">getline()</a> 。
                如果 <code class="special">{lnum}</code> 正好在末行之下，在末行之下添加 <code class="special">{text}</code>。

                如果成功，返回 0。如果失败 (多数是因为 <code class="special">{lnum}</code> 不合法) 返回 1。
                例如: 
<code class="example">                        :call setline(5, strftime("%c"))</code>
<code class="example"></code>
                如果 <code class="special">{text}</code> 为  <a href="eval.html#List">List</a> ，那么第 <code class="special">{lnum}</code> 行和其后的行被设为列表里
                的项目。例如: 
<code class="example">                        :call setline(5, ['aaa', 'bbb', 'ccc'])</code>
                等价于: 
<code class="example">                        :for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]</code>
<code class="example">                        :  call setline(n, l)</code>
<code class="example">                        :endfor</code>
<code class="example"></code>
                <code class="note">注意</code>: 这里不会设置 '[ 和 '] 位置标记。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetText()-&gt;setline(lnum)</code>
<code class="example"></code>
setloclist(<code class="special">{nr}</code>, <code class="special">{list}</code> [, <code class="special">{action}</code> [, <code class="special">{what}</code>]])                <b class="vimtag"> <a name="setloclist()">setloclist()</a> </b>
                创建或替代或加入到窗口 <code class="special">{nr}</code> 的位置列表。
                <code class="special">{nr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 为零，使用当前窗口。

                如果是位置列表窗口，修改所显示的位置列表。如果窗口号 <code class="special">{nr}</code> 非
                法，返回 -1。
                其它同  <a href="eval.html#setqflist()">setqflist()</a> 。
                另见  <a href="quickfix.html#location-list">location-list</a> 。

                如果给出可选的 <code class="special">{what}</code> 字典参数，只设置 <code class="special">{what}</code> 中列出的项目。
                关于 <code class="special">{what}</code> 支持的键值的列表，参见  <a href="eval.html#setqflist()">setqflist()</a> 。

setmatches(<code class="special">{list}</code> [, <code class="special">{win}</code>])                            <b class="vimtag"> <a name="setmatches()">setmatches()</a> </b>
                恢复  <a href="eval.html#getmatches()">getmatches()</a>  为当前窗口保存的匹配列表。如果成功，返回
                0，否则返回 -1。原有的所有匹配都被清除。示例见
                 <a href="eval.html#getmatches()">getmatches()</a> 。
                如果给出 <code class="special">{win}</code>，使用带此窗口号或窗口 ID 的窗口而不是当前窗口。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMatches()-&gt;setmatches()</code>

                                                        <b class="vimtag"> <a name="setpos()">setpos()</a> </b>
setpos(<code class="special">{expr}</code>, <code class="special">{list}</code>)
                设置 <code class="special">{expr}</code> 的位置。可能的值:
                        .       光标
                        'x      位置标记 x

                <code class="special">{list}</code> 必须是带四个或五个数值的  <a href="eval.html#List">List</a> :
                    [bufnum, lnum, col, off]
                    [bufnum, lnum, col, off, curswant]

                "bufnum" 是缓冲区号。零代表当前缓冲区。如果设置大写位置标记，
                "bufnum" 是位置标记位置的一部分。对其它的位置标记，它用于指定
                设置位置标记的缓冲区。可以用  <a href="eval.html#bufnr()">bufnr()</a>  函数把文件名转化为缓冲
                区号。
                设置光标和 ' 位置标记时忽略 "bufnum"，因为它们和窗口相关，而不
                是缓冲区相关。
                不修改跳转表。

                "lnum" 和 "col" 是缓冲区里的位置。第一列为 1。"lnum" 为零则删
                除位置标记。"col" 如小于 1，则以 1 代替。

                除非使用了 <a href="options.html#'virtualedit'">'virtualedit'</a>，不用 "off" 值。这是从对应字符开始位
                置以屏幕列计的位移。例如，在制表之中或最后一个字符之后的某个位
                置。

                "curswant" 值只用于设置光标位置。它指定垂直移动光标时的首选
                列。如果没有 "curswants" 值，不设置首选列。如果有但用于设置位
                置标记时，也没有效果。

                <code class="note">注意</code>对 '&lt; 和 '&gt; 而言，改变行号可能会使两者在实际中被调换，以保
                证 '&lt; 总是在 '&gt; 之前。

                如果位置可以设置，返回 0，否则返回 -1。如果 <code class="special">{expr}</code> 不合法，报
                错。

                另见  <a href="eval.html#getpos()">getpos()</a>  和  <a href="eval.html#getcurpos()">getcurpos()</a> 。

                这并不能恢复垂直移动使用的列；如果用它设置了光标位置， <a href="motion.html#j">j</a>  和
                 <a href="motion.html#k">k</a>  动作会跳转到上次的列上！ <a href="eval.html#cursor()">cursor()</a>  也可设置首选列。另见
                 <a href="eval.html#winrestview()">winrestview()</a>  的 "curswant" 键。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPosition()-&gt;setpos('.')</code>
<code class="example"></code>
setqflist(<code class="special">{list}</code> [, <code class="special">{action}</code> [, <code class="special">{what}</code>]])               <b class="vimtag"> <a name="setqflist()">setqflist()</a> </b>
                创建或替代或加入到 quickfix 表。

                如果不给出 <code class="special">{what}</code>，使用 <code class="special">{list}</code> 里的项目。每个 <code class="special">{list}</code> 项目是一
                个字典。<code class="special">{list}</code> 里非字典的项目被忽略。每个字典项目可以包含以下
                的项目:

                    bufnr       缓冲区号；必须为某个合法缓冲区的编号
                    filename    文件名；仅当 "bufnr" 不存在或者不合法时才使用
                    module      模块名；如果给出，在 quickfix 错误窗口用它而不
                                是文件名
                    lnum        缓冲区里的行号
                    pattern     用于定位错误的模式
                    col         列号
                    vcol        非零: "col" 是可视列
                                零: "col" 是字节位置
                    nr          错误号
                    text        错误描述
                    type        错误类型，'E'、'W' 等。
                    valid       经过识别的错误信息

                "col"、"vcol"、"nr"、"type" 和 "text" 项目是可选的。"lnum" 或
                "pattern" 项目用来定位匹配的错误行。
                如果 "filename" 和 "bufnr" 项目都不存在或者 "lnum" 和
                "pattern" 项目都不存在，那么此项目不被当作错误行处理。
                如果 "pattern" 和 "lnum" 都存在，使用 "pattern"。
                如果不提供 "valid" 项目，则在 "bufnr" 为合法的缓冲区或
                "filename" 存在时，置位 valid 标志位。
                如果 <code class="special">{list}</code> 为空，quickfix 列表被清除。
                <code class="note">注意</code> 此列表和  <a href="eval.html#getqflist()">getqflist()</a>  返回之值不尽相同。

                <code class="special">{action}</code> 值:                                    <b class="vimtag"> <a name="E927">E927</a> </b>
                'a'     把 <code class="special">{list}</code> 项目加入已有的 quickfix 列表。如果该列表尚不
                        存在，建立新表。

                'r'     <code class="special">{list}</code> 项目替换当前 quickfix 列表项目。也可用于清除列
                        表: 
<code class="example">                                :call setqflist([], 'r')</code>

                'f'     释放 quickfix 堆栈上的所有 quickfix 列表。

                如果 <code class="special">{action}</code> 不存在或者设为 ' '，那么建立新表。栈中在当前
                quickfix 列表之后加入新 quickfix 列表并释放其后的所有列表。要
                在栈的尾部加入新 quickfix 列表，把 <code class="special">{what}</code> 中的 "nr" 设为 "$"。

                如果提供了可选的 <code class="special">{what}</code> 字典参数，只设置 <code class="special">{what}</code> 列出的项目，忽
                略首个参数 <code class="special">{list}</code>。<code class="special">{what}</code> 支持以下项目:
                    context     quickfix 列表上下文。见  <a href="quickfix.html#quickfix-context">quickfix-context</a> 
                    efm         解析 "lines" 时使用的 errorformat。如果没有给
                                出，使用 <a href="options.html#'errorformat'">'errorformat'</a> 选项值。
                                见  <a href="quickfix.html#quickfix-parse">quickfix-parse</a> 
                    id          quickfix 列表标识号  <a href="quickfix.html#quickfix-ID">quickfix-ID</a> 
                    idx         <code class="badlink">'id'</code> 或 <code class="badlink">'nr'</code> 指定的 quickfix 列表的当前项的索
                                引。如果设为 '$'，列表的末项设为当前项。见
                                 <a href="quickfix.html#quickfix-index">quickfix-index</a> 
                    items       quickfix 项目的列表，同 <code class="special">{list}</code> 参数。
                    lines       用 <a href="options.html#'efm'">'efm'</a> (<code class="vim">译者注</code>: 原文作 <a href="options.html#'errorformat'">'errorformat'</a>，似不
                                妥) 解析文本行列表并其结果项目加入 quickfix 列
                                表 <code class="special">{nr}</code> 或 <code class="special">{id}</code> 中。只支持  <a href="eval.html#List">List</a>  类型。
                                见  <a href="quickfix.html#quickfix-parse">quickfix-parse</a> 
                    nr          quickfix 堆栈中的列表号；零代表当前
                                quickfix 列表，"$" 代表最后的 quickfix 列表。
                    title       quickfix 列表标题。见  <a href="quickfix.html#quickfix-title">quickfix-title</a> 
                忽略 <code class="special">{what}</code> 中不支持的项目。
                如果不给出 "nr"，修改当前 quickfix 列表。要创建新的 quickfix
                列表，"nr" 可设为比 quickfix 栈大小大一的值。

                在修改 quickfix 列表时，要保证修改的是正确的列表，应用 "id" 而
                不是 "nr" 来指定列表。

                示例 (另见  <a href="quickfix.html#setqflist-examples">setqflist-examples</a> ): 
<code class="example">                   :call setqflist([], 'r', {'title': 'My search'})</code>
<code class="example">                   :call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})</code>
<code class="example">                   :call setqflist([], 'a', {'id':qfid, 'lines':["F1:10:L10"]})</code>

                返回零代表成功，-1 代表失败。

                该函数用来独立于 <a href="options.html#'errorformat'">'errorformat'</a> 的设置建立 quickfix 列表。
                `:cc 1` 这样的命令可以跳转到第一个位置上。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetErrorlist()-&gt;setqflist()</code>

                                                        <b class="vimtag"> <a name="setreg()">setreg()</a> </b>
setreg(<code class="special">{regname}</code>, <code class="special">{value}</code> [, <code class="special">{options}</code>])
                设置寄存器 <code class="special">{regname}</code> 的值为 <code class="special">{value}</code>。
                <code class="special">{value}</code> 可以是  <a href="eval.html#getreg()">getreg()</a>  返回的任何类型，包括  <a href="eval.html#List">List</a> 。
                如果 <code class="special">{options}</code> 包含 "a" 或者 <code class="special">{regname}</code> 为大写，该值被附加于现
                有值之后。
                <code class="special">{options}</code> 还可以指定寄存器新类型的规格:
                    "c" 或 "v"         <a href="motion.html#characterwise">characterwise</a>  (面向字符) 模式
                    "l" 或 "V"         <a href="motion.html#linewise">linewise</a>  (面向行) 模式
                    "b" 或 "&lt;<code class="keystroke">CTRL-V</code>&gt;"  <a href="visual.html#blockwise-visual">blockwise-visual</a>  (面向列块) 模式
                如果 "b" 或 "&lt;<code class="keystroke">CTRL-V</code>&gt;" 之后紧跟数值，那么该数值用作选择的宽度
                - 如果没有指定，那么列块的宽度设为最长的行字符数 (把 <code class="special">&lt;Tab&gt;</code>
                看作一个字符)。

                如果 <code class="special">{options}</code> 没有寄存器设置，那么字符串值 <code class="special">{value}</code> 缺省使用面
                向字符模式，除非 <code class="special">{value}</code> 以 <code class="special">&lt;NL&gt;</code> 结尾，列表值的 <code class="special">{value}</code> 缺省使
                用面向行模式。不会自动选择面向列块模式。
                返回零代表成功，非零代表失败。

                                                        <b class="vimtag"> <a name="E883">E883</a> </b>
                <code class="note">备注</code>: 设置搜索和表达式寄存器时，不可使用多于一个项目的
                       <a href="eval.html#List">List</a> 。无项目的列表相当于空串。

                示例: 
<code class="example">                        :call setreg(v:register, @*)</code>
<code class="example">                        :call setreg('*', @%, 'ac')</code>
<code class="example">                        :call setreg('a', "1\n2\n3", 'b5')</code>
<code class="example"></code>
                本例说明如何使用函数来保存和恢复寄存器: 
<code class="example">                        :let var_a = getreg('a'， 1)</code>
<code class="example">                        :let var_amode = getregtype('a')</code>
<code class="example">                            ....</code>
<code class="example">                        :call setreg('a', var_a, var_amode)</code>
<code class="example"></code>
                <code class="note">备注</code>: 如果不提供  <a href="eval.html#getreg()">getreg()</a>  的第三个参数，就不能可靠地恢复寄存
                器值，因为此时，换行符和 Nul 字节都用换行符表示，见
                 <a href="pattern.html#NL-used-for-Nul">NL-used-for-Nul</a> )。

                你可以通过附加空串来改变寄存器的类型: 
<code class="example">                        :call setreg('a', '', 'al')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetText()-&gt;setreg('a')</code>
<code class="example"></code>
settabvar(<code class="special">{tabnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)                    <b class="vimtag"> <a name="settabvar()">settabvar()</a> </b>
                设置标签页 <code class="special">{tabnr}</code> 的标签页局部变量 <code class="special">{varname}</code> 的值为 <code class="special">{val}</code>。
                <code class="note">注意</code> 自动命令是阻塞的，可能不会触发副作用，比如设置 <a href="options.html#'filetype'">'filetype'</a>
                的时候。
                <code class="note">注意</code> 必须使用不带 "t:" 的名字。
                标签页的编号从一开始。
                该命令在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetValue()-&gt;settabvar(tab, name)</code>
<code class="example"></code>
settabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)        <b class="vimtag"> <a name="settabwinvar()">settabwinvar()</a> </b>
                设置窗口 <code class="special">{nr}</code> 的选项或局部变量 <code class="special">{varname}</code> 的值为 <code class="special">{val}</code>。
                标签页的编号从一开始。 <a href="eval.html#setwinvar()">setwinvar()</a>  总是使用当前标签页。
                <code class="special">{winnr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{winnr}</code> 为零，使用当前窗口。
                <code class="note">注意</code> 自动命令是阻塞的，可能不会触发副作用，比如设置 <a href="options.html#'filetype'">'filetype'</a>
                或 <a href="options.html#'syntax'">'syntax'</a> 的时候。
                也可用于全局或者局部于缓冲区的选项，但不能用于全局或者局部于缓
                冲区的变量。
                如果设置局部于缓冲区的选项，全局值不会改变。
                <code class="note">注意</code> 必须使用不带 "w:" 的变量名。
                示例: 
<code class="example">                        :call settabwinvar(1, 1, "&amp;list", 0)</code>
<code class="example">                        :call settabwinvar(3, 2, "myvar", "foobar")</code>
                该命令在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第四个参数传递的: 
<code class="example">                        GetValue()-&gt;settabvar(tab, winnr, name)</code>
                (<code class="vim">译者注</code>: 原文如此，应为 settabwinvar)

settagstack(<code class="special">{nr}</code>, <code class="special">{dict}</code> [, <code class="special">{action}</code>])                  <b class="vimtag"> <a name="settagstack()">settagstack()</a> </b>
                用 <code class="special">{dict}</code> 修改窗口 <code class="special">{nr}</code> 标签栈。
                <code class="special">{nr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。

                要查阅 <code class="special">{dict}</code> 支持项的列表，可参考  <a href="eval.html#gettagstack()">gettagstack()</a> 。
                "curidx" 在标签栈修改之前生效。
                                                        <b class="vimtag"> <a name="E962">E962</a> </b>
                标签栈如何修改取决于 <code class="special">{action}</code> 参数:
                - 如果 <code class="special">{action}</code> 没给出或是 'r'，标签栈被替换。
                - 如果 <code class="special">{action}</code> 是 'a'，则 <code class="special">{dict}</code> 中的新项被压进标签栈里。
                - 如果 <code class="special">{action}</code> 是 't'，删除标签栈的当前项或 <code class="special">{dict}</code> 中的
                  "curidx" 项里面的所有项目，然后把新项压进标签栈里。

                当前索引设为修改之后的标签栈的长度之后的那项。

                成功时返回零，失败则返回 -1。

                示例:
                    设置标签栈的当前索引为 4: 
<code class="example">                        call settagstack(1005, {'curidx' : 4})</code>
<code class="example"></code>
                    清空窗口 3 的标签栈: 
<code class="example">                        call settagstack(3, {'items' : []})</code>
<code class="example"></code>
                    给标签栈压入新项目: 
<code class="example">                        let pos = [bufnr('myfile.txt'), 10, 1, 0]</code>
<code class="example">                        let newtag = [{'tagname' : 'mytag', 'from' : pos}]</code>
<code class="example">                        call settagstack(2, {'items' : newtag}, 'a')</code>
<code class="example"></code>
                    保存并恢复标签栈: 
<code class="example">                        let stack = gettagstack(1003)</code>
<code class="example">                        " do something else</code>
<code class="example">                        call settagstack(1003, stack)</code>
<code class="example">                        unlet stack</code>

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetStack()-&gt;settagstack(winnr)</code>
<code class="example"></code>
setwinvar(<code class="special">{winnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)                    <b class="vimtag"> <a name="setwinvar()">setwinvar()</a> </b>
                类似于  <a href="eval.html#settabwinvar()">settabwinvar()</a> ，只用当前标签页。
                示例: 
<code class="example">                        :call setwinvar(1, "&amp;list", 0)</code>
<code class="example">                        :call setwinvar(2, "myvar", "foobar")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> ，基是作为第三个参数传递的: 
<code class="example">                        GetValue()-&gt;setwinvar(winnr, name)</code>
<code class="example"></code>
sha256(<code class="special">{string}</code>)                                                <b class="vimtag"> <a name="sha256()">sha256()</a> </b>
                返回 64 位十六进制字符串，即 <code class="special">{string}</code> 的 SHA256 校验码。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;sha256()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+cryptv">+cryptv</a>  特性才有效}</code>

shellescape(<code class="special">{string}</code> [, <code class="special">{special}</code>])                     <b class="vimtag"> <a name="shellescape()">shellescape()</a> </b>
                转义 <code class="special">{string}</code> 以便用作外壳命令的参数。
                在 MS-Windows 上，如果未设定 <a href="options.html#'shellslash'">'shellslash'</a>，用双引号包围
                <code class="special">{string}</code>，并给 <code class="special">{string}</code> 内的双引号加倍。
                否则，用单引号包围，并把所有的 "'" 替换为 "'\''"。

                如果给出 <code class="special">{special}</code> 参数且它是非零的数值或非空的字符串
                ( <a href="eval.html#non-zero-arg">non-zero-arg</a> )，则特殊项目如 "!"、"%"、"#" 和 "<code class="special">&lt;cword&gt;</code>" 等会
                在前面加上反斜杠。 <a href="various.html#:!">:!</a>  命令会再把反斜杠删除。

                如果 <a href="options.html#'shell'">'shell'</a> 以 "csh" 结尾，"!" 字符会被转义 (仍是当 <code class="special">{special}</code>
                为  <a href="eval.html#non-zero-arg">non-zero-arg</a>  时)。这是因为 csh 和 tcsh 即使在单引号内仍然
                使用 "!" 用于历史替换。

                如果 <code class="special">{special}</code> 为  <a href="eval.html#non-zero-arg">non-zero-arg</a> ，<code class="special">&lt;NL&gt;</code> 也被转义。<a href="options.html#'shell'">'shell'</a> 以
                "csh" 结尾时，转义两次。

                 <a href="various.html#:!">:!</a>  命令的示例: 
<code class="example">                    :exe '!dir ' . shellescape(expand('&lt;cfile&gt;'), 1)</code>
                返回光标所在文件给出的目录列表。 <a href="eval.html#system()">system()</a>  的示例: 
<code class="example">                    :call system("chmod +w -- " . shellescape(expand("%")))</code>
                另见  <a href="cmdline.html#::S">::S</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetCommand()-&gt;shellescape()</code>
<code class="example"></code>
<code class="example"></code>
shiftwidth([<code class="special">{col}</code>])                                             <b class="vimtag"> <a name="shiftwidth()">shiftwidth()</a> </b>
                返回 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 的有效值。即 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 值，除非其为零时则
                返回 <a href="options.html#'tabstop'">'tabstop'</a> 的值。此函数是 2012 年 7.3.694 补丁版本引入的，
                现在应该大家都有了 (不过可选的 <code class="special">{col}</code> 参数是 8.1.542 以后才有
                的)。

                给出一个参数 <code class="special">{col}</code> 时，指定列号，返回它所用的 <a href="options.html#'shiftwidth'">'shiftwidth'</a>
                值。这和 <a href="options.html#'vartabstop'">'vartabstop'</a> 特性有关。如果打开 <a href="options.html#'vartabstop'">'vartabstop'</a> 设置没有
                给出 <code class="special">{col}</code>，假定为列 1。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetColumn()-&gt;shiftwidth()</code>
<code class="example"></code>
sign_ 函数文档在这里:  <a href="sign.html#sign-functions-details">sign-functions-details</a> 。


simplify(<code class="special">{filename}</code>)                                    <b class="vimtag"> <a name="simplify()">simplify()</a> </b>
                在不改变含义的前提下，尽可能简化文件名。快捷方式 (MS-Windows
                上) 或者符号链接 (Unix 上) 不会被解析。如果 <code class="special">{filename}</code> 第一个
                路径部分指定了当前目录，结果也会是如此。而结尾的路径分隔符也不
                会被删除。
                示例: 
<code class="example">                        simplify("./dir/.././/file/") == "./file/"</code>
                <code class="note">注意</code>: 组合 "dir/.." 只有在 "dir" 是可以遍历的或者不存在的目录
                才会被删掉。Unix 上，如果 "dir" 是同一目录下的符号链接，也会删
                除该组合。为了在简化路径名之前解析所有牵涉到的符号链接，使用
                 <a href="eval.html#resolve()">resolve()</a> 。


sin(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="sin()">sin()</a> </b>
                返回浮点数，即以弧度测量的 <code class="special">{expr}</code> 的正弦值。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        :echo sin(100)</code>
                        -0.506366 
<code class="example">                        :echo sin(-4.01)</code>
                        0.763301

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;sin()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


sinh(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="sinh()">sinh()</a> </b>
                返回 <code class="special">{expr}</code> 的双曲正弦值，返回值为 [-inf, inf] 区间内的浮点
                数。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        :echo sinh(0.5)</code>
                        0.521095 
<code class="example">                        :echo sinh(-0.9)</code>
                        -1.026517

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;sinh()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


sort(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])                      <b class="vimtag"> <a name="sort()">sort()</a> </b> <b class="vimtag"> <a name="E702">E702</a> </b>
                给 <code class="special">{list}</code> 项目排序，原地直接修改列表。返回 <code class="special">{list}</code>。

                如果你不想修改列表，先构建一个备份: 
<code class="example">                        :let sortedlist = sort(copy(mylist))</code>
<code class="example"></code>
                如果 <code class="special">{func}</code> 省略、为空或为零，则 sort() 对每个项目使用字符串表
                示形式进行排序。数值排在字符串之后， <a href="eval.html#List">List</a>  排在数值之后。要给
                当前缓冲区的文本排序，用  <a href="change.html#:sort">:sort</a> 。

                如果给出 <code class="special">{func}</code> 且为 '1' 或 'i'，忽略大小写。

                如果给出 <code class="special">{func}</code> 且为 'n'，按数值顺序排序 (实现细节: 用
                strtod() 函数来解析数值，字符串、列表、字典和函数引用均视作
                0)。

                如果给出 <code class="special">{func}</code> 且为 'N'，按数值顺序排序。和 'n' 类似，但包含
                数位的字符串会被当作数值。

                如果给出 <code class="special">{func}</code> 且为 'f'，按数值顺序排序。所有值的类型必须是数
                值或浮点数。

                如果 <code class="special">{func}</code> 为  <a href="eval.html#Funcref">Funcref</a>  或函数名，调用该函数来比较项目。函数
                调用时使用两个项目作为参数，函数返回时，0 代表相等，1 或更高代
                表第一个排在第二个之后，-1 或更小代表第一个排在第二个之前。

                <code class="special">{dict}</code> 用于带 "dict" 属性的函数，并设为局部变量 "self"。
                 <a href="eval.html#Dictionary-function">Dictionary-function</a> 

                排序是稳定的，相同值 (数值或字符串) 的项目保持原有的顺序不变。
                例如，按数值顺序排序时，文本字符串会紧挨在一起，按原先的顺序出
                现。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;sort()</code>
<code class="example"></code>
                另见  <a href="eval.html#uniq()">uniq()</a> 。

                例如: 
<code class="example">                        func MyCompare(i1, i2)</code>
<code class="example">                           return a:i1 == a:i2 ? 0 : a:i1 &gt; a:i2 ? 1 : -1</code>
<code class="example">                        endfunc</code>
<code class="example">                        let sortedlist = sort(mylist, "MyCompare")</code>
                对这个简单的例子，有更简短的一个比较版本，不考虑溢出情况: 
<code class="example">                        func MyCompare(i1, i2)</code>
<code class="example">                           return a:i1 - a:i2</code>
<code class="example">                        endfunc</code>

sound_clear()                                           <b class="vimtag"> <a name="sound_clear()">sound_clear()</a> </b>
                停止播放所有声音。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+sound">+sound</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="sound_playevent()">sound_playevent()</a> </b>
sound_playevent(<code class="special">{name}</code> [, <code class="special">{callback}</code>])
                播放 <code class="special">{name}</code> 定义的声音。支持的事件名取决于系统。通常使用的是
                XDG 声音名。Ubuntu 上可以在
                /usr/share/sounds/freedesktop/stereo 中找到。例如: 
<code class="example">                        call sound_playevent('bell')</code>
                MS-Windows 上，<code class="special">{name}</code> 可以是 SystemAsterisk、SystemDefault、
                SystemExclamation、SystemExit、SystemHand、SystemQuestion、
                SystemStart、SystemWelcome 等等。

                <code class="special">{callback}</code> 给出时，在声音结束后调用。首个参数是声音 ID，第二个
                参数是状态:
                        0       声音播放到结束
                        1       声音被中断
                        2       声音启动后出错
                示例: 
<code class="example">                   func Callback(id, status)</code>
<code class="example">                     echomsg "sound " .. a:id .. " finished with " .. a:status</code>
<code class="example">                   endfunc</code>
<code class="example">                   call sound_playevent('bell', 'Callback')</code>
<code class="example"></code>
                MS-Windows: 此函数不支持 <code class="special">{callback}</code>。

                返回声音 ID，可传递给  <a href="eval.html#sound_stop()">sound_stop()</a> 。
                如果声音不能播放，返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetSoundName()-&gt;sound_playevent()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+sound">+sound</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="sound_playfile()">sound_playfile()</a> </b>
sound_playfile(<code class="special">{path}</code> [, <code class="special">{callback}</code>])
                类似于  <a href="eval.html#sound_playevent()">sound_playevent()</a>  但播放声音文件 <code class="special">{path}</code>。<code class="special">{path}</code> 必须
                是完整路径。Ubuntu 上可以用此命令找可播放的文件: 
<code class="example">                    :!find /usr/share/sounds -type f | grep -v index.theme</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetSoundPath()-&gt;sound_playfile()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+sound">+sound</a>  特性才有效}</code>


sound_stop(<code class="special">{id}</code>)                                        <b class="vimtag"> <a name="sound_stop()">sound_stop()</a> </b>
                停止播放声音 <code class="special">{id}</code>。<code class="special">{id}</code> 必须是之前  <a href="eval.html#sound_playevent()">sound_playevent()</a>  或
                 <a href="eval.html#sound_playfile()">sound_playfile()</a>  的返回值。

                MS-Windows 上，本函数不能用于  <a href="eval.html#sound_playevent()">sound_playevent()</a>  启动的事件声
                音。要停止事件声音，用  <a href="eval.html#sound_clear()">sound_clear()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        soundid-&gt;sound_stop()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+sound">+sound</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="soundfold()">soundfold()</a> </b>
soundfold(<code class="special">{word}</code>)
                返回 <code class="special">{word}</code> 按发音折叠的等价形式。使用当前窗口的 <a href="options.html#'spelllang'">'spelllang'</a>
                中第一个支持按发音折叠的语言。 <a href="options.html#'spell'">'spell'</a> 必须置位。如果不能按发
                音折叠，按原样返回 <code class="special">{word}</code>。
                可用来提供拼写建议。<code class="note">注意</code> 此方法可能很慢。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWord()-&gt;soundfold()</code>

                                                        <b class="vimtag"> <a name="spellbadword()">spellbadword()</a> </b>
spellbadword([<code class="special">{sentence}</code>])
                没有参数: 返回光标所在或之后的拼写错误的单词。光标移动到这个坏
                词的开始处。如果光标行上没有坏词，返回空字符串，不移动光标。

                有参数: 返回 <code class="special">{sentence}</code> 里第一个拼写错误的单词。如果没有拼写错
                误，返回空字符串。

                返回值是两个项目的列表:
                - 错误拼写的单词，或空字符串。
                - 拼写错误的类型:
                        "bad"           拼写错误
                        "rare"          偏僻词
                        "local"         只在其它区域里合法的单词
                        "caps"          单词应该大写开头
                例如: 
<code class="example">                        echo spellbadword("the quik brown fox")</code>
<code class="section">                        [<code class="badlink">'quik'</code>, <code class="badlink">'bad'</code>] </code>

                使用当前窗口的拼写信息。<a href="options.html#'spell'">'spell'</a> 选项必须置位，也用到
                <a href="options.html#'spelllang'">'spelllang'</a> 的值。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;spellbadword()</code>

                                                        <b class="vimtag"> <a name="spellsuggest()">spellsuggest()</a> </b>
spellsuggest(<code class="special">{word}</code> [, <code class="special">{max}</code> [, <code class="special">{capital}</code>]])
                返回  <a href="eval.html#List">List</a> ，包含替代 <code class="special">{word}</code> 的拼写建议。
                如果给出 <code class="special">{max}</code>，返回的建议不超过此数目。否则，返回不超过 25 个
                建议。

                如果给出 <code class="special">{capital}</code> 参数且非零，只给出大写开头的拼写建议。
                <a href="options.html#'spellcapcheck'">'spellcapcheck'</a> 匹配后再使用此功能。

                <code class="special">{word}</code> 可以是后跟其它文本的错误拼写单词。这样可以对两个被分开
                的单词进行连接。建议里也包含附加文本，以便你替换整行。

                <code class="special">{word}</code> 也可以是个好词。返回和它类似的单词。建议里不包含 <code class="special">{word}</code>
                自身，但可能会出现其大写开头的形式。

                使用当前窗口的拼写信息。<a href="options.html#'spell'">'spell'</a> 选项必须置位，也用到
                <a href="options.html#'spelllang'">'spelllang'</a> 和 <a href="options.html#'spellsuggest'">'spellsuggest'</a> 的值。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWord()-&gt;spellsuggest()</code>
<code class="example"></code>
split(<code class="special">{expr}</code> [, <code class="special">{pattern}</code> [, <code class="special">{keepempty}</code>]])                     <b class="vimtag"> <a name="split()">split()</a> </b>
                从 <code class="special">{expr}</code> 构造  <a href="eval.html#List">List</a> 。
                如果 <code class="special">{pattern}</code> 省略或为空，用每个空白分隔的字符序列构造一个项
                目。否则，在匹配 <code class="special">{pattern}</code> 的地方分割字符串，删除匹配部分的字
                符。<a href="options.html#'ignorecase'">'ignorecase'</a> 此处不适用，要忽略大小写，加上 \c。 <a href="pattern.html#%2F\c">/\c</a> 
                如果列表的首末项目为空，省略它们，除非 <code class="special">{keepempty}</code> 参数给出且
                非零。其它空项目在 <code class="special">{pattern}</code> 匹配至少一个字符或者 <code class="special">{keepempty}</code>
                非零的时候被保留。
                例如: 
<code class="example">                        :let words = split(getline('.'), '\W\+')</code>
                要把字符串分割到每个字符: 
<code class="example">                        :for c in split(mystring, '\zs')</code>
                如果你想保留分隔符，可以在模式尾部用 '\zs': 
<code class="example">                        :echo split('abc:def:ghi', ':\zs')</code>
<code class="section">                        ['abc:', 'def:', <code class="badlink">'ghi'</code>] </code>
                分割首项可能为空的表格: 
<code class="example">                        :let items = split(line, ':', 1)</code>
                逆函数是  <a href="eval.html#join()">join()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;split()</code>
<code class="example"></code>
sqrt(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="sqrt()">sqrt()</a> </b>
                返回浮点数，即 <code class="special">{expr}</code> 的非负平方根。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。如果 <code class="special">{expr}</code> 为负，返回
                NaN (Not a Number，非数)。
                示例: 
<code class="example">                        :echo sqrt(100)</code>
                        10.0 
<code class="example">                        :echo sqrt(-4.01)</code>
                        nan
                "nan" 可能不同，取决于系统库。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;sqrt()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


srand([<code class="special">{expr}</code>])                                         <b class="vimtag"> <a name="srand()">srand()</a> </b>
                初始化  <a href="eval.html#rand()">rand()</a>  用的种子:
                - 如果没给出 <code class="special">{expr}</code>，如果可以，读取 /dev/urandom 并用作种子,
                  否则，用 time(NULL) 也就是 epoch 时间；后者只有秒级精确度。
                - <code class="special">{expr}</code> 给出时必须是数值。用于初始种子值。可用于测试或需要可
                  预测序列的场合。

                示例: 
<code class="example">                        :let seed = srand()</code>
<code class="example">                        :let seed = srand(userinput)</code>
<code class="example">                        :echo rand(seed)</code>
<code class="example"></code>
state([<code class="special">{what}</code>])                                         <b class="vimtag"> <a name="state()">state()</a> </b>
                返回字符串，包含指示当前状态的字符。主要用于要做一些可能不总是
                安全的操作的回调。大致上，做的事是:
                - 回调使用 state() 检查工作是否安全。
                  是:  马上开始做。
                  否:  加入工作队列，新增  <a href="autocmd.html#SafeState">SafeState</a>  和/或  <a href="autocmd.html#SafeStateAgain">SafeStateAgain</a> 
                       自动命令 ( <a href="autocmd.html#SafeState">SafeState</a>  在顶层触发， <a href="autocmd.html#SafeStateAgain">SafeStateAgain</a>  在处
                       理完信息和回调后触发)。
                - SafeState 或 SafeStateAgain 触发时执行你的自动命令，检查
                   <a href="eval.html#state()">state()</a>  看看工作现在是否可以了，如果是的话从队列中删除之并
                  执行，如果队列为空也删除自动命令。
                另见  <a href="eval.html#mode()">mode()</a> 。

                <code class="special">{what}</code> 给出时只加入此字符串中的字符。例如，下例检查屏幕是否有
                滚动: 
<code class="example">                        if state('s') == ''</code>
<code class="example">                           " 屏幕还未滚动</code>

                这些字符指示状态，一般而言指示有东西在忙:
                    m   映射、:normal 命令、feedkeys() 或庞大的命令进行到中途
                        时
                    o   操作符等待状态或命令行等待参数输入时，如  <a href="motion.html#f">f</a>  之后
                    a   插入模式自动补全激活时
                    x   执行自动命令时
                    w   处于阻塞等待时，如 ch_evalexpr()、ch_read() 或
                        ch_readraw() 读入 json 时。
                    S   不触发 SafeState 或 SafeStateAgain
                    c   调用了包括定时器在内的回调 (递归时会重复，多至 "ccc")
                    s   屏幕已经为消息滚动过

str2float(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="str2float()">str2float()</a> </b>
                把字符串 <code class="special">{expr}</code> 转换为浮点数。这和使用浮点数的工作方式一样，见
                 <a href="eval.html#floating-point-format">floating-point-format</a> ，但稍稍宽松一点。例如，接受 "1e40"，而
                表达式中你必须书写 "1.0e40"。也接受十六进制形式 "0x123"，但其
                它的如二进制或八进制不行。
                安静地忽略数值之后的文本。
                小数点必须是 '.'，和当前的 locale 无关。逗号会使数值转换结束:
                "12,345.67" 转换为 12.0。用  <a href="eval.html#substitute()">substitute()</a>  可以拿掉千分位分
                隔符: 
<code class="example">                        let f = str2float(substitute(text, ',', '', 'g'))</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        let f = text-&gt;substitute(',', '', 'g')-&gt;str2float()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

str2list(<code class="special">{expr}</code> [, <code class="special">{utf8}</code>])                             <b class="vimtag"> <a name="str2list()">str2list()</a> </b>
                返回包含代表字符串 <code class="special">{expr}</code> 中的每个字符数值的列表。例如: 
<code class="example">                        str2list(" ")           返回 [32]</code>
<code class="example">                        str2list("ABC")         返回 [65, 66, 67]</code>
                 <a href="eval.html#list2str()">list2str()</a>  是逆操作。

                <code class="special">{utf8}</code> 省略或为零时，使用当前 <a href="options.html#'encoding'">'encoding'</a>。
                <code class="special">{utf8}</code> 为 1 时，总是把字符串当作 utf-8 字符。
                使用 utf-8 时，组合字符正常工作: 
<code class="example">                        str2list("aÌ")         返回 [97, 769]</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;str2list()</code>
<code class="example"></code>
str2nr(<code class="special">{expr}</code> [, <code class="special">{base}</code> [, <code class="special">{quoted}</code>]])                          <b class="vimtag"> <a name="str2nr()">str2nr()</a> </b>
                把字符串 <code class="special">{expr}</code> 转化为数值。
                <code class="special">{base}</code> 是转换的基底，可以为 2、8、10 或 16。
                给出 <code class="special">{quoted}</code> 且非零时，忽略内嵌的单引号，所以 "1<code class="badlink">'000'</code>000" 是
                一百万。

                如果省略 <code class="special">{base}</code>，使用基底 10。这也意味着开头的零不会导致八进制
                的转换，缺省的字符串到数值的转化并非如此。例如: 
<code class="example">                        let nr = str2nr('0123')</code>

                如果 <code class="special">{base}</code> 为 16，忽略开头的 "0x" 或 "0X"。如果使用别的基底，
                返回零。类似的，如果 <code class="special">{base}</code> 为 8，忽略开头的 "0"，如果 <code class="special">{base}</code>
                为 2，忽略开头的 "0b" 或 "0B"。
                安静地忽略数值之后的文本。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;str2nr()</code>
<code class="example"></code>
strcharpart(<code class="special">{src}</code>, <code class="special">{start}</code> [, <code class="special">{len}</code>])                   <b class="vimtag"> <a name="strcharpart()">strcharpart()</a> </b>
                和  <a href="eval.html#strpart()">strpart()</a>  类似，但用字符索引和长度而不是字节索引和长度。
                使用字符索引时如果字符不存在，假定有一个字符存在。例如: 
<code class="example">                        strcharpart('abc', -1, 2)</code>
                返回 'a'。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;strcharpart(5)</code>
<code class="example"></code>
strchars(<code class="special">{expr}</code> [, <code class="special">{skipcc}</code>])                                   <b class="vimtag"> <a name="strchars()">strchars()</a> </b>
                返回数值，给出字符串 <code class="special">{expr}</code> 中的字符数。
                <code class="special">{skipcc}</code> 省略或为零时，组合字符也算一个字符。
                <code class="special">{skipcc}</code> 设为 1 时，计算时忽略组合字符。
                另见  <a href="eval.html#strlen()">strlen()</a> 、 <a href="eval.html#strdisplaywidth()">strdisplaywidth()</a>  和  <a href="eval.html#strwidth()">strwidth()</a> 。

                <code class="special">{skipcc}</code> 只在 7.4.755 之后才出现。为了后向兼容，可以这样定义
                包装函数: 
<code class="example">                    if has("patch-7.4.755")</code>
<code class="example">                      function s:strchars(str, skipcc)</code>
<code class="example">                        return strchars(a:str, a:skipcc)</code>
<code class="example">                      endfunction</code>
<code class="example">                    else</code>
<code class="example">                      function s:strchars(str, skipcc)</code>
<code class="example">                        if a:skipcc</code>
<code class="example">                          return strlen(substitute(a:str, ".", "x", "g"))</code>
<code class="example">                        else</code>
<code class="example">                          return strchars(a:str)</code>
<code class="example">                        endif</code>
<code class="example">                      endfunction</code>
<code class="example">                    endif</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;strchars()</code>
<code class="example"></code>
strdisplaywidth(<code class="special">{expr}</code> [, <code class="special">{col}</code>])                       <b class="vimtag"> <a name="strdisplaywidth()">strdisplaywidth()</a> </b>
                返回数值，给出字符串 <code class="special">{expr}</code> 在 <code class="special">{col}</code> 开始时在屏幕上占据的显示
                单元的数目 (首列为零)。<code class="special">{col}</code> 省略时假定为零。否则给出开始计算
                的屏幕列号。该值对制表符的计算有影响。
                使用当前窗口的选项设置。其中影响显示的选项也对返回值有影响，如
                <a href="options.html#'tabstop'">'tabstop'</a> 和 <a href="options.html#'display'">'display'</a>。
                <code class="special">{expr}</code> 如包含东亚二义性宽度字符类，<a href="options.html#'ambiwidth'">'ambiwidth'</a> 也会影响返回结
                果。
                另见  <a href="eval.html#strlen()">strlen()</a> 、 <a href="eval.html#strwidth()">strwidth()</a>  和  <a href="eval.html#strchars()">strchars()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;strdisplaywidth()</code>
<code class="example"></code>
strftime(<code class="special">{format}</code> [, <code class="special">{time}</code>])                           <b class="vimtag"> <a name="strftime()">strftime()</a> </b>
                返回字符串，即经过 <code class="special">{format}</code> 字符串的格式转换的日期和时间。使用
                给定的 <code class="special">{time}</code>，如果没有给出时间，使用当前时间。可以接受的
                <code class="special">{format}</code> 取决于你的系统。这意味着该函数不是可移植的！
                可用的格式参见 C 函数 strftime() 的参考手册。返回结果的最大长
                度是 80 个字符。另见  <a href="eval.html#localtime()">localtime()</a> 、 <a href="eval.html#getftime()">getftime()</a>  和
                 <a href="eval.html#strptime()">strptime()</a> 。
                可以用  <a href="mlang.html#:language">:language</a>  命令改变语言。
                示例: 
<code class="example">                  :echo strftime("%c")             Sun Apr 27 11:49:23 1997</code>
<code class="example">                  :echo strftime("%Y %b %d %X")    1997 Apr 27 11:53:25</code>
<code class="example">                  :echo strftime("%y%m%d %T")      970427 11:53:55</code>
<code class="example">                  :echo strftime("%H:%M")          11:55</code>
<code class="example">                  :echo strftime("%c", getftime("file.c"))</code>
<code class="example">                                                   显示 file.c 的修改时间。</code>
                并非所有系统都可以用。要检查这一点，用: 
<code class="example">                        :if exists("*strftime")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFormat()-&gt;strftime()</code>
<code class="example"></code>
strgetchar(<code class="special">{str}</code>, <code class="special">{index}</code>)                              <b class="vimtag"> <a name="strgetchar()">strgetchar()</a> </b>
                获取 <code class="special">{str}</code> 中的第 <code class="special">{index}</code> 个字符。使用字符索引而不是字节索引。
                这里，组合字符当作单独的字符。
                另见  <a href="eval.html#strcharpart()">strcharpart()</a>  和  <a href="eval.html#strchars()">strchars()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;strgetchar(5)</code>
<code class="example"></code>
stridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])                <b class="vimtag"> <a name="stridx()">stridx()</a> </b>
                返回数值，给出字符串 <code class="special">{haystack}</code> 里第一个字符串 <code class="special">{needle}</code> 出现的
                字节位置。
                如果给出 <code class="special">{start}</code>，搜索从 <code class="special">{start}</code> 位置开始。可用来寻找第二个匹
                配: 
<code class="example">                        :let colon1 = stridx(line, ":")</code>
<code class="example">                        :let colon2 = stridx(line, ":", colon1 + 1)</code>
                搜索对大小写敏感。
                模式搜索可用  <a href="eval.html#match()">match()</a> 。
                如果 <code class="special">{needle}</code> 不出现在 <code class="special">{haystack}</code> 里，返回 -1。
                另见  <a href="eval.html#strridx()">strridx()</a> 。示例: 
<code class="example">                  :echo stridx("An Example", "Example")      3</code>
<code class="example">                  :echo stridx("Starting point", "Start")    0</code>
<code class="example">                  :echo stridx("Starting point", "start")   -1</code>
                                                <b class="vimtag"> <a name="strstr()">strstr()</a> </b> <b class="vimtag"> <a name="strchr()">strchr()</a> </b>
                stridx() 和 C 函数 strstr() 类似。如果使用单个字符，和
                strchr() 类似。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetHaystack()-&gt;stridx(needle)</code>

                                                        <b class="vimtag"> <a name="string()">string()</a> </b>
string(<code class="special">{expr}</code>)  返回 <code class="special">{expr}</code> 转换后的字符串。如果 <code class="special">{expr}</code> 为数值、浮点数、字符
                串、blob 或它们的复合形式，那么用  <a href="eval.html#eval()">eval()</a>  可以把结果转回去。
<code class="section">                        <code class="special">{expr}</code> 类型     返回值 </code>
                        字符串          <code class="badlink">'string'</code> (单引号加倍)
                        数值            123
                        浮点数          123.123456 或 1.23456e8
                        函数引用        function(<code class="badlink">'name'</code>)
                        blob            0z00112233.44556677.8899
                        列表            [item, item]
                        字典            {key: value, key: value}

                列表或字典中如有递归引用，被替换为 "[...]" 或 "<code class="special">{...}</code>"。在此结
                果上运行 eval() 会出错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;string()</code>
<code class="example"></code>
                另见  <a href="eval.html#strtrans()">strtrans()</a> 。

                                                        <b class="vimtag"> <a name="strlen()">strlen()</a> </b>
strlen(<code class="special">{expr}</code>)  返回数值，即字符串 <code class="special">{expr}</code> 的字节长度。
                如果参数为数值，先把它转化为字符串。其它类型报错。
                要计算多字节字符的数目，可用  <a href="eval.html#strchars()">strchars()</a> 。
                另见  <a href="eval.html#len()">len()</a> 、 <a href="eval.html#strdisplaywidth()">strdisplaywidth()</a>  和  <a href="eval.html#strwidth()">strwidth()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;strlen()</code>
<code class="example"></code>
strpart(<code class="special">{src}</code>, <code class="special">{start}</code> [, <code class="special">{len}</code>])                       <b class="vimtag"> <a name="strpart()">strpart()</a> </b>
                返回字符串，<code class="special">{src}</code> 从第 <code class="special">{start}</code> 个字节开始字节长度为 <code class="special">{len}</code> 的子
                串。
                要以字符而不是字节计算，用  <a href="eval.html#strcharpart()">strcharpart()</a> 。

                如果选择不存在的字节，不会产生错误。只是那些字节被忽略而已。
                如果没有提供 <code class="special">{len}</code>，子串从 <code class="special">{start}</code> 开始直到 <code class="special">{src}</code> 的结尾。 
<code class="example">                        strpart("abcdefg", 3, 2)    == "de"</code>
<code class="example">                        strpart("abcdefg", -2, 4)   == "ab"</code>
<code class="example">                        strpart("abcdefg", 5, 4)    == "fg"</code>
<code class="example">                        strpart("abcdefg", 3)       == "defg"</code>
<code class="example"></code>
                <code class="note">注意</code>: 要得到第一个字符，<code class="special">{start}</code> 必须是零。比如，要得到光标开始
                的三个字节: 
<code class="example">                        strpart(getline("."), col(".") - 1, 3)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;strpart(5)</code>
<code class="example"></code>
strptime(<code class="special">{format}</code>, <code class="special">{timestring}</code>)                                <b class="vimtag"> <a name="strptime()">strptime()</a> </b>
                返回数值，代表期待能匹配 <code class="special">{format}</code> 指定格式的 <code class="special">{timestring}</code> 中的
                日期和时间的 unix 时间戳。

                可接受的 <code class="special">{format}</code> 取决于系统，所以不可移植！具体格式见 C 函数
                strptime() 的手册页。特别要<code class="note">注意</code>避免 "%c"。$TZ 的值也相关。

                如果 <code class="special">{timestring}</code> 不能用 <code class="special">{format}</code> 格式解析，返回零。如果不知道
                <code class="special">{timestring}</code> 的格式，可以尝试不同的 <code class="special">{format}</code> 值直到返回非零值
                为止。

                另见  <a href="eval.html#strftime()">strftime()</a> 。
                示例: 
<code class="example">                  :echo strptime("%Y %b %d %X", "1997 Apr 27 11:49:23")</code>
                  862156163 
<code class="example">                  :echo strftime("%c", strptime("%y%m%d %T", "970427 11:53:55"))</code>
                  Sun Apr 27 11:53:55 1997 
<code class="example">                  :echo strftime("%c", strptime("%Y%m%d%H%M%S", "19970427115355") + 3600)</code>
                  Sun Apr 27 12:53:55 1997

                不是在所有系统都可用。要确认: 
<code class="example">                        :if exists("*strptime")</code>
<code class="example"></code>
<code class="example"></code>
strridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])                       <b class="vimtag"> <a name="strridx()">strridx()</a> </b>
                返回数值，给出字符串 <code class="special">{haystack}</code> 里最后一个字符串 <code class="special">{needle}</code> 出现
                的字节位置。
                如果给出 <code class="special">{start}</code>，此位置之外的匹配被忽略。可用来寻找上次匹配之
                前的匹配: 
<code class="example">                        :let lastcomma = strridx(line, ",")</code>
<code class="example">                        :let comma2 = strridx(line, ",", lastcomma - 1)</code>
                搜索对大小写敏感。
                模式搜索可用  <a href="eval.html#match()">match()</a> 。
                如果 <code class="special">{needle}</code> 不出现在 <code class="special">{haystack}</code> 里，返回 -1。
                如果 <code class="special">{needle}</code> 为空，返回 <code class="special">{haystack}</code> 的长度。
                另见  <a href="eval.html#stridx()">stridx()</a> 。示例: 
<code class="example">                  :echo strridx("an angry armadillo", "an")          3</code>
                                                        <b class="vimtag"> <a name="strrchr()">strrchr()</a> </b>
                如果使用单个字符，和 C 函数 strrchr() 类似。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetHaystack()-&gt;strridx(needle)</code>
<code class="example"></code>
strtrans(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="strtrans()">strtrans()</a> </b>
                返回等于 <code class="special">{expr}</code> 的字符串，但所有的不可显示字符被翻译成可显示的
                字符序列  <a href="options.html#'isprint'">'isprint'</a> ，类似于窗口里显示的形式。例如: 
<code class="example">                        echo strtrans(@a)</code>
                会显示寄存器里的换行符为 "^@" 而不是开启新行。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;strtrans()</code>
<code class="example"></code>
strwidth(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="strwidth()">strwidth()</a> </b>
                返回数值，给出字符串 <code class="special">{expr}</code> 在屏幕上占据的显示单元的数目。制表
                符算作一个单元。如果不想这样，可用  <a href="eval.html#strdisplaywidth()">strdisplaywidth()</a> 。
                <code class="special">{expr}</code> 如包含东亚二义性宽度字符类，<a href="options.html#'ambiwidth'">'ambiwidth'</a> 也会影响返回结
                果。
                另见  <a href="eval.html#strlen()">strlen()</a> 、 <a href="eval.html#strdisplaywidth()">strdisplaywidth()</a>  和  <a href="eval.html#strchars()">strchars()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;strwidth()</code>
<code class="example"></code>
submatch(<code class="special">{nr}</code> [, <code class="special">{list}</code>])                       <b class="vimtag"> <a name="submatch()">submatch()</a> </b> <b class="vimtag"> <a name="E935">E935</a> </b>
                只用于  <a href="change.html#:substitute">:substitute</a>  命令或 substitute() 函数中的表达式内。
                返回匹配文本的第 <code class="special">{nr}</code> 个子匹配。<code class="special">{nr}</code> 为 0 则返回整个匹配的文
                本。
                <code class="note">注意</code> 字符串中的 NL 既可以代表多行匹配的行尾，也可以是文件中的
                NUL 字符。
                另见  <a href="change.html#sub-replace-expression">sub-replace-expression</a> 。

                如果给出 <code class="special">{list}</code> 且非零，submatch() 返回字符串的列表，和带两个
                参数的  <a href="eval.html#getline()">getline()</a>  类似。文本中的 NL 代表文件中的 NUL 字符。
                只在  <a href="change.html#:substitute">:substitute</a>  中可能返回多于一个项目， <a href="eval.html#substitute()">substitute()</a>  中此
                列表总是包含一个或零个项目，因为没有真正的行尾。

                递归使用 substitute() 时，只能得到当前 (最深的) 调用的子匹配。

                例如: 
<code class="example">                        :s/\d\+/\=submatch(0) + 1/</code>
<code class="example">                        :echo substitute(text, '\d\+', '\=submatch(0) + 1', '')</code>
                找到行内第一个数值并加 1。
                使用 <code class="special">&lt;NL&gt;</code> 可以包含换行符。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetNr()-&gt;submatch()</code>
<code class="example"></code>
substitute(<code class="special">{expr}</code>, <code class="special">{pat}</code>, <code class="special">{sub}</code>, <code class="special">{flags}</code>)               <b class="vimtag"> <a name="substitute()">substitute()</a> </b>
                返回相当于 <code class="special">{expr}</code> 的字符串，但其中 <code class="special">{pat}</code> 的首个匹配被替代成
                <code class="special">{sub}</code>。
                如果 <code class="special">{flags}</code> 为 "g"，替换 <code class="special">{expr}</code> 里的所有 <code class="special">{pat}</code> 匹配。否则，
                <code class="special">{flags}</code> 应该为 ""。

                和 ":substitute" 命令 (不带任何标志位) 类似。但此处 <code class="special">{pat}</code> 的匹
                配总假定 <a href="options.html#'magic'">'magic'</a> 选项已置位且 <a href="options.html#'cpoptions'">'cpoptions'</a> 为空 (为了脚本的可移
                植性)。
                <a href="options.html#'ignorecase'">'ignorecase'</a> 仍然适用， <a href="pattern.html#%2F\c">/\c</a>  或  <a href="pattern.html#%2F\C">/\C</a>  可用来直接指定是否忽略或
                匹配大小写并忽略 <a href="options.html#'ignorecase'">'ignorecase'</a> 的设置。
                <a href="options.html#'smartcase'">'smartcase'</a> 此处不适用。
                 <a href="eval.html#string-match">string-match</a>  说明如何使用 <code class="special">{pat}</code>。

                <code class="special">{sub}</code> 里的 '~' 不会被换成前一个 <code class="special">{sub}</code>。
                <code class="note">注意</code> <code class="special">{sub}</code> 里的一些代码有特殊含义  <a href="change.html#sub-replace-special">sub-replace-special</a> 。比
                如，要替换若干文本为 "\n" (两个字符)，要用 "\\\\n" 或 '\\n'。

                如果 <code class="special">{pat}</code> 在 <code class="special">{expr}</code> 里不能匹配，返回没有修改的 <code class="special">{expr}</code>。

                示例: 
<code class="example">                   :let &amp;path = substitute(&amp;path, ",\\=[^,]*$", "", "")</code>
                删除 <a href="options.html#'path'">'path'</a> 选项的最后一部分。 
<code class="example">                   :echo substitute("testing", ".*", "\\U\\0", "")</code>
                返回 "TESTING"。

                <code class="special">{sub}</code> 参数以 \= 开始时，其余部分视为一个表达式，见
                 <a href="change.html#sub-replace-expression">sub-replace-expression</a> 。示例: 
<code class="example">                   :echo substitute(s, '%\(\x\x\)',</code>
<code class="example">                           \ '\=nr2char("0x" . submatch(1))', 'g')</code>
<code class="example"></code>
                <code class="special">{sub}</code> 若是函数引用，调用该函数，带一个可选参数。示例: 
<code class="example">                   :echo substitute(s, '%\(\x\x\)', SubNr, 'g')</code>
                可选参数是包含完整匹配及多达九个子匹配的列表，就像
                 <a href="eval.html#submatch()">submatch()</a>  的返回值那样。示例: 
<code class="example">                   :echo substitute(s, '%\(\x\x\)', {m -&gt; '0x' . m[1]}, 'g')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetString()-&gt;substitute(pat, sub, flags)</code>
<code class="example"></code>
swapinfo(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="swapinfo()">swapinfo()</a> </b>
                返回字曲，保存关于交换文件 <code class="special">{fname}</code> 的信息。可用的域是:
                        version Vim 版本
                        user    用户名
                        host    主机名
                        fname   原始文件名
                        pid     创建交换文件的 Vim 进程的 PID
                        mtime   以秒计的最近修改时间
                        inode   可选: 文件的 INODE 值
                        dirty   如果文件修改过为 1，否则为 0
                <code class="note">注意</code> "user" 和 "host" 被缩短为最多 39 个字节。如果失败，加入
                "error" 项目说明相关原因:
                        Cannot open file: 文件找不到或不能访问
                        Cannot read file: 不能读入首块
                        Not a swap file: 没有包含正确的块 ID
                        Magic number mismatch: 首块的信息不正确

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;swapinfo()</code>
<code class="example"></code>
swapname(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="swapname()">swapname()</a> </b>
                返回缓冲区 <code class="special">{expr}</code> 所用的交换文件路径。
                <code class="special">{expr}</code> 的使用方式见上  <a href="eval.html#bufname()">bufname()</a> 。
                如果缓冲区 <code class="special">{expr}</code> 是当前缓冲区，结果相当于  <a href="recover.html#:swapname">:swapname</a>  (除非没
                有交换文件)。
                如果缓冲区 <code class="special">{expr}</code> 无交换文件，返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufname()-&gt;swapname()</code>
<code class="example"></code>
synID(<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{trans}</code>)                           <b class="vimtag"> <a name="synID()">synID()</a> </b>
                返回数值，即当前窗口 <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列所在的语法 ID。
                语法 ID  可以用在  <a href="eval.html#synIDattr()">synIDattr()</a>  和  <a href="eval.html#synIDtrans()">synIDtrans()</a> ，以得到文本
                的语法信息。

                最左列的 <code class="special">{col}</code> 为 1。第一行的 <code class="special">{lnum}</code> 为 1。适用 <a href="options.html#'synmaxcol'">'synmaxcol'</a> 的
                值，如果行比它更长，就返回零。
                <code class="note">注意</code> 位置在最后一个字符之后是插入模式下可能的光标位置。此时，
                synID() 返回零。

                如果 <code class="special">{trans}</code> 为  <a href="eval.html#TRUE">TRUE</a> ，透明的项目被简约为它们实际显露的项目。
                这可以用于你想知道实际使用的颜色的情形。如果 <code class="special">{trans}</code> 为
                 <a href="eval.html#FALSE">FALSE</a> ，返回透明的项目本身。这可用于想知道实际有效的语法项目
                的情形 (比如，在括号内部)。
                警告: 本函数可能很慢。最佳速度可以通过正向遍历文件获得。

                例如 (回显光标所在的语法项目的名字): 
<code class="example">                        :echo synIDattr(synID(line("."), col("."), 1), "name")</code>


synIDattr(<code class="special">{synID}</code>, <code class="special">{what}</code> [, <code class="special">{mode}</code>])                   <b class="vimtag"> <a name="synIDattr()">synIDattr()</a> </b>
                返回字符串，syntax ID <code class="special">{synID}</code> 的 <code class="special">{what}</code> 属性。可用于得到语法项
                目的相关信息。
                <code class="special">{mode}</code> 可以是 "gui"、"cterm" 或 "term"，从而得到的是该模式下的
                属性。如果忽略 <code class="special">{mode}</code> 或者指定了非法的值，使用当前激活的高亮方
                式的属性 (GUI、cterm 或 term)。
                使用 synIDtrans() 来跟随链接的高亮组。
<code class="section">                <code class="special">{what}</code>          结果 </code>
                "name"          语法项目的名字
                "fg"            前景色 (GUI: 用于设置颜色的色彩名，cterm: 色彩
                                号，以字符串形式出现，term: 空字符串)
                "bg"            背景色 (细节同 "fg")
                "font"          字体名 (只适用于 GUI)  <a href="syntax.html#highlight-font">highlight-font</a> 
                "sp"            特殊颜色 (细节同 "fg")  <a href="syntax.html#highlight-guisp">highlight-guisp</a> 
                "fg#"           类似于 "fg"，但只适用于 GUI，而且 GUI 使用的名
                                字形如 "#RRGGBB"。
                "bg#"           "bg"，细节同 "fg#"
                "sp#"           "sp"，细节同 "fg#"
                "bold"          "1" 如果粗体
                "italic"        "1" 如果斜体
                "reverse"       "1" 如果反显
                "inverse"       "1" 如果反显 (= reverse)
                "standout"      "1" 如果突出
                "underline"     "1" 如果下划线
                "undercurl"     "1" 如果下曲线
                "strike"        "1" 如果删除线

                示例 (回显光标所在的语法项目的颜色): 
<code class="example">        :echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">        :echo synID(line("."), col("."), 1)-&gt;synIDtrans()-&gt;synIDattr("fg")</code>
<code class="example"></code>
<code class="example"></code>
synIDtrans(<code class="special">{synID}</code>)                                     <b class="vimtag"> <a name="synIDtrans()">synIDtrans()</a> </b>
                返回数值，即 <code class="special">{synID}</code> 经过翻译的语法 ID。这是用于高亮字符的语法
                组的 ID。":highlight link" 给出的高亮组被跟随，以找到实际使用
                的组。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">        :echo synID(line("."), col("."), 1)-&gt;synIDtrans()-&gt;synIDattr("fg")</code>
<code class="example"></code>
synconcealed(<code class="special">{lnum}</code>, <code class="special">{col}</code>)                             <b class="vimtag"> <a name="synconcealed()">synconcealed()</a> </b>
                返回列表，目前包含三个值:
                1. 如果 <code class="special">{lnum}</code> 和 <code class="special">{col}</code> 所在位置的字符不在可隐藏区域，列表的第
                   一个项目为 0，否则为 1。
                2. 列表的第二个项目为字符串。如果第一个值为 1，第二个值包含代
                   替被隐藏文本实际显示的文本，视乎 <a href="options.html#'conceallevel'">'conceallevel'</a> 和
                   <a href="options.html#'listchars'">'listchars'</a> 的当前值而定。
                3. 列表的第三个，也即最后一个项目是代表匹配的特定语法区域的唯
                   一的数值。这用于在有两个连续的使用相同替代字符的区域时，检
                   测此处是否是一个新的可隐藏区域的开始。例如，如果文本是
                   "123456"，"23" 和 "45" 都被隐藏，而替代字符是 "X"，则:
<code class="section">                        call                    returns </code>
                        synconcealed(lnum, 1)   [0, '', 0]
                        synconcealed(lnum, 2)   [1, 'X', 1]
                        synconcealed(lnum, 3)   [1, 'X', 1]
                        synconcealed(lnum, 4)   [1, 'X', 2]
                        synconcealed(lnum, 5)   [1, 'X', 2]
                        synconcealed(lnum, 6)   [0, '', 0]


synstack(<code class="special">{lnum}</code>, <code class="special">{col}</code>)                                 <b class="vimtag"> <a name="synstack()">synstack()</a> </b>
                返回  <a href="eval.html#List">List</a> ，即当前窗口在 <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列语法项目的堆栈。列
                表的每个项目是像  <a href="eval.html#synID()">synID()</a>  返回那样的 ID。
                列表的第一个项目是最外层区域，其后依次是包含在内的项目。末项即
                 <a href="eval.html#synID()">synID()</a>  返回的项目，除非不是整个项目都被高亮，或者它是一个透
                明项目。
                此函数可用于调试语法文件。
                显示光标所在的语法项目栈的示例: 
<code class="example">                        for id in synstack(line("."), col("."))</code>
<code class="example">                           echo synIDattr(id, "name")</code>
<code class="example">                        endfor</code>
                如果 <code class="special">{lnum}</code> 和 <code class="special">{col}</code> 指定的位置非法，不返回任何值。行末字符之
                后的位置以及空行的第一个位置是合法的位置。

system(<code class="special">{expr}</code> [, <code class="special">{input}</code>])                              <b class="vimtag"> <a name="system()">system()</a> </b> <b class="vimtag"> <a name="E677">E677</a> </b>
                得到外壳命令 <code class="special">{expr}</code> 字符串形式的输出结果。要得到列表形式的输出
                结果，见  <a href="eval.html#systemlist()">systemlist()</a> 。

                如果给出 <code class="special">{input}</code> 且为字符串，该字符串被写到文件里，并传给外壳
                命令作为标准输入。字符串照原样写入，你需要自己<code class="note">注意</code>使用合适的换
                行符。
                如果给出 <code class="special">{input}</code> 且为  <a href="eval.html#List">List</a> ，它被写到文件里，就像
                 <a href="eval.html#writefile()">writefile()</a>  带 <code class="special">{binary}</code> 设为 "b" 的工作方式那样 (即，列表项
                目间写入换行符，列表项目内部的换行符改写为 NUL)。
                如果给出 <code class="special">{input}</code> 且为数值，代表已存在的缓冲区的合法缓冲区号，
                逐行将该缓冲区的内容写入文件，每行以 NL 结尾，文本内的 NL 以
                NUL 字符代替。

                不使用管道，也不使用 <a href="options.html#'shelltemp'">'shelltemp'</a> 选项。

                如果加上前缀  <a href="various.html#:silent">:silent</a> ，终端不设为加工 (cooked) 模式。这用于不
                需要用户输入的命令，以避免屏幕上显示多余的字符而需要用
                 <a href="various.html#CTRL-L">CTRL-L</a>  来清除。 
<code class="example">                        :silent let f = system('ls *.vim')</code>

                <code class="note">注意</code>:  <a href="eval.html#shellescape()">shellescape()</a>  或  <a href="eval.html#expand()">expand()</a>  的  <a href="cmdline.html#::S">::S</a>  或
                 <a href="eval.html#fnamemodify()">fnamemodify()</a>  可以转义命令参数里的特殊字符。<code class="special">{expr}</code> 里的换行
                可能会使命令失败。<a href="options.html#'shellquote'">'shellquote'</a> 和 <a href="options.html#'shellxquote'">'shellxquote'</a> 里的字符也可能
                会引起麻烦。
                这不是用来执行交互命令的。

                返回字符串。示例: 
<code class="example">                    :let files = system("ls " .  shellescape(expand('%:h')))</code>
<code class="example">                    :let files = system('ls ' . expand('%:h:S'))</code>
<code class="example"></code>
                要使结果更独立于所用的系统，外壳输出的结果被过滤，Macintosh 的
                <code class="special">&lt;CR&gt;</code> 被换成 <code class="special">&lt;NL&gt;</code>，而 DOS 系列的系统上 <code class="special">&lt;CR&gt;</code><code class="special">&lt;NL&gt;</code> 也被换成 <code class="special">&lt;NL&gt;</code>。
                为了避免字符串在 NUL 处被截断，所有的 NUL 的字符被替换为 SOH
                (0x01)。

                使用若干选项，以下面的方法构造要执行的命令:
        <a href="options.html#'shell'">'shell'</a> <a href="options.html#'shellcmdflag'">'shellcmdflag'</a> <a href="options.html#'shellxquote'">'shellxquote'</a> <code class="special">{expr}</code> <a href="options.html#'shellredir'">'shellredir'</a> <code class="special">{tmp}</code> <a href="options.html#'shellxquote'">'shellxquote'</a>
                (<code class="special">{tmp}</code> 是自动生成的一个文件名)。
                Unix 上，<code class="special">{expr}</code> 用大括号包围，以便支持连接的多条命令。

                以加工 ("cooked") 模式执行命令，这样 <code class="keystroke">CTRL-C</code> 可以用来中止命令
                (至少在 Unix 上是如此)。

                返回的错误代码可以在  <a href="eval.html#v:shell_error">v:shell_error</a>  里找到。
                该函数不能运行于  <a href="starting.html#restricted-mode">restricted-mode</a> 。

                <code class="note">注意</code> 上面提到的选项值如有错误，该函数就会失败。使用若干安全代
                理应用时也有报告说它会失败。
                不同于 ":!cmd"，没有自动对改变过的文件的检查。使用
                 <a href="editing.html#:checktime">:checktime</a>  来强制这种检查。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :echo GetCmd()-&gt;system()</code>
<code class="example"></code>
<code class="example"></code>
systemlist(<code class="special">{expr}</code> [, <code class="special">{input}</code>])                          <b class="vimtag"> <a name="systemlist()">systemlist()</a> </b>
                和  <a href="eval.html#system()">system()</a>  相同，但返回由行组成的  <a href="eval.html#List">List</a>  (以 NL 分隔的输出
                各部分)，NUL 转换为 NL。输出的工作方式和  <a href="eval.html#readfile()">readfile()</a>  带
                <code class="special">{binary}</code> 参数设为 "b" 相同，除了结果以 NL 结尾时不会有额外的空
                项目以外。
                <code class="note">注意</code> MS-Windows 上可能会有拖尾的 CR 字符。

                要看到 "echo hello" 和 "echo -n hello" 的区别，参见  <a href="eval.html#system()">system()</a> 
                和  <a href="eval.html#split()">split()</a> : 
<code class="example">                        echo system('echo hello')-&gt;split('\n', 1)</code>

                有错时，返回空串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :echo GetCmd()-&gt;systemlist()</code>
<code class="example"></code>
<code class="example"></code>
tabpagebuflist([<code class="special">{arg}</code>])                                 <b class="vimtag"> <a name="tabpagebuflist()">tabpagebuflist()</a> </b>
                返回  <a href="eval.html#List">List</a> ，每个项目是当前标签页里每个窗口相关联的缓冲区的编
                号。
                <code class="special">{arg}</code> 指定使用的标签页的编号。如果省略，使用当前标签页。
                如果 <code class="special">{arg}</code> 非法，返回数值零。
                要得到所有标签页里的所有缓冲区的列表，这样用: 
<code class="example">                        let buflist = []</code>
<code class="example">                        for i in range(tabpagenr('$'))</code>
<code class="example">                           call extend(buflist, tabpagebuflist(i + 1))</code>
<code class="example">                        endfor</code>
                <code class="note">注意</code> 缓冲区可能出现于多于一个窗口里。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabpage()-&gt;tabpagebuflist()</code>
<code class="example"></code>
tabpagenr([<code class="special">{arg}</code>])                                      <b class="vimtag"> <a name="tabpagenr()">tabpagenr()</a> </b>
                返回数值，当前标签页号。第一个标签页的编号为 1。
                如果可选参数为 "$"，返回最后一个标签页的编号 (即标签页总数)。
                该数值可用于  <a href="tabpage.html#:tab">:tab</a>  命令。


tabpagewinnr(<code class="special">{tabarg}</code> [, <code class="special">{arg}</code>])                        <b class="vimtag"> <a name="tabpagewinnr()">tabpagewinnr()</a> </b>
                类似于  <a href="eval.html#winnr()">winnr()</a> ，但使用标签页 <code class="special">{tabarg}</code>。
                <code class="special">{tabarg}</code> 指定要使用的标签页号。
                <code class="special">{arg}</code> 的用法类似于  <a href="eval.html#winnr()">winnr()</a> :
                - 如果省略，返回当前窗口号，也就是转到该标签页时会使用的窗口。
                - 如果是 "$"，返回窗口的总数。
                - 如果是 "#"，返回上次的窗口编号。
                用于的例子: 
<code class="example">                    tabpagewinnr(1)         " 标签页 1 的当前窗口</code>
<code class="example">                    tabpagewinnr(4, '$')    " 标签页 4 的窗口总数</code>
                如果 <code class="special">{tabarg}</code> 非法，返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabpage()-&gt;tabpagewinnr()</code>


                                                        <b class="vimtag"> <a name="tagfiles()">tagfiles()</a> </b>
tagfiles()      返回  <a href="eval.html#List">List</a> ，当前缓冲区用于搜索的标签文件名。这是 <a href="options.html#'tags'">'tags'</a> 选项
                扩展后的内容。


taglist(<code class="special">{expr}</code> [, <code class="special">{filename}</code>])                          <b class="vimtag"> <a name="taglist()">taglist()</a> </b>
                返回匹配正规表达式 <code class="special">{expr}</code> 的标签列表。

                如果传入 <code class="special">{filename}</code>，用于像  <a href="tagsrch.html#:tselect">:tselect</a>  那样给结果排序。见
                 <a href="tagsrch.html#tag-priority">tag-priority</a> 。<code class="special">{filename}</code> 必须是文件的完整路径。

                每个列表项目是一个至少包含以下项目的字典:
                        name            标签名。
                        filename        标签定义的文件名。它或者相对于当前目
                                        录，或者包含完整路径。
                        cmd             用于在文件里定位标签的 Ex 命令。
                        kind            标签类型。该项目的值取决于特定于语言的
                                        类型值。只在 Exuberant ctags 或 hdrtag
                                        生成的标签文件里存在。
                        static          特定于文件的标签。详见  <a href="tagsrch.html#static-tag">static-tag</a> 。
                可能还有一些其它项目，取决于标签文件的内容: access、
                implementation、inherits 和 signature。这些字段的信息参见
                ctags 文档。C 代码里可能出现字段 "struct"、"class" 和 "enum"，
                它们给出标签所在的实体的名字。

                ex 命令 "cmd" 可以是 ex 搜索模式、行号或者行号后跟字节位置。

                如果没有匹配的标签，返回空列表。

                要得到标签的准确匹配，<code class="special">{expr}</code> 里必须使用 '^' 和 '$'。这也可加快
                函数的工作速度。
                关于标签搜索正规表达式模式的详情见  <a href="tagsrch.html#tag-regexp">tag-regexp</a> 。

                 <a href="options.html#'tags'">'tags'</a>  提供 Vim 如何定位标签文件的信息。 <a href="tagsrch.html#tags-file-format">tags-file-format</a> 
                说明不同的 ctags 工具生成的标签文件的格式。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTagpattern()-&gt;taglist()</code>
<code class="example"></code>
tan(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="tan()">tan()</a> </b>
                返回以弧度测量的 <code class="special">{expr}</code> 的正切值。返回值是 [-inf, inf] 区间内
                的浮点数。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        :echo tan(10)</code>
                        0.648361 
<code class="example">                        :echo tan(-4.01)</code>
                        -1.181502

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;tan()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

tanh(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="tanh()">tanh()</a> </b>
                返回 <code class="special">{expr}</code> 的双曲正切值，返回值为 [-1, 1] 区间内的浮点数。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        :echo tanh(0.5)</code>
                        0.462117 
<code class="example">                        :echo tanh(-1)</code>
                        -0.761594

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;tanh()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

tempname()                                      <b class="vimtag"> <a name="tempname()">tempname()</a> </b> <b class="vimtag"> <a name="temp-file-name">temp-file-name</a> </b>
                返回字符串，它是一个不存在的文件名。可以用作临时文件。该文件在
                至少 26 个接连的调用内不会重复。例如: 
<code class="example">                        :let tmpfile = tempname()</code>
<code class="example">                        :exe "redir &gt; " . tmpfile</code>
                Unix 上，文件会在用户个人的目录中  <a href="change.html#tempfile">tempfile</a> 。
                MS-Windows 上，如果置位了 <a href="options.html#'shellslash'">'shellslash'</a> 选项或者 <a href="options.html#'shellcmdflag'">'shellcmdflag'</a>
                以 '-' 开始的时候，使用正斜杠。

term_ 函数文档在这里:  <code class="badlink">terminal-functions-details</code> 

test_ 函数文档在这里:  <a href="testing.html#test-functions-details">test-functions-details</a> 


                                                        <b class="vimtag"> <a name="timer_info()">timer_info()</a> </b>
timer_info([<code class="special">{id}</code>])
                返回定时器信息的列表。
                给出 <code class="special">{id}</code> 时只返回此定时器的信息。如果定时器 <code class="special">{id}</code> 不存在，返回
                空列表。
                省略 <code class="special">{id}</code> 时，返回所有定时器的信息。

                每个定时器的信息以字典形式保存，有以下项目:
                    "id"            定时器号
                    "time"          定时器开始时间
                    "remaining"     定时器剩余时间
                    "repeat"        定时器激活的次数；-1 代表永远
                    "callback"      回调
                    "paused"        如果定时器暂停为 1，否则为 0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTimer()-&gt;timer_info()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>

timer_pause(<code class="special">{timer}</code>, <code class="special">{paused}</code>)                          <b class="vimtag"> <a name="timer_pause()">timer_pause()</a> </b>
                暂停或恢复定时器。暂停的定时器在到期是不调用回调。如果经过足够
                时间，恢复定时器会使回调几乎被立即调用。

                暂停定时器可用于短期停止回调的调用。

                如果 <code class="special">{paused}</code> 计算为非零的数值或非空的字符串，暂停定时器，否则
                恢复定时器。
                见  <a href="eval.html#non-zero-arg">non-zero-arg</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTimer()-&gt;timer_pause(1)</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>

                                                <b class="vimtag"> <a name="timer_start()">timer_start()</a> </b> <b class="vimtag"> <a name="timer">timer</a> </b> <b class="vimtag"> <a name="timers">timers</a> </b>
timer_start(<code class="special">{time}</code>, <code class="special">{callback}</code> [, <code class="special">{options}</code>])
                新建定时器并返回定时器号。

                <code class="special">{time}</code> 是毫秒计的等待时间。只是调用回回调的最短时间。系统如果
                繁忙或 Vim 不在等待输入时，时间会更长。

                <code class="special">{callback}</code> 是要调用的函数。可以是函数名或  <a href="eval.html#Funcref">Funcref</a> 。调用时接
                受一个参数，即定时器号。只有在 Vim 等待输入时才会调用回调。

                <code class="special">{options}</code> 是字典。支持的项目:
                   "repeat"     重复调用回调的次数。-1 代表永远。无定义时，调
                                用回调一次。
                                如果定时器连续出错三次，取消重复。这避免了 Vim
                                因为过多的错误信息导致的不可用的情形。

                示例: 
<code class="example">                        func MyHandler(timer)</code>
<code class="example">                          echo 'Handler called'</code>
<code class="example">                        endfunc</code>
<code class="example">                        let timer = timer_start(500, 'MyHandler',</code>
<code class="example">                                \ {'repeat': 3})</code>
                这会以 500 毫秒间隔调用 MyHandle() 三次。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetMsec()-&gt;timer_start(callback)</code>
<code class="example"></code>
                该命令在沙盘里不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>

timer_stop(<code class="special">{timer}</code>)                                     <b class="vimtag"> <a name="timer_stop()">timer_stop()</a> </b>
                停止定时器。不再调用定时器回调。
                <code class="special">{timer}</code> 是 timer_start() 返回的定时器号，所以必须是数值。如果
                <code class="special">{timer}</code> 不存在，不报错。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTimer()-&gt;timer_stop()</code>
<code class="example"></code>
                <code class="notvi">{仅当编译时加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>

timer_stopall()                                         <b class="vimtag"> <a name="timer_stopall()">timer_stopall()</a> </b>
                停止所有定时器。不再调用定时器回调。用于有定时器工作不正常的场
                合。如果没有任何定时器，不报错。

                <code class="notvi">{仅当编译时加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>

tolower(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="tolower()">tolower()</a> </b>
                返回给出字符串的备份，但所有的大写字符变为小写 (就如同在字符串
                上应用了  <a href="change.html#gu">gu</a>  一样)。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;tolower()</code>
<code class="example"></code>
toupper(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="toupper()">toupper()</a> </b>
                返回给出字符串的备份，但所有的小写字符变为大写 (就如同在字符串
                上应用了  <a href="change.html#gU">gU</a>  一样)。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;toupper()</code>
<code class="example"></code>
tr(<code class="special">{src}</code>, <code class="special">{fromstr}</code>, <code class="special">{tostr}</code>)                           <b class="vimtag"> <a name="tr()">tr()</a> </b>
                返回 <code class="special">{src}</code> 字符串的备份，其中 <code class="special">{fromstr}</code> 里的每个字符被 <code class="special">{tostr}</code>
                字符串里同样的位置的字符替代。也就是，<code class="special">{fromstr}</code> 的第一个字符被
                翻译成 <code class="special">{tostr}</code> 的第一个字符，依此类推。和 unix 命令 "tr" 完全
                相同。
                能正确处理多字节字符。

                例如: 
<code class="example">                        echo tr("hello there", "ht", "HT")</code>
                返回 "Hello THere" 
<code class="example">                        echo tr("&lt;blob&gt;", "&lt;&gt;", "{}")</code>
                返回 "<code class="special">{blob}</code>"

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;tr(from, to)</code>
<code class="example"></code>
trim(<code class="special">{text}</code> [, <code class="special">{mask}</code>])                                         <b class="vimtag"> <a name="trim()">trim()</a> </b>
                返回 <code class="special">{text}</code> 从头部和尾部删除 <code class="special">{mask}</code> 里出现的字符后的字符串。
                如果没给出 <code class="special">{mask}</code>，<code class="special">{mask}</code> 是所有直到 0x20 的字符，包括 Tab、空
                格、NL 和 CR，加上不换行空格 0xa0。
                此代码能正确处理多字节字符。

                示例: 
<code class="example">                        echo trim("   some text ")</code>
                返回 "some text" 
<code class="example">                        echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") . "_TAIL"</code>
                返回 "RESERVE_TAIL" 
<code class="example">                        echo trim("rm&lt;Xrm&lt;&gt;X&gt;rrm", "rm&lt;&gt;")</code>
                返回 "Xrm<code class="special">&lt;&gt;</code>X" (不删除中间部分的字符)

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;trim()</code>
<code class="example"></code>
trunc(<code class="special">{expr}</code>)                                                   <b class="vimtag"> <a name="trunc()">trunc()</a> </b>
                返回浮点数，即绝对值小于等于 <code class="special">{expr}</code> 的最大整数 (向零取整)。
                <code class="special">{expr}</code> 的计算结果必须是浮点数或数值。
                示例: 
<code class="example">                        echo trunc(1.456)</code>
                        1.0  
<code class="example">                        echo trunc(-5.456)</code>
                        -5.0  
<code class="example">                        echo trunc(4.0)</code>
                        4.0

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        Compute()-&gt;trunc()</code>

                <code class="notvi">{仅当编译时加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="type()">type()</a> </b>
type(<code class="special">{expr}</code>)    返回数值，代表 <code class="special">{expr}</code> 的类型。
                不要直接使用此值，最好用含有此值的 v:t_ 变量:
                        数值:       0   <a href="eval.html#v:t_number">v:t_number</a> 
                        字符串:     1   <a href="eval.html#v:t_string">v:t_string</a> 
                        函数引用:   2   <a href="eval.html#v:t_func">v:t_func</a> 
                        列表:       3   <a href="eval.html#v:t_list">v:t_list</a> 
                        字典:       4   <a href="eval.html#v:t_dict">v:t_dict</a> 
                        浮点数:     5   <a href="eval.html#v:t_float">v:t_float</a> 
                        布尔值:     6   <a href="eval.html#v:t_bool">v:t_bool</a>  (v:false 和 v:true)
                        None:       7   <a href="eval.html#v:t_none">v:t_none</a>  (v:null 和 v:none)
                        作业:       8   <a href="eval.html#v:t_job">v:t_job</a> 
                        通道:       9   <a href="eval.html#v:t_channel">v:t_channel</a> 
                        blob:      10   <a href="eval.html#v:t_blob">v:t_blob</a> 
                为了后向兼容，可以这样用此函数: 
<code class="example">                        :if type(myvar) == type(0)</code>
<code class="example">                        :if type(myvar) == type("")</code>
<code class="example">                        :if type(myvar) == type(function("tr"))</code>
<code class="example">                        :if type(myvar) == type([])</code>
<code class="example">                        :if type(myvar) == type({})</code>
<code class="example">                        :if type(myvar) == type(0.0)</code>
<code class="example">                        :if type(myvar) == type(v:false)</code>
<code class="example">                        :if type(myvar) == type(v:none)</code>
                要检查 v:t_ 这些变量是否存在，可用: 
<code class="example">                        :if exists('v:t_number')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;type()</code>
<code class="example"></code>
undofile(<code class="special">{name}</code>)                                        <b class="vimtag"> <a name="undofile()">undofile()</a> </b>
                返回用于名为 <code class="special">{name}</code> 的文件的撤销文件名。使用 <a href="options.html#'undodir'">'undodir'</a> 选项并
                寻找实际存在的目录。并不检查该撤销文件是否存在。
                <code class="special">{name}</code> 总是扩展为完整路径，因为内部是这么使用的。
                <code class="special">{name}</code> 为空时 undofile() 也返回空字符串，因为无名缓冲区不写入
                任何撤销文件。
                可用于  <a href="undo.html#:wundo">:wundo</a>  和  <a href="undo.html#:rundo">:rundo</a> 。
                如果编译时没有  <a href="various.html#+persistent_undo">+persistent_undo</a>  选项，总是返回空字符串。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetFilename()-&gt;undofile()</code>
<code class="example"></code>
undotree()                                              <b class="vimtag"> <a name="undotree()">undotree()</a> </b>
                返回撤销树的当前状态。返回值是包含以下项目的字典:
                  "seq_last"    最大使用的撤销序列号。
                  "seq_cur"     撤销树中当前位置的序列号。如果有撤销过的改变，
                                和 "seq_last" 会有不同。
                  "time_cur"    最近用于  <a href="undo.html#:earlier">:earlier</a>  和相关命令的时间。
                                可用  <a href="eval.html#strftime()">strftime()</a>  转换成可读的格式。
                  "save_last"   最后的文件写入编号。如果没有写入，返回零。
                  "save_cur"    撤销树当前位置的编号。
                  "synced"      如果最后的撤销块已经同步，返回非零值。等待用户
                                输入时会发生。见  <a href="undo.html#undo-blocks">undo-blocks</a> 。
                  "entries"     关于撤销块的信息的字典的列表。

                "entries" 列表的第一个值是最老的撤销项目。每个列表项目是一个包
                含以下项目的字典:
                  "seq"         撤销序列号。和  <a href="undo.html#:undolist">:undolist</a>  显示的相同。
                  "time"        改变发生的时间。可用  <a href="eval.html#strftime()">strftime()</a>  转换成可读的
                                格式。
                  "newhead"     只出现在最后加入的项目。标识最后的改变，并指示
                                将来的改变加入所在的位置。
                  "curhead"     只出现在最后撤销的项目。表示撤销树当前的位置，
                                该块可用于 redo 命令。如果最后改变之后没有撤销
                                动作，此项目不出现。
                  "save"        只出现在文件写入前最后的块。该值为写入计数。首
                                次写入的编号为 1，最后一次是上面提及的
                                "save_last"。
                  "alt"         替代项。这又是一个撤销块的列表。每个项目又可以
                                有 "alt" 项目。

uniq(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])                      <b class="vimtag"> <a name="uniq()">uniq()</a> </b> <b class="vimtag"> <a name="E882">E882</a> </b>
                原地删除重复相邻的 <code class="special">{list}</code> 项目的第二个及之后的版本。返回
                <code class="special">{list}</code> 。如果不想对列表进行修改，先建立一个备份: 
<code class="example">                        :let newlist = uniq(copy(mylist))</code>
                缺省比较函数使用每个项目的字符串表示形式。关于 <code class="special">{func}</code> 和
                <code class="special">{dict}</code> 的使用可见  <a href="eval.html#sort()">sort()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mylist-&gt;uniq()</code>
<code class="example"></code>
values(<code class="special">{dict}</code>)                                          <b class="vimtag"> <a name="values()">values()</a> </b>
                返回  <a href="eval.html#List">List</a> ，<code class="special">{dict}</code> 的所有值。 <a href="eval.html#List">List</a>  项目的顺序不定。另见
                 <a href="eval.html#items()">items()</a>  和  <a href="eval.html#keys()">keys()</a> 。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        mydict-&gt;values()</code>
<code class="example"></code>
virtcol(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="virtcol()">virtcol()</a> </b>
                要得到屏幕列的位置，用  <a href="eval.html#virtcol()">virtcol()</a> 。
                <code class="note">注意</code> 只能使用当前文件的位置标记。

                返回数值，即 <code class="special">{expr}</code> 给定的文件位置的屏幕列号。也就是，该位置的
                字符占据的最后一个屏幕位置，这里假设屏幕有无限的宽度。如果该位
                置是一个 <code class="special">&lt;Tab&gt;</code>，返回的数值是 <code class="special">&lt;Tab&gt;</code> 占据的最后一列。比如，如果
                <code class="special">&lt;Tab&gt;</code> 在第 1 列，而 <a href="options.html#'ts'">'ts'</a> 设为 8 的话，返回 8。忽略  <code class="badlink">conceal()</code> 
                因素。
                关于字节位置，见  <a href="eval.html#col()">col()</a> 。
                <code class="special">{expr}</code> 用法见  <a href="eval.html#col()">col()</a> 。
                如果使用 <a href="options.html#'virtualedit'">'virtualedit'</a>，<code class="special">{expr}</code> 可以用 [lnum, col, off]，其中
                "off" 是字符位置开始计算的屏幕列。例如，制表中或最后一个字符之
                后的某个位置。"off" 若省略，则假定为零。
                如果在当前模式下使用了虚拟编辑，也可能返回行尾之后的位置。
                 <a href="options.html#'virtualedit'">'virtualedit'</a> 
                可接受的位置是:
                    .       光标位置
                    $       光标行的行尾 (返回光标行显示的字符数加 1)
                    'x      位置标记 x 的位置 (如果该位置标记没有设置，返回 0)
                    v       可视模式下: 可视区域的开始位置 (光标是结束位置)。
                            如果不在可视模式下，返回当前光标位置。和  <a href="motion.html#'%3C">'&lt;</a>  不同
                            的是，会被立即更新。
                <code class="note">注意</code> 只能使用当前文件的位置标记。
                示例: 
<code class="example">  virtcol(".")     文本 "foo^Lbar"，光标在 "^L" 上，返回 5</code>
<code class="example">  virtcol("$")     文本 "foo^Lbar"，返回 9</code>
<code class="example">  virtcol("'t")    文本 "    there"，'t 在 'h' 上，返回 6</code>
                第一列为 1。返回 0 代表错误。
                一个更高级的示例，显示所有行的最大长度: 
<code class="example">                    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetPos()-&gt;virtcol()</code>
<code class="example"></code>
<code class="example"></code>
visualmode([<code class="special">{expr}</code>])                                            <b class="vimtag"> <a name="visualmode()">visualmode()</a> </b>
                返回字符串，它描述当前缓冲区最近使用的可视模式。一开始，它返回
                空字符串，一旦使用了可视模式，返回 "v"、"V" 或 "&lt;<code class="keystroke">CTRL-V</code>&gt;" (单
                个 <code class="keystroke">CTRL-V</code> 字符)，分别代表面向字符、面向行、和面向列块的可视模
                式。
                例如: 
<code class="example">                        :exe "normal " . visualmode()</code>
                进入和上次相同的可视模式。也可以用于在脚本里根据最近的可视模式
                采取不同的行动。
                如果当前正处于可视模式中， <a href="eval.html#mode()">mode()</a>  可得到具体的可视模式 (例如
                在  <a href="map.html#:vmap">:vmap</a>  中可用)。
                如果提供 <code class="special">{expr}</code> 并且计算结果是非零数值或者是非空字符串，那么将
                清除可视模式，并返回旧的值。见  <a href="eval.html#non-zero-arg">non-zero-arg</a> 。

wildmenumode()                                  <b class="vimtag"> <a name="wildmenumode()">wildmenumode()</a> </b>
                如果 wildmenu 打开，返回  <a href="eval.html#TRUE">TRUE</a> ，否则返回  <a href="eval.html#FALSE">FALSE</a> 。参见
                <a href="options.html#'wildmenu'">'wildmenu'</a> 和 <a href="options.html#'wildmode'">'wildmode'</a>。
                可用于在映射中方便地处理 <a href="options.html#'wildcharm'">'wildcharm'</a> 选项。(只对  <a href="map.html#mapmode-c">mapmode-c</a> 
                映射有意义)。

                例如要使 <code class="special">&lt;c-j&gt;</code> 在 wildmode 中等价于 <code class="special">&lt;down&gt;</code>，可用: 
<code class="example">    :cnoremap &lt;expr&gt; &lt;C-j&gt; wildmenumode() ? "\&lt;Down&gt;\&lt;Tab&gt;" : "\&lt;c-j&gt;"</code>

                (<code class="note">备注</code>，这需要 <a href="options.html#'wildcharm'">'wildcharm'</a> 合适的设置配合)。


win_execute(<code class="special">{id}</code>, <code class="special">{command}</code> [, <code class="special">{silent}</code>])               <b class="vimtag"> <a name="win_execute()">win_execute()</a> </b>
                类似于  <a href="eval.html#execute()">execute()</a>  但在窗口 <code class="special">{id}</code> 的上下文中执行。该窗口会被临
                时设为当前窗口，不触发自动命令。执行 <code class="special">{command}</code> 时会触发自动命
                令，这可能有意想不到的副作用。如有必要可用  <a href="autocmd.html#:noautocmd">:noautocmd</a> 。
                示例: 
<code class="example">                        call win_execute(winid, 'set syntax=python')</code>
                和  <a href="eval.html#setwinvar()">setwinvar()</a>  相同但不触发自动命令也不实际显示语法高亮。
                                                        <b class="vimtag"> <a name="E994">E994</a> </b>
                不是所有的命令都允许在弹出窗口中使用。
                窗口 <code class="special">{id}</code> 不存在时不报错。

                也可用作  <a href="eval.html#method">method</a> ，基是作为第二个参数传递的: 
<code class="example">                        GetCommand()-&gt;win_execute(winid)</code>
<code class="example"></code>
win_findbuf(<code class="special">{bufnr}</code>)                                    <b class="vimtag"> <a name="win_findbuf()">win_findbuf()</a> </b>
                返回包含缓冲区 <code class="special">{bufnr}</code> 的窗口的所有  <a href="windows.html#window-ID">window-ID</a>  的列表。如果
                没有这样的窗口，返回空列表。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetBufnr()-&gt;win_findbuf()</code>
<code class="example"></code>
win_getid([<code class="special">{win}</code> [, <code class="special">{tab}</code>]])                            <b class="vimtag"> <a name="win_getid()">win_getid()</a> </b>
                返回指定窗口的  <a href="windows.html#window-ID">window-ID</a> 。
                忽略 <code class="special">{win}</code> 则使用当前窗口。
                给定 <code class="special">{win}</code> 时，这是窗口号。顶部窗口的窗口号为 1。
                忽略 <code class="special">{tab}</code> 则使用当前标签页，否则使用标签页 <code class="special">{tab}</code>。首个标签页
                的标签页号为一。
                如果找不到这样的窗口，返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinnr()-&gt;win_getid()</code>
<code class="example"></code>
win_gotoid(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="win_gotoid()">win_gotoid()</a> </b>
                转到 ID 为 <code class="special">{expr}</code> 的窗口。可能会改变当前标签页。
                如果成功返回 1，如果找不到这样的窗口，返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;win_gotoid()</code>
<code class="example"></code>
win_id2tabwin(<code class="special">{expr}</code>)                                   <b class="vimtag"> <a name="win_id2tabwin()">win_id2tabwin()</a> </b>
                返回包含 ID 为 <code class="special">{expr}</code> 的窗口的标签页号和窗口号的列表: [tabnr,
                winnr]。
                如果找不到这样的窗口，返回 [0, 0]。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;win_id2tabwin()</code>
<code class="example"></code>
win_id2win(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="win_id2win()">win_id2win()</a> </b>
                返回 ID 为 <code class="special">{expr}</code> 的窗口号。
                如果在当前标签页下找不到这样的窗口，返回零。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;win_id2win()</code>
<code class="example"></code>
win_screenpos(<code class="special">{nr}</code>)                                     <b class="vimtag"> <a name="win_screenpos()">win_screenpos()</a> </b>
                返回两个数值的列表，即窗口 <code class="special">{nr}</code> 的屏幕位置: [row, col]。首个窗
                口的位置总是 [1, 1]，除非它有标签页行，此时为 [2, 1]。
                <code class="special">{nr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果在当前标签页找不到窗口，返回 [0, 0]。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;win_screenpos()</code>

win_splitmove(<code class="special">{nr}</code>, <code class="special">{target}</code> [, <code class="special">{options}</code>])             <b class="vimtag"> <a name="win_splitmove()">win_splitmove()</a> </b>
                移动窗口 <code class="special">{nr}</code> 成为窗口 <code class="special">{target}</code> 的新分割窗口。
                类似于先移动到 <code class="special">{target}</code>，用  <a href="windows.html#:split">:split</a>  创建新窗口但使用窗口 <code class="special">{nr}</code>
                相同的内容，然后关闭 <code class="special">{nr}</code>。

                <code class="special">{nr}</code> 和 <code class="special">{target}</code> 都可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。

                如果成功返回零，失败返回非零。

                <code class="special">{options}</code> 是包含以下可选项的字典:
                  "vertical"    为 TRUE 时垂直分割，类似于  <a href="windows.html#:vsplit">:vsplit</a> 。
                  "rightbelow"  为 TRUE 时分割在下方或右方 (垂直时)。为 FALSE
                                时分割在上方或左方 (垂直时)。如果未给出，使用
                                <a href="options.html#'splitbelow'">'splitbelow'</a> 和 <a href="options.html#'splitright'">'splitright'</a>。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;win_splitmove(target)</code>

                                                        <b class="vimtag"> <a name="winbufnr()">winbufnr()</a> </b>
winbufnr(<code class="special">{nr}</code>)  返回数值，即窗口 <code class="special">{nr}</code> 相关联的缓冲区号。<code class="special">{nr}</code> 可以是窗口号或
                 <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 为零，返回当前窗口的缓冲区号。
                如果窗口 <code class="special">{nr}</code> 不存在，返回 -1。
                示例: 
<code class="example">  :echo "当前窗口的文件是 " . bufname(winbufnr(0))</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        FindWindow()-&gt;winbufnr()-&gt;bufname()</code>

                                                        <b class="vimtag"> <a name="wincol()">wincol()</a> </b>
wincol()        返回数值，窗口光标的虚拟列。亦即从窗口左侧起算的屏幕列数。最左
                列为第一列。

                                                        <b class="vimtag"> <a name="windowsversion()">windowsversion()</a> </b>
windowsversion()
                返回字符串。MS-Windows 上指示 OS 版本。例如，Windows 10 是
                "10.0"。Windows 8 是 "6.2"，Windows XP 是 "5.1"。非 MS-Windows
                系统上返回空串。

winheight(<code class="special">{nr}</code>)                                         <b class="vimtag"> <a name="winheight()">winheight()</a> </b>
                返回数值，窗口 <code class="special">{nr}</code> 的高度。
                <code class="special">{nr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 为零，返回当前窗口的高度。如果窗口 <code class="special">{nr}</code> 不存在，返回
                -1。
                存在的窗口的高度至少为零。
                不计入任何窗口工具条行。
                示例: 
<code class="example">  :echo "当前窗口有 " . winheight(0) . " 行。"</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;winheight()</code>

winlayout([<code class="special">{tabnr}</code>])                                    <b class="vimtag"> <a name="winlayout()">winlayout()</a> </b>
                返回嵌套列表，包含标签页中的窗口布局。

                未给出 <code class="special">{tabnr}</code> 则使用当前标签页，否则使用号码为 <code class="special">{tabnr}</code> 的标签
                页。如果标签页 <code class="special">{tabnr}</code> 找不到，返回空列表。

                叶窗口返回:
                        [<code class="badlink">'leaf'</code>, <code class="special">{winid}</code>]
                水平分割的窗口构成一列，它们返回:
                        [<code class="badlink">'col'</code>, [{nested list of windows}]]
                垂直分割的窗口构成一行，它们返回:
                        [<code class="badlink">'row'</code>, [{nested list of windows}]]

                示例: 
<code class="example">                        " 标签页中只有一个窗口</code>
<code class="example">                        :echo winlayout()</code>
<code class="example">                        ['leaf', 1000]</code>
<code class="example">                        " 两个水平分割的窗口</code>
<code class="example">                        :echo winlayout()</code>
<code class="example">                        ['col', [['leaf', 1000], ['leaf', 1001]]]</code>
<code class="example">                        " 三个水平分割的窗口，中间窗口有两个垂直分割的窗口</code>
<code class="example">                        :echo winlayout(2)</code>
<code class="example">                        ['col', [['leaf', 1002], ['row', ['leaf', 1003],</code>
<code class="example">                                             ['leaf', 1001]]], ['leaf', 1000]]</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetTabnr()-&gt;winlayout()</code>

                                                        <b class="vimtag"> <a name="winline()">winline()</a> </b>
winline()       返回数值，窗口光标所在的屏幕行，亦即，从窗口顶部起算的屏幕行
                数。第一行返回 1。
                如果光标移动，文件的视图会先更新，这可能会导致滚动。

                                                        <b class="vimtag"> <a name="winnr()">winnr()</a> </b>
winnr([<code class="special">{arg}</code>])  返回数值，当前窗口的编号。最上面的窗口的编号为 1。

                可选参数 <code class="special">{arg}</code> 支持以下值:
                        $       返回最后一个窗口的编号 (即窗口的总数)。
                        #       返回最近访问的窗口号 ( <a href="windows.html#CTRL-W_p">CTRL-W_p</a>  到的地
                                方)。如果没有上次窗口或它在另一个标签页中，返
                                回 0。
                        <code class="special">{N}</code>j    当前窗口之下第 N 个窗口的窗口号 ( <a href="windows.html#CTRL-W_j">CTRL-W_j</a>  到
                                的地方)。
                        <code class="special">{N}</code>k    当前窗口之上第 N 个窗口的窗口号 ( <a href="windows.html#CTRL-W_k">CTRL-W_k</a>  到
                                的地方)。
                        <code class="special">{N}</code>h    当前窗口之左第 N 个窗口的窗口号 ( <a href="windows.html#CTRL-W_h">CTRL-W_h</a>  到
                                的地方)。
                        <code class="special">{N}</code>l    当前窗口之右第 N 个窗口的窗口号 ( <a href="windows.html#CTRL-W_l">CTRL-W_l</a>  到
                                的地方)。
                此编号可用于  <a href="windows.html#CTRL-W_w">CTRL-W_w</a>  和 ":wincmd w"  <a href="windows.html#:wincmd">:wincmd</a> 。
                另见  <a href="eval.html#tabpagewinnr()">tabpagewinnr()</a>  和  <a href="eval.html#win_getid()">win_getid()</a> 。
                示例: 
<code class="example">                        let window_count = winnr('$')</code>
<code class="example">                        let prev_window = winnr('#')</code>
<code class="example">                        let wnum = winnr('3k')</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinval()-&gt;winnr()</code>

                                                        <b class="vimtag"> <a name="winrestcmd()">winrestcmd()</a> </b>
winrestcmd()    返回  <a href="windows.html#:resize">:resize</a>  命令序列，该序列应该能够恢复当前窗口的大小。只
                有在没有窗口被打开或关闭且当前窗口和标签页都没有改变的时候才能
                正确工作。
                示例: 
<code class="example">                        :let cmd = winrestcmd()</code>
<code class="example">                        :call MessWithWindowSizes()</code>
<code class="example">                        :exe cmd</code>

                                                        <b class="vimtag"> <a name="winrestview()">winrestview()</a> </b>
winrestview(<code class="special">{dict}</code>)
                使用  <a href="eval.html#winsaveview()">winsaveview()</a>  返回的  <a href="eval.html#Dictionary">Dictionary</a>  来恢复当前窗口的视
                图。
                <code class="note">注意</code> <code class="special">{dict}</code> 不需要包含所有的  <a href="eval.html#winsaveview()">winsaveview()</a>  返回的值。如果不
                提供某值，则不恢复相应的设置。所以可以用: 
<code class="example">                    :call winrestview({'curswant': 4})</code>

                它只会设置光标的 curswant 值 (垂直移动的光标想移动到的列) 到第
                5 列 (是的，第 5 列)，而其它设置保持不变。这可用于手动设置光标
                位置。

                如果你改变了其中的值，结果无法预测。如果窗口大小改变了，结果不
                会完全一样。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetView()-&gt;winrestview()</code>

                                                        <b class="vimtag"> <a name="winsaveview()">winsaveview()</a> </b>
winsaveview()   返回  <a href="eval.html#Dictionary">Dictionary</a> ，包含当前窗口的信息，这些信息可用来恢复视
                图。
                 <a href="eval.html#winrestview()">winrestview()</a>  进行视图的恢复。
                可用于定义在缓冲区里跳转后想恢复的原来视图的映射。
                这里不保存折叠的信息。用 <a href="options.html#'foldenable'">'foldenable'</a> 选项来暂时关闭折叠功能，
                这样在移动时折叠就不会打开。这可能有副作用。
                返回值包括:
                        lnum            光标行号
                        col             光标列号 (<code class="note">注意</code>: 首列为零，和 getpos()
                                        不同)
                        coladd          <a href="options.html#'virtualedit'">'virtualedit'</a> 使用的光标列偏移
                        curswant        垂直移动使用的列
                        topline         窗口的第一行
                        topfill         填充行，只用于比较模式
                        leftcol         显示的第一列
                        skipcol         跳过的列数
                <code class="note">注意</code> 这里不保存任何选项值。


winwidth(<code class="special">{nr}</code>)                                          <b class="vimtag"> <a name="winwidth()">winwidth()</a> </b>
                返回数值，窗口 <code class="special">{nr}</code> 的宽度。
                <code class="special">{nr}</code> 可以是窗口号或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 为零，返回当前窗口的宽度。如果窗口 <code class="special">{nr}</code> 不存在，返回
                -1。
                存在的窗口的宽度至少为零。
                示例: 
<code class="example">  :echo "当前窗口有 " . winwidth(0) . " 列。"</code>
<code class="example">  :if winwidth(0) &lt;= 50</code>
<code class="example">  :  50 wincmd |</code>
<code class="example">  :endif</code>
                要得到终端或屏幕大小，可见 <a href="options.html#'columns'">'columns'</a> 选项。

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetWinid()-&gt;winwidth()</code>
<code class="example"></code>
<code class="example"></code>
wordcount()                                             <b class="vimtag"> <a name="wordcount()">wordcount()</a> </b>
                返回字典，包含当前缓冲区的字节/字符/单词的统计。和  <a href="editing.html#g_CTRL-G">g_CTRL-G</a> 
                包含的信息相同。
                返回值包括:
                        bytes           缓冲区的字节数
                        chars           缓冲区的字符数
                        words           缓冲区的单词数
                        cursor_bytes    光标前的字节数 (不在可视模式下)
                        cursor_chars    光标前的字符数 (不在可视模式下)
                        cursor_words    光标前的单词数 (不在可视模式下)
                        visual_bytes    可视选择的字节数 (只在可视模式下)
                        visual_chars    可视选择的字符数 (只在可视模式下)
                        visual_words    可视选择的单词数 (只在可视模式下)


                                                        <b class="vimtag"> <a name="writefile()">writefile()</a> </b>
writefile(<code class="special">{object}</code>, <code class="special">{fname}</code> [, <code class="special">{flags}</code>])
                <code class="special">{object}</code> 为  <a href="eval.html#List">List</a>  时，把列表写到文件 <code class="special">{fname}</code> 里。列表的项目间
                以 NL 分隔。每个列表项必须是字符串或数值。
                如果 <code class="special">{flags}</code> 包含 "b"，使用二进制模式: 最后一个列表项目之后没
                有 NL，最后的空项目使得文件的末行以 NL 结尾。

                <code class="special">{object}</code> 为  <a href="eval.html#Blob">Blob</a>  时，把这些字节不加修改地写到文件 <code class="special">{fname}</code>
                里。

                如果 <code class="special">{flags}</code> 包含 "a"，使用附加模式，写入行附加到文件之后: 
<code class="example">                        :call writefile(["foo"], "event.log", "a")</code>
<code class="example">                        :call writefile(["bar"], "event.log", "a")</code>

                如果 <code class="special">{flags}</code> 包含 "s"，写入文件后调用 fsync()。在可能的情况下
                它把文件刷新到盘上。这会多花些时间，但避免系统崩溃时丢失文件的
                风险。
                如果 <code class="special">{flags}</code> 不包含 "S" 或 "s"，<a href="options.html#'fsync'">'fsync'</a> 选项置位时调用
                fsync()。
                如果 <code class="special">{flags}</code> 包含 "S"，无论 <a href="options.html#'fsync'">'fsync'</a> 选项是否置位都不调用
                fsync()。

                所有的 NL 字符被 NUL 字符代替。
                CR 字符的插入需要在把 <code class="special">{list}</code> 传递给 writefile() 之前先做好。
                如果可能，覆盖已有的文件。
                如果写入失败，返回 -1，否则返回 0。如果文件不能建立或者写入失
                败，会有错误信息。
                另见  <a href="eval.html#readfile()">readfile()</a> 。
                要按字节复制文件: 
<code class="example">                        :let fl = readfile("foo", "b")</code>
<code class="example">                        :call writefile(fl, "foocopy", "b")</code>
<code class="example"></code>
                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        GetText()-&gt;writefile("thefile")</code>
<code class="example"></code>
<code class="example"></code>
xor(<code class="special">{expr}</code>, <code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="xor()">xor()</a> </b>
                对两个参数进行按位异或。参数须转换为数值。列表、字典或浮点数参
                数会报错。
                示例: 
<code class="example">                        :let bits = xor(bits, 0x80)</code>

                也可用作  <a href="eval.html#method">method</a> : 
<code class="example">                        :let bits = bits-&gt;xor(0x80)</code>


                                                        <b class="vimtag"> <a name="feature-list">feature-list</a> </b>
有四种类型的特性:
1.  只有在 Vim 编译时加入才会支持的特性  <a href="various.html#+feature-list">+feature-list</a> 。例如: 
<code class="example">        :if has("cindent")</code>
2.  只有特定条件满足才会支持的特性。例如: 
<code class="example">        :if has("gui_running")</code>
                                                        <b class="vimtag"> <a name="has-patch">has-patch</a> </b>
3.  特定版本之后或在特定版本上并包含了特定补丁。"patch-7.4.248" 特性意味着 Vim
    版本是 7.5 或之后，或 7.4 并包含了补丁 248。例如: 
<code class="example">        :if has("patch-7.4.248")</code>
    <code class="note">注意</code> 包含了补丁 249 但不包含补丁 248 是可能的，但这只适用于 cherrypick 补
    丁的情况。
    <code class="note">注意</code> 此形式只可用于 7.4.237 补丁或之后版本，在这之前，你需要检查补丁号和
    v:version。例如 (确定是 version 6.2.148 或更新的版本): 
<code class="example">        :if v:version &gt; 602 || v:version == 602 &amp;&amp; has("patch148")</code>
<code class="example"></code>
揭示: 要知道 Vim 是否支持文件名中的反斜杠 (MS-Windows)，
用: `if exists('+shellslash')`


acl                     编译时加入了  <a href="editing.html#ACL">ACL</a>  支持。
all_builtin_terms       编译时打开了所有的内建终端。
amiga                   Vim 的 Amiga 版本。
arabic                  编译时加入了阿拉伯语的支持。 <a href="arabic.html#Arabic">Arabic</a> 。
arp                     编译时加入了 ARP 的支持。(Amiga)。
autocmd                 编译时加入了自动命令的支持。(总为真)
autochdir               编译时加入了 <a href="options.html#'autochdir'">'autochdir'</a> 的支持
autoservername          自动打开  <a href="remote.html#clientserver">clientserver</a> 
balloon_eval            编译时加入了  <a href="debugger.html#balloon-eval">balloon-eval</a>  的支持。
balloon_multiline       GUI 支持多行气泡。
beos                    Vim 的 BeOS 版本。
browse                  编译时加入了  <a href="editing.html#:browse">:browse</a>  的支持。使 browse() 可以工作。
browsefilter            编译时加入了  <a href="editing.html#browsefilter">browsefilter</a>  的支持。
bsd                     编译时使用了 BSD 家族的 OS (除了 macOS)。
builtin_terms           编译时打开了一些内建终端。
byte_offset             编译时加入了 <a href="options.html#'statusline'">'statusline'</a> 中对 'o' 的支持。
cindent                 编译时加入了 <a href="options.html#'cindent'">'cindent'</a> 的支持。
clientserver            编译时加入了远程调用的支持。 <a href="remote.html#clientserver">clientserver</a> 。
clipboard               编译时加入了 <a href="options.html#'clipboard'">'clipboard'</a> 的支持。
clipboard_working       编译时加入了 <a href="options.html#'clipboard'">'clipboard'</a> 的支持且可用。
cmdline_compl           编译时加入了  <a href="cmdline.html#cmdline-completion">cmdline-completion</a>  的支持。
cmdline_hist            编译时加入了  <a href="cmdline.html#cmdline-history">cmdline-history</a>  的支持。
cmdline_info            编译时加入了 <a href="options.html#'showcmd'">'showcmd'</a> 和 <a href="options.html#'ruler'">'ruler'</a> 的支持。
comments                编译时加入了  <a href="options.html#'comments'">'comments'</a>  的支持。
compatible              编译时确保和 Vi 非常兼容。
conpty                   <a href="terminal.html#ConPTY">ConPTY</a>  可用的平台。
cryptv                  编译时加入了加密的支持。 <a href="editing.html#encryption">encryption</a> 。
cscope                  编译时加入了  <a href="if_cscop.html#cscope">cscope</a>  的支持。
cursorbind              编译时加入了  <a href="options.html#'cursorbind'">'cursorbind'</a>  的支持 (总为真)
debug                   编译时定义了 "DEBUG"。
dialog_con              编译时加入了控制台对话框的支持。
dialog_gui              编译时加入了 GUI 对话框的支持。
diff                    编译时加入了  <a href="diff.html#vimdiff">vimdiff</a>  和 <a href="options.html#'diff'">'diff'</a> 的支持。
digraphs                编译时加入了二合字母的支持。
directx                 编译时加入了 DirectX 和 <a href="options.html#'renderoptions'">'renderoptions'</a> 的支持。
dnd                     编译时加入了 "~ 寄存器的支持  <a href="change.html#quote_%7E">quote_~</a> 。
ebcdic                  在使用 ebcdic 字符集的机器上编译。
emacs_tags              编译时加入了 Emcac 标签的支持。
eval                    编译时加入了表达式计算的支持。当然总要打开啦！
ex_extra                 <a href="various.html#+ex_extra">+ex_extra</a>  (总为真)
extra_search            编译时加入了  <a href="options.html#'incsearch'">'incsearch'</a>  和  <a href="options.html#'hlsearch'">'hlsearch'</a>  的支持。
farsi                   删除了波斯语的支持  <a href="farsi.html#farsi">farsi</a> 。
file_in_path            编译时加入了  <a href="editing.html#gf">gf</a>  和  <a href="cmdline.html#%3Ccfile%3E">&lt;cfile&gt;</a>  的支持。
filterpipe              <a href="options.html#'shelltemp'">'shelltemp'</a> 关闭时，外壳读/写/过滤命令使用管道
find_in_path            编译时加入了头文件搜索  <a href="various.html#+find_in_path">+find_in_path</a>  的支持。
float                   编译时加入了  <a href="eval.html#Float">Float</a>  的支持。
fname_case              文件名大小写敏感 (在 Amiga 和 Windows 本特性不存在)。
folding                 编译时加入了  <a href="fold.html#folding">folding</a>  的支持。
footer                  编译时加入了 GUI 信息页脚的支持。 <a href="debugger.html#gui-footer">gui-footer</a> 
fork                    编译时决定使用 fork()/exec() 而不是 system()。
gettext                 编译时加入了信息翻译  <a href="mlang.html#multi-lang">multi-lang</a> 。
gui                     编译时加入了 GUI 的支持。
gui_athena              编译时加入了 Athena GUI。
gui_gnome               编译时加入了 Gnome 支持 (同时也定义了 gui_gtk)。
gui_gtk                 编译时加入了 GTK+ GUI (任何版本)。
gui_gtk2                编译时加入了 GTK+ 2 GUI (同时也定义了 gui_gtk)。
gui_gtk3                编译时加入了 GTK+ 3 GUI (同时也定义了 gui_gtk)。
gui_mac                 编译时加入了 Macintosh GUI。
gui_motif               编译时加入了 Motif GUI。
gui_photon              编译时加入了 Photon GUI。
gui_running             Vim 在 GUI 上运行，或者 GUI 将很快启动。
gui_win32               编译时加入了 MS Windows Win32 GUI。
gui_win32s              同上，使用了 Win32s 系统 (Windows 3.1)
hangul_input            编译时加入了韩语输入的支持。 <a href="hangulin.html#hangul">hangul</a> 
hpux                    Vim 的 HP-UX 版本。
iconv                   可以使用 iconv() 进行转换。
insert_expand           编译时加入了插入模式中 <code class="keystroke">CTRL-X</code> 扩展命令的支持。(总为真)
jumplist                编译时加入了  <a href="motion.html#jumplist">jumplist</a>  的支持。
keymap                  编译时加入了 <a href="options.html#'keymap'">'keymap'</a> 的支持。
lambda                  编译时加入了  <a href="eval.html#lambda">lambda</a>  的支持。
langmap                 编译时加入了 <a href="options.html#'langmap'">'langmap'</a> 的支持。
libcall                 编译时加入了  <a href="eval.html#libcall()">libcall()</a>  的支持。
linebreak               编译时加入了 <a href="options.html#'linebreak'">'linebreak'</a>、<a href="options.html#'breakat'">'breakat'</a>、<a href="options.html#'showbreak'">'showbreak'</a> 和
                        <a href="options.html#'breakindent'">'breakindent'</a> 的支持。
linux                   Vim 的 Linux 版本。
lispindent              编译时加入了 lisp 缩进的支持。
listcmds                编译时加入了缓冲区列表  <a href="windows.html#:files">:files</a>  和参数列表  <a href="editing.html#arglist">arglist</a> 
                        的命令。
localmap                编译时加入了局部映射和缩写。 <a href="map.html#:map-local">:map-local</a> 
lua                     编译时加入了 Lua 接口  <a href="if_lua.html#Lua">Lua</a> 。
mac                     Vim 的 Macintosh 版本，参照 osx
macunix                 等同于 osxdarwin
menu                    编译时加入了  <a href="gui.html#:menu">:menu</a>  的支持。
mksession               编译时加入了  <a href="starting.html#:mksession">:mksession</a>  的支持。
modify_fname            编译时加入了文件名的修饰符支持。 <a href="cmdline.html#filename-modifiers">filename-modifiers</a> 
                        (总为真)
mouse                   编译时加入了鼠标的支持。
mouse_dec               编译时加入了 Dec 终端的鼠标支持。
mouse_gpm               编译时加入了 gpm (Linux 控制台鼠标) 的支持。
mouse_gpm_enabled       GPM 鼠标可用
mouse_netterm           编译时加入了 netterm 的鼠标支持。
mouse_pterm             编译时加入了 qnx 的鼠标支持。
mouse_sysmouse          编译时加入了 sysmouse 支持 (*BSD 控制台鼠标)
mouse_sgr               编译时加入了 sgr 的鼠标支持。
mouse_urxvt             编译时加入了 urxvt 的鼠标支持。
mouse_xterm             编译时加入了 xterm 的鼠标支持。
mouseshape              编译时加入了 <a href="options.html#'mouseshape'">'mouseshape'</a> 的支持。
multi_byte              编译时加入了 <a href="options.html#'encoding'">'encoding'</a> 的支持 (总为真)
multi_byte_encoding     <a href="options.html#'encoding'">'encoding'</a> 设为某个多字节的编码。
multi_byte_ime          编译时加入了 IME 输入方法的支持。
multi_lang              编译时加入了多语言的支持。
mzscheme                编译时加入了 MzScheme 接口支持  <a href="if_mzsch.html#mzscheme">mzscheme</a> 。
netbeans_enabled        编译时加入了  <a href="netbeans.html#netbeans">netbeans</a>  的支持并且已连接上。
netbeans_intg           编译时加入了  <a href="netbeans.html#netbeans">netbeans</a>  的支持。
num64                   编译时加入了64 位  <a href="eval.html#Number">Number</a>  的支持。
ole                     编译时加入了 Win32 OLE automation 的支持。
osx                     为 macOS 编译，参照 mac
osxdarwin               为 macOS 编译，带有  <a href="os_mac.html#mac-darwin-feature">mac-darwin-feature</a> 
packages                编译时加入了  <a href="repeat.html#packages">packages</a>  的支持。
path_extra              编译时加入了 <a href="options.html#'path'">'path'</a> 和 <a href="options.html#'tags'">'tags'</a> 上下搜索的支持。
perl                    编译时加入了 Perl 接口。
persistent_undo         编译时加入了持久化撤销历史的支持。
postscript              编译时加入了 PostScript 文件打印的支持。
printer                 编译时加入了  <a href="print.html#:hardcopy">:hardcopy</a>  的支持。
profile                 编译时加入了  <a href="repeat.html#:profile">:profile</a>  的支持。
python                  Python 2.x 接口可用。 <a href="if_pyth.html#has-python">has-python</a> 
python_compiled         编译时加入了 Python 2.x 接口。 <a href="if_pyth.html#has-python">has-python</a> 
python_dynamic          Python 2.x 接口已动态载入。 <a href="if_pyth.html#has-python">has-python</a> 
python3                 Python 3.x 接口可用。 <a href="if_pyth.html#has-python">has-python</a> 
python3_compiled        编译时加入了 Python 3.x 接口。 <a href="if_pyth.html#has-python">has-python</a> 
python3_dynamic         Python 3.x 接口已动态载入。 <a href="if_pyth.html#has-python">has-python</a> 
pythonx                 编译时加入了  <a href="if_pyth.html#python_x">python_x</a>  接口。 <a href="if_pyth.html#has-pythonx">has-pythonx</a> 
qnx                     Vim 的 QNX 版本。
quickfix                编译时加入了  <a href="quickfix.html#quickfix">quickfix</a>  的支持。
reltime                 编译时加入了  <a href="eval.html#reltime()">reltime()</a>  的支持。
rightleft               编译时加入了 <a href="options.html#'rightleft'">'rightleft'</a> 的支持。
ruby                    编译时加入了 Ruby 接口  <a href="if_ruby.html#ruby">ruby</a> 。
scrollbind              编译时加入了 <a href="options.html#'scrollbind'">'scrollbind'</a> 的支持。(总为真)
showcmd                 编译时加入了 <a href="options.html#'showcmd'">'showcmd'</a> 的支持。
signs                   编译时加入了  <a href="sign.html#:sign">:sign</a>  的支持。
smartindent             编译时加入了 <a href="options.html#'smartindent'">'smartindent'</a> 的支持。
sound                   编译时加入了声音的支持，例如  <a href="eval.html#sound_playevent()">sound_playevent()</a> 
spell                   编译时加入了拼写检查的支持  <a href="spell.html#spell">spell</a> 。
startuptime             编译时加入了  <a href="starting.html#--startuptime">--startuptime</a>  支持。
statusline              编译时加入了 <a href="options.html#'statusline'">'statusline'</a> 和 <a href="options.html#'rulerformat'">'rulerformat'</a> 还有
                        <a href="options.html#'titlestring'">'titlestring'</a> 和 <a href="options.html#'iconstring'">'iconstring'</a> 的特殊格式的支持。
sun                     Vim 的 SunOS 版本。
sun_workshop            删除了 Sun  <a href="workshop.html#workshop">workshop</a>  的支持。
syntax                  编译时加入了语法高亮的支持  <a href="syntax.html#syntax">syntax</a> 。
syntax_items            当前缓冲区有激活的语法高亮项目。
system                  编译时决定使用 system() 而不是 fork()/exec()。
tag_binary              编译时加入了标签文件的二分搜索  <a href="tagsrch.html#tag-binary-search">tag-binary-search</a> 。
tag_old_static          删除了老的静态标签的支持，见  <a href="tagsrch.html#tag-old-static">tag-old-static</a> 。
tcl                     编译时加入了 Tcl 接口。
termguicolors           编译时加入了终端的真彩支持。
terminal                编译时加入  <a href="terminal.html#terminal">terminal</a>  的支持。
terminfo                编译时决定使用 terminfo 而不是 termcap。
termresponse            编译时加入了  <a href="term.html#t_RV">t_RV</a>  和  <a href="eval.html#v:termresponse">v:termresponse</a>  的支持。
textobjects             编译时加入了  <a href="motion.html#text-objects">text-objects</a>  的支持。
textprop                编译时加入了  <a href="textprop.html#text-properties">text-properties</a>  的支持。
tgetent                 编译时加入了 tgetent 的支持，可以使用外部 termcap 或
                        terminfo 文件。
timers                  编译时加入了  <a href="eval.html#timer_start()">timer_start()</a>  支持。
title                   编译时加入了窗口标题的支持。 <a href="options.html#'title'">'title'</a> 。
toolbar                 编译时加入了  <a href="gui.html#gui-toolbar">gui-toolbar</a>  的支持。
ttyin                   输入是终端 (tty)
ttyout                  输出是终端 (tty)
unix                    Vim 的 Unix 版本。 <b class="vimtag"> <a name="+unix">+unix</a> </b>
unnamedplus             编译时加入了 <a href="options.html#'clipboard'">'clipboard'</a> 对 "unnamedplus" 的支持。
user_commands           用户定义命令支持。(总为真)
vartabs                 编译时加入了可变制表位的支持  <a href="options.html#'vartabstop'">'vartabstop'</a> 。
vcon                    Win32: 有虚拟终端支持，可用 <a href="options.html#'termguicolors'">'termguicolors'</a>。另见
                         <a href="various.html#+vtp">+vtp</a> 。
vertsplit               编译时加入了垂直分割窗口的支持  <a href="windows.html#:vsplit">:vsplit</a> 。(总为真)
vim_starting            如果在启动载入脚本的阶段则为真。 <a href="starting.html#startup">startup</a> 
                        <b class="vimtag"> <a name="vim_starting">vim_starting</a> </b>
viminfo                 编译时加入了 viminfo 的支持。
vimscript-1             编译时加入了 Vim 脚本版本 1 的支持
vimscript-2             编译时加入了 Vim 脚本版本 2 的支持
vimscript-3             编译时加入了 Vim 脚本版本 3 的支持
virtualedit             编译时加入了 <a href="options.html#'virtualedit'">'virtualedit'</a> 选项支持。(总为真)
visual                  编译时加入了可视模式的支持。(总为真)
visualextra             编译时加入了附加的可视模式命令支持。(总为真)
                         <a href="visual.html#blockwise-operators">blockwise-operators</a> 。
vms                     Vim 的 VMS 版本。
vreplace                编译时加入了  <a href="change.html#gR">gR</a>  和  <a href="change.html#gr">gr</a>  命令支持。(总为真)
vtp                     编译时加入了 vcon 支持  <a href="various.html#+vtp">+vtp</a>  (检查 vcon 可知当前控制
                        台是否支持)。
wildignore              编译时加入了 <a href="options.html#'wildignore'">'wildignore'</a> 选项支持。
wildmenu                编译时加入了 <a href="options.html#'wildmenu'">'wildmenu'</a> 选项支持。
win16                   旧版本 MS-Windows 3.1 (总为假)
win32                   Vim 的 Win32 版本。(MS-Windows 95 及其后的 32 或 64 位
                        版本)。
win32unix               Vim 的 Win32 版本。使用 Unix 文件命名 (Cygwin)
win64                   Vim 的 Win64 版本。(MS-Windows 64 位)。
win95                   支持 MS-Windows 95/98/ME 的 Win32 版本 (总为假)
winaltkeys              编译时加入了 <a href="options.html#'winaltkeys'">'winaltkeys'</a> 选项。
windows                 编译时加入了多窗口的支持。(总为真)
writebackup             编译时决定缺省打开 <a href="options.html#'writebackup'">'writebackup'</a>。
xfontset                编译时加入了 X 字体集 的支持。 <a href="mbyte.html#xfontset">xfontset</a> 。
xim                     编译时加入了 X 输入法 的支持。 <a href="mbyte.html#xim">xim</a> 。
xpm                     编译时加入了 pixmap 的支持。
xpm_w32                 编译时加入了 Win32 的 pixmap 的支持。(只为后向兼容而
                        保留，用 "xpm" 代替)
xsmp                    编译时加入了 X 会话管理 的支持。
xsmp_interact           编译时加入了交互的 X 会话管理 的支持。
xterm_clipboard         编译时加入了 xterm 剪贴板的支持。
xterm_save              编译时加入了保存和恢复 xterm 屏幕的支持。
x11                     编译时加入了 X11 的支持。

                                                        <b class="vimtag"> <a name="string-match">string-match</a> </b>
字符串里的模式匹配

 <a href="pattern.html#pattern">pattern</a>  说明的正规表达式通常用于寻找缓冲区行的匹配。如果匹配用来在字符串里寻
找匹配，几乎所有的功能都相同。唯一的区别是，字符串是作为单行处理的。如果字符串
里包含了 "\n" 字符，它并不看作是模式里的换行。它可以匹配模式里的 "\n"，甚至于
"."。示例: 
<code class="example">        :let a = "aaaa\nxxxx"</code>
<code class="example">        :echo matchstr(a, "..\n..")</code>
<code class="example">        aa</code>
<code class="example">        xx</code>
<code class="example">        :echo matchstr(a, "a.x")</code>
<code class="example">        a</code>
<code class="example">        x</code>
<code class="example"></code>
不要忘记 "^" 只会在字符串的第一个字符匹配，而 "$" 在字符串的最后一个字符匹配。
它们不会匹配 "\n" 之后和之前的位置。

</section><hr class="doubleline" /><section class=inner>
<h4>5. 定义函数                                             <b class="vimtag"> <a name="user-functions">user-functions</a> </b></h4>
可以定义新的函数。调用的方式就像内建函数一样。函数执行一系列 Ex 命令。普通模式
下的命令可以用  <a href="various.html#:normal">:normal</a>  命令执行。

函数名须以大写字母开始，以免和内建函数引起混淆。要避免在不同脚本使用相同的名
字，避免显见的或者过短的名字。一个好习惯是使用脚本名字作为函数名字的开头，比如
"HTMLcolor()"。

也可以使用花括号，见  <a href="eval.html#curly-braces-names">curly-braces-names</a> 。 <a href="eval.html#autoload">autoload</a>  机制可用于在调用时才提供
函数的定义。

                                                        <b class="vimtag"> <a name="local-function">local-function</a> </b>
局部于脚本的函数必须以 "s:" 开始。局部于脚本的函数只能在同一脚本和脚本中定义的
函数、用户命令和自动命令里调用。也可以在脚本定义的映射里调用该函数，但必须使用
 <a href="map.html#%3CSID%3E">&lt;SID&gt;</a>  而不是 "s:"，如果映射会在脚本之外被扩展的话。
只有局部于脚本的函数，没有局部于缓冲区或局部于窗口的函数。

                                        <b class="vimtag"> <a name=":fu">:fu</a> </b> <b class="vimtag"> <a name=":function">:function</a> </b> <b class="vimtag"> <a name="E128">E128</a> </b> <b class="vimtag"> <a name="E129">E129</a> </b> <b class="vimtag"> <a name="E123">E123</a> </b>
:fu[nction]             列出所有函数和它们的参数。

:fu[nction] <code class="special">{name}</code>      列出 <code class="special">{name}</code> 命名的函数。
                        <code class="special">{name}</code> 也可以是  <a href="eval.html#Funcref">Funcref</a>  类型的  <a href="eval.html#Dictionary">Dictionary</a>  项目: 
<code class="example">                                :function dict.init</code>
<code class="example"></code>
:fu[nction] /<code class="special">{pattern}</code>  列出名字匹配 <code class="special">{pattern}</code> 的函数。
                        列出所有以 "File" 结束的函数的例子: 
<code class="example">                                :function /File$</code>

                                                        <b class="vimtag"> <a name=":function-verbose">:function-verbose</a> </b>
如果 <a href="options.html#'verbose'">'verbose'</a> 非零，列出函数的同时也显示它上次定义的位置。例如: 
<code class="example"></code>
<code class="example">    :verbose function SetFileTypeSH</code>
<code class="example">        function SetFileTypeSH(name)</code>
<code class="example">            Last set from /usr/share/vim/vim-7.0/filetype.vim</code>

 <a href="various.html#:verbose-cmd">:verbose-cmd</a>  有更多信息。

                                                <b class="vimtag"> <a name="E124">E124</a> </b> <b class="vimtag"> <a name="E125">E125</a> </b> <b class="vimtag"> <a name="E853">E853</a> </b> <b class="vimtag"> <a name="E884">E884</a> </b>
:fu[nction][!] <code class="special">{name}</code>(<code class="special">[arguments]</code>) <code class="special">[range]</code> <code class="special">[abort]</code> <code class="special">[dict]</code> <code class="special">[closure]</code>
                        定义 <code class="special">{name}</code> 命名的新函数。函数体在之后的行给出，直到匹
                        配的  <a href="eval.html#:endfunction">:endfunction</a>  为止。

                        名字必须由字母数字和 '_' 字符组成，而且必须以大写字母
                        或者 "s:" 开头 (见上)。<code class="note">注意</code> "b:" 或 "g:" 是不允许的。(
                        从补丁 7.4.260 开始，如果函数名中有冒号，给出 E884，
                        如 "foo:bar()"。此补丁之前不报错)。

                        <code class="special">{name}</code> 也可以是  <a href="eval.html#Funcref">Funcref</a>  类型的  <a href="eval.html#Dictionary">Dictionary</a>  项目: 
<code class="example">                                :function dict.init(arg)</code>
                        "dict" 必须是一个已经存在的字典。如果还不存在，项目
                        "init" 被加入此字典。否则必须提供 [!] 以覆盖已经存在的
                        函数。返回指向一个编号函数的  <a href="eval.html#Funcref">Funcref</a> 。该函数只能通过
                         <a href="eval.html#Funcref">Funcref</a>  引用，没有引用指向它时，该函数会被删除。
                                                                <b class="vimtag"> <a name="E127">E127</a> </b> <b class="vimtag"> <a name="E122">E122</a> </b>
                        如果同名的函数已经存在而且没有使用 [!]，给出错误信息。
                        有一个例外: 再次执行脚本时，该脚本中之前定义过的函数会
                        被悄然替代。
                        如果给出 [!]，已有的函数被悄然替代。如果该函数正在执行
                        期间除外。此时，这是一个错误。
                        <code class="note">备注</code>: 小心使用 !。如果不小心，可能会意外地替代已有的函
                        数。这很难调试。

                        <code class="special">{arguments}</code> 参见  <a href="eval.html#function-argument">function-argument</a> 。

                                        <b class="vimtag"> <a name=":func-range">:func-range</a> </b> <b class="vimtag"> <a name="a:firstline">a:firstline</a> </b> <b class="vimtag"> <a name="a:lastline">a:lastline</a> </b>
                        如果给出 <code class="special">[range]</code> 参数，则该函数自己能理解并处理行范
                        围。该范围通过 "a:firstline" 和 "a:lastline" 定义。如
                        果没有 <code class="special">[range]</code>，":<code class="special">{range}</code>call" 会在该范围的每一行分别
                        执行该函数，每次光标都定位在处理行的行首。见
                         <a href="eval.html#function-range-example">function-range-example</a> 。
                        就像所有的 Ex 命令一样，光标仍然会被移动到范围的首行。
                                                                <b class="vimtag"> <a name=":func-abort">:func-abort</a> </b>
                        如果给出 <code class="special">[abort]</code> 参数，该函数在遇到错误时立即中止。
                                                                <b class="vimtag"> <a name=":func-dict">:func-dict</a> </b>
                        如果给出 <code class="special">[dict]</code> 参数，该函数必须通过  <a href="eval.html#Dictionary">Dictionary</a>  的项
                        目才能调用。局部变量 "self" 这时设为该字典。见
                         <a href="eval.html#Dictionary-function">Dictionary-function</a> 。
                                                <b class="vimtag"> <a name=":func-closure">:func-closure</a> </b> <b class="vimtag"> <a name="E932">E932</a> </b>
                        加入 <code class="special">[closure]</code> 参数时，函数可以访问外部作用域的变量和
                        参数。通常这被称为闭包。此例中 Bar() 使用 Foo() 作用
                        域的 "x"。即使 Foo() 返回后仍被引用: 
<code class="example">                                :function! Foo()</code>
<code class="example">                                :  let x = 0</code>
<code class="example">                                :  function! Bar() closure</code>
<code class="example">                                :    let x += 1</code>
<code class="example">                                :    return x</code>
<code class="example">                                :  endfunction</code>
<code class="example">                                :  return funcref('Bar')</code>
<code class="example">                                :endfunction</code>
<code class="example"></code>
<code class="example">                                :let F = Foo()</code>
<code class="example">                                :echo F()</code>
                                1 
<code class="example">                                :echo F()</code>
                                2 
<code class="example">                                :echo F()</code>
                                3


                                                <b class="vimtag"> <a name="function-search-undo">function-search-undo</a> </b>
                        最近使用的搜索模式和重做命令 "." 不会受到函数的影响。
                        这也意味着  <a href="pattern.html#:nohlsearch">:nohlsearch</a>  的效果在函数返回时会被撤销。

                                <b class="vimtag"> <a name=":endf">:endf</a> </b> <b class="vimtag"> <a name=":endfunction">:endfunction</a> </b> <b class="vimtag"> <a name="E126">E126</a> </b> <b class="vimtag"> <a name="E193">E193</a> </b> <b class="vimtag"> <a name="W22">W22</a> </b>
:endf[unction]          结束函数定义。最好单起一行，没有 <code class="special">[argument]</code>。

                        <code class="special">[argument]</code> 可以是:
                                | 命令          下面执行的命令
                                \n 命令         下面执行的命令
                                " 注释          总是忽略
                                其它            忽略，如果 <a href="options.html#'verbose'">'verbose'</a> 非零给出
                                                警告
                        对后续命令的支持是 Vim 8.0.0654 加入的，之前任何参数都
                        被悄悄地忽略。

                        要在  <a href="eval.html#:execute">:execute</a>  命令里定义函数，用换行符而不是
                         <a href="cmdline.html#:bar">:bar</a> : 
<code class="example">                                :exe "func Foo()\necho 'foo'\nendfunc"</code>

                                <b class="vimtag"> <a name=":delf">:delf</a> </b> <b class="vimtag"> <a name=":delfunction">:delfunction</a> </b> <b class="vimtag"> <a name="E130">E130</a> </b> <b class="vimtag"> <a name="E131">E131</a> </b> <b class="vimtag"> <a name="E933">E933</a> </b>
:delf[unction][!] <code class="special">{name}</code>
                        删除 <code class="special">{name}</code> 命名的函数。
                        <code class="special">{name}</code> 也可以是  <a href="eval.html#Funcref">Funcref</a>  类型的  <a href="eval.html#Dictionary">Dictionary</a>  项目: 
<code class="example">                                :delfunc dict.init</code>
                        会删除 "dict" 的 "init" 项目。如果没有更多指向它的引
                        用，该函数被删除。
                        用了 ! 后，即使函数不存在也不报错。
                                                <b class="vimtag"> <a name=":retu">:retu</a> </b> <b class="vimtag"> <a name=":return">:return</a> </b> <b class="vimtag"> <a name="E133">E133</a> </b>
:retu[rn] <code class="special">[expr]</code>        从函数返回。如果给出 "[expr]"，计算该表达式的结果成为
                        函数的返回值。如果没有给出 "[expr]"，返回 0。
                        如果函数退出时没有显式的调用 ":return"，返回 0。
                        <code class="note">注意</code> 没有不可到达行的检查，因而，如果有命令在
                        ":return" 之后，不会给出警告。

                        如果 ":return" 在  <a href="eval.html#:try">:try</a>  之后使用但在匹配的  <a href="eval.html#:finally">:finally</a> 
                        (如果有的话) 之前的话，":finally" 之后直到匹配的
                         <a href="eval.html#:endtry">:endtry</a>  的命令会先执行。该过程反复应用于所有函数内的
                        嵌套 ":try" 块。在最外层 ":endtry" 结束之后才真正返
                        回。


                                                <b class="vimtag"> <a name="function-argument">function-argument</a> </b> <b class="vimtag"> <a name="a:var">a:var</a> </b>
参数的定义只要给出它的名字。在函数里，可以使用 "a:name" 来访问 ("a:" 代表参数
(argument))。
                                        <b class="vimtag"> <a name="a:0">a:0</a> </b> <b class="vimtag"> <a name="a:1">a:1</a> </b> <b class="vimtag"> <a name="a:000">a:000</a> </b> <b class="vimtag"> <a name="E740">E740</a> </b> <b class="vimtag"> <a name="...">...</a> </b>
可以给出不超过 20 个参数，以逗号分隔。最后，可以给出参数 "..."，意味着可以有更
多的参数。在函数里，可以通过 "a:1"、"a:2" 等等访问它们。"a:0" 设为这些附加参数
的数目 (可以为 0)。"a:000" 设为包含这些参数的  <a href="eval.html#List">List</a> 。<code class="note">注意</code> "a:1" 等同于
"a:000[0]"。
                                                                <b class="vimtag"> <a name="E742">E742</a> </b>
a: 作用域和其中的变量不能修改，它们是固定的。不过，如果使用了复合类型，例如
 <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> ，可以改变它们的内容。这样就可以传递给函数一个  <a href="eval.html#List">List</a> ，
让该函数在里面增加项目。如果要确保函数不能修改  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> ，用
 <a href="eval.html#:lockvar">:lockvar</a> 。

可以定义没有参数的函数。但你这时仍然需要提供 ()。

可以在函数体里定义别的函数。

                                                <b class="vimtag"> <a name="optional-function-argument">optional-function-argument</a> </b>
可以提供位置命名参数的缺省值。这使得函数调用时它们成为可选参数。位置参数如果在
调用时不指定，则使用缺省表达式来初始化。
只用于  <a href="eval.html#:function">:function</a>  声明的函数，而不适用于匿名表达式  <a href="eval.html#expr-lambda">expr-lambda</a> 。

示例: 
<code class="example">  function Something(key, value = 10)</code>
<code class="example">     echo a:key .. ": " .. a:value</code>
<code class="example">  endfunction</code>
<code class="example">  call Something('empty')       "empty: 10"</code>
<code class="example">  call Something('key', 20)     "key: 20"</code>
<code class="example"></code>
参数的缺省表达式在函数调用时而非定义时进行计算。这样就可用函数定义时非法的表达
式。该表达式也只在调用中未指定参数时才进行计算。

可传递  <a href="eval.html#v:none">v:none</a>  来使用缺省表达式。<code class="note">注意</code> 这意味着参数如果有缺省表达式，你不能传
递 v:none 作为正常值。

示例: 
<code class="example">  function Something(a = 10, b = 20, c = 30)</code>
<code class="example">  endfunction</code>
<code class="example">  call Something(1, v:none, 3)      " b = 20</code>

                                                                <b class="vimtag"> <a name="E989">E989</a> </b>
带缺省表达式的可选参数必须在任何必选参数之后出现。"..." 可在所有可选命名参数之
后使用。

出现在后面的参数的缺省可引用在它之前的参数，反之不可以。就像所有参数一样，必须
使用 "a:" 前缀。

合法的例子: 
<code class="example">  :function Okay(mandatory, optional = a:mandatory)</code>
<code class="example">  :endfunction</code>
 <code class="emphasis">不</code> 合法的例子: 
<code class="example">  :function NoGood(first = a:second, second = 10)</code>
<code class="example">  :endfunction</code>

如果不使用 "..."，实际给出的参数数目必须等于必选参数的数目。如果使用 "..."，参
数的数目可以更多。

                                                        <b class="vimtag"> <a name="local-variables">local-variables</a> </b>
在函数里，可以使用局部变量。它们在函数返回时就会消失。全局变量的访问需要通过
"g:"。

例如: 
<code class="example">  :function Table(title, ...)</code>
<code class="example">  :  echohl Title</code>
<code class="example">  :  echo a:title</code>
<code class="example">  :  echohl None</code>
<code class="example">  :  echo a:0 . " items:"</code>
<code class="example">  :  for s in a:000</code>
<code class="example">  :    echon ' ' . s</code>
<code class="example">  :  endfor</code>
<code class="example">  :endfunction</code>
<code class="example"></code>
该函数这时可以这样调用: 
<code class="example">  call Table("Table", "line1", "line2")</code>
<code class="example">  call Table("Empty Table")</code>
<code class="example"></code>
要返回多于一个值，返回一个  <a href="eval.html#List">List</a> : 
<code class="example">  :function Compute(n1, n2)</code>
<code class="example">  :  if a:n2 == 0</code>
<code class="example">  :    return ["fail", 0]</code>
<code class="example">  :  endif</code>
<code class="example">  :  return ["ok", a:n1 / a:n2]</code>
<code class="example">  :endfunction</code>
<code class="example"></code>
该函数这时可以这样调用: 
<code class="example">  :let [success, div] = Compute(102, 6)</code>
<code class="example">  :if success == "ok"</code>
<code class="example">  :  echo div</code>
<code class="example">  :endif</code>

                                                <b class="vimtag"> <a name=":cal">:cal</a> </b> <b class="vimtag"> <a name=":call">:call</a> </b> <b class="vimtag"> <a name="E107">E107</a> </b> <b class="vimtag"> <a name="E117">E117</a> </b>
:<code class="special">[range]</code>cal[l] <code class="special">{name}</code>(<code class="special">[arguments]</code>)
                调用函数。函数名和参数通过  <a href="eval.html#:function">:function</a>  指定。可以使用不超过 20
                个参数。忽略返回值。
                如果没有给出范围而函数又接受范围，该函数被调用一次。如果给出范
                围，光标在执行函数前定位在该范围的第一行的开始。
                如果给出范围但函数自己不能处理之，该函数在范围里的每一行分别执
                行。光标定位在每个处理行的第一列。光标留在最后一行 (但可能被最
                后一个函数调用移动)。每一行上，参数被重新计算。所以这是可以的:
                                                <b class="vimtag"> <a name="function-range-example">function-range-example</a> </b>  
<code class="example">        :function Mynumber(arg)</code>
<code class="example">        :  echo line(".") . " " . a:arg</code>
<code class="example">        :endfunction</code>
<code class="example">        :1,5call Mynumber(getline("."))</code>

                "a:firstline" 和 "a:lastline" 总是有定义的。它们可以用来在范围
                的开始或结束处进行一些不同的处理。

                能处理范围本身的函数示例: 
<code class="example"></code>
<code class="example">        :function Cont() range</code>
<code class="example">        :  execute (a:firstline + 1) . "," . a:lastline . 's/^/\t\\ '</code>
<code class="example">        :endfunction</code>
<code class="example">        :4,8call Cont()</code>

                该函数在范围里的每行开头插入续行符 "\"，除了第一行以外。

                如果函数返回复合值，该值可被进一步解除参照 (<code class="vim">译者注</code>: 调用其上的
                方法)，但该范围不能被继续使用。例如: 
<code class="example">        :4,8call GetDict().method()</code>
                这里 GetDict() 得到范围值，method() 不会。

                                                                <b class="vimtag"> <a name="E132">E132</a> </b>
用户函数的递归调用受到  <a href="options.html#'maxfuncdepth'">'maxfuncdepth'</a>  选项的限制。

也可以使用  <a href="eval.html#:eval">:eval</a> 。不支持范围，但支持方法的链式调用，例如: 
<code class="example">        eval GetList()-&gt;Filter()-&gt;append('$')</code>
<code class="example"></code>
函数也可以在表达式计算的一部分或作为方法调用: 
<code class="example">        let x = GetList()</code>
<code class="example">        let y = GetList()-&gt;Filter()</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">自 动 载 入 函 数 </code>
                                                        <b class="vimtag"> <a name="autoload-functions">autoload-functions</a> </b>
如果使用很多或者很大的函数，可以在需要使用它们的时候才自动提供其定义。有两个方
法: 用自动命令，还有用 <a href="options.html#'runtimepath'">'runtimepath'</a> 里的 "autoload" 目录。


<code class="section">使用自动命令 </code>

用户手册  <a href="usr_41.html#41.14">41.14</a>  一节有介绍。

自动命令可用于很长的 Vim 脚本的插件。你可以定义自动命令然后用  <a href="repeat.html#:finish">:finish</a>  快速退
出脚本。这使得 Vim 启动快得多。这时，自动命令应该再次载入相同的文件，并设置变
量使得  <a href="repeat.html#:finish">:finish</a>  命令被跳过。

使用 FuncUndefined 自动命令事件，它需要一个能匹配等待定义的函数的模式。例如: 
<code class="example"></code>
<code class="example">        :au FuncUndefined BufNet* source ~/vim/bufnetfuncs.vim</code>
<code class="example"></code>
文件 "~/vim/bufnetfuncs.vim" 这时应该定义 "BufNet" 开始的函数。另见
 <a href="autocmd.html#FuncUndefined">FuncUndefined</a> 。


<code class="section">使用 autoload 脚本 </code>
                                                        <b class="vimtag"> <a name="autoload">autoload</a> </b> <b class="vimtag"> <a name="E746">E746</a> </b>
用户手册  <a href="usr_41.html#41.15">41.15</a>  一节有介绍。

在 "autoload" 目录里定义脚本更简单，但需要使用准确的文件名。能够自动载入的函数
的名字形如: 
<code class="example"></code>
<code class="example">        :call filename#funcname()</code>
<code class="example"></code>
这样的函数如果调用时还没有定义，Vim 在 <a href="options.html#'runtimepath'">'runtimepath'</a> 里的 "autoload" 目录搜索
脚本文件 "filename.vim"。例如 "~/.vim/autoload/filename.vim"。该文件这时应该这
样定义函数: 
<code class="example"></code>
<code class="example">        function filename#funcname()</code>
<code class="example">           echo "Done!"</code>
<code class="example">        endfunction</code>
<code class="example"></code>
文件名和函数的 # 之前的名字必须完全匹配，而定义的函数名也必须和调用时使用的形
式完全一致。

可以使用子目录。函数名每个 # 相当于路径分隔符。这样，调用函数: 
<code class="example"></code>
<code class="example">        :call foo#bar#func()</code>
<code class="example"></code>
的时候，Vim 寻找 <a href="options.html#'runtimepath'">'runtimepath'</a> 里的文件 "autoload/foo/bar.vim"。

也适用于读取还没有设置的变量: 
<code class="example"></code>
<code class="example">        :let l = foo#bar#lvar</code>
<code class="example"></code>
不过，如果 autoload 脚本已经载入，不会为未知的变量再次载入该脚本。

给这样的变量赋值并没有什么特别。这可以用于在载入 autoload 脚本之前给它传递一些
设置: 
<code class="example"></code>
<code class="example">        :let foo#bar#toggle = 1</code>
<code class="example">        :call foo#bar#func()</code>

<code class="note">注意</code> 如果你不小心调用了应该在 autoload 脚本里定义，但该脚本实际没有定义的函数
时，每次试图对该函数的调用都会重新载入一次脚本。从而每次都会得到错误信息。

还有，<code class="note">注意</code> 如果你有两个脚本文件，不能在使用的函数定义之前同时从一个文件里调用
另一个文件里的函数并且从那个文件里调用这个文件的函数。
避免在顶层使用自动载入功能。

提示: 如果你发布很多脚本，可以用  <a href="pi_vimball.html#vimball">vimball</a>  工具把它们捆绑在一起。另请阅读用户
手册  <a href="usr_41.html#distribute-script">distribute-script</a> 。

</section><hr class="doubleline" /><section class=inner>
<h4>6. 花括号名字                                           <b class="vimtag"> <a name="curly-braces-names">curly-braces-names</a> </b></h4>
多数使用变量的地方可以改用 "花括号名字" 变量。和常规的变量名类似，但可以包含一
到多个花括号 <code class="special">{}</code> 包围的表达式，形如: 
<code class="example">        my_{adjective}_variable</code>
<code class="example"></code>
如果 Vim 遇到这种情形，它会计算花括号内的表达式，把结果放在表达式所在的位置，
然后重新解释整个字符串为完整的变量名。所以在上例中，如果变量 "adjective" 设为
"noisy"，那么引用的将是 "my_noisy_variable"。如果 "adjective" 设为 "quiet"，那
么引用的将是 "my_quiet_variable"。

一个这种形式的应用是建立一系列变量，由一个选项管理。比如，语句 
<code class="example">        echo my_{&amp;background}_message</code>
<code class="example"></code>
会显示 "my_dark_message" 或者 "my_light_message" 的内容，取决于 <a href="options.html#'background'">'background'</a>
的当前值。

你可以使用多个花括号对: 
<code class="example">        echo my_{adverb}_{adjective}_message</code>
..甚至嵌套使用: 
<code class="example">        echo my_{ad{end_of_word}}_message</code>
其中 "end_of_word" 可以是 "verb" 或者 "jective"。

不过，花括号里的表达式必须计算出合法的单个变量名，比如，这不行: 
<code class="example">        :let foo='a + b'</code>
<code class="example">        :echo c{foo}d</code>
.. 因为扩展的结果是 "ca + bd"，这不是合法的变量名。

                                                <b class="vimtag"> <a name="curly-braces-function-names">curly-braces-function-names</a> </b>
类似的，你可以调用和定义计算的出的函数名。比如: 
<code class="example">        :let func_end='whizz'</code>
<code class="example">        :call my_func_{func_end}(parameter)</code>
<code class="example"></code>
会调用函数 "my_func_whizz(parameter)"。

这样 <code class="emphasis">不</code> 行: 
<code class="example">  :let i = 3</code>
<code class="example">  :let @{i} = ''  " 报错</code>
<code class="example">  :echo @{i}      " 报错</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>7. 命令                                                 <b class="vimtag"> <a name="expression-commands">expression-commands</a> </b></h4>
:let <code class="special">{var-name}</code> = <code class="special">{expr1}</code>                               <b class="vimtag"> <a name=":let">:let</a> </b> <b class="vimtag"> <a name="E18">E18</a> </b>
                        设置内部变量 <code class="special">{var-name}</code> 为表达式 <code class="special">{expr1}</code> 的计算结果。
                        该变量也会得到 <code class="special">{expr}</code> 的类型。如果 <code class="special">{var-name}</code> 不存在，
                        它会被创立。

:let <code class="special">{var-name}</code>[<code class="special">{idx}</code>] = <code class="special">{expr1}</code>                        <b class="vimtag"> <a name="E689">E689</a> </b>
                        设置列表项目为表达式 <code class="special">{expr1}</code> 的返回值。<code class="special">{var-name}</code> 必须
                        引用列表而 <code class="special">{idx}</code> 必须是该列表里合法的索引值。嵌套的列
                        表可以重复使用索引。
                        不能用于给列表  <a href="eval.html#List">List</a>  增加项目。
                        不能用来给字符串改变个别字节。为此你可以这么做: 
<code class="example">                                :let var = var[0:2] . 'X' . var[4:]</code>
                        如果 <code class="special">{var-name}</code> 是  <a href="eval.html#Blob">Blob</a> ，<code class="special">{idx}</code> 可以等于 blob 的长
                        度，此时附加一个字节。

                                                        <b class="vimtag"> <a name="E711">E711</a> </b> <b class="vimtag"> <a name="E719">E719</a> </b>
:let <code class="special">{var-name}</code>[<code class="special">{idx1}</code>:<code class="special">{idx2}</code>] = <code class="special">{expr1}</code>                <b class="vimtag"> <a name="E708">E708</a> </b> <b class="vimtag"> <a name="E709">E709</a> </b> <b class="vimtag"> <a name="E710">E710</a> </b>
                        设置  <a href="eval.html#List">List</a>  的一系列项目为表达式 <code class="special">{expr1}</code> 的返回值，后
                        者必须是正确数量项目的列表。
                        <code class="special">{idx1}</code> 可以省略，这时以零代替。
                        <code class="special">{idx2}</code> 可以省略，这时意味着到列表尾部。
                        如果选择的项目范围部分越过列表的尾部，会加入新的项目。

                        <b class="vimtag"> <a name=":let+%20">:let+=</a> </b> <b class="vimtag"> <a name=":let-%20">:let-=</a> </b> <b class="vimtag"> <a name=":letstar%20">:letstar=</a> </b>
                        <b class="vimtag"> <a name=":let%2F%20">:let/=</a> </b> <b class="vimtag"> <a name=":let%%20">:let%=</a> </b> <b class="vimtag"> <a name=":let.%20">:let.=</a> </b> <b class="vimtag"> <a name=":let..%20">:let..=</a> </b> <b class="vimtag"> <a name="E734">E734</a> </b> <b class="vimtag"> <a name="E985">E985</a> </b>
:let <code class="special">{var}</code> += <code class="special">{expr1}</code>   类似于 ":let <code class="special">{var}</code> = <code class="special">{var}</code> + <code class="special">{expr1}</code>"。
:let <code class="special">{var}</code> -= <code class="special">{expr1}</code>   类似于 ":let <code class="special">{var}</code> = <code class="special">{var}</code> - <code class="special">{expr1}</code>"。
:let <code class="special">{var}</code> *= <code class="special">{expr1}</code>   类似于 ":let <code class="special">{var}</code> = <code class="special">{var}</code> * <code class="special">{expr1}</code>"。
:let <code class="special">{var}</code> /= <code class="special">{expr1}</code>   类似于 ":let <code class="special">{var}</code> = <code class="special">{var}</code> / <code class="special">{expr1}</code>"。
:let <code class="special">{var}</code> %= <code class="special">{expr1}</code>   类似于 ":let <code class="special">{var}</code> = <code class="special">{var}</code> % <code class="special">{expr1}</code>"。
:let <code class="special">{var}</code> .= <code class="special">{expr1}</code>   类似于 ":let <code class="special">{var}</code> = <code class="special">{var}</code> . <code class="special">{expr1}</code>"。
:let <code class="special">{var}</code> ..= <code class="special">{expr1}</code>  类似于 ":let <code class="special">{var}</code> = <code class="special">{var}</code> .. <code class="special">{expr1}</code>"。
                        如果 <code class="special">{var}</code> 还没有设置或者 <code class="special">{var}</code> 和 <code class="special">{expr1}</code> 的类型不符
                        合操作符的要求，失败。
                        Vim 脚本版本 2 或之后不支持  <code class="badlink">.=</code>  ，见
                         <a href="eval.html#vimscript-version">vimscript-version</a> 。


:let $<code class="special">{env-name}</code> = <code class="special">{expr1}</code>                      <b class="vimtag"> <a name=":let-environment">:let-environment</a> </b> <b class="vimtag"> <a name=":let-$">:let-$</a> </b>
                        设置环境变量 <code class="special">{env-name}</code> 为表达式 <code class="special">{expr1}</code> 的计算结果。
                        它总是字符串型。

                        在有的系统中使环境变量为空会把它删除。很多系统不区别不
                        置位的环境变量和空的环境变量。

:let $<code class="special">{env-name}</code> .= <code class="special">{expr1}</code>
                        把 <code class="special">{expr1}</code> 附加到环境变量 <code class="special">{env-name}</code> 之后。如果该环境
                        变量还不存在，相当于 "="。

:let @<code class="special">{reg-name}</code> = <code class="special">{expr1}</code>                      <b class="vimtag"> <a name=":let-register">:let-register</a> </b> <b class="vimtag"> <a name=":let-@">:let-@</a> </b>
                        把表达式 <code class="special">{expr1}</code> 的计算结果写到寄存器 <code class="special">{reg-name}</code> 里。
                        <code class="special">{reg-name}</code> 必须是单个字符，而且是一个可以写入的寄存器
                        (见  <a href="change.html#registers">registers</a> )。"@@" 可以用来访问无名寄存器，而 "@/"
                        设置搜索模式。
                        如果 <code class="special">{expr1}</code> 的结果以 <code class="special">&lt;CR&gt;</code> 或 <code class="special">&lt;NL&gt;</code> 结束，该寄存器会成
                        为面向行类型，不然，它会成为面向字符类型。
                        这可以用来清除最近的搜索模式: 
<code class="example">                                :let @/ = ""</code>
                        这和搜索空字符串不同，后者会在任何地方得到匹配。

:let @<code class="special">{reg-name}</code> .= <code class="special">{expr1}</code>
                        把 <code class="special">{expr1}</code> 附加到寄存器 <code class="special">{reg-name}</code> 之后。如果寄存器为
                        空，相当于把它设为 <code class="special">{expr1}</code> 的值。

:let &amp;<code class="special">{option-name}</code> = <code class="special">{expr1}</code>                   <b class="vimtag"> <a name=":let-option">:let-option</a> </b> <b class="vimtag"> <a name=":let-&">:let-&amp;</a> </b>
                        设置选项 <code class="special">{option-name}</code> 为表达式 <code class="special">{expr1}</code> 的计算结果。字
                        符串或数值类型的值总会被转化为选项需要的类型。
                        对于局部于窗口或者缓冲区的选项而言，这和  <a href="options.html#:set">:set</a>  命令的
                        效果相同: 局部值和全局值都被改变。
                        例如: 
<code class="example">                                :let &amp;path = &amp;path . ',/usr/local/include'</code>
                        也可用于形如 t_xx 的终端代码。但只可用字母数字形式的名
                        字。例如: 
<code class="example">                                :let &amp;t_k1 = "\&lt;Esc&gt;[234;"</code>
                        如果代码还不存在，会新建一个终端键值，因此不会报错。

:let &amp;<code class="special">{option-name}</code> .= <code class="special">{expr1}</code>
                        对字符串选项: 附加 <code class="special">{expr1}</code> 到选项值之后。和  <a href="options.html#:set+%20">:set+=</a> 
                        不同，不会插入逗号。

:let &amp;<code class="special">{option-name}</code> += <code class="special">{expr1}</code>
:let &amp;<code class="special">{option-name}</code> -= <code class="special">{expr1}</code>
                        对数值或布尔选项: 加减 <code class="special">{expr1}</code>。

:let &amp;l:<code class="special">{option-name}</code> = <code class="special">{expr1}</code>
:let &amp;l:<code class="special">{option-name}</code> .= <code class="special">{expr1}</code>
:let &amp;l:<code class="special">{option-name}</code> += <code class="special">{expr1}</code>
:let &amp;l:<code class="special">{option-name}</code> -= <code class="special">{expr1}</code>
                        同上，但只设置选项的局部值 (如果有的话)。和
                         <a href="options.html#:setlocal">:setlocal</a>  类似。

:let &amp;g:<code class="special">{option-name}</code> = <code class="special">{expr1}</code>
:let &amp;g:<code class="special">{option-name}</code> .= <code class="special">{expr1}</code>
:let &amp;g:<code class="special">{option-name}</code> += <code class="special">{expr1}</code>
:let &amp;g:<code class="special">{option-name}</code> -= <code class="special">{expr1}</code>
                        同上，但只设置选项的全局值 (如果有的话)。和
                         <a href="options.html#:setglobal">:setglobal</a>  类似。

:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] = <code class="special">{expr1}</code>          <b class="vimtag"> <a name=":let-unpack">:let-unpack</a> </b> <b class="vimtag"> <a name="E687">E687</a> </b> <b class="vimtag"> <a name="E688">E688</a> </b>
                        <code class="special">{expr1}</code> 计算结果必须是  <a href="eval.html#List">List</a> 。该列表的第一项赋给
                        <code class="special">{name1}</code>，第二项给 <code class="special">{name2}</code>，依此类推。
                        命名的数量必须匹配  <a href="eval.html#List">List</a>  项目的数量。
                        每个名字必须是上面提到的 ":let" 命令的项目之一。
                        例如: 
<code class="example">                                :let [s, item] = GetItem(s)</code>
                        细节: 先计算 <code class="special">{expr1}</code>，然后按顺序依次进行赋值。如果
                        <code class="special">{name2}</code> 依赖于 <code class="special">{name1}</code>，该细节就有关系。例如: 
<code class="example">                                :let x = [0, 1]</code>
<code class="example">                                :let i = 0</code>
<code class="example">                                :let [i, x[i]] = [1, 2]</code>
<code class="example">                                :echo x</code>
                        结果是 [0, 2]。

:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] .= <code class="special">{expr1}</code>
:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] += <code class="special">{expr1}</code>
:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] -= <code class="special">{expr1}</code>
                        同上，但附加/加/减值到每个  <a href="eval.html#List">List</a>  项目。

:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] = <code class="special">{expr1}</code>
                        类似于上面的  <a href="eval.html#:let-unpack">:let-unpack</a> ，但  <a href="eval.html#List">List</a>  可以包含比给出名
                        字的数量更多的项目。列表其余项目赋给 <code class="special">{lastname}</code>。
                        如果没有余下的项目，<code class="special">{lastname}</code> 设为空列表。
                        例如: 
<code class="example">                                :let [a, b; rest] = ["aval", "bval", 3, 4]</code>

:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] .= <code class="special">{expr1}</code>
:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] += <code class="special">{expr1}</code>
:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] -= <code class="special">{expr1}</code>
                        同上，但附加/加/减值到每个  <a href="eval.html#List">List</a>  项目。

                                                <b class="vimtag"> <a name=":let%20%3C%3C">:let=&lt;&lt;</a> </b> <b class="vimtag"> <a name=":let-heredoc">:let-heredoc</a> </b>
                                                <b class="vimtag"> <a name="E990">E990</a> </b> <b class="vimtag"> <a name="E991">E991</a> </b> <b class="vimtag"> <a name="E172">E172</a> </b> <b class="vimtag"> <a name="E221">E221</a> </b>
:let <code class="special">{var-name}</code> =&lt;&lt; <code class="special">[trim]</code> <code class="special">{endmarker}</code>
text...
text...
<code class="special">{endmarker}</code>
                        设置内部变量 <code class="special">{var-name}</code> 为由 <code class="special">{endmarker}</code> 字符串定界的
                        文本行的列表。
                        <code class="special">{endmarker}</code> 不能包含空白。
                        <code class="special">{endmarker}</code> 不能以小写字母开头。
                        末行必须以 <code class="special">{endmarker}</code> 字符串结束，而不能有其它字符。
                        小心 <code class="special">{endmarker}</code> 之后的空白！

                        如果不给出 "trim" 保留文本行中的空白字符。如果
                        <code class="special">{endmarker}</code> 之前给出 "trim"，则删除缩进，所以可以这
                        样: 
<code class="example">                                let text =&lt;&lt; trim END</code>
<code class="example">                                   if ok</code>
<code class="example">                                     echo 'done'</code>
<code class="example">                                   endif</code>
<code class="example">                                END</code>
                        结果是: ["if ok", "  echo <code class="badlink">'done'</code>", "endif"]
                        marker 必须和 "let" 对齐，此时从所有文本行中删除首行的
                        缩进。
                        具体地说: 和首个非空文本行引导缩进完全一致的所有输入行
                        的缩引导进会被删除。
                        和  <code class="badlink">let</code>  之前的引导缩进完全一致的包含 <code class="special">{endmarker}</code> 的行
                        的所有的引导缩进也会被删除。
                        <code class="note">注意</code> 这里空格和制表是有区别的。

                        如果 <code class="special">{var-name}</code> 还不存在，会被创建。
                        不能跟在其它命令后面，但后面可以跟注释。

                        要避免续行符的使用，考虑在 <a href="options.html#'cpoptions'">'cpoptions'</a> 中加入 'C': 
<code class="example">                                set cpo+=C</code>
<code class="example">                                let var =&lt;&lt; END</code>
<code class="example">                                   \ leading backslash</code>
<code class="example">                                END</code>
<code class="example">                                set cpo-=C</code>

                        示例: 
<code class="example">                                let var1 =&lt;&lt; END</code>
<code class="example">                                Sample text 1</code>
<code class="example">                                    Sample text 2</code>
<code class="example">                                Sample text 3</code>
<code class="example">                                END</code>
<code class="example"></code>
<code class="example">                                let data =&lt;&lt; trim DATA</code>
<code class="example">                                        1 2 3 4</code>
<code class="example">                                        5 6 7 8</code>
<code class="example">                                DATA</code>

                                                                <b class="vimtag"> <a name="E121">E121</a> </b>
:let <code class="special">{var-name}</code> ..      列出变量 <code class="special">{var-name}</code> 的值。可以给出多个变量的名字。这里
                        识别特殊的名字包括:             <b class="vimtag"> <a name="E738">E738</a> </b>
                          g:    全局变量
                          b:    缓冲区的局部变量
                          w:    窗口的局部变量
                          t:    标签页的局部变量
                          s:    脚本的局部变量
                          l:    函数的局部变量
                          v:    Vim 变量。

:let                    列出所有变量的值。变量的类型在值之前给出:
                               &lt;空&gt;     字符串
                                #       数值
                                *       函数引用


:unl[et][!] <code class="special">{name}</code> ...                          <b class="vimtag"> <a name=":unlet">:unlet</a> </b> <b class="vimtag"> <a name=":unl">:unl</a> </b> <b class="vimtag"> <a name="E108">E108</a> </b> <b class="vimtag"> <a name="E795">E795</a> </b>
                        删除内部变量 <code class="special">{var-name}</code>。可以给出多个变量的名字。它们
                        都被删除。该名字也可以是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  项目。
                        如果使用 [!]，即使变量不存在也不会给出错误。
                         <a href="eval.html#List">List</a>  里可以删除一到多个项目: 
<code class="example">                                :unlet list[3]    " remove fourth item</code>
<code class="example">                                :unlet list[3:]   " remove fourth item to last</code>
                         <a href="eval.html#Dictionary">Dictionary</a>  里一次只能删除一个项目: 
<code class="example">                                :unlet dict['two']</code>
<code class="example">                                :unlet dict.two</code>
                        这对于清除全局和脚本局部变量很有用 (脚本结束时并不自动
                        删除这些变量)。函数局部变量在函数结束时是自动清除的。

:unl[et] $<code class="special">{env-name}</code> ...                        <b class="vimtag"> <a name=":unlet-environment">:unlet-environment</a> </b> <b class="vimtag"> <a name=":unlet-$">:unlet-$</a> </b>
                        删除环境变量 <code class="special">{env-name}</code>。
                        在一个 :unlet 命令里可以混合 <code class="special">{name}</code> 和 $<code class="special">{env-name}</code>。
                        不对不存在的变量报错，即使没有 ! 也是如此。
                        如果系统不支持删除环境变量，则将它清空。

                                                <b class="vimtag"> <a name=":cons">:cons</a> </b> <b class="vimtag"> <a name=":const">:const</a> </b>
:cons[t] <code class="special">{var-name}</code> = <code class="special">{expr1}</code>
:cons[t] [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] = <code class="special">{expr1}</code>
:cons[t] [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] = <code class="special">{expr1}</code>
:cons[t] <code class="special">{var-name}</code> =&lt;&lt; <code class="special">[trim]</code> <code class="special">{marker}</code>
text...
text...
<code class="special">{marker}</code>
                        和  <a href="eval.html#:let">:let</a>  类似，但设置值后额外地给变量加锁。等价于
                         <a href="eval.html#:let">:let</a>  之后立即用  <a href="eval.html#:lockvar">:lockvar</a>  给变量加锁，所以: 
<code class="example">                                :const x = 1</code>
                        等价于: 
<code class="example">                                :let x = 1</code>
<code class="example">                                :lockvar 1 x</code>
                        可用于保证变量之后不会被修改。
                                                        <b class="vimtag"> <a name="E995">E995</a> </b>
                         <a href="eval.html#:const">:const</a>  不能用来修改变量: 
<code class="example">                                :let x = 1</code>
<code class="example">                                :const x = 2  " Error!</code>
                                                        <b class="vimtag"> <a name="E996">E996</a> </b>
                        <code class="note">注意</code> 这里不能使用环境变量、选项值和寄存器值，因为它们
                        不能被锁定。

:cons[t]
:cons[t] <code class="special">{var-name}</code>
                        如果不给出参数或只给出 <code class="special">{var-name}</code>，等价于  <a href="eval.html#:let">:let</a> 。

:lockv[ar][!] <code class="special">[depth]</code> <code class="special">{name}</code> ...                        <b class="vimtag"> <a name=":lockvar">:lockvar</a> </b> <b class="vimtag"> <a name=":lockv">:lockv</a> </b>
                        给内部变量 <code class="special">{name}</code> 加锁。加锁意味着不能再修改该变量 (直
                        到它被解锁为止)。
                        加锁的变量可以删除: 
<code class="example">                                :lockvar v</code>
<code class="example">                                :let v = 'asdf'         " fails!</code>
<code class="example">                                :unlet v</code>
                                                        <b class="vimtag"> <a name="E741">E741</a> </b> <b class="vimtag"> <a name="E940">E940</a> </b>
                        如果试图修改加锁的变量，你会得到错误信息: "E741: Value
                        is locked: <code class="special">{name}</code>"。
                        如果试图加锁或解锁内建变量，会报错: "E940: Cannot lock
                        or unlock variable <code class="special">{name}</code>"。


                        给  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  加锁时用到 <code class="special">[depth]</code>。它决定加
                        锁到达的深度:
                                1       给  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  自身加锁。不
                                        能增加或者删除项目，但你可以修改它们的
                                        值。
                                2       给这些值加也锁，不能修改项目。如果项目
                                        是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> ，不能增加或
                                        删除其中项目，但仍然可以修改项目值。
                                3       同 2，但又适用于  <a href="eval.html#List">List</a>  /  <a href="eval.html#Dictionary">Dictionary</a> 
                                        中的  <a href="eval.html#List">List</a>  /  <a href="eval.html#Dictionary">Dictionary</a>  项目，更深
                                        一层。
                        缺省的 <code class="special">[depth]</code> 为 2，<code class="special">{name}</code> 是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 
                        时，不能修改项目值。
                                                                <b class="vimtag"> <a name="E743">E743</a> </b>
                        要使用没有限制的深度，用 [!] 并省略 <code class="special">[depth]</code>。不过，为
                        了捕获循环，设定最大深度为 100。

                        <code class="note">注意</code> 如果两个变量引用同一个  <a href="eval.html#List">List</a>  而你锁住其中一个，
                        通过另一个变量来访问  <a href="eval.html#List">List</a>  也同时被锁住。
                        例如: 
<code class="example">                                :let l = [0, 1, 2, 3]</code>
<code class="example">                                :let cl = l</code>
<code class="example">                                :lockvar l</code>
<code class="example">                                :let cl[1] = 99         " won't work!</code>
                        为了避免这一点，可以给列表建立备份。见  <a href="eval.html#deepcopy()">deepcopy()</a> 。


:unlo[ckvar][!] <code class="special">[depth]</code> <code class="special">{name}</code> ...                      <b class="vimtag"> <a name=":unlockvar">:unlockvar</a> </b> <b class="vimtag"> <a name=":unlo">:unlo</a> </b>
                        给内部变量 <code class="special">{name}</code> 解锁。和  <a href="eval.html#:lockvar">:lockvar</a>  刚好相反。


:if <code class="special">{expr1}</code>                     <b class="vimtag"> <a name=":if">:if</a> </b> <b class="vimtag"> <a name=":end">:end</a> </b> <b class="vimtag"> <a name=":endif">:endif</a> </b> <b class="vimtag"> <a name=":en">:en</a> </b> <b class="vimtag"> <a name="E171">E171</a> </b> <b class="vimtag"> <a name="E579">E579</a> </b> <b class="vimtag"> <a name="E580">E580</a> </b>
:en[dif]                如果 <code class="special">{expr}</code> 计算为非零，执行命令直到其后匹配的 ":else"
                        或者 ":endif" 为止。

                        从 Vim 版本 4.5 到 5.0，":if" 和 ":endif" 之间的 Ex 命
                        令被忽略。提供这两个命令只是为了后向兼容 (<code class="vim">译者注</code>，原文
                        如此)，以方便未来的扩展。可以嵌套。<code class="note">注意</code> 任何的 ":else"
                        或 ":elseif" 也被忽略，"else" 部分也一样不会执行。

                        利用这一点，你可以保持和旧版本的兼容: 
<code class="example">                                :if version &gt;= 500</code>
<code class="example">                                :  版本 5 专用的命令</code>
<code class="example">                                :endif</code>
                        为了找到 "endif"，仍然需要分析命令。有时，旧版本的 Vim
                        不能识别新的命令。比如， ":silent" 被识别为
                        ":substitute" 命令。这种情形可以用 ":execute" 来避
                        免: 
<code class="example">                                :if version &gt;= 600</code>
<code class="example">                                :  execute "silent 1,$delete"</code>
<code class="example">                                :endif</code>

                        <code class="note">注意</code>: ":append" 和 ":insert" 命令在 ":if" 和 ":endif"
                        之间不能正常工作。

                                                <b class="vimtag"> <a name=":else">:else</a> </b> <b class="vimtag"> <a name=":el">:el</a> </b> <b class="vimtag"> <a name="E581">E581</a> </b> <b class="vimtag"> <a name="E583">E583</a> </b>
:el[se]                 如果这之前的命令没有被执行，执行命令直到其后匹配的
                        ":else" 或 ":endif"。

                                        <b class="vimtag"> <a name=":elseif">:elseif</a> </b> <b class="vimtag"> <a name=":elsei">:elsei</a> </b> <b class="vimtag"> <a name="E582">E582</a> </b> <b class="vimtag"> <a name="E584">E584</a> </b>
:elsei[f] <code class="special">{expr1}</code>       ":else" ":if" 的缩写，而且无需另一个 ":endif"。

:wh[ile] <code class="special">{expr1}</code>                        <b class="vimtag"> <a name=":while">:while</a> </b> <b class="vimtag"> <a name=":endwhile">:endwhile</a> </b> <b class="vimtag"> <a name=":wh">:wh</a> </b> <b class="vimtag"> <a name=":endw">:endw</a> </b>
                                                <b class="vimtag"> <a name="E170">E170</a> </b> <b class="vimtag"> <a name="E585">E585</a> </b> <b class="vimtag"> <a name="E588">E588</a> </b> <b class="vimtag"> <a name="E733">E733</a> </b>
:endw[hile]             只要 <code class="special">{expr1}</code> 计算的结果非零，重复 ":while" 和
                        ":endwhile" 之间的命令。
                        如果发现循环里有命令出错，从 "endwhile" 之后继续执行。
                        例如: 
<code class="example">                                :let lnum = 1</code>
<code class="example">                                :while lnum &lt;= line("$")</code>
<code class="example">                                   :call FixLine(lnum)</code>
<code class="example">                                   :let lnum = lnum + 1</code>
<code class="example">                                :endwhile</code>

                        <code class="note">注意</code>: ":append" 和 ":insert" 命令在 ":while" 和 ":for"
                        循环里不能正常工作。

:for <code class="special">{var}</code> in <code class="special">{object}</code>                                  <b class="vimtag"> <a name=":for">:for</a> </b> <b class="vimtag"> <a name="E690">E690</a> </b> <b class="vimtag"> <a name="E732">E732</a> </b>
:endfo[r]                                               <b class="vimtag"> <a name=":endfo">:endfo</a> </b> <b class="vimtag"> <a name=":endfor">:endfor</a> </b>
                        为每个 <code class="special">{object}</code> 项目重复执行 ":for" 和 ":endfor" 之间
                        的命令。<code class="special">{object}</code> 可以是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Blob">Blob</a> 。变量 <code class="special">{var}</code>
                        设为每个项目的值。如果循环里某个命令出错，从 "endfor"
                        之后继续执行。
                        在循环里修改 <code class="special">{object}</code> 影响使用的项目。如果不希望如此，
                        构建一个备份: 
<code class="example">                                :for item in copy(mylist)</code>

                        如果 <code class="special">{object}</code> 为  <a href="eval.html#List">List</a>  且没有备份，Vim 在为当前项目执
                        行命令前保存列表里下一个项目的引用。这样，删除当前项目
                        不会影响循环的继续。而删除任何后来的项目也会使循环跳过
                        它。这意味着下例可以工作 (一个效率低下的清空列表的方
                        法): 
<code class="example">                                for item in mylist</code>
<code class="example">                                   call remove(mylist, 0)</code>
<code class="example">                                endfor</code>
                        <code class="note">注意</code> 给  <a href="eval.html#List">List</a>  调整顺序 (例如用 sort() 或 reverse())
                        可能会有意想不到的效果。

                        如果 <code class="special">{object}</code> 为  <a href="eval.html#Blob">Blob</a> ，Vim 总是先建立备份再循环。和
                         <a href="eval.html#List">List</a>  不同，对  <a href="eval.html#Blob">Blob</a>  的修改不影响循环。

:for [<code class="special">{var1}</code>, <code class="special">{var2}</code>, ...] in <code class="special">{listlist}</code>
:endfo[r]
                        和上面 ":for" 类似，但每个 <code class="special">{listlist}</code> 项目必须是列表，
                        其中每个项目被依次赋予 <code class="special">{var1}</code>、<code class="special">{var2}</code> 等。例如: 
<code class="example">                                :for [lnum, col] in [[1, 3], [2, 5], [3, 8]]</code>
<code class="example">                                   :echo getline(lnum)[col]</code>
<code class="example">                                :endfor</code>

                                                <b class="vimtag"> <a name=":continue">:continue</a> </b> <b class="vimtag"> <a name=":con">:con</a> </b> <b class="vimtag"> <a name="E586">E586</a> </b>
:con[tinue]             在 ":while" 或 ":for" 循环的内部，跳回循环开始的地方。
                        如果在循环内部的  <a href="eval.html#:try">:try</a>  之后但在匹配的  <a href="eval.html#:finally">:finally</a>  (如
                        果有的话) 之前，":finally" 之后，匹配的  <a href="eval.html#:endtry">:endtry</a>  之前
                        的命令会被先执行。该过程反复应用于所有函数内的嵌套
                        ":try" 块。在最外层 ":endtry" 结束之后才跳回循环的开始
                        处。

                                                <b class="vimtag"> <a name=":break">:break</a> </b> <b class="vimtag"> <a name=":brea">:brea</a> </b> <b class="vimtag"> <a name="E587">E587</a> </b>
:brea[k]                在 ":while" 或 ":for" 循环的内部，跳到相匹配的
                        ":endwhile" 或 ":endfor" 之后的命令。
                        如果在循环内部的  <a href="eval.html#:try">:try</a>  之后但在匹配的  <a href="eval.html#:finally">:finally</a>  (如
                        果有的话) 之前，":finally" 之后，匹配的  <a href="eval.html#:endtry">:endtry</a>  之前
                        的命令会被先执行。该过程反复应用于所有函数内的嵌套
                        ":try" 块。在最外层 ":endtry" 结束之后才跳到循环之后的
                        命令。

:try                            <b class="vimtag"> <a name=":try">:try</a> </b> <b class="vimtag"> <a name=":endt">:endt</a> </b> <b class="vimtag"> <a name=":endtry">:endtry</a> </b> <b class="vimtag"> <a name="E600">E600</a> </b> <b class="vimtag"> <a name="E601">E601</a> </b> <b class="vimtag"> <a name="E602">E602</a> </b>
:endt[ry]               改变 ":try" 和 ":endtry" 之间命令的错误处理，包括所有
                        执行的内容，":source" 里的命令，函数调用，或者自动命令
                        的激活等。

                        如果检测到错误或者中断，而其后又跟随了  <a href="eval.html#:finally">:finally</a>  命
                        令，执行从 ":finally" 之后继续。否则，或者在那以后遇到
                        了 ":endtry"，则检查是否存在 (动态的) 往外一层的
                        ":try" 以及其相应的 ":finally" 等等。然后，脚本的处理
                        被终止。(函数定义里是否有 "abort" 参数都不相干。)
                        示例: 
<code class="example">                :try | edit too much | finally | echo "cleanup" | endtry</code>
<code class="example">                :echo "impossible"      " 到不了这里，脚本在上面已经终止</code>

                        另外，":try" 和 ":endtry" 之间的错误或者中断 (动态地)
                        被转换成一个例外。它的捕获过程如同它被  <a href="eval.html#:throw">:throw</a>  命令抛
                        出那样 (见  <a href="eval.html#:catch">:catch</a> )。这种情况下，脚本的处理不会被终
                        止。

                        "Vim:Interrupt" 的值用于中断例外。Vim 命令的错误被转换
                        成形如 "Vim(<code class="special">{command}</code>):<code class="special">{errmsg}</code>" 的值，其它错误被转换
                        成形如 "Vim:<code class="special">{errmsg}</code>"。这里，<code class="special">{command}</code> 是完整的命令
                        名，而 <code class="special">{errmsg}</code> 是错误例外如果没有被捕获的时候会显示的
                        消息，它总以错误号开始。
                        示例: 
<code class="example">                :try | sleep 100 | catch /^Vim:Interrupt$/ | endtry</code>
<code class="example">                :try | edit | catch /^Vim(edit):E\d\+/ | echo "error" | endtry</code>

                                        <b class="vimtag"> <a name=":cat">:cat</a> </b> <b class="vimtag"> <a name=":catch">:catch</a> </b> <b class="vimtag"> <a name="E603">E603</a> </b> <b class="vimtag"> <a name="E604">E604</a> </b> <b class="vimtag"> <a name="E605">E605</a> </b>
:cat[ch] /<code class="special">{pattern}</code>/    匹配 <code class="special">{pattern}</code> 的例外抛出时，如果它没有被前一个
                        ":catch" 捕获，则执行本语句之后的命令，直到遇到和本
                        ":catch" 处于同一  <a href="eval.html#:try">:try</a>  块的下一个  <a href="eval.html#:catch">:catch</a> 、
                         <a href="eval.html#:finally">:finally</a>  或者  <a href="eval.html#:endtry">:endtry</a>  为止。否则，这些命令被跳过。
                        如果没有提供 <code class="special">{pattern}</code>，所有的错误都会被捕获。
                        示例: 
<code class="example">                :catch /^Vim:Interrupt$/         " 捕获中断 (CTRL-C)</code>
<code class="example">                :catch /^Vim\%((\a\+)\)\=:E/     " 捕获所有的 Vim 错误</code>
<code class="example">                :catch /^Vim\%((\a\+)\)\=:/      " 捕获错误和中断</code>
<code class="example">                :catch /^Vim(write):/            " 捕获所有 :write 的错误</code>
<code class="example">                :catch /^Vim\%((\a\+)\)\=:E123:/ " 捕获错误 E123</code>
<code class="example">                :catch /my-exception/            " 捕获用户例外</code>
<code class="example">                :catch /.*/                      " 捕获一切</code>
<code class="example">                :catch                           " 等同于 /.*/</code>

                        除了 / 以外，也可以用别的字符包围 <code class="special">{pattern}</code>，只要它没
                        有特殊含义 (比如 '|' 或 '"') 而且不出现在 <code class="special">{pattern}</code>
                        里。
                        关于例外的信息可见  <a href="eval.html#v:exception">v:exception</a> 。另见
                         <a href="eval.html#throw-variables">throw-variables</a> 。
                        <code class="note">注意</code>: 依赖 ":catch" 去捕获错误信息的 <code class="emphasis">文本</code> 是不可靠的，
                        因为不同的 locale 的信息可以不同。

                                        <b class="vimtag"> <a name=":fina">:fina</a> </b> <b class="vimtag"> <a name=":finally">:finally</a> </b> <b class="vimtag"> <a name="E606">E606</a> </b> <b class="vimtag"> <a name="E607">E607</a> </b>
:fina[lly]              任何匹配的  <a href="eval.html#:try">:try</a>  和本 ":finally" 之间的部分要离开的时
                        候都执行本语句之后的命令，直到遇到匹配的  <a href="eval.html#:endtry">:endtry</a>  为
                        止。包括这些情形: 正常完成且要执行到 ":finally"，通过
                         <a href="eval.html#:continue">:continue</a> 、 <a href="eval.html#:break">:break</a> 、 <a href="repeat.html#:finish">:finish</a>  或  <a href="eval.html#:return">:return</a> ，或者由
                        于错误或者中断或者例外 (见  <a href="eval.html#:throw">:throw</a> )。

                                                        <b class="vimtag"> <a name=":th">:th</a> </b> <b class="vimtag"> <a name=":throw">:throw</a> </b> <b class="vimtag"> <a name="E608">E608</a> </b>
:th[row] <code class="special">{expr1}</code>        计算 <code class="special">{expr1}</code> 然后抛出例外。如果 ":throw" 在  <a href="eval.html#:try">:try</a>  之
                        后但在第一个对应的  <a href="eval.html#:catch">:catch</a>  之前使用，它之后的命令被跳
                        过，直到遇到第一个匹配 <code class="special">{expr1}</code> 为止。如果没有这样的
                        ":catch"，或者如果 ":throw" 在 ":catch" 之后
                         <a href="eval.html#:finally">:finally</a>  之前使用，执行 ":finally" (如果有的话) 之后
                        直到匹配的  <a href="eval.html#:endtry">:endtry</a>  为止的命令。如果本 ":throw" 在
                        ":finally" 之后之后出现，直到 ":endtry" 为止的命令都被
                        跳过。到达 ":endtry" 的时候，在动态计算的往外一层的
                        ":try" 块上再次重复本过程 (这可能出现在外层调用的函数
                        或者执行的脚本上)，直到找到一个匹配的 ":catch"。如果最
                        终该例外没有被捕获，命令处理被终止。
                        示例: 
<code class="example">                :try | throw "oops" | catch /^oo/ | echo "caught" | endtry</code>
                        <code class="note">注意</code> "catch" 可能需要放在单独一行上，因为某些错误可以
                        导致整行在解析时被跳过而无法看到分隔命令的 "|"。

                                                        <b class="vimtag"> <a name=":ec">:ec</a> </b> <b class="vimtag"> <a name=":echo">:echo</a> </b>
:ec[ho] <code class="special">{expr1}</code> ..      回显每个 <code class="special">{expr1}</code>，以空格分隔。第一个 <code class="special">{expr1}</code> 开启一个
                        新行。另见  <a href="cmdline.html#:comment">:comment</a> 。
                        使用 "\n" 来开启新行。使用 "\r" 把光标移到第一列。
                        使用  <a href="eval.html#:echohl">:echohl</a>  命令的高亮设置。
                        后面不能跟注释。
                        示例: 
<code class="example">                :echo "'shell' 的值是 " &amp;shell</code>
                                                        <b class="vimtag"> <a name=":echo-redraw">:echo-redraw</a> </b>
                        后来的重画可能使消息再次消失。因为 Vim 常常会推迟重画
                        直到整个命令序列执行完为止，这个问题会频繁出现。要避免
                        ":echo" 之前的命令引起它之后的重画 (通常，重画被延迟到
                        有输入的时候才进行)，使用  <a href="various.html#:redraw">:redraw</a>  命令强制重画。例
                        如: 
<code class="example">                :new | redraw | echo "这里有一个新窗口"</code>

                                                        <b class="vimtag"> <a name=":echon">:echon</a> </b>
:echon <code class="special">{expr1}</code> ..       回显每个 <code class="special">{expr1}</code>，不附加其它字符。另见  <a href="cmdline.html#:comment">:comment</a> 。
                        使用  <a href="eval.html#:echohl">:echohl</a>  命令的高亮设置。
                        后面不能跟注释。
                        例如: 
<code class="example">                                :echon "'shell' 的值是 " &amp;shell</code>

                        <code class="note">注意</code> 两者的区别: ":echo" 是一个 Vim 命令，而 ":!echo"
                        是一个外部的外壳命令: 
<code class="example">                :!echo %                --&gt; filename</code>
                        ":!" 的参数被扩展，见  <a href="cmdline.html#:_%">:_%</a> 。 
<code class="example">                :!echo "%"              --&gt; filename or "filename"</code>
                        和前例类似，你是否会看到双引号取决于你的 <a href="options.html#'shell'">'shell'</a>。 
<code class="example">                :echo %                 --&gt; nothing</code>
                        '%' 不是一个表达式合法的字符。 
<code class="example">                :echo "%"               --&gt; %</code>
                        只会回显 '%' 字符。 
<code class="example">                :echo expand("%")       --&gt; filename</code>
                        调用 expand() 函数来扩展 '%'。

                                                        <b class="vimtag"> <a name=":echoh">:echoh</a> </b> <b class="vimtag"> <a name=":echohl">:echohl</a> </b>
:echoh[l] <code class="special">{name}</code>        让其后的  <a href="eval.html#:echo">:echo</a> 、 <a href="eval.html#:echon">:echon</a>  和  <a href="eval.html#:echomsg">:echomsg</a>  命令使用高亮
                        组 <code class="special">{name}</code>。也可用于  <a href="eval.html#input()">input()</a>  的提示。示例: 
<code class="example">                :echohl WarningMsg | echo "Don't panic!" | echohl None</code>
                        不要忘记把组设回 "None"。不然其后的 echo 都会被高亮。

                                                        <b class="vimtag"> <a name=":echom">:echom</a> </b> <b class="vimtag"> <a name=":echomsg">:echomsg</a> </b>
:echom[sg] <code class="special">{expr1}</code> ..   回显表达式的结果，将其作为一个真正的消息，并把该消息保
                        存在  <a href="message.html#message-history">message-history</a>  里。
                        参数之间加入空格，和  <a href="eval.html#:echo">:echo</a>  类似。但不可显示的字符只
                        是回显而不会被解释。
                        这里的分析过程和  <a href="eval.html#:echo">:echo</a>  略有不同，而更像  <a href="eval.html#:execute">:execute</a> 。
                        所有的表达式都先经计算后进行连接，然后再进行回显。
                        如果表达式返回的不是数值或字符串，使用 string() 把它转
                        化为字符串。
                        应用  <a href="eval.html#:echohl">:echohl</a>  命令的高亮设置。
                        示例: 
<code class="example">                :echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."</code>
                         <a href="eval.html#:echo-redraw">:echo-redraw</a>  说明如何避免屏幕重画时消息的消失问题。
                                                        <b class="vimtag"> <a name=":echoe">:echoe</a> </b> <b class="vimtag"> <a name=":echoerr">:echoerr</a> </b>
:echoe[rr] <code class="special">{expr1}</code> ..   回显表达式的结果，将其作为一个错误消息，并把该消息保
                        存在  <a href="message.html#message-history">message-history</a>  里。如果用在脚本或函数里，会加
                        入行号。
                        参数之间加入空格的方法和  <a href="eval.html#:echomsg">:echomsg</a>  类似。如果在 try
                        条件句里使用，该消息会抛出一个错误例外 (见
                         <a href="eval.html#try-echoerr">try-echoerr</a> )。
                        示例: 
<code class="example">                :echoerr "This script just failed!"</code>
                        如果你只想要使用  <a href="eval.html#:echohl">:echohl</a>  高亮的消息。
                        要得到铃声: 
<code class="example">                :exe "normal \&lt;Esc&gt;"</code>

                                                        <b class="vimtag"> <a name=":eval">:eval</a> </b>
:eval <code class="special">{expr}</code>            计算 <code class="special">{expr}</code> 并忽略其返回值。例如: 
<code class="example">                                :eval Getlist()-&gt;Filter()-&gt;append('$')</code>
<code class="example"></code>
                        因为不使用返回值，表达式假定有副作用。此例中
                         <a href="eval.html#append()">append()</a>  调用会在缓冲区后附加列表中的文本。它类似于
                         <a href="eval.html#:call">:call</a> ，但可用于所有表达式。

                        此命令本可缩短为  <code class="badlink">:ev</code>  或  <code class="badlink">:eva</code> ，但不易记，所以不提
                        供。


                                                        <b class="vimtag"> <a name=":exe">:exe</a> </b> <b class="vimtag"> <a name=":execute">:execute</a> </b>
:exe[cute] <code class="special">{expr1}</code> ..   计算 <code class="special">{expr1}</code>，返回的字符串作为 Ex 命令执行。
                        多个参数用空格连接。如果不想有额外的空格，使用 "." 操
                        作符来连接字符串使之成为一个参数。
                        <code class="special">{expr1}</code> 用作被处理的命令，命令行编辑的键不会被识别。
                        后面不能跟注释。
                        示例: 
<code class="example">                :execute "buffer" nextbuf</code>
<code class="example">                :execute "normal" count . "w"</code>

                        ":execute" 可以用来把命令附加到不能接受 '|' 的命令后
                        面。比如: 
<code class="example">                :execute '!ls' | echo "theend"</code>
<code class="example"></code>
                        ":execute" 也是一个避免在 Vim 脚本里为 ":normal" 命令
                        输入控制字符的好方法: 
<code class="example">                :execute "normal ixxx\&lt;Esc&gt;"</code>
                        这里给出一个 <code class="special">&lt;Esc&gt;</code> 字符，见  <a href="eval.html#expr-string">expr-string</a> 。

                        要谨慎对待文件名中特殊字符的正确转义。 <a href="eval.html#fnameescape()">fnameescape()</a> 
                        可用于 Vim 命令， <a href="eval.html#shellescape()">shellescape()</a>  可用于  <a href="various.html#:!">:!</a>  命令。示
                        例: 
<code class="example">                :execute "e " . fnameescape(filename)</code>
<code class="example">                :execute "!ls " . shellescape(filename, 1)</code>

                        <code class="note">注意</code>: 执行的字符串可以是任何命令行，但开始或结束一个
                        "if"、"while" 和 "for" 命令不能保证没有问题，因为跳过
                        命令时，不执行 ":execute"，Vim 就不能准确找到块开始和
                        结束的地方。另外，"break" 和 "continue" 不应出现在
                        ":execute" 内部。
                        下例不能工作，因为 ":execute" 不被执行，Vim 看不见
                        ":while"，找到 ":endwhile" 时就报错: 
<code class="example">                :if 0</code>
<code class="example">                : execute 'while i &gt; 5'</code>
<code class="example">                :  echo "test"</code>
<code class="example">                : endwhile</code>
<code class="example">                :endif</code>

                        但如果执行的字符串里有完整的 "while" 和 "if" 命令就没
                        有问题: 
<code class="example">                :execute 'while i &lt; 5 | echo i | let i = i + 1 | endwhile'</code>


                                                        <b class="vimtag"> <a name=":exe-comment">:exe-comment</a> </b>
                        ":execute"、":echo" 和 ":echon" 后面不能直接跟注释。
                        因它们把 '"' 看成字符串的开始。但你可以把注释加到 '|'
                        后面。例如: 
<code class="example">                :echo "foo" | "这是一个注释</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>8. 例外处理                                             <b class="vimtag"> <a name="exception-handling">exception-handling</a> </b></h4>
Vim 脚本语言包含了例外处理特性。本节解释如何在 Vim 脚本里应用该机制。

Vim 在出错或者中断的时候可以抛出例外。见  <a href="eval.html#catch-errors">catch-errors</a>  和  <a href="eval.html#catch-interrupt">catch-interrupt</a> 。
你也可以显式地使用 ":throw" 命令抛出例外。见  <a href="eval.html#throw-catch">throw-catch</a> 。


TRY 条 件 句                                            <b class="vimtag"> <a name="try-conditionals">try-conditionals</a> </b>

例外可以被捕获或者用来激发清理代码的运行。你可以使用 try 条件句来指定 catch 子
句 (捕获例外) 和/或 finally 子句 (执行清理)。
   try 条件句以  <a href="eval.html#:try">:try</a>  命令开始，以匹配的  <a href="eval.html#:endtry">:endtry</a>  命令结束。两者之间，你可以
使用  <a href="eval.html#:catch">:catch</a>  命令开始 catch 子句，或者用  <a href="eval.html#:finally">:finally</a>  命令开始 finally 子句。
catch 子句可有零到多个，但 finally 子句至多只有一个，且它之后不能再有 catch 子
句。catch 子句和 finally 子句之前的行称为 try 块。

     :try
     :  ...
     :  ...                             TRY 块
     :  ...
     :catch /<code class="special">{pattern}</code>/
     :  ...
     :  ...                             CATCH 子 句
     :  ...
     :catch /<code class="special">{pattern}</code>/
     :  ...
     :  ...                             CATCH 子 句
     :  ...
     :finally
     :  ...
     :  ...                             FINALLY 子 句
     :  ...
     :endtry

try 子句允许观察代码里是否有例外，并采取合适的行动。try 块里的例外可能被捕获。
try 块和 catch 子句里的例外可能引起清理动作。
   如果 try 块的执行过程中没有抛出例外，控制转移到 finally 子句。在它执行后，
脚本从 ":endtry" 之后的行继续。
   如果 try 块的执行过程中抛出了例外，该 try 块其余的行被跳过。例外和 ":catch"
命令的模式参数一一比较。第一个匹配的 ":catch" 之后的 catch 子句被采用，其余的
catch 子句则不会执行。catch 子句在下一个最早遇到的 ":catch"、":finally" 或
":endtry" 命令结束。这时，finally 子句 (如果有的话) 被执行。当遇到 ":endtry"
的时候，脚本从后面的行继续，一如往常。
   如果 try 块抛出的例外不能匹配任何 ":catch" 命令的模式，该例外不能由本 try
条件句捕获，因而不会执行任何的 catch 子句。只有 finally 子句，如果有的话，被采
用。该例外在 finally 子句的执行时被暂时搁置。在 ":endtry" 之后才继续。这样，
":endtry" 之后的命令不会被执行，而该例外可以在别的地方捕获，见  <a href="eval.html#try-nesting">try-nesting</a> 。
   如果在 catch 子句的执行过程中抛出了另一个错误，catch 子句的其余部分不再执
行。新的例外不会和试图和同一个 try 条件句的任何 ":catch" 命令的模式匹配，因而
也不会执行任何它的 catch 子句。不过，如果有 finally 子句，它还是会被执行，而在
它的执行过程中暂时搁置新的例外。":endtry" 之后的命令也不会执行。而新的例外仍可
能在别的地方捕获，见  <a href="eval.html#try-nesting">try-nesting</a> 。
   如果在 finally 子句 (如果有的话) 的执行过程中抛出了另一个错误，finally 子句
的其余部分不再执行。如果 finally 子句是因为 try 块或者某个 catch 子句里产生的
例外引起的，原先的 (被暂时搁置的) 例外被放弃。":endtry" 之后的命令也不会执行。
而 finally 子句的这个例外被传播，而可以在别的地方捕获，见  <a href="eval.html#try-nesting">try-nesting</a> 。

在 ":while" 循环包含的完整的 try 条件句里的 try 块或者某个 catch 子句里遇到
":break" 或 ":continue" 时，或者在函数或者被执行的脚本里的 try 条件句里的 try
块或者某个 catch 子句里执行 ":return" (函数) 或者 ":finish" (脚本) 的时候，也
会执行 finally 子句。":break"、":continue"、":return" 或者 ":finish" 在
finally 子句的执行时被暂停，而在遇到 ":endtry" 时继续。不过，如果在执行
finally 子句时抛出例外，它们都被抛弃。
   在 ":while" 循环包含的完整的 try 条件句里的 finally 子句里遇到 ":break" 或
":continue" 时，或者在函数或者被执行的脚本里的 finally 子句里执行 ":return" (
函数) 或者 ":finish" (脚本) 的时候，finally 子句的其余部分被跳过，而
":break"、":continue"、":return" 或 ":finish" 会如常继续执行。如果 finally 的
执行是因为例外或者早先的 try 块或者 catch 子句的 ":break"、":continue"、
":return" 或者 ":finish" 引起的，暂停的例外或者命令被放弃。

例子可见  <a href="eval.html#throw-catch">throw-catch</a>  和  <a href="eval.html#try-finally">try-finally</a> 。


TRY 条 件 句 的 嵌 套                                   <b class="vimtag"> <a name="try-nesting">try-nesting</a> </b>

try 条件句可以任意嵌套。也就是说，完整的 try 条件句可以在另一个 try 条件句的
try 块、某个 catch 子句或者 finally 子句里出现。如果内层的 try 条件句不能捕获
它的 try 块抛出的例外，或者在它的某个 catch 子句后者 finally 子句里抛出新的例
外的话，那么根据上述规则由外层的 try 条件句继续检查是否能捕获该例外。如果内层
try 条件句在外层 try 条件句的 try 块里，检查外层的 catch 子句，不然只有
finally 子句会被执行。对嵌套的处理而言，内层 try 条件句是直接包含在外层里面，
还是外层执行了脚本或者调用了函数，而后者又包含了内层 try 条件句，无关紧要。

如果没有活动的 try 条件句能捕获某个例外，只有它们的 finally 子句会执行。最后，
脚本结束它的处理。如果是 ":throw" 命令显式地抛出的未捕获的例外，显示错误信息。
对于 Vim 隐含抛出的未捕获的错误或者中断例外，错误信息或者中断信息也会像平常一
样显示。

例子可见  <a href="eval.html#throw-catch">throw-catch</a> 。


检 查 例 外 处 理 代 码                                 <b class="vimtag"> <a name="except-examine">except-examine</a> </b>

例外处理的代码的编写可能很麻烦。如果你不知道发生了什么，把 <a href="options.html#'verbose'">'verbose'</a> 设为 13，
或者在执行脚本文件时使用 ":13verbose" 命令修饰符。这样，你能看到什么时候例外被
抛出、放弃、捕获、或者最终处理。如果详细程度大于等于 14，finally 子句暂停什么
也会显示。这些信息在调试模式里也会给出 (见  <a href="repeat.html#debug-scripts">debug-scripts</a> )。


抛 出 和 捕 获 例 外                                    <b class="vimtag"> <a name="throw-catch">throw-catch</a> </b>

你可以抛出任何数值或者字符串作为例外。使用  <a href="eval.html#:throw">:throw</a>  命令然后把要抛出的值作为参
数传入: 
<code class="example">        :throw 4711</code>
<code class="example">        :throw "string"</code>
                                                        <b class="vimtag"> <a name="throw-expression">throw-expression</a> </b>
你可以指定表达式参数。该表达式先进行计算，然后抛出其结果: 
<code class="example">        :throw 4705 + strlen("string")</code>
<code class="example">        :throw strpart("strings", 0, 6)</code>
<code class="example"></code>
在计算 ":throw" 命令的参数的时候，也可能会抛出例外。除非它被捕获，不然表达式的
计算会被放弃。":throw" 命令这时不会抛出新的例外。
   例如: 
<code class="example"></code>
<code class="example">        :function! Foo(arg)</code>
<code class="example">        :  try</code>
<code class="example">        :    throw a:arg</code>
<code class="example">        :  catch /foo/</code>
<code class="example">        :  endtry</code>
<code class="example">        :  return 1</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Bar()</code>
<code class="example">        :  echo "in Bar"</code>
<code class="example">        :  return 4710</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :throw Foo("arrgh") + Bar()</code>
<code class="example"></code>
这里抛出了 "arrgh"，而不会显示 "in Bar"，因为 Bar() 没有执行。 
<code class="example">        :throw Foo("foo") + Bar()</code>
却显示 "in Bar" 并且抛出 4711。

别的接受表达式作为参数的命令也可能因为表达式计算过程的 (未捕获的) 例外而被放
弃。例外这时被传播给该命令的调用者。
   例如: 
<code class="example"></code>
<code class="example">        :if Foo("arrgh")</code>
<code class="example">        :  echo "then"</code>
<code class="example">        :else</code>
<code class="example">        :  echo "else"</code>
<code class="example">        :endif</code>
<code class="example"></code>
这里 "then" 和 "else" 都不会显示。

                                                        <b class="vimtag"> <a name="catch-order">catch-order</a> </b>
try 条件句里的例外可以用一个或多个  <a href="eval.html#:catch">:catch</a>  命令捕获，见  <a href="eval.html#try-conditionals">try-conditionals</a> 。
每个 ":catch" 命令可以捕获的值通过模式参数指定。捕获匹配的例外时，执行其后的
catch 子句。
   例如: 
<code class="example"></code>
<code class="example">        :function! Foo(value)</code>
<code class="example">        :  try</code>
<code class="example">        :    throw a:value</code>
<code class="example">        :  catch /^\d\+$/</code>
<code class="example">        :    echo "Number thrown"</code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    echo "String thrown"</code>
<code class="example">        :  endtry</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :call Foo(0x1267)</code>
<code class="example">        :call Foo('string')</code>
<code class="example"></code>
第一个 Foo() 的调用显示 "Number thrown"，第二个 "String thrown"。
按照 ":catch" 命令本身的顺序，依次匹配例外。只用第一个成功匹配。所以，你应该把
更专门的 ":catch" 放在前面。下面的顺序并不合理: 
<code class="example"></code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    echo "String thrown"</code>
<code class="example">        :  catch /^\d\+$/</code>
<code class="example">        :    echo "Number thrown"</code>
<code class="example"></code>
这里，第一个 ":catch" 总是会被匹配，所以第二个子句永远不可能被采用。

                                                        <b class="vimtag"> <a name="throw-variables">throw-variables</a> </b>
如果你使用通用的模式捕获到例外，可以通过变量  <a href="eval.html#v:exception">v:exception</a>  得到准确的例外值: 
<code class="example"></code>
<code class="example">        :  catch /^\d\+$/</code>
<code class="example">        :    echo "Number thrown.  Value is" v:exception</code>
<code class="example"></code>
你也许会对在什么地方抛出例外也感兴趣。它被保存在  <a href="eval.html#v:throwpoint">v:throwpoint</a>  里。<code class="note">注意</code>
"v:exception" 和 "v:throwpoint" 可用于最近捕获的例外，只要该例外还没有完成处
理。
   例如: 
<code class="example"></code>
<code class="example">        :function! Caught()</code>
<code class="example">        :  if v:exception != ""</code>
<code class="example">        :    echo 'Caught "' . v:exception . '" in ' . v:throwpoint</code>
<code class="example">        :  else</code>
<code class="example">        :    echo 'Nothing caught'</code>
<code class="example">        :  endif</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Foo()</code>
<code class="example">        :  try</code>
<code class="example">        :    try</code>
<code class="example">        :      try</code>
<code class="example">        :        throw 4711</code>
<code class="example">        :      finally</code>
<code class="example">        :        call Caught()</code>
<code class="example">        :      endtry</code>
<code class="example">        :    catch /.*/</code>
<code class="example">        :      call Caught()</code>
<code class="example">        :      throw "oops"</code>
<code class="example">        :    endtry</code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    call Caught()</code>
<code class="example">        :  finally</code>
<code class="example">        :    call Caught()</code>
<code class="example">        :  endtry</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :call Foo()</code>
<code class="example"></code>
会显示 
<code class="example"></code>
<code class="example">        Nothing caught</code>
<code class="example">        Caught "4711" in function Foo, line 4</code>
<code class="example">        Caught "oops" in function Foo, line 10</code>
<code class="example">        Nothing caught</code>
<code class="example"></code>
更实际的例子:  下面的命令 ":LineNumber" 显示调用它时，脚本或者函数里的行号: 
<code class="example"></code>
<code class="example">        :function! LineNumber()</code>
<code class="example">        :    return substitute(v:throwpoint, '.*\D\(\d\+\).*', '\1', "")</code>
<code class="example">        :endfunction</code>
<code class="example">        :command! LineNumber try | throw "" | catch | echo LineNumber() | endtry</code>

                                                        <b class="vimtag"> <a name="try-nested">try-nested</a> </b>
try 条件句没有捕获的例外可以在包围它的 try 条件句中捕获: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  try</code>
<code class="example">        :    throw "foo"</code>
<code class="example">        :  catch /foobar/</code>
<code class="example">        :    echo "foobar"</code>
<code class="example">        :  finally</code>
<code class="example">        :    echo "inner finally"</code>
<code class="example">        :  endtry</code>
<code class="example">        :catch /foo/</code>
<code class="example">        :  echo "foo"</code>
<code class="example">        :endtry</code>
<code class="example"></code>
内层的 try 条件句没有捕获例外，只执行了 finally 子句。例外在外层得到捕获。本例
显示 "inner finally" 然后是 "foo"。

                                                        <b class="vimtag"> <a name="throw-from-catch">throw-from-catch</a> </b>
你可以捕获某例外，然后抛出另一个。它在该 catch 子句之外捕获: 
<code class="example"></code>
<code class="example">        :function! Foo()</code>
<code class="example">        :  throw "foo"</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Bar()</code>
<code class="example">        :  try</code>
<code class="example">        :    call Foo()</code>
<code class="example">        :  catch /foo/</code>
<code class="example">        :    echo "Caught foo, throw bar"</code>
<code class="example">        :    throw "bar"</code>
<code class="example">        :  endtry</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  call Bar()</code>
<code class="example">        :catch /.*/</code>
<code class="example">        :  echo "Caught" v:exception</code>
<code class="example">        :endtry</code>
<code class="example"></code>
显示 "Caught foo, throw bar" 然后是 "Caught bar"。

                                                        <b class="vimtag"> <a name="rethrow">rethrow</a> </b>
Vim 脚本语言没有真正的 rethrow。但可以抛出 "v:exception" 来代替: 
<code class="example"></code>
<code class="example">        :function! Bar()</code>
<code class="example">        :  try</code>
<code class="example">        :    call Foo()</code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    echo "Rethrow" v:exception</code>
<code class="example">        :    throw v:exception</code>
<code class="example">        :  endtry</code>
<code class="example">        :endfunction</code>
                                                        <b class="vimtag"> <a name="try-echoerr">try-echoerr</a> </b>
<code class="note">注意</code> 这个方法不能用来 "rethrow" Vim 错误或者中断例外，因为不能伪造 Vim 的内部
例外。试图这么做会产生一个错误例外。你应该抛出自己的例外来说明这种情形。如果你
想产生 Vim 的错误例外并包含原来的错误例外的值，可以使用  <a href="eval.html#:echoerr">:echoerr</a>  命令: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  try</code>
<code class="example">        :    asdf</code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    echoerr v:exception</code>
<code class="example">        :  endtry</code>
<code class="example">        :catch /.*/</code>
<code class="example">        :  echo v:exception</code>
<code class="example">        :endtry</code>
<code class="example"></code>
本代码会显示

<code class="section">        Vim(echoerr):Vim:E492: Not an editor command:   asdf </code>


清 理 代 码                                             <b class="vimtag"> <a name="try-finally">try-finally</a> </b>

脚本经常需要改变全局设定然后结束时恢复之。不过，如果用户按了 <code class="keystroke">CTRL-C</code> 中止脚本，
这些设定会处于不一致的状态。如果你处于某脚本的开发阶段而发生了错误或者你显式地
抛出例外而没有试图捕获之，也会有相同的情况。用带有 finally 子句的 try 条件句，
可以恢复设置，从而解决这个问题。可以保证无论是正常的控制流、出错或者显式的例外
":throw"、还是被中断，都会执行 finally 子句 (<code class="note">注意</code> try 条件句的错误和中断被转换
成例外。如果没有捕获，它们在 finally 子句执行完之后会终止脚本。)
例如: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  let s:saved_ts = &amp;ts</code>
<code class="example">        :  set ts=17</code>
<code class="example">        :</code>
<code class="example">        :  " 这里执行重要的任务。</code>
<code class="example">        :</code>
<code class="example">        :finally</code>
<code class="example">        :  let &amp;ts = s:saved_ts</code>
<code class="example">        :  unlet s:saved_ts</code>
<code class="example">        :endtry</code>
<code class="example"></code>
无论任何函数还是脚本的一部分，只要它需要修改全局设置，而在失败或者成功退出该函
数或者脚本部分时需要恢复这些设置，就应该在本地应用本方法。

                                                        <b class="vimtag"> <a name="break-finally">break-finally</a> </b>
清理代码也适用于 ":continue"、":break"、":return" 或 ":finish" 退出的 try 块或
catch 子句。
   例如: 
<code class="example"></code>
<code class="example">        :let first = 1</code>
<code class="example">        :while 1</code>
<code class="example">        :  try</code>
<code class="example">        :    if first</code>
<code class="example">        :      echo "first"</code>
<code class="example">        :      let first = 0</code>
<code class="example">        :      continue</code>
<code class="example">        :    else</code>
<code class="example">        :      throw "second"</code>
<code class="example">        :    endif</code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    echo v:exception</code>
<code class="example">        :    break</code>
<code class="example">        :  finally</code>
<code class="example">        :    echo "cleanup"</code>
<code class="example">        :  endtry</code>
<code class="example">        :  echo "still in while"</code>
<code class="example">        :endwhile</code>
<code class="example">        :echo "end"</code>
<code class="example"></code>
会显示 "first"、"cleanup"、"second"、"cleanup" 和 "end"。 
<code class="example"></code>
<code class="example">        :function! Foo()</code>
<code class="example">        :  try</code>
<code class="example">        :    return 4711</code>
<code class="example">        :  finally</code>
<code class="example">        :    echo "cleanup\n"</code>
<code class="example">        :  endtry</code>
<code class="example">        :  echo "Foo still active"</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :echo Foo() "returned by Foo"</code>
<code class="example"></code>
会显示 "cleanup" 和 "4711 returned by Foo"。你不需要在 finally 子句里加上附加
的 ":return"。(最终，它会覆盖原来的返回值。)

                                                        <b class="vimtag"> <a name="except-from-finally">except-from-finally</a> </b>
finally 子句里可以使用 ":continue"、":break"、":return"、":finish" 或
":throw"，但不推荐，因为它放弃了 try 条件句的清理工作。不过当然了，finally 子
句里仍然可能有中断或者错误例外。
   finally 子句的错误引起中断不能正常工作的例子: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  try</code>
<code class="example">        :    echo "Press CTRL-C for interrupt"</code>
<code class="example">        :    while 1</code>
<code class="example">        :    endwhile</code>
<code class="example">        :  finally</code>
<code class="example">        :    unlet novar</code>
<code class="example">        :  endtry</code>
<code class="example">        :catch /novar/</code>
<code class="example">        :endtry</code>
<code class="example">        :echo "Script still running"</code>
<code class="example">        :sleep 1</code>
<code class="example"></code>
如果你需要在 finally 里放入可能出错的命令，考虑捕获或者忽略这些命令的错误，见
 <a href="eval.html#catch-errors">catch-errors</a>  和  <a href="eval.html#ignore-errors">ignore-errors</a> 。


捕 获 错 误                                             <b class="vimtag"> <a name="catch-errors">catch-errors</a> </b>

如果你想捕获特定的错误，你需要把要关注的代码放到 try 块里，然后为该错误消息加
入 catch 子句。try 条件句的存在使得所有的错误被转换为例外。不会显示消息，而
 <a href="eval.html#v:errmsg">v:errmsg</a>  也不会设置。要找到 ":catch" 命令右边的模式，你需要知道错误例外的格
式。
   错误例外使用如下的格式: 
<code class="example"></code>
<code class="example">        Vim({cmdname}):{errmsg}</code>
或 
<code class="example">        Vim:{errmsg}</code>
<code class="example"></code>
<code class="special">{cmdname}</code> 是失败的命令名；第二种形式用于命令名未知的场合。<code class="special">{errmsg}</code> 是错误在
try 条件句发生时，本应产生的错误消息。它总是以大写的 "E" 开始，后面跟两或者三
位的错误号，一个冒号和一个空格。

例如:

命令 
<code class="example">        :unlet novar</code>
通常产生错误信息 
<code class="example">        E108: No such variable: "novar"</code>
它在 try 条件句里被转换为例外 
<code class="example">        Vim(unlet):E108: No such variable: "novar"</code>
<code class="example"></code>
命令 
<code class="example">        :dwim</code>
通常产生错误信息 
<code class="example">        E492: Not an editor command: dwim</code>
它在 try 条件句里被转换为例外 
<code class="example">        Vim:E492: Not an editor command: dwim</code>
<code class="example"></code>
你可以这样捕获所有的 ":unlet" 错误 
<code class="example">        :catch /^Vim(unlet):/</code>
或者这样捕获所有拼错命令名字的错误 
<code class="example">        :catch /^Vim:E492:/</code>
<code class="example"></code>
有的错误信息可能由不同的命令产生: 
<code class="example">        :function nofunc</code>
和 
<code class="example">        :delfunction nofunc</code>
都会产生错误信息 
<code class="example">        E128: Function name must start with a capital: nofunc</code>
它在 try 条件句里被分别转换为例外 
<code class="example">        Vim(function):E128: Function name must start with a capital: nofunc</code>
或 
<code class="example">        Vim(delfunction):E128: Function name must start with a capital: nofunc</code>
使用下面的模式，你可以根据其号码捕获错误，而不管产生的命令是什么: 
<code class="example">        :catch /^Vim(\a\+):E128:/</code>
<code class="example"></code>
有些命令，比如 
<code class="example">        :let x = novar</code>
产生多个错误信息，这里: 
<code class="example">        E121: Undefined variable: novar</code>
<code class="example">        E15: Invalid expression:  novar</code>
只有第一个会用做例外的值，因为它是最专门的那个 (见  <a href="eval.html#except-several-errors">except-several-errors</a> )。
所以你应该这样捕获它 
<code class="example">        :catch /^Vim(\a\+):E121:/</code>
<code class="example"></code>
你可以这样捕获所有和名字 "nofunc" 相关的错误 
<code class="example">        :catch /\&lt;nofunc\&gt;/</code>
<code class="example"></code>
你可以这样捕获 ":write" 和 ":read" 命令产生的所有 Vim 的错误 
<code class="example">        :catch /^Vim(\(write\|read\)):E\d\+:/</code>
<code class="example"></code>
你可以这样捕获所有的 Vim 错误 
<code class="example">        :catch /^Vim\((\a\+)\)\=:E\d\+:/</code>

                                                        <b class="vimtag"> <a name="catch-text">catch-text</a> </b>
<code class="note">注意</code>: 永远不要根据错误信息文本本身捕获错误: 
<code class="example">        :catch /No such variable/</code>
只适用于英语的 locale，如果用户用  <a href="mlang.html#:language">:language</a>  命令使用别的语言就不行了。不过，
在注释里引用该消息或许有帮助: 
<code class="example">        :catch /^Vim(\a\+):E108:/   " No such variable</code>
<code class="example"></code>
<code class="example"></code>
忽 略 错 误                                             <b class="vimtag"> <a name="ignore-errors">ignore-errors</a> </b>

你可以通过在本地捕获来忽略某个 Vim 命令的错误: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  write</code>
<code class="example">        :catch</code>
<code class="example">        :endtry</code>
<code class="example"></code>
但强烈建议， <code class="emphasis">不要</code> 使用这种简单的形式，因为它捕获的东西超过你的想象。":write"
命令里，会执行一些自动命令，它们可能引起与写入无关的错误。例如: 
<code class="example"></code>
<code class="example">        :au BufWritePre * unlet novar</code>
<code class="example"></code>
作为脚本的作者，你不应该负责处理这些错误: 使用你书写的脚本的用户可能定义了这些
自动命令。而你这么做只会屏蔽用户自己的错误。
   更好的方法是用 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  write</code>
<code class="example">        :catch /^Vim(write):/</code>
<code class="example">        :endtry</code>
<code class="example"></code>
这样，只捕获真正的 write 错误。总之，只应该捕获你有意忽略的错误。

对于单个不会执行自动命令的命令，你可以用 ":silent!" 命令来关闭错误到例外的转
换: 
<code class="example">        :silent! nunmap k</code>
即使在活动的 try 条件句里也能这么用。


捕 获 中 断                                             <b class="vimtag"> <a name="catch-interrupt">catch-interrupt</a> </b>

如果有活动的 try 条件句，中断 (<code class="keystroke">CTRL-C</code>) 被转换为例外 "Vim:Interrupt"。你可以和
其他例外一样捕获它。那样，脚本就不会中止。
   例如: 
<code class="example"></code>
<code class="example">        :function! TASK1()</code>
<code class="example">        :  sleep 10</code>
<code class="example">        :endfunction</code>
<code class="example"></code>
<code class="example">        :function! TASK2()</code>
<code class="example">        :  sleep 20</code>
<code class="example">        :endfunction</code>
<code class="example"></code>
<code class="example">        :while 1</code>
<code class="example">        :  let command = input("Type a command: ")</code>
<code class="example">        :  try</code>
<code class="example">        :    if command == ""</code>
<code class="example">        :      continue</code>
<code class="example">        :    elseif command == "END"</code>
<code class="example">        :      break</code>
<code class="example">        :    elseif command == "TASK1"</code>
<code class="example">        :      call TASK1()</code>
<code class="example">        :    elseif command == "TASK2"</code>
<code class="example">        :      call TASK2()</code>
<code class="example">        :    else</code>
<code class="example">        :      echo "\nIllegal command:" command</code>
<code class="example">        :      continue</code>
<code class="example">        :    endif</code>
<code class="example">        :  catch /^Vim:Interrupt$/</code>
<code class="example">        :    echo "\nCommand interrupted"</code>
<code class="example">        :    " Caught the interrupt.  Continue with next prompt.</code>
<code class="example">        :  endtry</code>
<code class="example">        :endwhile</code>
<code class="example"></code>
这里，你可以用 <code class="keystroke">CTRL-C</code> 中止任务；脚本会询问新的命令。如果你在提示上按 <code class="keystroke">CTRL-C</code>，
脚本就会中止。

要测试在你脚本的某一行上如果按了 <code class="keystroke">CTRL-C</code> 会发生什么，使用调试模式，然后在那行上
执行  <a href="repeat.html#%3Equit">&gt;quit</a>  或  <a href="repeat.html#%3Einterrupt">&gt;interrupt</a> 。见  <a href="repeat.html#debug-scripts">debug-scripts</a> 。


捕 获 一 切                                             <b class="vimtag"> <a name="catch-all">catch-all</a> </b>

命令 
<code class="example"></code>
<code class="example">        :catch /.*/</code>
<code class="example">        :catch //</code>
<code class="example">        :catch</code>
<code class="example"></code>
会捕获一切: 错误例外，中断例外和  <a href="eval.html#:throw">:throw</a>  命令显式抛出的例外。脚本的顶层可用此
捕获所有意料不到的问题。
   示例: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :</code>
<code class="example">        :  " 这里做重要的工作</code>
<code class="example">        :</code>
<code class="example">        :catch /MyException/</code>
<code class="example">        :</code>
<code class="example">        :  " 处理未知的问题</code>
<code class="example">        :</code>
<code class="example">        :catch /^Vim:Interrupt$/</code>
<code class="example">        :    echo "脚本被中断"</code>
<code class="example">        :catch /.*/</code>
<code class="example">        :  echo "内部错误 (" . v:exception . ")"</code>
<code class="example">        :  echo " - 发生在 " . v:throwpoint</code>
<code class="example">        :endtry</code>
<code class="example">        :" 脚本结束</code>

<code class="note">注意</code>: 捕获一切可能会捕获到比你想得到的更多的错误。所以，强烈建议你只用指定模式
参数的 ":catch" 来捕获你真正处理的错误。
   例如: 捕获一切会使得按 <code class="keystroke">CTRL-C</code> 来中断脚本几乎没有办法: 
<code class="example"></code>
<code class="example">        :while 1</code>
<code class="example">        :  try</code>
<code class="example">        :    sleep 1</code>
<code class="example">        :  catch</code>
<code class="example">        :  endtry</code>
<code class="example">        :endwhile</code>
<code class="example"></code>
<code class="example"></code>
例 外 和 自 动 命 令                                    <b class="vimtag"> <a name="except-autocmd">except-autocmd</a> </b>

执行自动命令的过程中可以使用例外。例如: 
<code class="example"></code>
<code class="example">        :autocmd User x try</code>
<code class="example">        :autocmd User x   throw "Oops!"</code>
<code class="example">        :autocmd User x catch</code>
<code class="example">        :autocmd User x   echo v:exception</code>
<code class="example">        :autocmd User x endtry</code>
<code class="example">        :autocmd User x throw "Arrgh!"</code>
<code class="example">        :autocmd User x echo "Should not be displayed"</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  doautocmd User x</code>
<code class="example">        :catch</code>
<code class="example">        :  echo v:exception</code>
<code class="example">        :endtry</code>
<code class="example"></code>
会显示 "Oops!" 和 "Arrgh!"。

                                                        <b class="vimtag"> <a name="except-autocmd-Pre">except-autocmd-Pre</a> </b>
有些命令里，自动命令在命令执行的主要动作之前执行。如果在自动命令的序列中抛
出没有捕获的例外，该序列和导致其执行的命令本身被放弃，而例外被传播到命令的调用
者那里。
   例如: 
<code class="example"></code>
<code class="example">        :autocmd BufWritePre * throw "FAIL"</code>
<code class="example">        :autocmd BufWritePre * echo "应该不会显示"</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  write</code>
<code class="example">        :catch</code>
<code class="example">        :  echo "Caught:" v:exception "from" v:throwpoint</code>
<code class="example">        :endtry</code>
<code class="example"></code>
这里，":write" 命令不会写入当前编辑的文件 (你可以通过查看 <a href="options.html#'modified'">'modified'</a> 发现)。因
为例外来自 BufWritePre 自动命令，它放弃了 ":write"。然后，该例外被捕获而脚本会
显示: 
<code class="example"></code>
<code class="example">        Caught: FAIL from BufWrite Auto commands for "*"</code>

                                                        <b class="vimtag"> <a name="except-autocmd-Post">except-autocmd-Post</a> </b>
有些命令里，自动命令在命令执行的主要动作之后执行。如果主要动作失败，而命令包含
在活动的 try 条件句里，将跳过这些自动命令并抛出错误例外，该命令的调用者可以捕
获这些例外。
   例如: 
<code class="example"></code>
<code class="example">        :autocmd BufWritePost * echo "文件被成功写入！"</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  write /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">        :catch</code>
<code class="example">        :  echo v:exception</code>
<code class="example">        :endtry</code>
<code class="example"></code>
只会显示: 
<code class="example"></code>
<code class="example">        Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)</code>
<code class="example"></code>
如果你真想在主要动作失败的时候也执行自动命令的话，在 catch 子句里激活自动命令
事件。
   例如: 
<code class="example"></code>
<code class="example">        :autocmd BufWritePre  * set noreadonly</code>
<code class="example">        :autocmd BufWritePost * set readonly</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  write /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">        :catch</code>
<code class="example">        :  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">        :endtry</code>

你也可以用 ":silent!": 
<code class="example"></code>
<code class="example">        :let x = "ok"</code>
<code class="example">        :let v:errmsg = ""</code>
<code class="example">        :autocmd BufWritePost * if v:errmsg != ""</code>
<code class="example">        :autocmd BufWritePost *   let x = "after fail"</code>
<code class="example">        :autocmd BufWritePost * endif</code>
<code class="example">        :try</code>
<code class="example">        :  silent! write /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">        :catch</code>
<code class="example">        :endtry</code>
<code class="example">        :echo x</code>
<code class="example"></code>
会显示 "after fail"。

如果命令的主要动作没有失败，可以在命令的调用者那里捕获自动命令产生的例外: 
<code class="example"></code>
<code class="example">        :autocmd BufWritePost * throw ":-("</code>
<code class="example">        :autocmd BufWritePost * echo "这里不应该被显示"</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  write</code>
<code class="example">        :catch</code>
<code class="example">        :  echo v:exception</code>
<code class="example">        :endtry</code>

                                                        <b class="vimtag"> <a name="except-autocmd-Cmd">except-autocmd-Cmd</a> </b>
有的命令的正常动作可以被自动命令的序列代替。可以在命令的调用者那里捕获该序列产
生的例外。
   例如: 对于 ":write" 命令，调用者并不知道发生例外时，文件是不是已经被写入。
你需要想办法告知调用者。 
<code class="example"></code>
<code class="example">        :if !exists("cnt")</code>
<code class="example">        :  let cnt = 0</code>
<code class="example">        :</code>
<code class="example">        :  autocmd BufWriteCmd * if &amp;modified</code>
<code class="example">        :  autocmd BufWriteCmd *   let cnt = cnt + 1</code>
<code class="example">        :  autocmd BufWriteCmd *   if cnt % 3 == 2</code>
<code class="example">        :  autocmd BufWriteCmd *     throw "BufWriteCmdError"</code>
<code class="example">        :  autocmd BufWriteCmd *   endif</code>
<code class="example">        :  autocmd BufWriteCmd *   write | set nomodified</code>
<code class="example">        :  autocmd BufWriteCmd *   if cnt % 3 == 0</code>
<code class="example">        :  autocmd BufWriteCmd *     throw "BufWriteCmdError"</code>
<code class="example">        :  autocmd BufWriteCmd *   endif</code>
<code class="example">        :  autocmd BufWriteCmd *   echo "File successfully written!"</code>
<code class="example">        :  autocmd BufWriteCmd * endif</code>
<code class="example">        :endif</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :       write</code>
<code class="example">        :catch /^BufWriteCmdError$/</code>
<code class="example">        :  if &amp;modified</code>
<code class="example">        :    echo "Error on writing (file contents not changed)"</code>
<code class="example">        :  else</code>
<code class="example">        :    echo "Error after writing"</code>
<code class="example">        :  endif</code>
<code class="example">        :catch /^Vim(write):/</code>
<code class="example">        :    echo "Error on writing"</code>
<code class="example">        :endtry</code>
<code class="example"></code>
如果脚本在修改后执行了多次，它先显示 
<code class="example">        File successfully written!</code>
然后 
<code class="example">        Error on writing (file contents not changed)</code>
然后 
<code class="example">        Error after writing</code>
等等。

                                                        <b class="vimtag"> <a name="except-autocmd-ill">except-autocmd-ill</a> </b>
你不能把一个 try 条件句分散到不同事件的自动命令。
下面的代码是非法的构造: 
<code class="example"></code>
<code class="example">        :autocmd BufWritePre  * try</code>
<code class="example">        :</code>
<code class="example">        :autocmd BufWritePost * catch</code>
<code class="example">        :autocmd BufWritePost *   echo v:exception</code>
<code class="example">        :autocmd BufWritePost * endtry</code>
<code class="example">        :</code>
<code class="example">        :write</code>
<code class="example"></code>
<code class="example"></code>
例 外 层 次 和 参 数 化 的 例 外                        <b class="vimtag"> <a name="except-hier-param">except-hier-param</a> </b>

有些编程语言支持使用例外类的层次结构，或者在例外类的对象里传入附加的信息。你可
以在 Vim 里完成类似的工作。
   为了抛出属于某层次的例外，只要抛出完整的类名，部件之间用冒号分隔。比如，在
某个数学库里的溢出错误可以抛出字符串 "EXCEPT:MATHERR:OVERFLOW"。
   如果你想给例外类传递附加的信息，把它加到括号里。比如写入文件 "myfile" 时的
错误，可以抛出字符串 "EXCEPT:IO:WRITEERR(myfile)"。
   在 ":catch" 命令里使用合适的模式，可以捕获你的层次中的基本类或者派生类。括
号里的附加信息也可以运用 ":substitute" 命令从  <a href="eval.html#v:exception">v:exception</a>  里切出。
   例如: 
<code class="example"></code>
<code class="example">        :function! CheckRange(a, func)</code>
<code class="example">        :  if a:a &lt; 0</code>
<code class="example">        :    throw "EXCEPT:MATHERR:RANGE(" . a:func . ")"</code>
<code class="example">        :  endif</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Add(a, b)</code>
<code class="example">        :  call CheckRange(a:a, "Add")</code>
<code class="example">        :  call CheckRange(a:b, "Add")</code>
<code class="example">        :  let c = a:a + a:b</code>
<code class="example">        :  if c &lt; 0</code>
<code class="example">        :    throw "EXCEPT:MATHERR:OVERFLOW"</code>
<code class="example">        :  endif</code>
<code class="example">        :  return c</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Div(a, b)</code>
<code class="example">        :  call CheckRange(a:a, "Div")</code>
<code class="example">        :  call CheckRange(a:b, "Div")</code>
<code class="example">        :  if (a:b == 0)</code>
<code class="example">        :    throw "EXCEPT:MATHERR:ZERODIV"</code>
<code class="example">        :  endif</code>
<code class="example">        :  return a:a / a:b</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Write(file)</code>
<code class="example">        :  try</code>
<code class="example">        :    execute "write" fnameescape(a:file)</code>
<code class="example">        :  catch /^Vim(write):/</code>
<code class="example">        :    throw "EXCEPT:IO(" . getcwd() . ", " . a:file . "):WRITEERR"</code>
<code class="example">        :  endtry</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :</code>
<code class="example">        :  " 一些算术和 I/O</code>
<code class="example">        :</code>
<code class="example">        :catch /^EXCEPT:MATHERR:RANGE/</code>
<code class="example">        :  let function = substitute(v:exception, '.*(\(\a\+\)).*', '\1', "")</code>
<code class="example">        :  echo "Range error in" function</code>
<code class="example">        :</code>
<code class="example">        :catch /^EXCEPT:MATHERR/        " 捕获 OVERFLOW 和 ZERODIV</code>
<code class="example">        :  echo "Math error"</code>
<code class="example">        :</code>
<code class="example">        :catch /^EXCEPT:IO/</code>
<code class="example">        :  let dir = substitute(v:exception, '.*(\(.\+\),\s*.\+).*', '\1', "")</code>
<code class="example">        :  let file = substitute(v:exception, '.*(.\+,\s*\(.\+\)).*', '\1', "")</code>
<code class="example">        :  if file !~ '^/'</code>
<code class="example">        :    let file = dir . "/" . file</code>
<code class="example">        :  endif</code>
<code class="example">        :  echo 'I/O error for "' . file . '"'</code>
<code class="example">        :</code>
<code class="example">        :catch /^EXCEPT/</code>
<code class="example">        :  echo "Unspecified error"</code>
<code class="example">        :</code>
<code class="example">        :endtry</code>
<code class="example"></code>
Vim 自己抛出的例外 (错误或者按了 <code class="keystroke">CTRL-C</code>) 使用扁平的层次: 它们都在 "Vim" 类里。
你自己不能抛出带有 "Vim" 前缀的例外；它们是 Vim 保留的。
   如果已知失败的命令名，Vim 错误例外使用该命令名作为参数。见  <a href="eval.html#catch-errors">catch-errors</a> 。


特 别 之 处
                                                        <b class="vimtag"> <a name="except-compat">except-compat</a> </b>
例外处理的概念需要产生例外的命令序列被立即中止，而控制转移到 finally 子句和/或
catch 子句。

在 Vim 脚本语言里，有一些情况下脚本和函数在错误后还会继续: 在没有 "abort" 标志
位的函数或者 ":silent!" 之后的命令里，控制流转到下一行。而在函数外，控制流转到
最外层 ":endwhile" 或者 ":endif" 之后的行。另一方面，错误应该可以作为例外被捕
获 (因而，需要立即被中止)。

这个问题的解决方法是把仅在有活动 try 条件句的时候，把错误转化为例外，并立即中
止 (如果没有用 ":silent!" 抑制的话)。这不是一个限制，因为 (错误) 例外只能在活
动的 try 条件句里被捕获。如果你需要立即终止而不需要捕获错误的话，只要用一个没
有 catch 子句的 try 子句就可以了 (你可以用 finally 子句指定终止前执行的清理代
码。)

如果没有活动的 try 条件句，使用通常的中止和继续行为，而不是立即中止。这样，保
证了与 Vim 6.1 和之前版本编写的脚本的兼容性。

不过，如果在活动的 try 条件句里执行已有的不使用例外处理命令的脚本 (或者调用它
的一个函数)，你也许会改变已有脚本发生错误时的控制流。你会在错误时立即中止并且
在新的脚本里捕获错误。如果被执行的脚本通过 ":silent!" 命令抑制了错误 (在合适的
时候测试  <a href="eval.html#v:errmsg">v:errmsg</a>  来检查错误)，它的执行路径没有改变。错误也不会转换为例外。
(见  <a href="various.html#:silent">:silent</a> 。) 所以唯一留下的可能是不关心错误并产生错误信息的脚本。可能，你
也不希望在新的脚本里使用这样的代码吧。

                                                        <b class="vimtag"> <a name="except-syntax-err">except-syntax-err</a> </b>
例外处理命令的语法错误永远不会被它所属的 try 条件句的任何 ":catch" 命令所捕
获。不过，还是会执行它的 finally 子句。
   例如: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  try</code>
<code class="example">        :    throw 4711</code>
<code class="example">        :  catch /\(/ " 有语法错误</code>
<code class="example">        :    echo "in catch with syntax error"</code>
<code class="example">        :  catch</code>
<code class="example">        :    echo "inner catch-all"</code>
<code class="example">        :  finally</code>
<code class="example">        :    echo "inner finally"</code>
<code class="example">        :  endtry</code>
<code class="example">        :catch</code>
<code class="example">        :  echo 'outer catch-all caught "' . v:exception . '"'</code>
<code class="example">        :  finally</code>
<code class="example">        :    echo "outer finally"</code>
<code class="example">        :endtry</code>
<code class="example"></code>
会显示: 
<code class="example">    inner finally</code>
<code class="example">    outer catch-all caught "Vim(catch):E54: Unmatched \("</code>
<code class="example">    outer finally</code>
原来的例外被丢弃了，抛出的是取而代之的语法错误的错误例外。

                                                        <b class="vimtag"> <a name="except-single-line">except-single-line</a> </b>
":try"、":catch"、":finally" 和 ":endtry" 命令可以放在一行里，但这样如果有语法
错误，可能使得 "catch" 行无法被识别。所以，最好不要这么做。
   例如: 
<code class="example">        :try | unlet! foo # | catch | endtry</code>
":unlet!" 参数之后的拖尾字符抛出了错误例外，但因此无法看到 ":catch" 和
":endtry" 命令，从而只能丢弃该错误例外并且显示消息 "E488: Trailing
characters"。

                                                        <b class="vimtag"> <a name="except-several-errors">except-several-errors</a> </b>
如果多个错误在一个命令里出现，第一个错误信息通常是最专门的，因而它被转换为错误
例外。
   例如: 
<code class="example">        echo novar</code>
产生 
<code class="example">        E121: Undefined variable: novar</code>
<code class="example">        E15: Invalid expression: novar</code>
try 条件句里错误例外的值是: 
<code class="example">        Vim(echo):E121: Undefined variable: novar</code>
                                                        <b class="vimtag"> <a name="except-syntax-error">except-syntax-error</a> </b>
不过，如果同一命令在普通错误之后发现了语法错误，语法错误被用作抛出的例外。
   例如: 
<code class="example">        unlet novar #</code>
产生 
<code class="example">        E108: No such variable: "novar"</code>
<code class="example">        E488: Trailing characters</code>
try 条件句里错误例外的值是: 
<code class="example">        Vim(unlet):E488: Trailing characters</code>
这么做是因为语法错误可能会以用户意想不到的方式改变执行的路径。例如: 
<code class="example">        try</code>
<code class="example">            try | unlet novar # | catch | echo v:exception | endtry</code>
<code class="example">        catch /.*/</code>
<code class="example">            echo "outer catch:" v:exception</code>
<code class="example">        endtry</code>
显示 "outer catch: Vim(unlet):E488: Trailing characters"，然后给出错误信息
"E600: Missing :endtry"，见  <a href="eval.html#except-single-line">except-single-line</a> 。

</section><hr class="doubleline" /><section class=inner>
<h4>9. 示例                                                 <b class="vimtag"> <a name="eval-examples">eval-examples</a> </b></h4>
<code class="section">用二进制显示 </code>

<code class="example">  :" 函数 Nr2Bin() 返回数值的二进制字符串。</code>
<code class="example">  :func Nr2Bin(nr)</code>
<code class="example">  :  let n = a:nr</code>
<code class="example">  :  let r = ""</code>
<code class="example">  :  while n</code>
<code class="example">  :    let r = '01'[n % 2] . r</code>
<code class="example">  :    let n = n / 2</code>
<code class="example">  :  endwhile</code>
<code class="example">  :  return r</code>
<code class="example">  :endfunc</code>
<code class="example"></code>
<code class="example">  :" 函数 String2Hex() 把字符串里的每个字符转换成二进制字符串，用连字符分隔字</code>
<code class="example">  :" 符。</code>
<code class="example">  :func String2Bin(str)</code>
<code class="example">  :  let out = ''</code>
<code class="example">  :  for ix in range(strlen(a:str))</code>
<code class="example">  :    let out = out . '-' . Nr2Bin(char2nr(a:str[ix]))</code>
<code class="example">  :  endfor</code>
<code class="example">  :  return out[1:]</code>
<code class="example">  :endfunc</code>
<code class="example"></code>
使用示例: 
<code class="example">  :echo Nr2Bin(32)</code>
返回: "100000" 
<code class="example">  :echo String2Bin("32")</code>
返回: "110011-110010"


<code class="section">给行排序 </code>

下例用特定比较函数给行排序。 
<code class="example"></code>
<code class="example">  :func SortBuffer()</code>
<code class="example">  :  let lines = getline(1, '$')</code>
<code class="example">  :  call sort(lines, function("Strcmp"))</code>
<code class="example">  :  call setline(1, lines)</code>
<code class="example">  :endfunction</code>
<code class="example"></code>
可写为一行程序: 
<code class="example">  :call setline(1, sort(getline(1, '$'), function("Strcmp")))</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">scanf() 的替代 </code>
                                                        <b class="vimtag"> <a name="sscanf">sscanf</a> </b>
Vim 里没有 sscanf() 函数。如果你需要提取一行的部分内容，可以使用 matchstr() 和
substitute() 完成。本例子说明如何得到从类似 "foobar.txt, 123, 45" 的行里提取文
件名，行号和列号。 
<code class="example">   :" 设置匹配模式</code>
<code class="example">   :let mx='\(\f\+\),\s*\(\d\+\),\s*\(\d\+\)'</code>
<code class="example">   :"取得匹配整个表达式的文本部分</code>
<code class="example">   :let l = matchstr(line, mx)</code>
<code class="example">   :"从匹配中提取每个项目</code>
<code class="example">   :let file = substitute(l, mx, '\1', '')</code>
<code class="example">   :let lnum = substitute(l, mx, '\2', '')</code>
<code class="example">   :let col = substitute(l, mx, '\3', '')</code>
<code class="example"></code>
这里，输入是变量 "line"，返回值放在变量 "file"、"lnum" 和 "col" 里。(Michael
Geddes 提供的方法)


<code class="section">输出 scriptnames 到字典 </code>
                                                <b class="vimtag"> <a name="scriptnames-dictionary">scriptnames-dictionary</a> </b>
 <a href="repeat.html#:scriptnames">:scriptnames</a>  命令可用于得到执行过的所有脚本文件的列表。没有等价的函数或变量
(因为很少用到)。如果需要操作此列表，可以使用下面的代码: 
<code class="example">    " 把 ":scriptnames" 的输出存放到 scriptnames_output 变量中。</code>
<code class="example">    let scriptnames_output = ''</code>
<code class="example">    redir =&gt; scriptnames_output</code>
<code class="example">    silent scriptnames</code>
<code class="example">    redir END</code>
<code class="example"></code>
<code class="example">    " 把输出分拆为行，并对每行进行分析。在 "script" 字典中加入项目。</code>
<code class="example">    let scripts = {}</code>
<code class="example">    for line in split(scriptnames_output, "\n")</code>
<code class="example">      " 只处理非空白行。</code>
<code class="example">      if line =~ '\S'</code>
<code class="example">        " 获取每行的第一个数字。</code>
<code class="example">        let nr = matchstr(line, '\d\+')</code>
<code class="example">        " 获取文件名，删除脚本号 " 123: "。</code>
<code class="example">        let name = substitute(line, '.\+:\s*', '', '')</code>
<code class="example">        " 在字典中加入项目</code>
<code class="example">        let scripts[nr] = name</code>
<code class="example">      endif</code>
<code class="example">    endfor</code>
<code class="example">    unlet scriptnames_output</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>10. Vim script versions         <b class="vimtag"> <a name="vimscript-version">vimscript-version</a> </b> <b class="vimtag"> <a name="vimscript-versions">vimscript-versions</a> </b></h4>                                                        <b class="vimtag"> <a name="scriptversion">scriptversion</a> </b>
随着时间推移，Vim 脚本加入很多新特性。这包括了 Ex 命令、函数、变量类型等等。每
个单独的特性都可以用  <a href="eval.html#has()">has()</a>  和  <a href="eval.html#exists()">exists()</a>  函数检查。

有时旧功能的语法阻碍了 Vim 的改进。而撤销相关支持又会破坏旧的 Vim 脚本。为此，
可用显式的  <a href="repeat.html#:scriptversion">:scriptversion</a>  命令。当 Vim 脚本和旧版本的 Vim 不兼容时，会显式地
报错，而不会出现各种奇怪的失败。

                                                        <b class="vimtag"> <a name="scriptversion-1">scriptversion-1</a> </b>  
<code class="example"> :scriptversion 1</code>
        这是原本的 Vim 脚本，和不使用  <a href="repeat.html#:scriptversion">:scriptversion</a>  命令一样。可用于把一段
        代码回到旧语法。这样测试是否支持: 
<code class="example">                has('vimscript-1')</code>
<code class="example"></code>
                                                        <b class="vimtag"> <a name="scriptversion-2">scriptversion-2</a> </b>  
<code class="example"> :scriptversion 2</code>
        不支持用 "." 进行字符串连接，而用 ".." 代替。
        这避免了字典成员访问和浮点数的二义性。现在 ".5" 意味着数值 0.5。

                                                        <b class="vimtag"> <a name="scriptversion-3">scriptversion-3</a> </b>  
<code class="example"> :scriptversion 3</code>
        所有的  <a href="eval.html#vim-variable">vim-variable</a>  必须使用 "v:" 前缀。例如 "version" 不再用作
         <a href="eval.html#v:version">v:version</a>  的简称，而可以用作正常变量。
        同样适用于一些显而易见的名字，如 "count" 等等。

        这样测试是否支持: 
<code class="example">                has('vimscript-3')</code>

                                                        <b class="vimtag"> <a name="scriptversion-4">scriptversion-4</a> </b>  
<code class="example"> :scriptversion 4</code>
        不把零开始的数值识别为八进制。在之前的版本中你会看到: 
<code class="example">                echo 017   " 显示 15</code>
<code class="example">                echo 018   " 显示 18</code>
        使用脚本版本 4 后: 
<code class="example">                echo 017   " 显示 17</code>
<code class="example">                echo 018   " 显示 18</code>
        同时，可以在数值内部使用单引号来提高可读性: 
<code class="example">                echo 1'000'000</code>
        引号必须在数位之间。

        这样测试是否支持: 
<code class="example">                has('vimscript-4')</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>11. 不包含 +eval 特性                           <b class="vimtag"> <a name="no-eval-feature">no-eval-feature</a> </b></h4>
如果编译时关闭了  <a href="various.html#+eval">+eval</a>  特性，以上的表达式计算命令都不可用。为了避免因此导致
你的 Vim 脚本产生各种错误，":if" 和 ":endif" 命令仍然得到识别。不过 ":if" 的参
数和一切 ":if" 和匹配的 ":endif" 之间的内容都被忽略。可以嵌套 ":if" 块，但只允
许出现在行首。不识别 ":else" 命令。

下例演示如何在不存在  <a href="various.html#+eval">+eval</a>  特性时不执行命令: 
<code class="example"></code>
<code class="example">        :if 1</code>
<code class="example">        :  echo "编译加入了表达式求值"</code>
<code class="example">        :else</code>
<code class="example">        :  echo "你_永远_看不到这条消息"</code>
<code class="example">        :endif</code>
<code class="example"></code>
要在  <a href="various.html#+eval">+eval</a>  特性关闭时才执行命令有两种方法。最简单的是提前退出脚本 (或
Vim): 
<code class="example">        if 1</code>
<code class="example">           echo "带 +eval 执行的命令"</code>
<code class="example">           finish</code>
<code class="example">        endif</code>
<code class="example">        args  " 不带 +eval 执行的命令</code>
<code class="example"></code>
如果不想中止脚本的载入可以用一些小技巧，如下例所示: 
<code class="example"></code>
<code class="example">        silent! while 0</code>
<code class="example">          set history=111</code>
<code class="example">        silent! endwhile</code>
<code class="example"></code>
 <a href="various.html#+eval">+eval</a>  特性可用时，因为 "while 0" 跳过此命令。没有  <a href="various.html#+eval">+eval</a>  特性时，"while 0"
是错误但被安静地忽略，从而执行此命令。

</section><hr class="doubleline" /><section class=inner>
<h4>12. 沙盘 (sandbox)                              <b class="vimtag"> <a name="eval-sandbox">eval-sandbox</a> </b> <b class="vimtag"> <a name="sandbox">sandbox</a> </b> <b class="vimtag"> <a name="E48">E48</a> </b></h4>
<a href="options.html#'foldexpr'">'foldexpr'</a>、<a href="options.html#'formatexpr'">'formatexpr'</a>、<a href="options.html#'includeexpr'">'includeexpr'</a>、<a href="options.html#'indentexpr'">'indentexpr'</a>、<a href="options.html#'statusline'">'statusline'</a> 和
<a href="options.html#'foldtext'">'foldtext'</a> 选项在沙盘 (sandbox) 里进行计算。这意味着这些表达式不会产生可怕的副
作用。在模式行上设置这些选项时，以及在标签文件里和命令行上的 <code class="keystroke">CTRL-R</code> = 执行命令
时，这项措施提供了一定的安全性。
沙盘也用于  <a href="eval.html#:sandbox">:sandbox</a>  命令。

沙盘里，不允许以下操作:
        - 修改缓冲区文本
        - 定义或者改变映射、自动命令和用户命令
        - 设置若干选项 (见  <a href="options.html#option-summary">option-summary</a> )
        - 设置若干 v: 变量 (见  <a href="eval.html#v:var">v:var</a> )  <b class="vimtag"> <a name="E794">E794</a> </b>
        - 执行外壳命令
        - 读入或者写到文件
        - 跳转到另一缓冲区或者去编辑文件
        - 执行 Python、Perl 等命令
这并不能保证 100% 安全，但应该可以挡住大多数攻击。

                                                        <b class="vimtag"> <a name=":san">:san</a> </b> <b class="vimtag"> <a name=":sandbox">:sandbox</a> </b>
:san[dbox] <code class="special">{cmd}</code>        在沙盘里执行 <code class="special">{cmd}</code>。用于计算可能在模式行里设置的选项，
                        比如 <a href="options.html#'foldexpr'">'foldexpr'</a>。

                                                        <b class="vimtag"> <a name="sandbox-option">sandbox-option</a> </b>
一些选项包含表达式。对这些表达式进行计算时可能要使用沙盘才能避免安全性的威胁。
但沙盘限制较多，所以只有在从不安全的位置设置选项时才会如此。在此上下文中，不安
全的位置指:
- 执行当前目录的 .vimrc 或 .exrc 时
- 在沙盘里执行时
- 来自模式行的值
- 执行沙盘里定义的函数时

<code class="note">注意</code> 如果在沙盘里保存选项值然后恢复之，该选项仍然标记为在沙盘里设置。

</section><hr class="doubleline" /><section class=inner>
<h4>13. 文本锁                                                      <b class="vimtag"> <a name="textlock">textlock</a> </b></h4>
在一些情况下，不允许修改缓冲区里的文本、跳转到其它窗口和一些其它会引起混淆或打
断 Vim 正在进行的操作的动作。这主要适用于和 Vim 实际正在进行其它操作的同时发生
的事情。例如，<a href="options.html#'balloonexpr'">'balloonexpr'</a> 的计算可能发生在鼠标指针定位在若干位置的任何时候。

文本锁激活时，不允许:
        - 修改缓冲区文本
        - 跳转到其它缓冲区或窗口
        - 编辑其它文件
        - 关闭窗口或者退出 Vim
        - 其它

 vim:tw=78:ts=8:noet:ft=help:norl:
</section>
<footer>
Generated by vim2html
</footer>
</article>
</body>
</html>
