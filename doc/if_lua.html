<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<![endif]-->
<title>VIM 中文帮助: Lua 接口</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css" />
<link rel="canonical" href="https://yianwillis.github.io/vimcdoc/doc/if_lua.html" />
<script type="text/javascript" src="vimcdoc.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
<nav id=banner>
<form action=tags.html target="tag_iframe">
  <input type="text" name="tag" id="tag" placeholder="标签搜索">
</form>
<iframe name="tag_iframe" src=""></iframe>
<a href="help.html">帮助总览</a> &middot;
<hr/>
<a href="quickref.html">快速参考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="eval.html#functions">函数列表</a> &middot;
<a href="quickref.html#option-list">选项列表</a> &middot;
<hr/>
<a href="usr_toc.html">用户手册</a> &middot;
<a href="help.html#reference_toc">参考手册</a> &middot;
</nav>

<header>
<h2>if_lua</h2>
</header>
<article id=outer>
<section class=inner>
<b class="vimtag"> <a name="if_lua.txt">if_lua.txt</a> </b>    适用于 Vim 9.1 版本。   最近更新: 2022年7月


                  <code class="vim">VIM 参考手册    by Luis Carvalho</code>
                                <code class="vim">译者</code>: Willis


Vim 的 Lua 接口                                         <b class="vimtag"> <a name="lua">lua</a> </b> <b class="vimtag"> <a name="Lua">Lua</a> </b>

1. 命令                          <a href="if_lua.html#lua-commands">lua-commands</a> 
2. vim 模块                      <a href="if_lua.html#lua-vim">lua-vim</a> 
3. 列表用户数据                  <a href="if_lua.html#lua-list">lua-list</a> 
4. 字典用户数据                  <a href="if_lua.html#lua-dict">lua-dict</a> 
5. blob 用户数据                 <a href="if_lua.html#lua-blob">lua-blob</a> 
6. 函数引用用户数据              <a href="if_lua.html#lua-funcref">lua-funcref</a> 
7. 缓冲区用户数据                <a href="if_lua.html#lua-buffer">lua-buffer</a> 
8. 窗口用户数据                  <a href="if_lua.html#lua-window">lua-window</a> 
9. luaeval 函数                  <a href="if_lua.html#lua-luaeval">lua-luaeval</a> 
10. 动态调入                     <a href="if_lua.html#lua-dynamic">lua-dynamic</a> 

<code class="notvi">{仅当 Vim 编译时加入  <a href="various.html#+lua">+lua</a>  特性时才有效}</code>

</section><hr class="doubleline" /><section class=inner>
<h4>1. 命令                                                 <b class="vimtag"> <a name="lua-commands">lua-commands</a> </b></h4>
                                                        <b class="vimtag"> <a name=":lua">:lua</a> </b>
:<code class="special">[range]</code>lua <code class="special">{chunk}</code>
                        执行 Lua 语言块 <code class="special">{chunk}</code>。

示例:

<code class="example">        :lua print("Hello, Vim!")</code>
<code class="example">        :lua local curbuf = vim.buffer() curbuf[7] = "line #7"</code>


:<code class="special">[range]</code>lua &lt;&lt; <code class="special">[trim]</code> [<code class="special">{endmarker}</code>]
<code class="special">{script}</code>
<code class="special">{endmarker}</code>
                        执行 Lua 脚本 <code class="special">{script}</code>。
                        <code class="note">注意</code>: 如果编译时没有加入 Lua 特性，此命令不能工作。要
                        避免错误，见  <a href="if_perl.html#script-here">script-here</a> 。

如果 "&lt;&lt;" 之后的 <code class="special">{endmarker}</code> 省略，<code class="special">{script}</code> 之后必须加上一个点号 '.'，就像
 <a href="insert.html#:append">:append</a>  和  <a href="insert.html#:insert">:insert</a>  命令那样。更多详情可见  <a href="eval.html#:let-heredoc">:let-heredoc</a> 。

这种形式的  <a href="if_lua.html#:lua">:lua</a>  命令主要用于在 Vim 脚本中嵌入 Lua 代码。

示例:

<code class="example">        function! CurrentLineInfo()</code>
<code class="example">        lua &lt;&lt; EOF</code>
<code class="example">        local linenr = vim.window().line</code>
<code class="example">        local curline = vim.buffer()[linenr]</code>
<code class="example">        print(string.format("Current line [%d] has %d chars",</code>
<code class="example">                linenr, #curline))</code>
<code class="example">        EOF</code>
<code class="example">        endfunction</code>

要看运行的 Lua 版本:
<code class="example">        :lua print(_VERSION)</code>
<code class="example"></code>
如果用 LuaJIT，也可以用:
<code class="example">        :lua print(jit.version)</code>


                                                        <b class="vimtag"> <a name=":luado">:luado</a> </b>
:<code class="special">[range]</code>luado <code class="special">{body}</code>    在 <code class="special">[range]</code> 行范围的每行执行 Lua 函数
                        "function (line,linenr) <code class="special">{body}</code> end"，其中，函数参数是
                        每行的文本，结尾的 <code class="special">&lt;EOL&gt;</code> 不计，和当前的行号。函数返回
                        值为字符串时用来替代当前行的文本。缺省的 <code class="special">[range]</code> 是整
                        个文件: "1,$"。

示例:

<code class="example">        :luado return string.format("%s\t%d", line:reverse(), #line)</code>
<code class="example"></code>
<code class="example">        :lua require"lpeg"</code>
<code class="example">        :lua -- balanced parenthesis grammar:</code>
<code class="example">        :lua bp = lpeg.P{ "(" * ((1 - lpeg.S"()") + lpeg.V(1))^0 * ")" }</code>
<code class="example">        :luado if bp:match(line) then return "--&gt;\t" .. line end</code>


                                                        <b class="vimtag"> <a name=":luafile">:luafile</a> </b>
:<code class="special">[range]</code>luafile <code class="special">{file}</code>
                        执行 Lua <code class="special">{file}</code> 文件中的脚本。
                        整个参数用作单个文件名。

示例:

<code class="example">        :luafile script.lua</code>
<code class="example">        :luafile %</code>


以上的命令都可执行一段 Lua 代码块 (chunk)，或从命令行 (:lua 和 :luado)，或从文
件 (:luafile)，并可给出行范围 <code class="special">[range]</code>。和 Lua 解释器类似，每个代码块都有自己的
作用域，所以命令之间只有全局变量可以共享。所有的 Lua 缺省库都可用。此外，Lua
的 "print" 函数的输出重定向到 Vim 消息区，参数以空格而不是制表符分隔。

Lua 使用 "vim" 模块 (见  <a href="if_lua.html#lua-vim">lua-vim</a> ) 来对 Vim 发出指令以及对缓冲区
( <a href="if_lua.html#lua-buffer">lua-buffer</a> ) 和窗口 ( <a href="if_lua.html#lua-window">lua-window</a> ) 进行管理。不过在  <a href="eval.html#sandbox">sandbox</a>  中执行命令时，
修改缓冲区内容、打开新缓冲区和改变光标位置的过程受到限制。


</section><hr class="doubleline" /><section class=inner>
<h4>2. vim 模块                                             <b class="vimtag"> <a name="lua-vim">lua-vim</a> </b></h4>
Lua 通过 "vim" 模块和 Vim 进行接口。输入行范围的首末行分别存入 "vim.firstline"
和 "vim.lastline"。该模块也包含一些对缓冲区、窗口以及当前行查询的例程、Vim 调
用和命令执行，以及其它各种操作。

        vim.list(<code class="special">[arg]</code>)         返回空列表或者，如果给出 "arg" 为带有数值键值
                                1, ..., n 的Lua 表 (即 "sequence")，返回列表
                                l，l[i] = arg[i] 对 i = 1, .., n (见  <a href="eval.html#List">List</a> )。
                                非数值的键值不用于列表的初始化。转换规则参见
                                 <a href="if_lua.html#lua-eval">lua-eval</a> 。示例:
<code class="example">                                    :lua t = {math.pi, false, say = 'hi'}</code>
<code class="example">                                    :echo luaeval('vim.list(t)')</code>
<code class="example">                                    :" [3.141593, v:false], 'say' 被忽略</code>


        vim.dict(<code class="special">[arg]</code>)         返回空字典或者，如果给出 "arg" 为 Lua 表，返回
                                字典 d，d[k] = arg[k] 对所有 "arg" 中的字符串
                                键值 k (见  <a href="eval.html#Dictionary">Dictionary</a> )。数值键值转化为字符
                                串。非字符串的键值不用于列表的初始化。转换规则
                                参见  <a href="if_lua.html#lua-eval">lua-eval</a> 。示例:
<code class="example">                                    :lua t = {math.pi, false, say = 'hi'}</code>
<code class="example">                                    :echo luaeval('vim.dict(t)')</code>
<code class="example">                                    :" {'1': 3.141593, '2': v:false,</code>
<code class="example">                                    :" 'say': 'hi'}</code>

        vim.blob(<code class="special">[arg]</code>)         返回空 blob 或者，如果给出 "arg" 为 Lua 字符
                                串，返回 blob b，b 等价于作为字节字符串的
                                "arg"。
                                例如:
<code class="example">                                    :lua s = "12ab\x00\x80\xfe\xff"</code>
<code class="example">                                    :echo luaeval('vim.blob(s)')</code>
<code class="example">                                    :" 0z31326162.0080FEFF</code>

        vim.funcref(<code class="special">{name}</code>)     返回对应函数名 <code class="special">{name}</code> 的函数引用 (参见
                                 <a href="eval.html#Funcref">Funcref</a> )。等价于 Vim 的 function()。

        vim.buffer(<code class="special">[arg]</code>)       如果 "arg" 是数值，返回缓冲区列表中编号为
                                "arg" 的缓冲区。如果 "arg" 为字符串，返回完整
                                明或简短名为 "arg" 的缓冲区。这两种情况下，如
                                果找不到缓冲区，返回 <code class="badlink">'nil'</code>。此外，如果
                                "toboolean(arg)" 为 <code class="badlink">'true'</code>，返回缓冲区列表的首
                                个缓冲区，否则返回当前缓冲区。

        vim.window(<code class="special">[arg]</code>)       如果 "arg" 是数值，返回编号为 "arg" 的窗口，如
                                果找不到，返回 <code class="badlink">'nil'</code>。此外，如果
                                "toboolean(arg)" 为 <code class="badlink">'true'</code>，返回首个窗口，否则
                                返回当前窗口。

        vim.type(<code class="special">{arg}</code>)         返回 <code class="special">{arg}</code> 的类型。等价于 Lua 的 "type" 函数，
                                但若 <code class="special">{arg}</code> 是列表、字典、缓冲区、窗口则分别返
                                回 "list"、"dict"、"funcref"、"buffer" 或
                                "window"。示例:
<code class="example">                                        :lua l = vim.list()</code>
<code class="example">                                        :lua print(type(l), vim.type(l))</code>
<code class="example">                                        :" list</code>

        vim.command(<code class="special">{cmds}</code>)     执行 <code class="special">{cmds}</code> 里一行或多行的 Ex 模式命令。
                                示例:
<code class="example">                                        :lua vim.command"set tw=60"</code>
<code class="example">                                        :lua vim.command"normal ddp"</code>
<code class="example">                                        lua &lt;&lt; trim END</code>
<code class="example">                                          vim.command([[</code>
<code class="example">                                              new Myfile.js</code>
<code class="example">                                              call search('start')</code>
<code class="example">                                          ]])</code>
<code class="example">                                        END</code>

        vim.eval(<code class="special">{expr}</code>)        计算表达式 <code class="special">{expr}</code> (见  <a href="eval.html#expression">expression</a> )，把结果转
                                化为 Lua 格式并返回。Vim 字符串和数值被直接转
                                为响应的 Lua 字符串和数值类型。Vim 列表和字典
                                被转化为 Lua 的用户数据 (userdata) (见
                                 <a href="if_lua.html#lua-list">lua-list</a>  和  <a href="if_lua.html#lua-dict">lua-dict</a> )。
                                示例:
<code class="example">                                        :lua tw = vim.eval"&amp;tw"</code>
<code class="example">                                        :lua print(vim.eval"{'a': 'one'}".a)</code>

        vim.line()              返回当前行 (没有结尾的 <code class="special">&lt;EOL&gt;</code>)，Lua 字符串。

        vim.beep()              鸣笛。

        vim.open(<code class="special">{fname}</code>)       为文件 <code class="special">{fname}</code> 打开新缓冲区并返回之。<code class="note">注意</code> 并不
                                把该缓冲区设为当前缓冲区。

        vim.call(<code class="special">{name}</code> [, <code class="special">{args}</code>])
                                调用名为 <code class="special">{name}</code> 带参数 <code class="special">{args}</code> 的 Vim 函数的代
                                理。例如:
<code class="example">                                        :lua print(vim.call('has', 'timers'))</code>

        vim.fn                  调用 Vim 函数的代理。代理方法会按需建立。
                                例如:
<code class="example">                                        :lua print(vim.fn.has('timers'))</code>

        vim.lua_version         Vim 编译所带的 Lua 版本，形如
                                <code class="special">{major}</code>.<code class="special">{minor}</code>.<code class="special">{patch}</code>，如 "5.1.4"。

        vim.version()           返回 Lua 表，提供Vim 版本信息。
                                此表有以下键:
                                        major - 主 Vim 版本号。
                                        minor - 次 Vim 版本号。
                                        patch - 包含的最新补丁号。

                                                        <b class="vimtag"> <a name="lua-vim-variables">lua-vim-variables</a> </b>
Lua 可以方便地和合乎惯例地引用下面所述的  <code class="badlink">vim.*</code>  Lua 表来访问 Vim 编辑器的全局
字典  <a href="eval.html#g:">g:</a>   <a href="eval.html#w:">w:</a>   <a href="eval.html#b:">b:</a>   <a href="eval.html#t:">t:</a>   <a href="eval.html#v:">v:</a> 。这样在 Lua 里读取和修改全局 Vim 脚本变量就十分
方便。

示例:
<code class="example"></code>
<code class="example">    vim.g.foo = 5     -- 设置 g:foo Vim 脚本变量。</code>
<code class="example">    print(vim.g.foo)  -- 获取和显示 g:foo Vim 脚本变量。</code>
<code class="example">    vim.g.foo = nil   -- 删除 (:unlet) Vim 脚本变量。</code>
<code class="example"></code>
vim.g                                                   <b class="vimtag"> <a name="vim.g">vim.g</a> </b>
        全局 ( <a href="eval.html#g:">g:</a> ) 编辑器变量集。
        无对应值的键返回  <code class="badlink">nil</code> 。

vim.b                                                   <b class="vimtag"> <a name="vim.b">vim.b</a> </b>
        当前缓冲区的缓冲区作用域 ( <a href="eval.html#b:">b:</a> ) 变量集。
        非法或未设置的键返回  <code class="badlink">nil</code> 。

vim.w                                                   <b class="vimtag"> <a name="vim.w">vim.w</a> </b>
        当前窗口的窗口作用域 ( <a href="eval.html#w:">w:</a> ) 变量集。
        非法或未设置的键返回  <code class="badlink">nil</code> 。

vim.t                                                   <b class="vimtag"> <a name="vim.t">vim.t</a> </b>
        当前标签页的标签页作用域 ( <a href="eval.html#t:">t:</a> ) 变量集。
        非法或未设置的键返回  <code class="badlink">nil</code> 。

vim.v                                                   <b class="vimtag"> <a name="vim.v">vim.v</a> </b>
         <a href="eval.html#v:">v:</a>  变量。
        非法或未设置的键返回  <code class="badlink">nil</code> 。

</section><hr class="doubleline" /><section class=inner>
<h4>3. 列表用户数据                                         <b class="vimtag"> <a name="lua-list">lua-list</a> </b></h4>
列表用户数据代表 vim 的列表，其接口尽量和 Vim 的列表语法相近。因为列表为对象，
Lua 中列表引用的改变会反映在 Vim 中，反之亦然。列表 "l" 有以下属性和方法:

<code class="note">注意</code>: 8.2.1066 补丁开始，数组索引从以零为底改为以一为底。可以这样检查:
<code class="example">            if has("patch-8.2.1066")</code>
<code class="example"></code>
属性
</section><hr class="singleline" /><section class=inner>
        o "#l" 是列表 "l" 的项目数，相当于 Vim 中的 "len(l)"。
        o "l[k]" 返回 "l" 的第 k 项；"l" 索引从一开始，和 Lua 一样。
            要修改第 k 项，可用 "l[k] = newitem"；特别地，"l[k] = nil" 删除
            "l" 的第 k 项。要在列表最后附加项目，可用 "l[#l + 1] = newitem"
        o "l()" 返回遍历 "l" 的 iterator。
        o "table.insert(l, newitem)" 在列表最后插入项目。
            (仅适用于 Lua 5.3 和以后版本)
        o "table.insert(l, position, newitem)" 在指定位置插入项目。"position"
            从一开始。(仅适用于 Lua 5.3 和以后版本)
        o "table.remove(l, position)" 在指定位置删除项目。"position" 从一开
            始。

方法
</section><hr class="singleline" /><section class=inner>
        o "l:add(item)" 在 "l" 尾部附加 "item" 项目。
        o "l:insert(item[, pos])" 在可选的 "pos" 指定的位置上插入 "item" 项
            目。"pos" 缺省值为 "0"。

示例:

<code class="example">        :let l = [1, 'item']</code>
<code class="example">        :lua l = vim.eval('l') -- 相同的 'l'</code>
<code class="example">        :lua l:add(vim.list())</code>
<code class="example">        :lua l[1] = math.pi</code>
<code class="example">        :echo l[0] " 3.141593</code>
<code class="example">        :lua l[1] = nil -- 删除第一项</code>
<code class="example">        :lua l:insert(true, 1)</code>
<code class="example">        :lua print(l, #l, l[1], l[2])</code>
<code class="example">        :lua l[#l + 1] = 'value'</code>
<code class="example">        :lua table.insert(l, 100)</code>
<code class="example">        :lua table.insert(l, 2, 200)</code>
<code class="example">        :lua table.remove(l, 1)</code>
<code class="example">        :lua for item in l() do print(item) end</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>4. 字典用户数据                                         <b class="vimtag"> <a name="lua-dict">lua-dict</a> </b></h4>
和列表用户数据类似，字典用户数据代表 vim 的字典；既然字典也是对象，Lua 和 Vim
共享对象的引用。字典 "d" 有以下属性:

属性
</section><hr class="singleline" /><section class=inner>
        o "#d" 是字典 "d" 的项目数，相当于 Vim 中的 "len(d)"。
        o "d.key" 或 "d[<a href="options.html#'key'">'key'</a>]" 返回 "d" "key" 对应项目的值。要修改其值，可用
          "d.key = newvalue"；特别地，"d[k] = nil" 删除 "d" 中的对应项目。
        o "d()" 返回遍历 "d" 的 iterator，等价于 Vim 的 "items(d)"。

示例:

<code class="example">        :let d = {'n':10}</code>
<code class="example">        :lua d = vim.eval('d') -- 相同的 'd'</code>
<code class="example">        :lua print(d, d.n, #d)</code>
<code class="example">        :let d.self = d</code>
<code class="example">        :lua for k, v in d() do print(d, k, v) end</code>
<code class="example">        :lua d.x = math.pi</code>
<code class="example">        :lua d.self = nil -- 删除项目</code>
<code class="example">        :echo d</code>


</section><hr class="doubleline" /><section class=inner>
<h4>5. blob 用户数据                                        <b class="vimtag"> <a name="lua-blob">lua-blob</a> </b></h4>
blob 用户数据代表 vim blob。blob "b" 有以下属性:

属性
</section><hr class="singleline" /><section class=inner>
        o "#b" 是 blob "b" 的长度，等价于 Vim 中的 "len(b)"。
        o "b[k]" 返回 "b" 的第 k 项；就像 Vim 那样，"b" 的索引从零开始。
            要修改第 k 项，简单地用 "b[k] = number"；特别地，
            "b[#b] = number" 可以在尾处附加一个字节。

方法
</section><hr class="singleline" /><section class=inner>
        o "b:add(bytes)" 在 "b" 的尾处附加 "bytes"。

示例:

<code class="example">        :let b = 0z001122</code>
<code class="example">        :lua b = vim.eval('b') -- 相同的 'b'</code>
<code class="example">        :lua print(b, b[0], #b)</code>
<code class="example">        :lua b[1] = 32</code>
<code class="example">        :lua b[#b] = 0x33 -- 在尾处附加一个字节</code>
<code class="example">        :lua b:add("\x80\x81\xfe\xff")</code>
<code class="example">        :echo b</code>


</section><hr class="doubleline" /><section class=inner>
<h4>6. 函数引用用户数据                                     <b class="vimtag"> <a name="lua-funcref">lua-funcref</a> </b></h4>
函数引用用户数据代表 Vim 的函数引用变量。定义时带有 "dict" 属性的函数引用需通
过赋给某字典的一个键值来使其 "self" 对应该字典 (见下例)。函数引用 "f" 有以下属
性:

属性
</section><hr class="singleline" /><section class=inner>
        o "#f" 是 "f" 引用的函数名
        o "f(...)" 调用 "f" 引用的函数 (带参数)

示例:

<code class="example">        :function I(x)</code>
<code class="example">        :  return a:x</code>
<code class="example">        :  endfunction</code>
<code class="example">        :let R = function('I')</code>
<code class="example">        :lua i1 = vim.funcref('I')</code>
<code class="example">        :lua i2 = vim.eval('R')</code>
<code class="example">        :lua print(#i1, #i2) -- 都应返回 'I'</code>
<code class="example">        :lua print(i1, i2, #i2(i1) == #i1(i2))</code>
<code class="example">        :function Mylen() dict</code>
<code class="example">        :  return len(self.data)</code>
<code class="example">        :  endfunction</code>
<code class="example">        :let mydict = {'data': [0, 1, 2, 3]}</code>
<code class="example">        :lua d = vim.eval('mydict'); d.len = vim.funcref('Mylen')</code>
<code class="example">        :echo mydict.len()</code>
<code class="example">        :lua l = d.len -- 把 d 视为 'self'</code>
<code class="example">        :lua print(l())</code>

Lua 函数和闭包会自动转换为 Vim 的  <a href="eval.html#Funcref">Funcref</a> ，以便在 Vim 脚本里访问。例如:

<code class="example">        lua &lt;&lt;EOF</code>
<code class="example">        vim.fn.timer_start(1000, function(timer)</code>
<code class="example">            print('timer callback')</code>
<code class="example">        end)</code>
<code class="example">        EOF</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>7. 缓冲区用户数据                                       <b class="vimtag"> <a name="lua-buffer">lua-buffer</a> </b></h4>
缓冲区用户数据代表 vim 的缓冲区。缓冲区用户数据 "b" 包含以下属性和方法:

属性
</section><hr class="singleline" /><section class=inner>
        o "b()" 设置 "b" 为当前缓冲区。
        o "#b" 是缓冲区 "b" 的行数。
        o "b[k]" 代表行号 k: "b[k] = newline" 把第 "k" 行替换为字符串
            "newline"，还有 "b[k] = nil" 删除第 "k" 行。
        o "b.name" 包含缓冲区 "b" 的简短名 (只读)。
        o "b.fname" 包含缓冲区 "b" 的完整名 (只读)。
        o "b.number" 包含缓冲区 "b" 在缓冲区列表的位置 (只读)。

方法
</section><hr class="singleline" /><section class=inner>
        o "b:insert(newline"[, pos]")" 在缓冲区 "pos" (可选) 位置插入
            "newline" 字符串。"pos" 缺省值为 "#b + 1"。如果 "pos == 0"，
            "newline" 将成为缓冲区的首行。
        o "b:next()" 返回缓冲区列表中 "b" 的下一个缓冲区。
        o "b:previous()" 返回缓冲区列表 "b" 的前一个缓冲区。
        o "b:isvalid()" 如果缓冲区 "b" 对应 "真正的" (内存没有释放的) Vim 缓
            冲区时，返回 <code class="badlink">'true'</code> (布尔值)。

示例:

<code class="example">        :lua b = vim.buffer() -- 当前缓冲区</code>
<code class="example">        :lua print(b.name, b.number)</code>
<code class="example">        :lua b[1] = "first line"</code>
<code class="example">        :lua b:insert("FIRST!", 0)</code>
<code class="example">        :lua b[1] = nil -- 删除首行</code>
<code class="example">        :lua for i=1,3 do b:insert(math.random()) end</code>
<code class="example">        :3,4lua for i=vim.lastline,vim.firstline,-1 do b[i] = nil end</code>
<code class="example">        :lua vim.open"myfile"() -- 打开缓冲区，设为当前缓冲区</code>
<code class="example"></code>
<code class="example">        function! ListBuffers()</code>
<code class="example">        lua &lt;&lt; EOF</code>
<code class="example">        local b = vim.buffer(true) -- 列表中的首个缓冲区</code>
<code class="example">        while b ~= nil do</code>
<code class="example">                print(b.number, b.name, #b)</code>
<code class="example">                b = b:next()</code>
<code class="example">        end</code>
<code class="example">        vim.beep()</code>
<code class="example">        EOF</code>
<code class="example">        endfunction</code>


</section><hr class="doubleline" /><section class=inner>
<h4>8. 窗口用户数据                                         <b class="vimtag"> <a name="lua-window">lua-window</a> </b></h4>
窗口对象代表 vim 窗口。窗口用户数据 "w" 有以下属性和方法:

属性
</section><hr class="singleline" /><section class=inner>
        o "w()" 设置 "w" 为当前窗口。
        o "w.buffer" 返回窗口 "w" 对应的缓冲区 (只读)。
        o "w.line" 返回窗口 "w" 的光标行位置。
        o "w.col" 返回窗口 "w" 的光标列位置。
        o "w.width" 代表窗口 "w" 的宽度。
        o "w.height" 代表窗口 "w" 的高度。

方法
</section><hr class="singleline" /><section class=inner>
        o "w:next()" 返回 "w" 的下一个窗口。
        o "w:previous()" 返回 "w" 的前一个窗口。
        o "w:isvalid()"  如果窗口 "w" 对应 "真正的" (内存没有释放的) Vim 窗
            口，返回 <code class="badlink">'true'</code> (布尔值)。

示例:

<code class="example">        :lua w = vim.window() -- 当前窗口</code>
<code class="example">        :lua print(w.buffer.name, w.line, w.col)</code>
<code class="example">        :lua w.width = w.width + math.random(10)</code>
<code class="example">        :lua w.height = 2 * math.random() * w.height</code>
<code class="example">        :lua n,w = 0,vim.window(true) while w~=nil do n,w = n + 1,w:next() end</code>
<code class="example">        :lua print("有 " .. n .. " 个窗口")</code>


</section><hr class="doubleline" /><section class=inner>
<h4>9. luaeval 函数                                         <b class="vimtag"> <a name="lua-luaeval">lua-luaeval</a> </b> <b class="vimtag"> <a name="lua-eval">lua-eval</a> </b></h4>
和 "vim.eval" 对应，"luaeval" 在 Vim 中接受 Lua 值的传入。"luaeval" 接受一个
表达式字符串以及一个可选的参数，并返回表达式计算的结果。语义上，等价于在 Lua
里进行如下的操作:

<code class="example">        local chunkheader = "local _A = select(1, ...) return "</code>
<code class="example">        function luaeval (expstr, arg)</code>
<code class="example">            local chunk = assert(loadstring(chunkheader .. expstr, "luaeval"))</code>
<code class="example">            return chunk(arg) -- return typval</code>
<code class="example">        end</code>

<code class="note">注意</code> "_A" 接收给 "luaeval" 的参数。Lua 数值，字符串，列表，字典、blob 和函数引
用用户数据转化为 Vim 对应的类型，Lua 布尔型转化为数值。试图转换其他 Lua 类型的
企图，包括非列表、字典、blob、函数引用的用户数据，会抛出错误。

示例:
<code class="example"></code>
<code class="example">        :echo luaeval('math.pi')</code>
<code class="example">        :lua a = vim.list():add('newlist')</code>
<code class="example">        :let a = luaeval('a')</code>
<code class="example">        :echo a[0] " 'newlist'</code>
<code class="example">        :function Rand(x,y) " random uniform between x and y</code>
<code class="example">        :  return luaeval('(_A.y-_A.x)*math.random()+_A.x', {'x':a:x,'y':a:y})</code>
<code class="example">        :  endfunction</code>
<code class="example">        :echo Rand(1,10)</code>
<code class="example"></code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>10. 动态调入                                        <b class="vimtag"> <a name="lua-dynamic">lua-dynamic</a> </b></h4>
MS-Windows 和 Unix 上，可以动态调入 Lua 库。此时  <a href="various.html#:version">:version</a>  输出包含
 <a href="various.html#+lua%2Fdyn">+lua/dyn</a> 。

这意味着 Vim 只有在必要时才寻找 Lua DLL 或共享文件。如果不使用 Lua 接口，
你就不需要它们。这样，即使没有这些 DLL 文件，你也可使用 Vim。


<code class="section">MS-Windows </code>

要使用 Lua 接口，Lua DLL 必须在搜索路径上。控制台窗口里输入 "path" 可以看到
(搜索路径) 当前使用的目录。也可用 <a href="options.html#'luadll'">'luadll'</a> 选项指定 Lua DLL。DLL 的版本必须和
Vim 编译使用的 Lua 版本保持一致。


<code class="section">Unix </code>

<a href="options.html#'luadll'">'luadll'</a> 选项可用来指定 Lua 共享库文件，而不用编译时指定的 DYNAMIC_LUA_DLL 文
件。共享库的版本必须和 Vim 编译使用的 Lua 版本保持一致。


</section><hr class="doubleline" /><section class=inner>
<h4> vim:tw=78:ts=8:noet:ft=help:norl:</h4></section>
</article>
<footer>
Generated by vim2html
</footer>
</body>
</html>
