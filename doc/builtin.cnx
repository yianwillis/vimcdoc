*builtin.txt*	适用于 Vim 9.1 版本。  最近更新: 2025年12月

		  VIM 参考手册	by Bram Moolenaar
				译者: Willis


内建函数					*builtin-functions*

注意: 编译时如果关闭了表达式求值。内建函数也将不可用。见 |+eval| 和
|no-eval-feature|。

按用途分类的函数列表，可见 |function-list|。

1. 概览					|builtin-function-list|
2. 详述					|builtin-function-details|
3. 特性列表				|feature-list|
4. 字符串里的模式匹配			|string-match|

==============================================================================
1. 概览						*builtin-function-list*

在函数名上使用 CTRL-] 跳转到完整的功能说明。

用法				结果	描述	~

abs({expr})			浮点/数值
					{expr} 的绝对值
acos({expr})			浮点	{expr} 的反余弦值
add({object}, {item})		列表/blob
					在 {object} 末尾附加项目 {item}
and({expr}, {expr})		数值	按位与
append({lnum}, {text})		数值	在当前缓冲区第 {lnum} 行下附加 {text}
appendbufline({buf}, {lnum}, {text})
				数值	在缓冲区 {buf} 行 {lnum} 下附加 {text}
argc([{winid}])			数值	全局或指定窗口的局部参数列表的文件数目
argidx()			数值	参数列表的当前索引
arglistid([{winnr} [, {tabnr}]])
				数值	全局或指定窗口的局部参数列表 id
argv({nr} [, {winid}])		字符串	参数列表第 {nr} 个参数
asin({expr})			浮点	{expr} 的反正弦值
argv([-1, {winid}])		列表	参数列表
assert_beeps({cmd})		数值	执行 {cmd}，断言执行过程中会响铃
assert_equal({exp}, {act} [, {msg}])
				数值	断言 {exp} 等于 {act}
assert_equalfile({fname-one}, {fname-two} [, {msg}])
				数值	断言指定的两个文件的内容相同
assert_exception({error} [, {msg}])
				数值	断言 |v:exception| 中有 {error}
assert_fails({cmd} [, {error} [, {msg} [, {lnum} [, {context}]]]])
				数值	执行 {cmd}，断言其会失败
assert_false({actual} [, {msg}])
				数值	断言 {actual} 为假
assert_inrange({lower}, {upper}, {actual} [, {msg}])
				数值	断言 {actual} 在 [{lower}, {upper}] 内
assert_match({pat}, {text} [, {msg}])
				数值	断言模式 {pat} 匹配 {text}
assert_nobeep({cmd})		数值	运行 {cmd}，断言执行过程中不导致响铃
assert_notequal({exp}, {act} [, {msg}])
				数值	断言 {exp} 不等于 {act}
assert_notmatch({pat}, {text} [, {msg}])
				数值	断言模式 {pat} 不匹配 {text}
assert_report({msg})		数值	报告一个测试失败，使用错误信息 {msg}
assert_true({actual} [, {msg}])	数值	断言 {actual} 为真
atan({expr})			浮点	{expr} 的反正切值
atan2({expr1}, {expr2})		浮点	{expr1} / {expr2} 的反正切值
autocmd_add({acmds})		布尔型	新增一组自动命令和自动命令组
autocmd_delete({acmds})		布尔型	删除一组自动命令和自动命令组
autocmd_get([{opts}])		列表	自动命令列表
balloon_gettext()		字符串	气泡的当前文本
balloon_show({expr})		无	在气泡中显示 {expr}
balloon_split({msg})		列表	切分用于气泡的 {msg}
base64_decode({string})		blob	对 {string} 里的字符进行 base64 解码
base64_encode({blob})		字符串	对 {blob} 的字节进行 base64 编码
bindtextdomain({package}, {path})
				布尔型	绑定文本域 {package} 到特定路径 {path}
blob2list({blob})		列表	将 {blob} 转换为数值字节代码的列表
blob2str({blob} [, {options}])	列表	将 {blob} 转换为字符串列表，每行一项
browse({save}, {title}, {initdir}, {default})
				字符串	启动文件请求窗口
browsedir({title}, {initdir})	字符串	启动目录请求窗口，指定标题和开始目录
bufadd({name})			数值	在缓冲区列表中加入缓冲区 {name}
bufexists({buf})		数值	缓冲区 {buf} 存在则为 |TRUE|
buflisted({buf})		数值	缓冲区 {buf} 在缓冲区列表中则为 |TRUE|
bufload({buf})			数值	尚未加载时载入缓冲区 {buf}
bufloaded({buf})		数值	缓冲区 {buf} 已加载则为 |TRUE|
bufname([{buf}])		字符串	缓冲区 {buf} 的名字
bufnr([{buf} [, {create}]])	数值	缓冲区 {buf} 的编号
bufwinid({buf})			数值	缓冲区 {buf} 相关联的窗口 ID
bufwinnr({buf})			数值	缓冲区 {buf} 相关联的窗口号
byte2line({byte})		数值	当前缓冲区第 {byte} 个字节所在的行号
byteidx({expr}, {nr} [, {utf16}])
				数值	{expr} 里第 {nr} 个字符的字节位置
byteidxcomp({expr}, {nr} [, {utf16}])
				数值	{expr} 字符 {nr} 的字节位置，组合单算
call({func}, {arglist} [, {dict}])
				可变	调用函数 {func}，使用参数 {arglist}
ceil({expr})			浮点	{expr} 向上取整
ch_canread({handle})		数值	检查 {handle} 是否有可读的内容
ch_close({handle})		无	关闭 {handle}
ch_close_in({handle})		无	关闭 {handle} 的 in 部分
ch_evalexpr({handle}, {expr} [, {options}])
				可变	在 JSON {handle} 上执行 {expr}
ch_evalraw({handle}, {string} [, {options}])
				可变	在原始 {handle} 上执行 {string}
ch_getbufnr({handle}, {what})	数值	获取 {handle} 用于 {what} 的缓冲区号
ch_getjob({channel})		作业	获取 {channel} 的相关作业
ch_info({handle})		字符串	通道 {handle} 的相关信息
ch_log({msg} [, {handle}])	无	在通道日志文件中写入 {msg}
ch_logfile({fname} [, {mode}])	无	启动通道日志，使用文件 {fname}
ch_open({address} [, {options}])
				通道	打开到 {address} 的通道
ch_read({handle} [, {options}])	字符串	从 {handle} 读取
ch_readblob({handle} [, {options}])
				blob	从 {handle} 读取 blob
ch_readraw({handle} [, {options}])
				字符串	从 {handle} 读取原始格式数据
ch_sendexpr({handle}, {expr} [, {options}])
				可变	在 JSON {handle} 上发送 {expr}
ch_sendraw({handle}, {expr} [, {options}])
				可变	在原始 {handle} 上发送 {expr}
ch_setoptions({handle}, {options})
				无	设置 {handle} 的选项
ch_status({handle} [, {options}])
				字符串	通道 {handle} 的状态
changenr()			数值	当前改变号
char2nr({expr} [, {utf8}])	数值	{expr} 首个字符的 ASCII/UTF-8 值
charclass({string})		数值	{string} 首个字符的字符类
charcol({expr} [, {winid}])	数值	光标或位置标记的列字符索引
charidx({string}, {idx} [, {countcc} [, {utf16}]])
				数值	{string} 里字节 {idx} 所属的字符索引
chdir({dir})			数值	切换当前工作目录
cindent({lnum})			数值	第 {lnum} 行的 C 缩进量
clearmatches([{win}])		无	清除所有的匹配
cmdcomplete_info()		字典	获取当前命令行补全信息
col({expr} [, {winid}])		数值	光标或位置标记的列字节索引
complete({startcol}, {matches})	无	设置插入模式补全
complete_add({expr})		数值	新增补全匹配 {expr}
complete_check()		数值	补全时检查输入的键
complete_info([{what}])		字典	获取当前补全信息
confirm({msg} [, {choices} [, {default} [, {type}]]])
				数值	让用户选择，返回选项的序号
copy({expr})			可变	构造 {expr} 的浅备份
cos({expr})			浮点	{expr} 的余弦值
cosh({expr})			浮点	{expr} 的双曲余弦值
count({comp}, {expr} [, {ic} [, {start}]])
				数值	统计 {comp} 里的 {expr} 个数
cscope_connection([{num} , {dbpath} [, {prepend}]])
				数值	检查 cscope 连接是否存在
cursor({lnum}, {col} [, {off}])
				数值	定位光标到位置 {lnum}，{col}，{off}
debugbreak({pid})		数值	中断待调试的进程
cursor({list})			数值	移动光标到 {list} 里的位置
deepcopy({expr} [, {noref}])	可变	构造 {expr} 的完整备份
delete({fname} [, {flags}])	数值	删除文件或目录 {fname}
deletebufline({buf}, {first} [, {last}])
				数值	删除缓冲区 {buf} 中的一行或多行
did_filetype()			数值	用过 FileType 自动命令事件则为 |TRUE|
diff({fromlist}, {tolist} [, {options}])
				列表	比较字符串列表 {fromlist} 和 {tolist}
diff_filler({lnum})		数值	第 {lnum} 行之上的比较填充行数目
diff_hlID({lnum}, {col})	数值	{lnum}/{col} 位置所在的比较高亮
digraph_get({chars})		字符串	获取 {chars} 对应的二合字母 |digraph|
digraph_getlist([{listall}])	列表	获取所有二的合字母 |digraph|
digraph_set({chars}, {digraph})	布尔型	注册二合字母 |digraph|
digraph_setlist({digraphlist})	布尔型	注册多个二合字母 |digraph|
echoraw({expr})			无	按原样输出 {expr}
empty({expr})			数值	{expr} 为空则为 |TRUE|
environ()			字典	所有环境变量构成的字典
err_teapot([{expr}])		无	{expr} 为 |TRUE| 时报错 E418 或 E503
escape({string}, {chars})	字符串	在 {string} 里用 '\' 转义 {chars}
eval({string})			可变	计算 {string} 并返回其结果
eventhandler()			数值	处于事件处理器中则为 |TRUE|
executable({expr})		数值	可执行文件 {expr} 存在则为 1
execute({command})		字符串	执行 {command} 并获取其输出结果
exepath({expr})			字符串	命令 {expr} 的完整路径
exists({expr})			数值	{expr} 存在则为 |TRUE|
exists_compiled({expr})		数值	{expr} 编译时存在则为 |TRUE|
exp({expr})			浮点	{expr} 的指数函数值 (以 e 为底)
expand({expr} [, {nosuf} [, {list}]])
				可变	扩展 {expr} 里的通配符和特殊关键字
expandcmd({string} [, {options}])
				字符串	像 `:edit` 那样扩展 {string}
extend({expr1}, {expr2} [, {expr3}])
				列表/字典
					把 {expr2} 里的项目追加到 {expr1} 之后
extendnew({expr1}, {expr2} [, {expr3}])
				列表/字典
					和 |extend()| 类同，但建立新列表或字典
feedkeys({string} [, {mode}])	数值	将键序列 {string} 加入预输入缓冲区
filecopy({from}, {to})		数值	复制文件 {from} 到 {to}，返回成功与否
filereadable({file})		数值	{file} 为可读文件则为 |TRUE|
filewritable({file})		数值	{file} 为可写文件则为 |TRUE|
filter({expr1}, {expr2})	列表/字典/blob/字符串
					删除 {expr1} 里 {expr2} 为 0 的项目
finddir({name} [, {path} [, {count}]])
				字符串	在 {path} 里查找目录 {name}
findfile({name} [, {path} [, {count}]])
				字符串/列表
					在 {path} 里查找文件 {name}
flatten({list} [, {maxdepth}])	列表	展平 {list}，最多到 {maxdepth} 层
flattennew({list} [, {maxdepth}])
				列表	展平 {list}，先创建备份再进行
float2nr({expr})		数值	取浮点数 {expr} 的整数部分，转换为数值
floor({expr})			浮点	{expr} 向下取整
fmod({expr1}, {expr2})		浮点	{expr1} / {expr2} 的浮点余数
fnameescape({fname})		字符串	转义 {fname} 中的特殊字符
fnamemodify({fname}, {mods})	字符串	根据修饰符 {mods} 修改文件名 {fname}
foldclosed({lnum})		数值	第 {lnum} 行所在已关闭折叠的首行
foldclosedend({lnum})		数值	第 {lnum} 行所在已关闭折叠的末行
foldlevel({lnum})		数值	第 {lnum} 行所处的折叠级别
foldtext()			字符串	获取折叠关闭时会显示的行
foldtextresult({lnum})		字符串	{lnum} 所在的已关闭折叠的显示文本
foreach({expr1}, {expr2})	列表/元组/字典/blob/字符串
					对 {expr1} 里的每个项目计算 {expr2}
foreground()			数值	把 Vim 窗口带到前台
fullcommand({name} [, {vim9}])	字符串	获取命令缩写 {name} 的完整命令名
funcref({name} [, {arglist}] [, {dict}])
				函数引用
					函数 {name} 的引用
function({name} [, {arglist}] [, {dict}])
				函数引用
					函数 {name} 的命名引用
garbagecollect([{atexit}])	无	释放内存，打破循环引用
get({list}, {idx} [, {def}])	可变	获取 {list} 的列表项 {idx}，缺省 {def}
get({dict}, {key} [, {def}])	可变	获取 {dict} 的字典项 {key}，缺省 {def}
get({func}, {what})		可变	函数引用/偏函数 {func} 的 {what} 属性
getbufinfo([{buf}])		列表	缓冲区的相关信息
getbufline({buf}, {lnum} [, {end}])
				列表	缓冲区 {buf} 第 {lnum} 到 {end} 行文本
getbufoneline({buf}, {lnum})	字符串	缓冲区 {buf} 第 {lnum} 行文本
getbufvar({buf}, {varname} [, {def}])
				可变	缓冲区 {buf} 的局部变量 {varname}
getcellpixels()			列表	获取字符的屏幕单元的像素尺寸
getcellwidths()			列表	获取字符的屏幕单元宽度覆盖
getchangelist([{buf}])		列表	缓冲区 {buf} 里改变列表所有项目的列表
getchar([{expr} [, {opts}]])	数值/字符串
					让用户输入一个字符
getcharmod()			数值	最近输入字符时使用的修饰符
getcharpos({expr})		列表	光标所在、末行、位置标记等的字符位置
getcharsearch()			字典	最近一次字符搜索的相关信息
getcharstr([{expr} [, {opts}]])	字符串	让用户输入一个字符，返回字符串
getcmdcomplpat()		字符串	当前命令行的补全模式
getcmdcompltype()		字符串	当前命令行的补全类型
getcmdline()			字符串	当前命令行的输入
getcmdpos()			数值	当前命令行的光标字节位置
getcmdprompt()			字符串	当前命令行的提示字符串
getcmdscreenpos()		数值	当前命令行的光标屏幕位置
getcmdtype()			字符串	当前命令行类型
getcmdwintype()			字符串	当前命令行窗口的类型
getcompletion({pat}, {type} [, {filtered}])
				列表	命令行补全的匹配项列表
getcompletiontype({pat})	字符串	{pat} 使用的命令行补全的类型
getcurpos([{winnr}])		列表	光标所在的字节位置
getcursorcharpos([{winnr}])	列表	光标所在的字符位置
getcwd([{winnr} [, {tabnr}]])	字符串	全局或指定窗口或标签页的当前工作目录
getenv({name})			字符串	返回环境变量 {name} 的值
getfontname([{name}])		字符串	正在使用的字体名或 {name} 的实际字体名
getfperm({fname})		字符串	文件 {fname} 的文件权限
getfsize({fname})		数值	文件 {fname} 以字节计算的大小
getftime({fname})		数值	文件 {fname} 的最新修改时间
getftype({fname})		字符串	文件 {fname} 所属类型的描述
getimstatus()			数值	IME 处于激活状态则为 |TRUE|
getjumplist([{winnr} [, {tabnr}]])
				列表	指定窗口的跳转列表里所有项目的列表
getline({lnum})			字符串	当前缓冲区中第 {lnum} 行
getline({lnum}, {end})		列表	当前缓冲区中第 {lnum} 到 {end} 行
getloclist({nr})		列表	窗口 {nr} 的位置列表里所有项目的列表
getloclist({nr}, {what})	字典	获取窗口 {nr} 的位置列表里的指定项目
getmarklist([{buf}])		列表	全局或局部于 {buf} 的位置标记的列表
getmatches([{win}])		列表	当前匹配列表
getmousepos()			字典	鼠标最近已知位置
getmouseshape()			字符串	当前鼠标指针的外型名
getpid()			数值	Vim 的进程 ID
getpos({expr})			列表	光标所在、末行、位置标记等的字节位置
getqflist()			列表	快速修复列表里所有项目的列表
getqflist([{what}])		字典	获取快速修复列表里的指定项目
getreg([{regname} [, 1 [, {list}]]])
				字符串/列表
					寄存器 {regname} 的内容
getreginfo([{regname}])		字典	寄存器 {regname} 的相关信息
getregion({pos1}, {pos2} [, {opts}])
				列表	获取从 {pos1} 到 {pos2} 区域的文本
getregionpos({pos1}, {pos2} [, {opts}])
				列表	获取从 {pos1} 到 {pos2} 区域的位置列表
getregtype([{regname}])		字符串	寄存器 {regname} 的类型
getscriptinfo([{opts}])		列表	已执行脚本的信息列表
getstacktrace()			列表	获取 Vim 脚本的当前栈追踪
gettabinfo([{expr}])		列表	所有标签页信息的列表
gettabvar({nr}, {varname} [, {def}])
				可变	标签页 {tabnr} 的局部变量 {varname}
gettabwinvar({tabnr}, {winnr}, {name} [, {def}])
				可变	指定标签页中指定窗口的局部变量 {name}
gettagstack([{nr}])		字典	获取窗口 {nr} 的标签栈
gettext({text} [, {package}])	字符串	查找 {text} 的翻译
getwininfo([{winid}])		列表	所有窗口信息的列表
getwinpos([{timeout}])		列表	Vim 窗口左上角以像素计的 X 和 Y 坐标
getwinposx()			数值	Vim 窗口左上角以像素计的 X 坐标
getwinposy()			数值	Vim 窗口左上角以像素计的 Y 坐标
getwinvar({nr}, {varname} [, {def}])
				可变	窗口 {nr} 的局部变量 {varname}
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])
				可变	扩展 {expr} 里的文件通配符
glob2regpat({expr})		字符串	将 glob 模式 {expr} 转换为搜索模式
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
				字符串	在 {path} 所有目录下执行 glob({expr})
has({feature} [, {check}])	数值	支持特性 {feature} 则为 |TRUE|
has_key({dict}, {key})		数值	{dict} 里存在键 {key} 则为 |TRUE|
haslocaldir([{winnr} [, {tabnr}]])
				数值	窗口用过 `:lcd` 或 `:tcd` 则为 |TRUE|
hasmapto({what} [, {mode} [, {abbr}]])
				数值	存在到 {what} 的映射则为 |TRUE|
histadd({history},{item})	数值	在历史 {history} 里新增项目 {item}
histdel({history} [, {item}])	数值	从历史 {history} 里删除项目
histget({history} [, {index}])	字符串	获取历史 {history} 里的第 {index} 项
histnr({history})		数值	历史 {history} 里最高的项目号
hlID({name})			数值	高亮组 {name} 的语法 (高亮组) ID
hlexists({name})		数值	高亮组 {name} 存在则为 |TRUE|
hlget([{name} [, {resolve}]])	列表	获取高亮组属性
hlset({list})			数值	设置高亮组属性
hostname()			字符串	运行 Vim 的机器名
iconv({expr}, {from}, {to})	字符串	转换 {expr} 的编码，从 {from} 到 {to}
id({item})			字符串	获取项目 {item} 的唯一标识字符串
indent({lnum})			数值	第 {lnum} 行的缩进量
index({object}, {expr} [, {start} [, {ic}]])
				数值	{expr} 在 {object} 里出现的索引位置
indexof({object}, {expr} [, {opts}]])
				数值	{object} 里使 {expr} 为真的项目的索引
input({prompt} [, {text} [, {completion}]])
				字符串	从用户获取输入
inputdialog({prompt} [, {text} [, {cancelreturn}]])
				字符串	和 input() 类同，但使用 GUI 对话框
inputlist({textlist})		数值	让用户从选择列表里挑选
inputrestore()			数值	恢复先前保存的预输入
inputsave()			数值	保存并清除预输入
inputsecret({prompt} [, {text}])
				字符串	和 input() 类同，但隐藏文本
insert({object}, {item} [, {idx}])
				列表	在 {object} 里插入 {item} [{idx} 之前]
instanceof({object}, {class})	数值	{object} 为 {class} 的实例则为 |TRUE|
interrupt()			无	中断脚本执行
invert({expr})			数值	按位取反
isabsolutepath({path})		数值	{directory} 是绝对路径则为 |TRUE|
isdirectory({directory})	数值	{directory} 是目录则为 |TRUE|
islocked({expr})		数值	{expr} 被锁住则为 |TRUE|
isinf({expr})			数值	{expr} 为无限大 (正或负) 则为 |TRUE|
isnan({expr})			数值	{expr} 为 NaN 则为 |TRUE|
items({expr})			列表	{expr} 里所有的键/索引-值组对
job_getchannel({job})		通道	获取 {job} 的通道句柄
job_info([{job}])		字典	获取 {job} 的信息
job_setoptions({job}, {options})
				无	设置 {job} 选项
job_start({command} [, {options}])
				作业	启动作业，执行 {command}
job_status({job})		字符串	获取 {job} 的状态
job_stop({job} [, {how}])	数值	停止 {job}
join({expr} [, {sep}])		字符串	将 {expr} 的所有项目连接成一个字符串
js_decode({string})		可变	对 {string} 进行 JS 风格的 JSON 解码
js_encode({expr})		字符串	对 {expr} 进行 JS 风格的 JSON 编码
json_decode({string})		可变	对 {string} 进行 JSON 解码
json_encode({expr})		字符串	对 {expr} 进行 JSON 编码
keys({dict})			列表	{dict} 里的所有键
keytrans({string})		字符串	把内部键值翻译为 |:map| 可接受的形式
len({expr})			数值	{expr} 的长度
libcall({lib}, {func}, {arg})	字符串	调用库 {lib} 函数 {func} 带参数 {arg}
libcallnr({lib}, {func}, {arg})	数值	同上，但返回数值
line({expr} [, {winid}])	数值	光标所在、末行或者位置标记所在的行号
line2byte({lnum})		数值	第 {lnum} 行对应的字节位置
lispindent({lnum})		数值	第 {lnum} 行的 Lisp 缩进量
list2blob({list})		blob	将数值字节代码 {list} 转换为 blob
list2str({list} [, {utf8}])	字符串	将数值字符代码 {list} 转换为字符串
list2tuple({list})		元组	用 {list} 里的项目创建新元组
listener_add({callback} [, {buf} [, {unbuffered}]])
				数值	新增改动监听器回调
listener_flush([{buf}])		无	激活监听器回调
listener_remove({id})		无	删除监听器回调
localtime()			数值	当前时间
log({expr})			浮点	{expr} 的自然对数 (以 e 为底)
log10({expr})			浮点	{expr} 以 10 为底的对数
luaeval({expr} [, {expr}])	可变	计算 |Lua| 表达式
map({expr1}, {expr2})		列表/字典/blob/字符串
					将 {expr1} 的每个项目用 {expr2} 替代
maparg({name} [, {mode} [, {abbr} [, {dict}]]])
				字符串/字典
					模式 {mode} 下映射 {name} 的右侧内容
mapcheck({name} [, {mode} [, {abbr}]])
				字符串	检查模式 {mode} 下匹配 {name} 的映射
maplist([{abbr}])		列表	所有映射的列表，每个映射对应一个字典
mapnew({expr1}, {expr2})	列表/字典/blob/字符串
					和 |map()| 类同，但创建新列表或字典
mapset({mode}, {abbr}, {dict})	无	通过 |maparg()| 的返回值来恢复映射
match({expr}, {pat} [, {start} [, {count}]])
				数值	{expr} 里 {pat} 的匹配位置
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
				数值	定义匹配，用 {group} 高亮 {pattern}
matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
				数值	定义匹配，用 {group} 高亮指定位置
matcharg({nr})			列表	`:match` 定义时使用的参数
matchbufline({buf}, {pat}, {lnum}, {end}, [, {dict})
				列表	缓冲区 {buf} 里的所有 {pat} 匹配
matchdelete({id} [, {win}])	数值	删除 {id} 指定的匹配
matchend({expr}, {pat} [, {start} [, {count}]])
				数值	{expr} 里 {pat} 的匹配结束位置
matchfuzzy({list}, {str} [, {dict}])
				列表	在 {list} 中模糊匹配 {str}
matchfuzzypos({list}, {str} [, {dict}])
				列表	在 {list} 中模糊匹配 {str}，也返回位置
matchlist({expr}, {pat} [, {start} [, {count}]])
				列表	{expr} 里 {pat} 的匹配和子匹配
matchstr({expr}, {pat} [, {start} [, {count}]])
				字符串	{expr} 里 {pat} 的第 {count} 个匹配
matchstrlist({list}, {pat} [, {dict})
				列表	{list} 里所有的 {pat} 匹配
matchstrpos({expr}, {pat} [, {start} [, {count}]])
				列表	{expr} 里 {pat} 的第 {count} 个匹配
max({expr})			数值	{expr} 中所有元素的最大值
menu_info({name} [, {mode}])	字典	获取 {mode} 下名为 {name} 的菜单项信息
min({expr})			数值	{expr} 中所有元素的最小值
mkdir({name} [, {flags} [, {prot}]])
				数值	创建目录 {name}
mode([{expr}])			字符串	当前编辑模式
mzeval({expr})			可变	计算 |MzScheme| 表达式
nextnonblank({lnum})		数值	第一个 >= {lnum} 的非空白行的行号
ngettext({single}, {plural}, {number}[, {domain}])
				字符串	根据 {number} 及单复数规则来翻译文本
nr2char({expr} [, {utf8}])	字符串	将 ASCII/UTF-8 值 {expr} 转为字符
or({expr}, {expr})		数值	按位或
pathshorten({expr} [, {len}])	字符串	缩短路径 {expr} 里的各层目录名
perleval({expr})		可变	计算 |Perl| 表达式
popup_atcursor({what}, {options})
				数值	在光标附近创建弹出窗口
popup_beval({what}, {options})	数值	为 'ballooneval' 创建弹出窗口
popup_clear()			无	关闭所有弹出窗口
popup_close({id} [, {result}])	无	关闭弹出窗口 {id}
popup_create({what}, {options})	数值	创建弹出窗口
popup_dialog({what}, {options})	数值	创建弹出窗口用作对话框
popup_filter_menu({id}, {key})	数值	菜单弹出窗口的过滤
popup_filter_yesno({id}, {key})	数值	对话框弹出窗口的过滤
popup_findecho()		数值	获取 `:echowin` 的弹出窗口 ID
popup_findinfo()		数值	获取信息弹出窗口的窗口 ID
popup_findpreview()		数值	获取预览弹出窗口的窗口 ID
popup_getoptions({id})		字典	获取弹出窗口 {id} 的选项
popup_getpos({id})		字典	获取弹出窗口 {id} 的位置
popup_hide({id})		无	隐藏弹出窗口 {id}
popup_list()			列表	获取所有弹出的窗口 ID 列表
popup_locate({row}, {col})	数值	获取在给出位置的弹出窗口 ID
popup_menu({what}, {options})	数值	创建弹出窗口用作菜单
popup_move({id}, {options})	无	设置弹出窗口 {id} 的位置
popup_notification({what}, {options})
				数值	创建通知弹出窗口
popup_setbuf({id}, {buf})	布尔型	设置弹出窗口 {id} 的缓冲区
popup_setoptions({id}, {options})
				无	设置弹出窗口 {id} 的选项
popup_settext({id}, {text})	无	设置弹出窗口 {id} 的文本
popup_show({id})		数值	撤销弹出窗口 {id} 的隐藏
pow({x}, {y})			浮点	{x} 的 {y} 次方
preinserted()			数值	是否有预输入文本插入在光标后方
prevnonblank({lnum})		数值	最后一个 <= {lnum} 的非空白行的行号
printf({fmt}, {expr1}...)	字符串	按照 {fmt} 来排版文本
prompt_getprompt({buf})		字符串	获取缓冲区 {buf} 的提示文本
prompt_setcallback({buf}, {expr})
				无	设置缓冲区 {buf} 的提示回调函数
prompt_setinterrupt({buf}, {text})
				无	设置缓冲区 {buf} 的提示中断函数
prompt_setprompt({buf}, {text})	无	设置缓冲区 {buf} 的提示文本为 {text}
prop_add({lnum}, {col}, {props})
				无	新增一项文本属性
prop_add_list({props}, [[{lnum}, {col}, {end-lnum}, {end-col}], ...])
				无	新增多项文本属性
prop_clear({lnum} [, {lnum-end} [, {props}]])
				无	删除所有文本属性
prop_find({props} [, {direction}])
				字典	查找文本属性
prop_list({lnum} [, {props}])	列表	{lnum} 的文本属性
prop_remove({props} [, {lnum} [, {lnum-end}]])
				数值	删除一个文本属性
prop_type_add({name}, {props})	无	定义新的文本属性类型
prop_type_change({name}, {props})
				无	改变已有的文本属性类型
prop_type_delete({name} [, {props}])
				无	删除文本属性类型
prop_type_get({name} [, {props}])
				字典	获取文本属性类型的值
prop_type_list([{props}])	列表	获取文本属性类型的列表
pum_getpos()			字典	如果可见，弹出菜单的位置和大小
pumvisible()			数值	弹出菜单是否可见
py3eval({expr} [, {locals}])	可变	计算 |python3| 表达式
pyeval({expr} [, {locals}])	可变	计算 |Python| 表达式
pyxeval({expr} [, {locals}])	可变	计算 |python_x| 表达式
rand([{expr}])			数值	用 {expr} 作为种子，获取伪随机数
range({expr} [, {max} [, {stride}]])
				列表	从 {expr} 到 {max} 的数值序列
readblob({fname} [, {offset} [, {size}]])
				blob	从文件 {fname} 读取 |Blob|
readdir({dir} [, {expr} [, {dict}]])
				列表	用 {expr} 来选择 {dir} 中的文件名
readdirex({dir} [, {expr} [, {dict}]])
				列表	用 {expr} 来选择 {dir} 中的文件信息
readfile({fname} [, {type} [, {max}]])
				列表	从文件 {fname} 读取文本行列表
redraw_listener_add({opts})	数值	新增重画监听器回调
redraw_listener_remove({id})	无	删除重画监听器回调
reduce({object}, {func} [, {initial}])
				可变	用 {func} 来缩减 {object}
reg_executing()			字符串	获取执行中的寄存器名
reg_recording()			字符串	获取记录中的寄存器名
reltime([{start} [, {end}]])	列表	获取时间值: 当前时间或时间差
reltimefloat({time})		浮点数	将时间值 {time} 转化为浮点数
reltimestr({time})		字符串	将时间值 {time} 转化为字符串
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
				字符串	发送表达式 {string} 到 {server}
remote_foreground({server})	数值	把名为 {server} 的 Vim 服务器带到前台
remote_peek({serverid} [, {retvar}])
				数值	检查来自 {serverid} 的应答字符串
remote_read({serverid} [, {timeout}])
				字符串	从 {serverid} 读入应答字符串
remote_send({server}, {string} [, {idvar}])
				字符串	发送键序列 {string} 到 {server}
remote_startserver({name})	无	成为服务器 {name}
remove({list}, {idx} [, {end}])	可变/列表
					从 {list} 里删除项目 {idx}-{end}
remove({blob}, {idx} [, {end}])	可变/blob
					从 {blob} 里删除字节 {idx}-{end}
remove({dict}, {key})		可变	从 {dict} 里删除键为 {key} 的项目
rename({from}, {to})		数值	将文件 {from} 换名 (移动) 为 {to}
repeat({expr}, {count})		列表/元组/Blob/字符串
					将 {expr} 重复 {count} 次
resolve({filename})		字符串	解析快捷方式所对应的文件名
reverse({obj})			列表/元组/Blob/字符串
					反转 {obj}
round({expr})			浮点	{expr} 四舍五入
rubyeval({expr})		可变	计算 |Ruby| 表达式
screenattr({row}, {col})	数值	给定屏幕位置上字符的属性
screenchar({row}, {col})	数值	给定屏幕位置上的字符
screenchars({row}, {col})	列表	给定屏幕位置上基本加组合形成的字符列表
screencol()			数值	当前光标位置的屏幕列号
screenpos({winid}, {lnum}, {col})
				字典	窗口 {winid} 里文本位置对应的屏幕位置
screenrow()			数值	当前光标位置的屏幕行号
screenstring({row}, {col})	字符串	给定屏幕位置上基本加组合形成的字符串
search({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
				数值	搜索 {pattern}，返回行号
searchcount([{options}])	字典	获取或更新搜索的统计数据
searchdecl({name} [, {global} [, {thisblock}]])
				数值	搜索变量 {name} 的声明
searchpair({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				数值	搜索 start/end 组对的另一侧，返回行号
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				列表	搜索 start/end 组对的另一侧，返回行列
searchpos({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
				列表	搜索 {pattern}，返回行列
server2client({clientid}, {string})
				数值	向客户端 {clientid} 发送应答字符串
serverlist()			字符串	获取可用的服务器列表
setbufline({buf}, {lnum}, {text})
				数值	设置缓冲区 {buf} 第 {lnum} 行为 {text}
setbufvar({buf}, {varname}, {val})
				无	设置缓冲区 {buf} 的 {varname} 为 {val}
setcellwidths({list})		无	设置字符的屏幕单元宽度覆盖
setcharpos({expr}, {list})	数值	设置光标和位置标记的字符位置为 {list}
setcharsearch({dict})		字典	用 {dict} 设置字符搜索的相关选项
setcmdline({str} [, {pos}])	数值	设置命令行为 {str}，并设置光标位置
setcmdpos({pos})		数值	设置命令行上的光标字节位置
setcursorcharpos({list})	数值	移动光标到 {list} 指定的字符位置
setenv({name}, {val})		无	设置环境变量 {name} 为 {val}
setfperm({fname}, {mode})	数值	设置文件 {fname} 的权限为 {mode}
setline({lnum}, {line})		数值	设置第 {lnum} 行的内容为 {line}
setloclist({nr}, {list} [, {action}])
				数值	用 {list} 来修改位置列表
setloclist({nr}, {list} [, {action} [, {what}]])
				数值	修改指定的位置列表项目
setmatches({list} [, {win}])	数值	恢复匹配列表
setpos({expr}, {list})		数值	设置光标或位置标记的字节位置为 {list}
setqflist({list} [, {action}])	数值	用 {list} 来修改快速修复列表
setqflist({list} [, {action} [, {what}]])
				数值	修改指定的快速修复列表项目
setreg({n}, {v} [, {opt}])	数值	设置寄存器的值和类型
settabvar({nr}, {varname}, {val})
				无	设置指定标签页的局部变量值
settabwinvar({tabnr}, {winnr}, {varname}, {val})
				无	设置指定标签页中指定窗口的局部变量值
settagstack({nr}, {dict} [, {action}])
				数值	用 {dict} 来修改窗口 {nr} 的标签栈
setwinvar({nr}, {varname}, {val})
				无	设置窗口 {expr} 的 {varname} 为 {val}
sha256({expr})			字符串	字符串或 blob {expr} 的 SHA256 校验码
shellescape({string} [, {special}])
				字符串	转义 {string} 以便用作外壳命令的参数
shiftwidth([{col}])		数值	'shiftwidth' 的有效值
sign_define({name} [, {dict}])	数值	定义或更新单个标号
sign_define({list})		列表	定义或更新一列标号
sign_getdefined([{name}])	列表	获取已定义的标号的列表
sign_getplaced([{buf} [, {dict}]])
				列表	获取已放置的标号的列表
sign_jump({id}, {group}, {buf})
				数值	跳转到 {buf} 里组 {group} 的标号 {id}
sign_place({id}, {group}, {name}, {buf} [, {dict}])
				数值	放置单个标号
sign_placelist({list})		列表	放置一列标号
sign_undefine([{name}])		数值	撤销单个标号的定义
sign_undefine({list})		列表	撤销一列标号的定义
sign_unplace({group} [, {dict}])
				数值	撤销单个标号的放置
sign_unplacelist({list})	列表	撤销一列标号的放置
simplify({filename})		字符串	尽可能简化文件名
sin({expr})			浮点	{expr} 的正弦值
sinh({expr})			浮点	{expr} 的双曲正弦值
slice({expr}, {start} [, {end}])
				字符串/列表/blob
					字符串、列表或 blob 的切片
sort({list} [, {how} [, {dict}]])
				列表	对 {list} 排序，{how} 指定比较方式
sound_clear()			无	停止播放所有声音
sound_playevent({name} [, {callback}])
				数值	播放 {name} 事件声音
sound_playfile({path} [, {callback}])
				数值	播放声音文件 {path}
sound_stop({id})		无	停止播放声音 {id}
soundfold({word})		字符串	按发音折叠 {word}
spellbadword()			字符串	光标所在的有拼写错误的单词
spellsuggest({word} [, {max} [, {capital}]])
				列表	替代 {word} 的拼写建议
split({expr} [, {pat} [, {keepempty}]])
				列表	用 {pat} 拆分 {expr}，构造 |List|
sqrt({expr})			浮点	{expr} 的平方根
srand([{expr}])			列表	初始化 |rand()| 使用的种子
state([{what}])			字符串	Vim 的当前状态
str2blob({list} [, {options}])	blob	将字符串列表转换为 blob
str2float({expr} [, {quoted}])	浮点	将字符串转换为浮点数
str2list({expr} [, {utf8}])	列表	将 {expr} 的每个字符转换为 ASCII/UTF-8
str2nr({expr} [, {base} [, {quoted}]])
				数值	将字符串转换为数值
strcharlen({expr})		数值	字符串 {expr} 的字符长度，组合不单算
strcharpart({str}, {start} [, {len} [, {skipcc}]])
				字符串	{str} 从字符 {start} 始的 {len} 个字符
strchars({expr} [, {skipcc}])	数值	字符串 {expr} 的字符长度，组合可单算
strdisplaywidth({expr} [, {col}])
				数值	字符串 {expr} 的显示长度，制表符展开
strftime({format} [, {time}])	字符串	使用指定格式 {format} 排版时间
strgetchar({str}, {index})	数值	获取 {str} 里的第 {index} 个字符
stridx({haystack}, {needle} [, {start}])
				数值	{haystack} 里第一个 {needle} 的位置
string({expr})			字符串	{expr} 值的字符串表示
strlen({expr})			数值	字符串 {expr} 的字节长度
strpart({str}, {start} [, {len} [, {chars}]])
				字符串	{str} 从 {start} 字节开始的 {len} 个字
					节/字符
strptime({format}, {timestring})
				数值	将 {timestring} 转换为 unix 时间戳
strridx({haystack}, {needle} [, {start}])
				数值	{haystack} 里最后一个 {needle} 的位置
strtrans({expr})		字符串	翻译字符串，使之可以显示
strutf16len({string} [, {countcc}])
				数值	{string} 里的 UTF-16 代码单元数
strwidth({expr})		数值	字符串 {expr} 的显示长度，制表符不展开
submatch({nr} [, {list}])	字符串/列表
					`:substitute` 或 |substitute()| 子匹配
substitute({expr}, {pat}, {sub}, {flags})
				字符串	{expr} 里的所有 {pat} 用 {sub} 替代
swapfilelist()			列表	'directory' 里能找到的交换文件列表
swapinfo({fname})		字典	关于交换文件 {fname} 的信息
swapname({buf})			字符串	缓冲区 {buf} 的交换文件
synID({lnum}, {col}, {trans})	数值	{lnum} 行 {col} 列所在的语法 ID
synIDattr({synID}, {what} [, {mode}])
				字符串	语法 ID {synID} 的 {what} 属性
synIDtrans({synID})		数值	{synID} 翻译后的语法 ID
synconcealed({lnum}, {col})	列表	关于指定位置可隐藏区域的信息
synstack({lnum}, {col})		列表	{lnum} 行 {col} 列所在的语法 ID 堆栈
system({expr} [, {input}])	字符串	外壳命令/过滤 {expr} 的输出
systemlist({expr} [, {input}])	列表	外壳命令/过滤 {expr} 的输出，多行列表
tabpagebuflist([{arg}])		列表	标签页里所有缓冲区号的列表
tabpagenr([{arg}])		数值	当前或最后标签页的编号
tabpagewinnr({tabarg} [, {arg}])
				数值	标签页里当前窗口的编号
tagfiles()			列表	使用的标签文件
taglist({expr} [, {filename}])	列表	匹配 {expr} 的标签列表
tan({expr})			浮点	{expr} 的正切值
tanh({expr})			浮点	{expr} 的双曲正切值
tempname()			字符串	临时文件的文件名
term_dumpdiff({filename}, {filename} [, {options}])
				数值	显示两份截图间的差异
term_dumpload({filename} [, {options}])
				数值	显示一份屏幕截图
term_dumpwrite({buf}, {filename} [, {options}])
				无	对终端窗口的内容进行截图
term_getaltscreen({buf})	数值	取得终端是否使用备用屏幕的标志位
term_getansicolors({buf})	列表	取得 GUI 色彩模式使用的 ANSI 调色板
term_getattr({attr}, {what})	数值	取得属性里的 {what} 值
term_getcursor({buf})		列表	取得终端光标位置
term_getjob({buf})		作业	取得终端关联的作业
term_getline({buf}, {row})	字符串	从终端取得一行文本行
term_getscrolled({buf})		数值	取得终端的滚动行数
term_getsize({buf})		列表	取得终端的大小
term_getstatus({buf})		字符串	取得终端的状态
term_gettitle({buf})		字符串	取得终端的标题
term_gettty({buf}, [{input}])	字符串	取得终端的 tty 名
term_list()			列表	取得所有终端缓冲区组成的列表
term_scrape({buf}, {row})	列表	取得终端屏幕的某行
term_sendkeys({buf}, {keys})	无	给终端发送键击序列
term_setansicolors({buf}, {colors})
				无	设置 GUI 色彩模式使用的 ANSI 调色板
term_setapi({buf}, {expr})	无	设置 |terminal-api| 函数名前缀
term_setkill({buf}, {how})	无	设置停止终端中的作业的信号值
term_setrestore({buf}, {command})
				无	设置恢复终端的命令
term_setsize({buf}, {rows}, {cols})
				无	设置终端的大小
term_start({cmd} [, {options}])	数值	打开终端窗口并执行作业
term_wait({buf} [, {time}])	数值	等待屏幕刷新
terminalprops()			字典	终端属性
test_alloc_fail({id}, {countdown}, {repeat})
				无	使内存分配失败
test_autochdir()		无	系统启动中打开 'autochdir'
test_feedinput({string})	无	给输入缓冲区添加键序列
test_garbagecollect_now()	无	用于测试，立即释放内存
test_garbagecollect_soon()	无	用于测试，尽快释放内存
test_getvalue({string})		可变	获取内部变量的值
test_gui_event({event}, {args})	布尔型	用于测试，生成 GUI 事件
test_ignore_error({expr})	无	忽略特定的错误
test_mswin_event({event}, {args})
				布尔型	用于测试，生成 MS-Windows 事件
test_null_blob()		blob	用作测试的空值 (null)
test_null_channel()		通道	用作测试的空值 (null)
test_null_dict()		字典	用作测试的空值 (null)
test_null_function()		函数引用
					用作测试的空值 (null)
test_null_job()			作业	用作测试的空值 (null)
test_null_list()		列表	用作测试的空值 (null)
test_null_partial()		函数引用
					用作测试的空值 (null)
test_null_string()		字符串	用作测试的空值 (null)
test_null_tuple()		元组	用作测试的空元组
test_option_not_set({name})	无	复位指示选项已设置过的标志位
test_override({expr}, {val})	无	用于测试，覆盖 Vim 内部行为
test_refcount({expr})		数值	获取 {expr} 的引用计数
test_setmouse({row}, {col})	无	用于测试，设置鼠标位置
test_settime({expr})		无	用作测试的当前时间
test_srand_seed([{seed}])	无	为 srand() 测试用，设置种子
test_unknown()			可变	用作测试的未知值
test_void()			可变	且作测试的无值 (void)
timer_info([{id}])		列表	定时器信息
timer_pause({id}, {pause})	无	暂停或恢复定时器
timer_start({time}, {callback} [, {options}])
				数值	新建定时器
timer_stop({timer})		无	停止一个定时器
timer_stopall()			无	停止所有定时器
tolower({expr})			字符串	将字符串 {expr} 变为小写
toupper({expr})			字符串	将字符串 {expr} 变为大写
tr({src}, {fromstr}, {tostr})	字符串	指定字符翻译表，对 {src} 进行字符替换
trim({text} [, {mask} [, {dir}]])
				字符串	从 {text} 中删除 {mask} 里出现的字符
trunc({expr})			浮点	将浮点数 {expr} 截断小数点
tuple2list({tuple})		列表	将元素的 {tuple} 转化为元素的列表
type({expr})			数值	值 {expr} 的类型值
typename({expr})		字符串	{expr} 的类型描述
undofile({name})		字符串	对应 {name} 的撤销文件名
undotree([{buf}])		列表	缓冲区 {buf} 的撤销树
uniq({list} [, {func} [, {dict}]])
				列表	从列表中删除相邻的重复项
uri_decode({string})		字符串	对字符串进行 URI-解码
uri_encode({string})		字符串	对字符串进行 URI-编码
utf16idx({string}, {idx} [, {countcc} [, {charidx}]])
				数值	{string} 里字节 {idx} 的 UTF-16 索引
values({dict})			列表	{dict} 中的所有值
virtcol({expr} [, {list} [, {winid}])
				数值/列表
					光标或位置标记所在的屏幕列
virtcol2col({winid}, {lnum}, {col})
				数值	屏幕位置所在字符的字节索引
visualmode([{expr}])		字符串	最近使用的可视模式
wildmenumode()			数值	'wildmenu' 模式是否打开
wildtrigger()			数值	启动通配扩展
win_execute({id}, {command} [, {silent}])
				字符串	在窗口 {id} 中执行 {command}
win_findbuf({bufnr})		列表	寻找包含 {bufnr} 的所有窗口
win_getid([{win} [, {tab}]])	数值	标签页 {tab} 中编号为 {win} 的窗口 ID
win_gettype([{nr}])		字符串	窗口 {nr} 的类型
win_gotoid({expr})		数值	切换到 ID 为 {expr} 的窗口
win_id2tabwin({expr})		列表	从窗口 ID 获取标签页与窗口号
win_id2win({expr})		数值	从窗口 ID 获取窗口号
win_move_separator({nr})	数值	移动窗口的垂直分割符
win_move_statusline({nr})	数值	移动窗口的状态行
win_screenpos({nr})		列表	获取窗口 {nr} 的屏幕位置
win_splitmove({nr}, {target} [, {options}])
				数值	移动窗口 {nr} 成为 {target} 的分割窗口
winbufnr({nr})			数值	窗口 {nr} 中显示的缓冲区号
wincol()			数值	光标所在的窗口列
windowsversion()		字符串	MS-Windows 操作系统版本
winheight({nr})			数值	窗口 {nr} 的高度
winlayout([{tabnr}])		列表	标签页 {tabnr} 的窗口布局
winline()			数值	光标所在的窗口行
winnr([{expr}])			数值	当前窗口的编号
winrestcmd()			字符串	返回恢复窗口大小的命令
winrestview({dict})		无	恢复当前窗口的视图
winsaveview()			字典	保存当前窗口的视图
winwidth({nr})			数值	窗口 {nr} 的宽度
wordcount()			字典	字节/字符/单词统计
writefile({object}, {fname} [, {flags}])
				数值	将 |Blob| 或行 |List| 写入文件 {fname}
xor({expr}, {expr})		数值	按位异或

==============================================================================
2. 详述						*builtin-function-details*

此处并不包含所有函数，有些特定功能的函数移到了相应的单独帮助文件里。
返回类型指定 |Vim9-script| 使用的类型，见 |vim9-types|

abs({expr})						*abs()*
		返回 {expr} 的绝对值。当 {expr} 计算结果为 |Float| 时，abs()
		返回 |Float|。而当 {expr} 可转换为 |Number| 时，abs() 返回
		|Number|。否则报错并返回 -1。
		示例: >
			echo abs(1.456)
<			1.456  >
			echo abs(-5.456)
<			5.456  >
			echo abs(-4)
<			4

		也可用作 |method|: >
			Compute()->abs()
<
		返回类型: |Number| 或 |Float|，取决于 {expr}


acos({expr})						*acos()*
		返回 {expr} 的反余弦值，类型为 |Float|，范围在 [0, pi] 弧度之
		间。
		{expr} 的计算结果必须是 [-1, 1] 区间内的 |Float| 或 |Number|。
		否则 acos() 返回 "nan"。
		示例: >
			:echo acos(0)
<			1.570796 >
			:echo acos(-0.5)
<			2.094395

		也可用作 |method|: >
			Compute()->acos()
<
		返回类型: |Float|


add({object}, {expr})					*add()*
		在 |List| 或 |Blob| {object} 末尾附加项目 {expr}。返回新生成的
		|List| 或 |Blob|。例如: >
			:let alist = add([1, 2, 3], item)
			:call add(mylist, "woodstock")
<		注意 如果 {expr} 是 |List|，它被作为单个项目追加。
		|extend()| 则可用来连接 |List|。
		{object} 是 |Blob| 时，{expr} 必须是数值。
		|insert()| 可用来在其它位置插入项目。
		如果 {object} 不是 |List| 或 |Blob|，返回 1。

		也可用作 |method|: >
			mylist->add(val1)->add(val2)
<
		返回类型: list<{type}> (取决于输入的 |List|) 或 |Blob|


and({expr}, {expr})					*and()*
		对两个参数进行按位与。参数会被转换为数值。参数如果是列表、字典
		或浮点数会报错。
		另见 |or()| 和 |xor()|。
		示例: >
			:let flag = and(bits, 0x80)
<		也可用作 |method|: >
			:let flag = bits->and(0x80)
<
		返回类型: |Number|


append({lnum}, {text})					*append()*
		当 {text} 为 |List| 时: 把 |List| 里的每个项目作为单独的文本
		行，附加到当前缓冲区第 {lnum} 行之下。
		否则，把 {text} 作为单个文本行，附加到当前缓冲区第 {lnum} 行之
		下。
		接受任何项目，并会被转换为字符串。
		{lnum} 可为零，用于在第一行前插入一行。
		{lnum} 的用法可见 |getline()|。
		如果失败 ({lnum} 越界或内存溢出)，返回 1，成功则返回 0。{text}
		为空列表时，不管 {lnum} 为何，总返回零。
		|Vim9| 脚本中非法参数或负数会报错。例如: >
			:let failed = append(line('$'), "# THE END")
			:let failed = append(0, ["Chapter 1", "the beginning"])

<		也可用作列表的 |method|，基是作为第二个参数传递的: >
			mylist->append(lnum)
<
		返回类型: |Number|


appendbufline({buf}, {lnum}, {text})			*appendbufline()*
		类似于 |append()|，但在指定缓冲区 {buf} 中附加文本。

		本函数只能用于已加载的缓冲区。如有必要，可先调用 |bufload()|。

		{buf} 的用法见 |bufname()|。

		{lnum} 是行号，在其下附加文本。注意 使用 |line()| 会引用当前缓
		冲区而非正在追加的缓冲区。"$" 可用来附加于缓冲区末尾。除此以
		外，不支持其他字符串值。

		成功时返回 0，失败则返回 1。
		|Vim9| 脚本中非法 {lnum} 会报错。

		如果 {buf} 不是合法缓冲区或 {lnum} 不合法，报错。例如: >
			:let failed = appendbufline(13, 0, "# THE START")
<		不过，{text} 为空列表时，非法 {lnum} 也不会报错，因为并不实际
		使用 {lnum}。

		也可用作列表的 |method|，基是作为第二个参数传递的: >
			mylist->appendbufline(buf, lnum)
<
		返回类型: |Number|


argc([{winid}])						*argc()*
		返回参数列表的文件数目。见 |arglist|。
		{winid} 省略时，使用当前窗口的参数列表。
		否则如果 {winid} 是 -1，使用全局参数列表。
		否则，{winid} 指定参数列表所在的窗口: 窗口号或窗口 ID 均可。
		如果 {winid} 参数不合法，返回 -1。

		返回类型: |Number|


argidx()						*argidx()*
		返回参数列表的当前索引。0 对应首个文件。|argc()| - 1 对应最后
		一个文件。见 |arglist|。

		返回类型: |Number|


arglistid([{winnr} [, {tabnr}]])			*arglistid()*
		返回参数列表 ID，该数值用于标识正在使用的参数列表。零代表全局
		参数列表。见 |arglist|。
		如果参数非法，返回 -1。

		参数省略时，使用当前窗口。
		只提供 {winnr} 时，使用当前标签页的指定窗口。
		同时提供 {winnr} 和 {tabnr} 时，使用指定标签页的指定窗口。
		{winnr} 可为窗口号或 |window-ID|。

		返回类型: |Number|


argv([{nr} [, {winid}]])				*argv()*
		返回参数列表第 {nr} 个参数。见 |arglist|。"argv(0)" 对应首个参
		数。例如: >
	:let i = 0
	:while i < argc()
	:  let f = escape(fnameescape(argv(i)), '. ')
	:  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '<CR>'
	:  let i = i + 1
	:endwhile
<		{nr} 参数省略或为 -1 时，返回类型为 |List| 的完整 {arglist}。

		{winid} 参数指定窗口 ID，见 |argc()|。
		关于 Vim 的命令行参数，可见 |v:argv|。

		如果参数列表中不存在第 {nr} 个参数，返回空串。如果 {winid} 参
		数非法，返回空列表。

		返回类型: |String|


asin({expr})						*asin()*
		返回 {expr} 的反正弦值，类型为 |Float|，范围在 [-pi/2, pi/2]
		弧度之间。
		{expr} 的计算结果必须是 [-1, 1] 区间内的 |Float| 或 |Number|。
		如果 {expr} 越出 [-1, 1] 区间，返回 "nan"。如果 {expr} 不是
		|Float| 或 |Number|，返回 0.0。
		示例: >
			:echo asin(0.8)
<			0.927295 >
			:echo asin(-0.5)
<			-0.523599

		也可用作 |method|: >
			Compute()->asin()
<
		返回类型: |Float|

assert_ 函数文档在这里: |assert-functions-details|


atan({expr})						*atan()*
		返回 {expr} 的反正切主值，类型为 |Float|，范围在
		[-pi/2, +pi/2] 弧度之间。
		{expr} 的计算结果必须是 |Float| 或 |Number|。否则返回 0.0。
		示例: >
			:echo atan(100)
<			1.560797 >
			:echo atan(-4.01)
<			-1.326405

		也可用作 |method|: >
			Compute()->atan()
<
		返回类型: |Float|


atan2({expr1}, {expr2})					*atan2()*
		返回 {expr1} / {expr2} 的反正切值，类型为 |Float|，范围在
		[-pi, +pi] 弧度之间。
		{expr1} 和 {expr2} 的计算结果必须是 |Float| 或 |Number|。否则
		返回 0.0。
		示例: >
			:echo atan2(-1, 1)
<			-0.785398 >
			:echo atan2(1, -1)
<			2.356194

		也可用作 |method|: >
			Compute()->atan2(1)
<
		返回类型: |Float|


autocmd_add({acmds})					*autocmd_add()*
		新增一组自动命令和自动命令组。

		{acmds} 参数是列表，其中每个项目为包含以下可选项目的字典:
		    bufnr	要新增缓冲区局部自动命令时使用的缓冲区号。如果
				指定，忽略 "pattern" 项目。
		    cmd		此自动命令事件要执行的 Ex 命令
		    event	自动命令事件名。参见 |autocmd-events|。参数可
				以是单个事件名的字符串，也可以是包含多个事件名
				的列表。
		    group	自动命令组名。参见 |autocmd-groups|。如指定组
				尚不存在，先创建之。如果不指定或为空，使用缺省
				组。
		    nested	布尔型标志位，要新增支持嵌套的自动命令时设为
				v:true。参见 |autocmd-nested|。
		    once	布尔型标志位，要新增只执行一次的自动命令时设为
				v:true。参见 |autocmd-once|。
		    pattern	自动命令的模式串。参见 |autocmd-patterns|。如
				果指定 "bufnr" 项目，会忽略本项目。参数可以是
				单个模式的字符串，也可以是包含多个模式的列表。
		    replace	布尔型标志位，设为 v:true 时，先删除和指定自动
				命令事件和组关联的所有命令，再加入 {cmd}。这可
				用于避免为同一组和同一事件重复添加相同的自动命
				令。

		成功时返回 v:true，而失败时返回 v:false。
		示例: >
			" 为 5 号缓冲区创建缓冲区局部自动命令
			let acmd = {}
			let acmd.group = 'MyGroup'
			let acmd.event = 'BufEnter'
			let acmd.bufnr = 5
			let acmd.cmd = 'call BufEnterFunc()'
			call autocmd_add([acmd])
<
		也可用作 |method|: >
			GetAutocmdList()->autocmd_add()
<
		返回类型: |vim9-boolean|


autocmd_delete({acmds})					*autocmd_delete()*
		删除一组自动命令和自动命令组。

		{acmds} 参数是列表，其中每个项目为包含以下可选项目的字典:
		    bufnr	待删除的缓冲区局部自动命令的缓冲区号。如果指
				定，忽略 "pattern" 项目。
		    cmd		此自动命令事件要执行的 Ex 命令
		    event	自动命令事件名。参见 |autocmd-events|。如果为
				'*'，删除此组中的所有自动命令事件。
		    group	自动命令组名。参见 |autocmd-groups|。如果不指
				定或为空，使用缺省组。
		    nested	布尔型标志位，要指定支持嵌套的自动命令时设为
				v:true。参见 |autocmd-nested|。
		    once	布尔型标志位，要指定只执行一次的自动命令时设为
				v:true。参见 |autocmd-once|。
		    pattern	自动命令的模式串。参见 |autocmd-patterns|。如
				果指定 "bufnr" 项目，会忽略本项目。

		如果 {acmds} 字典只指定了 {group} 而未指定 {event}、{pattern}
		和 {cmd}，则删除整个自动命令组。

		成功时返回 v:true，而失败时返回 v:false。
		示例: >
			" :autocmd! BufLeave *.vim
			let acmd = #{event: 'BufLeave', pattern: '*.vim'}
			call autocmd_delete([acmd]})
			" :autocmd! MyGroup1 BufLeave
			let acmd = #{group: 'MyGroup1', event: 'BufLeave'}
			call autocmd_delete([acmd])
			" :autocmd! MyGroup2 BufEnter *.c
			let acmd = #{group: 'MyGroup2', event: 'BufEnter',
							\ pattern: '*.c'}
			" :autocmd! MyGroup2 * *.c
			let acmd = #{group: 'MyGroup2', event: '*',
							\ pattern: '*.c'}
			call autocmd_delete([acmd])
			" :autocmd! MyGroup3
			let acmd = #{group: 'MyGroup3'}
			call autocmd_delete([acmd])
<
		也可用作 |method|: >
			GetAutocmdList()->autocmd_delete()
<
		返回类型: |vim9-boolean|


autocmd_get([{opts}])					*autocmd_get()*
		返回自动命令 |List|。{opts} 省略时，返回所有组里所有事件的自动
		命令。

		可选的 {opts} 字典参数支持以下项目:
		    group	自动命令组名。如果指定，只返回此组中定义的自动
				命令。如果给出的组不存在，返回错误信息。如果设
				为空串，使用缺省自动命令组。
		    event	自动命令事件名。如果指定，只返回为此事件定义的
				自动命令。如为 "*"，返回所有事件的自动命令。如
				果给出的事件不存在，返回错误信息。
		    pattern	自动命令模式。如果指定，只返回使用此模式定义的
				自动命令。
		{opts} 接受以上三者的组合。

		返回列表中的每个项目是包含以下项目的字典:
		    bufnr	对缓冲区局部自动命令而言，此自动命令定义所在的
				缓冲区号。
		    cmd		此自动命令执行的命令。
		    event	自动命令事件名。
		    group	自动命令组名。
		    nested	布尔型标志位，自动命令支持嵌套则为 v:true。见
				|autocmd-nested|。
		    once	布尔型标志位，自动命令只执行一次则为 v:true。
				参见 |autocmd-once|。
		    pattern	自动命令模式。如果是缓冲区局部自动命令，则有以
				下形式 "<buffer=n>"。
		如果同一组里的一个事件对应多个自动命令，每个命令都会作为单独的
		项目返回。

		如果对应指定组、事件或模式的自动命令不存在，返回空列表。

		示例: >
			" :autocmd MyGroup
			echo autocmd_get(#{group: 'Mygroup'})
			" :autocmd G BufUnload
			echo autocmd_get(#{group: 'G', event: 'BufUnload'})
			" :autocmd G * *.ts
			let acmd = #{group: 'G', event: '*', pattern: '*.ts'}
			echo autocmd_get(acmd)
			" :autocmd Syntax
			echo autocmd_get(#{event: 'Syntax'})
			" :autocmd G BufEnter *.ts
			let acmd = #{group: 'G', event: 'BufEnter',
							\ pattern: '*.ts'}
			echo autocmd_get(acmd)
<
		也可用作 |method|: >
			Getopts()->autocmd_get()
<
		返回类型: list<dict<any>>


balloon_gettext()					*balloon_gettext()*
		返回气泡的当前文本。只用于字符串，不用于列表。如果气泡不存在，
		返回空串。

		返回类型: |String|


balloon_show({expr})					*balloon_show()*
		在气泡中显示 {expr}。GUI 中 {expr} 作为字符串使用。而终端中
		{expr} 可为多行的列表。如果 {expr} 不是列表，将通过
		|balloon_split()| 先进行分割。
		{expr} 为空时，删除任何已存在的气泡。

		示例: >
			func GetBalloonContent()
			   " ... 启动内容的获取
			   return ''
			endfunc
			set balloonexpr=GetBalloonContent()

			func BalloonCallback(result)
			  call balloon_show(a:result)
			endfunc
<		也可用作 |method|: >
			GetText()->balloon_show()
<
		期待的用法是从 'balloonexpr' 启动气泡内容的获取。它应调用异步
		方法，然后在其回调中执行 balloon_show()。'balloonexpr' 自
		身可返回空串或任何占位符，例如 "载入中..."。

		如果不能显示气泡，不做任何事，不会报错。
		{仅当编译时加入 |+balloon_eval| 或 |balloon_eval_term| 特性才
		有效}

		返回类型: |Number|


balloon_split({msg})					*balloon_split()*
		把字符串 {msg} 切分为方便在气泡中显示的多行。切分依据的是当前
		窗口大小，并进行优化以显示调试器的输出。
		返回切分后的行 |List|。如果出错，返回空列表。
		也可用作 |method|: >
			GetText()->balloon_split()->balloon_show()

<		{仅当编译时加入 |balloon_eval_term| 特性才有效}

		返回类型: list<any> 或 list<string>


base64_decode({string})					*base64_decode()*
		返回 blob，包含 {string} 里 base64 编码字符解码后的字节。

		{string} 参数只能包含 base64-编码的字符，长度必须为 4 的倍数。

		如果出错，返回空 blob。

		示例: >
		    " 把解码内容写到二进制文件
		    call writefile(base64_decode(s), 'tools.bmp')
		    " 解码 base64-编码的字符串
		    echo blob2str(base64_decode(encodedstr))
<
		也可用作 |method|: >
			GetEncodedString()->base64_decode()
<
		返回类型: |Blob|


base64_encode({blob})					*base64_encode()*
		返回将 {blob} 里包含的字节进行 base64 编码后的字符串。使用 RFC
		4648 定义的 base64 字母表。

		示例: >
		    " 对二进制文件内容进行编码
		    echo base64_encode(readblob('somefile.bin'))
		    " 对字符串进行编码
		    echo base64_encode(str2blob(somestr->split("\n")))
<
		也可用作 |method|: >
			GetBinaryData()->base64_encode()
<
		返回类型: |String|


bindtextdomain({package}, {path})			*bindtextdomain()*
		将指定的 {package} 和 {path} 进行绑定，使得 |gettext()| 函数可
		用于得到该包的特定语言翻译。{path} 为包含翻译文件的目录名。见
		|package-translation|。

		成功时返回 v:true，而失败时返回 v:false (内存溢出)。

		返回类型: |vim9-boolean|


blob2list({blob})					*blob2list()*
		返回 {blob} 中每个字节对应的数值的列表。示例: >
			blob2list(0z0102.0304)	返回 [1, 2, 3, 4]
			blob2list(0z)		返回 []
<		如果出错，返回空列表。|list2blob()| 是其逆操作。

		也可用作 |method|: >
			GetBlob()->blob2list()
<
		返回类型: list<any> 或 list<number>


blob2str({blob} [, {options}])				*blob2str()*
		返回 {blob} 中字节序列使用当前 'encoding' 转换为字符后组成的字
		符串列表。

		blob 里的每个 <NL> 字节视作字符串结束，并生成新列表项目。而
		blob 里的每个 <NUL> 字节则被转换为 <NL> 字符。

		{options} 省略时，使用当前 'encoding' 值来解码 {blob} 里的字节
		序列。

		参数 {options} 为 |Dict|，支持以下项目:
		    encoding	使用此编码来解码 {blob} 里的字节序列。|String|
				值。支持的值可见 |encoding-names| (加上特殊值
				"none")。
							*E1515* *E1516*
		当前 'encoding' 如为 "utf-8"，{blob} 发现非法字节序列时会报错
		并返回空列表。要抑制此种检验而不介意得到可能非法的字符串，将
		{options} 里的 "encoding" 设为 "none"。

		blob 为空时返回空列表。

		另见 |str2blob()|

		示例: >
		    blob2str(0z6162)		返回 ['ab']
		    blob2str(0zC2ABC2BB)	返回 ['«»']
		    blob2str(0z610A62)		返回 ['a', 'b']
		    blob2str(0z610062)		返回 ['a\nb']
		    blob2str(0zABBB, {'encoding': 'latin1'}) 返回 ['«»']
<
		也可用作 |method|: >
			GetBlob()->blob2str()
<
		返回类型: list<string>


browse({save}, {title}, {initdir}, {default})		*browse()*
		启动文件请求窗口。只有在 "has("browse")" 返回 |TRUE| 时 (只在
		一些 GUI 版本里有效) 才可用。
		输入的字段包括:
		    {save}	选择的文件如果用于写入，则为 |TRUE|
		    {title}	请求窗口的标题
		    {initdir}	开始浏览的目录
		    {default}	缺省文件名
		如果按了 "Cancel" 按钮、出错或者无法浏览，则返回空串。

		返回类型: |String|


browsedir({title}, {initdir})				*browsedir()*
		启动目录请求窗口。只有在 "has("browse")" 返回 |TRUE| 时 (只在
		一些 GUI 版本里有效) 才可用。
		有的系统上不支持目录浏览器，这时会使用文件浏览器。此种情况下:
		请选择要用的目录里的一个文件。
		输入的字段包括:
		    {title}	请求窗口的标题
		    {initdir}	开始浏览的目录
		如果按了 "Cancel" 按钮、出错或者无法浏览，则返回空串。

		返回类型: |String|


bufadd({name})						*bufadd()*
		在缓冲区列表中加入名为 {name} (必须为字符串) 的缓冲区。
		如果对应文件 {name} 的缓冲区已存在，返回该缓冲区号。否则返回新
		建缓冲区的号。{name} 为空串时，总是建立新缓冲区。
		该缓冲区未置位 'buflisted'，而且尚未加载。要在缓冲区中增加文
		件: >
			let bufnr = bufadd('someName')
			call bufload(bufnr)
			call setbufline(bufnr, 1, ['some', 'text'])
<		如果出错，返回 0。
		也可用作 |method|: >
			let bufnr = 'somename'->bufadd()
<
		返回类型: |Number|


bufexists({buf})					*bufexists()*
		返回数值，如果存在名为 {buf} 的缓冲区，返回 |TRUE|。
		{buf} 参数是数值时，指定缓冲区号。数值零指定当前窗口的轮换缓
		冲区。

		{buf} 参数是字符串时，必须完全匹配指定缓冲区名。该名可以是:
		- 相对于当前目录的相对路径。
		- 完整路径。
		- 'buftype' 设为 "nofile" 时的缓冲区名。
		- URL 名。
		即使缓冲区不在列表中，也能被找到。
		注意 帮助文件在 |:buffers| 里列出的是它们的短名字。但
		bufexists() 需要它们的长名字才能找到它们。
		bufexists() 可报告缓冲区存在，但要使用用于 |:buffer| 命令的名
		字，可能需要借助 |expand()|。尤其在 MS-Windows 中需要形如
		"c:\DOCUME~1" 的 8.3 名字。
		"bufexists(0)" 可用来测试轮换文件名是否存在。

		也可用作 |method|: >
			let exists = 'somename'->bufexists()
<
		返回类型: |Number|

		已废弃的名字: buffer_exists()。		*buffer_exists()*

buflisted({buf})					*buflisted()*
		返回数值，名为 {buf} 的缓冲区在列表中 (置位了 'buflisted' 选
		项) 时，返回 |TRUE|。
		{buf} 参数用法同 |bufexists()|。

		也可用作 |method|: >
			let listed = 'somename'->buflisted()
<
		返回类型: |Number|


bufload({buf})						*bufload()*
		确保缓冲区 {buf} 已加载。缓冲区名对应的文件存在时，读入该文
		件。否则缓冲区保持为空。如果缓冲区已载入，则不作任何改变。如
		果缓冲区不和文件相关 (例如 'buftype' 为 "nofile")，不读取文
		件。如果缓冲区的文件已有交换文件，不弹出对话框，直接载入缓冲
		区。
		{buf} 参数的用法可见 |bufexists()|。

		也可用作 |method|: >
			eval 'somename'->bufload()
<
		返回类型: |Number|


bufloaded({buf})					*bufloaded()*
		返回数值，名为 {buf} 的缓冲区存在且已加载 (无论在窗口中显示还
		是被隐藏) 时，返回 |TRUE|。
		{buf} 参数用法同 |bufexists()|。

		也可用作 |method|: >
			let loaded = 'somename'->bufloaded()
<
		返回类型: |Number|


bufname([{buf}])					*bufname()*
		返回缓冲区的名字，多数情况下与 ":ls" 命令显示的一致，但不会使
		用诸如 "[未命名]" 那样的特别名称。
		{buf} 省略时，使用当前缓冲区。
		{buf} 参数为数值时，用来指定缓冲区号。数值零代表当前窗口的轮换
		缓冲区。
		{buf} 参数为字符串时，用作匹配缓冲区名字的 |file-pattern|。这
		里假设 'magic' 总是置位而 'cpoptions' 总为空。如果匹配超过一
		个，返回空串。
		可用 "" 或 "%" 来指定当前缓冲区，而 "#" 指定轮换缓冲区。
		完整匹配优先，如果找不到，也接受在缓冲区名的开头，结尾或中间的
		匹配。如果只接受完整匹配，在模式的开头加上 "^"，而结尾加 "$"。
		列表内缓冲区优先。如果列表内有唯一的匹配，返回该缓冲区。否则，
		继续在列表外的缓冲区里查找。
		如果 {buf} 是字符串但想用作缓冲区号，可通过加零将它强制转化为
		数值: >
			:echo bufname("3" + 0)
<		也可用作 |method|: >
			echo bufnr->bufname()

<		如果缓冲区不存在，或者没有名字，返回空串。 >
	bufname("#")		轮换缓冲区名
	bufname(3)		缓冲区 3 的名字
	bufname("%")		当前缓冲区名
	bufname("file2")	匹配 "file2" 的缓冲区名。
<
		返回类型: |String|
							*buffer_name()*
		已废弃的名字: buffer_name()。


bufnr([{buf} [, {create}]])				*bufnr()*
		返回缓冲区的编号，与 ":ls" 命令显示的一致。{buf} 的用法见上
		|bufname()|。

		如果不存在符合条件的缓冲区，返回 -1。但如果提供了 {create} 参
		数且为 TRUE，则会建立一个新的列表外缓冲区，并返回其编号。例
		如: >
			let newbuf = bufnr('Scratch001', 1)
<		空名会指定当前缓冲区。要创建带空名的新缓冲区可用 |bufadd()|。

		bufnr("$") 对应最后一个缓冲区: >
			:let last_buffer = bufnr("$")
<		返回当前已存在缓冲区的最大编号，类型为数值。注意 较小的编号不
		一定对应仍存在的缓冲区，因为可能已被 ":bwipeout" 永久删除。
		|bufexists()| 可用来测试缓冲区是否存在。

		也可用作 |method|: >
			echo bufref->bufnr()
<
		返回类型: |Number|

		已废弃的名字: buffer_number()。		*buffer_number()*
							*last_buffer_nr()*
		bufnr("$") 已废弃的名字: last_buffer_nr()。

bufwinid({buf})						*bufwinid()*
		返回数值，与缓冲区 {buf} 相关联的首个窗口的 |window-ID|。{buf}
		的用法见上述 |bufname()|。如果缓冲区 {buf} 不存在或没有对应窗
		口，返回 -1。示例: >

	echo "包含缓冲区 1 的窗口是 " .. (bufwinid(1))
<
		只处理当前标签页。要找到更多窗口可见 |win_findbuf()|。

		也可用作 |method|: >
			FindBuffer()->bufwinid()
<
		返回类型: |Number|


bufwinnr({buf})						*bufwinnr()*
		类似于 |bufwinid()|，但返回窗口号而不是 |window-ID|。
		如果缓冲区 {buf} 不存在或没有对应窗口，返回 -1。例如: >

	echo "包含缓冲区 1 的窗口是 " .. (bufwinnr(1))

<		该编号可用于 |CTRL-W_w| 和 ":wincmd w" |:wincmd|。

		也可用作 |method|: >
			FindBuffer()->bufwinnr()
<
		返回类型: |Number|


byte2line({byte})					*byte2line()*
		返回当前缓冲区第 {byte} 个字节所在的行号。取决于当前缓冲区的
		'fileformat' 选项，这可以包括不同的换行符。第一个字符的字节编
		号为 1。
		另见 |line2byte()|、|go| 和 |:goto|。

		如果 {byte} 值非法，返回 -1。

		也可用作 |method|: >
			GetOffset()->byte2line()
<
		返回类型: |Number|

		{仅当编译时加入 |+byte_offset| 特性才有效}


byteidx({expr}, {nr} [, {utf16}])			*byteidx()*
		返回字符串 {expr} 里第 {nr} 个字符的字节位置。零代表第一个字
		符，此时会返回零。
		如果没有多字节字符，返回值总是等于 {nr}。
		组合字符不单独计数，其字节长度加到其前导的基础字符上。要将组合
		字符分别计数，见下 |byteidxcomp()|。
		{utf16} 给出且为 TRUE 时，{nr} 用作字符串 {expr} 的 UTF-16 索
		引，而不是字符索引。UTF-16 索引是字符串以 16 位单词编码时的索
		引。如果指定的 UTF-16 索引在某字符 (如 4-字节字符) 的内部，返
		回该字符首个字节的字节索引。详见 |string-offset-encoding|。
		例如: >
			echo matchstr(str, ".", byteidx(str, 3))
<		显示第四个字符。另一个方法也能达到相同的效果: >
			let s = strpart(str, byteidx(str, 3))
			echo strpart(s, 0, byteidx(s, 1))
<		另见 |strgetchar()| 和 |strcharpart()|。

		如果字符数不足 {nr}，返回 -1。
		如果刚好有 {nr} 个字符，返回字符串的字节长度。
		要从字节索引相应地获取字符索引和 UTF-16 索引，见 |charidx()|
		和 |utf16idx()|。
		示例: >
			echo byteidx('a😊😊', 2)	返回 5
			echo byteidx('a😊😊', 2, 1)	返回 1
			echo byteidx('a😊😊', 3, 1)	返回 5
<
		也可用作 |method|: >
			GetName()->byteidx(idx)
<
		返回类型: |Number|


byteidxcomp({expr}, {nr} [, {utf16}])			*byteidxcomp()*
		和 |byteidx()| 类同，但组合字符作为一个单独的字符计算。示例: >
			let s = 'e' .. nr2char(0x301)
			echo byteidx(s, 1)
			echo byteidxcomp(s, 1)
			echo byteidxcomp(s, 2)
<		第一个和第三个 echo 返回 3 ('e' 加上组合字符是 3 个字节)，第二
		个 echo 返回 1 ('e' 是一个字节)。
		仅当 'encoding' 为某种 Unicode 编码时，结果才会和 |byteidx()|
		有所不同。

		也可用作 |method|: >
			GetName()->byteidxcomp(idx)
<
		返回类型: |Number|


call({func}, {arglist} [, {dict}])			*call()* *E699*
		调用函数 {func}，使用 |List| {arglist} 项目作为参数。
		{func} 可为 |Funcref| 或函数名。
		调用时，a:firstline 和 a:lastline 都设为光标所在行。
		返回所调函数的返回值。
		{dict} 用于为函数指定 "dict" 属性。用于设置局部变量 "self"。
		|Dictionary-function|

		也可用作 |method|: >
			GetFunc()->call([arg, arg], dict)
<
		返回类型: any，取决于 {func}


ceil({expr})						*ceil()*
		返回浮点数形式的大于等于 {expr} 的最小整数 (向上取整)。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			echo ceil(1.456)
<			2.0  >
			echo ceil(-5.456)
<			-5.0  >
			echo ceil(4.0)
<			4.0

		如果 {expr} 不是 |Float| 或 |Number|，返回 0.0。

		也可用作 |method|: >
			Compute()->ceil()
<
		返回类型: |Float|


ch_ 函数文档在这里: |channel-functions-details|


changenr()						*changenr()*
		返回最近的改变号。这和 |:undolist| 显示的编号一致，并可用于
		|:undo| 命令。
		对一般的改变，返回的是该改变的编号。对重做操作，返回的是重做改
		变的编号。而对撤销操作，返回的是撤销改变的编号减一。
		如果撤销列表为空，返回 0。

		返回类型: |Number|


char2nr({string} [, {utf8}])				*char2nr()*
		返回 {string} 首个字符，类型为数值。例如: >
			char2nr(" ")		返回 32
			char2nr("ABC")		返回 65
<		{utf8} 省略或为零时，使用当前 'encoding'。
		以 "utf-8" 为例: >
			char2nr("á")		返回 225
			char2nr("á"[0])		返回 195
<		{utf8} 为 TRUE 时，总是按 UTF-8 字符处理。
		组合字符当作单独的字符。
		|nr2char()| 是其逆操作。
		要把字符串转换为字符对应数值的列表: >
		    let str = "ABC"
		    let list = map(split(str, '\zs'), {_, val -> char2nr(val)})
<		结果是: [65, 66, 67]

		如果 {string} 不是字符串型，返回 0。

		也可用作 |method|: >
			GetChar()->char2nr()
<
		返回类型: |Number|


charclass({string})					*charclass()*
		返回 {string} 首个字符的字符类。
		字符类为以下之一:
			0	空白
			1	标点
			2	单词字符 (取决于 'iskeyword')
			3	表情符号
			其它	特定 Unicode 类 (译者注:
				中日韩统一表意文字	0x4e00，或 19968
				上标字符		0x2070，或 8304
				下标字符		0x2080，或 8320
				盲文			0x2800，或 10240
				平假名			0x3040，或 12352
				片假名			0x30a0，或 12448
				谚文音节		0xac00，或 44032
				)
		此类用于模式匹配和单词动作。
		如果 {string} 不是字符串型，返回 0。

		返回类型: |Number|


charcol({expr} [, {winid}])				*charcol()*
		同 |col()|，但返回 {expr} 给出的列位置的字符索引，而非字节索
		引。

		示例:
		当光标在第五行文本 "여보세요" 的 '세' 时: >
			charcol('.')		返回 3
			col('.')		返回 7

<		也可用作 |method|: >
			GetPos()->col()
<
		返回类型: |Number|


charidx({string}, {idx} [, {countcc} [, {utf16}]])	*charidx()*
		返回 {string} 里第 {idx} 个字节所属字符的索引。
		首个字符的索引为零。
		如果字符串里不含多字节字符，返回值等于 {idx}。

		{countcc} 省略或 |FALSE| 时，组合字符不单独计算，其字节长度会
		加到前导的基本字符上。
		{countcc} 为 |TRUE| 时，组合字符算作单独的字符。

		{utf16} 给出且为 TRUE 时，{idx} 用作 {string} 的 UTF-16 索引，
		而非字节索引。

		如果参数非法或字节数不足 {idx}，返回 -1。如果正好有 {idx} 个字
		节，返回字符串的字符长度。

		如果首个参数不是字符串、第二个参数不是数值或第三个参数存在且非
		零或一，报错。

		想了解如何从字符索引得到字节索引，可参见 |byteidx()| 和
		|byteidxcomp()|，而要从字符索引得到 UTF-16 索引，可见
		|utf16idx|。
		详见 |string-offset-encoding|。
		示例: >
			echo charidx('áb́ć', 3)		返回 1
			echo charidx('áb́ć', 6, 1)	返回 4
			echo charidx('áb́ć', 16)		返回 -1
			echo charidx('a😊😊', 4, 0, 1)	返回 2
<
		也可用作 |method|: >
			GetName()->charidx(idx)
<
		返回类型: |Number|


chdir({dir} [, {scope}])				*chdir()*
		将当前工作目录切换为 {dir}。改变目录的作用域见下:
		{scope} 省略时，根据当前目录的作用域来切换当前工作目录:
		    - 如果设置了窗口局部目录 (|:lcd|)，则在该作用域里改变当前
		      工作目录。
		    - 否则，如果设置了标签页局部目录 (|:tcd|)，则在该作用域里
		      改变当前工作目录。
		    - 再不然，改变全局目录。

		{scope} 给出时，只为其指定的作用域改变当前工作目录:
		    "window"	改变窗口局部目录。|:lcd|
		    "tabpage"	改变标签页局部目录。|:tcd|
		    "global"	改变全局目录。|:cd|

		{dir} 必须为字符串。
		如果成功，返回上次的工作目录。把它传给下一个 chdir() 可以恢复
		上次目录。
		如果失败，返回空串。

		示例: >
			let save_dir = chdir(newdir)
			if save_dir != ""
			   " ... 做点事
			   call chdir(save_dir)
			endif

<		也可用作 |method|: >
			GetDir()->chdir()
<
		返回类型: |String|


cindent({lnum})						*cindent()*
		返回第 {lnum} 行根据 C 缩进规则应有的缩进量，见 'cindent'。
		缩进以空格计，因而与 'tabstop' 的值相关。{lnum} 的用法可见
		|getline()|。
		如果 {lnum} 非法，返回 -1。
		参见 |C-indenting|。

		也可用作 |method|: >
			GetLnum()->cindent()
<
		返回类型: |Number|


clearmatches([{win}])					*clearmatches()*
		清除当前窗口中之前通过 |matchadd()| 和 |:match| 命令定义的所有
		匹配。
		当 {win} 存在时，使用对应窗口号或窗口 ID 的窗口，而非默认的当
		前窗口。

		也可用作 |method|: >
			GetWin()->clearmatches()
<
		返回类型: |Number|


cmdcomplete_info()					*cmdcomplete_info()*
		返回类型为 |Dictionary| 的命令行补全信息。见
		|cmdline-completion|。
		其中的项目有:
		   cmdline_orig	补全开始前原始的命令行字符串。
		   pum_visible	弹出菜单可见则为 |TRUE|。
				见 |pumvisible()|。
		   matches	所有补全候选组成的列表。每个项目都是字符串。
		   selected	选中项目的索引。首个项目的索引值为零。如果没选
				中任何项目 (仅显示输入文本，或者在按 <Up> 或
				<Down> 键查找历史记录时没有选中任何项目而重新
				显示最近一次补全)，此值为 -1

		如果没有尝试过补全、只有一个候选且已完整提供、或者出了错，返回
		空 |Dictionary|。

		返回类型: dict<any>


col({expr} [, {winid}])					*col()*
		返回 {expr} 给定的列位置的字节索引，类型为数值。
		可接受的位置参见 |getpos()|。
		{expr} 为 "$" 表示光标行的行尾，此时返回光标行的字节总数加一。
		{expr} 也可以是形如 [lnum, col] 的 |List|，包含行号和列号。常
		用于指定列号为 "$" 以得到特定行的末列列号。如果 "lnum" 或
		"col" 超出范围，col() 返回零。

		可选的 {winid} 参数表示从指定窗口而非从当前窗口中取值。

		若需行号，可用 |line()|。若同时需要行列号，可用 |getpos()|。
		若需屏幕列位置，可用 |virtcol()|。而若需字符位置，可用
		|charcol()|。

		注意 只能使用当前文件的位置标记。

		例如: >
			col(".")		光标所在列
			col("$")		光标行的长度加 1
			col("'t")		位置标记 t 的列号
			col("'" .. markname)	名为 markname 的位置标记的列号
<
		首列的列号为 1。如果 {expr} 非法或 ID 为 {winid} 的窗口不存
		在，返回 0。
		大写位置标记所指的列可能实际位于另一个缓冲区中。
		激活 'virtualedit' 时，如果光标位于行尾之后，返回的光标所在列
		位置为行尾列号加一。此外，使用 <Cmd> 的映射不移动光标，可以利
		用此一特性获取插入模式下的列号: >
			:imap <F2> <Cmd>echowin col(".")<CR>

<		也可用作 |method|: >
			GetPos()->col()
<
		返回类型: |Number|


complete({startcol}, {matches})				*complete()* *E785*
		设置插入模式补全的匹配项列表。只能用于插入模式。通常在
		CTRL-R = 的映射里调用 (见 |i_CTRL-R|)，在 |<Cmd>| 或
		|<ScriptCmd>| 映射里调用也可。但不能在 CTRL-O 之后或表达式映射
		里使用。
		{startcol} 是行内待补全文本的起始字节偏移。从此位置到光标为止
		的文本为原始文本，将要被匹配内容替代。这里用 col('.') 会得到空
		串。而用 "col('.') - 1" 将使单个字符被匹配内容替代。
		{matches} 必须是 |List|。其中每个 |List| 项目是一个匹配项。
		|complete-items| 说明匹配项可能的类型。忽略 'completeopt' 里的
		"longest"。
		注意 调用本函数后，不应插入任何会导致补全停止的内容。
		像普通插入模式补全一样，可通过 CTRL-N 和 CTRL-P 选择匹配项。如
		果设置了相关选项，会显示弹出菜单，见 |ins-completion-menu|。

		示例 (使用老式 Vim 脚本): >

		inoremap <F5> <C-R>=ListMonths()<CR>

		func ListMonths()
		  call complete(col('.'), ['January', 'February', 'March',
			\ 'April', 'May', 'June', 'July', 'August',
			\ 'September', 'October', 'November', 'December'])
		  return ''
		endfunc
<
		示例 (使用 Vim9 脚本): >

		vim9script
		def ListMonths(): string
		  const months = [ 'January', 'February', 'March', 'April',
			'May', 'June', 'July', 'September', 'October',
			'November', 'December']
		  complete(col('.'), months)
		  return ''
		enddef

		inoremap <F5> <ScriptCmd>ListMonths()<CR>

<		此例用途有限，但可用于演示功能。注意 此处返回空串，不然就会插
		入一个零。

		也可用作 |method|，基是作为第二个参数传递的: >
			GetMatches()->complete(col('.'))
<
		返回类型: |Number|


complete_add({expr})					*complete_add()*
		把 {expr} 添加到匹配列表中。只能在用 'completefunc' 选项指定的
		函数中调用。
		失败时 (值为空串或者内存不足) 返回 0，匹配成功加入时返回 1，如
		果匹配已在列表中，返回 2。
		|complete-functions| 有 {expr} 的用法说明。与 'omnifunc' 返回
		的列表中的单个项目相同。

		也可用作 |method|: >
			GetMoreMatches()->complete_add()
<
		返回类型: |Number|


complete_check()					*complete_check()*
		在寻找补全匹配时，检查输入的键。当匹配搜索可能耗时较长时使用。
		如果匹配的搜索被中止，返回 |TRUE|。否则返回零。
		只能在用 'completefunc' 选项指定的函数中调用。

		返回类型: |Number|


complete_info([{what}])					*complete_info()*
		返回插入模式补全信息的 |Dictionary|。见 |ins-completion|。
		其中包含的项目有:
		   completed	返回字典，包含当前选中项目在 "items" 中列出的
				所有条目。
		   items	包含所有补全备选的列表。每个项目是一个字典，包
				含 "word"、"abbr"、"menu"、"kind"、"info" 和
				"user_data" 条目。
				见 |complete-items|。
		   matches	类似于 "items"，但只返回匹配当前查询的项目。如
				果 "what" 里同时要求 "matches" 和 "items"，会
				返回单个名叫 "items" 的列表，但每个项目会有一
				个额外的 "match" 字段。
		   mode		包含当前补全模式名的字符串。
				可用值见 |complete_info_mode|。
		   preinserted_text
				预插入的实际文本，见 |preinserted()|。
		   pum_visible	弹出菜单可见则为 |TRUE|。
				见 |pumvisible()|。
		   selected	选中项目的索引。首个项目的索引为零。如果没有选
				中的项目(仅显示输入文本，或者在按 <Up> 或
				<Down> 键时没有选中任何项目而重新显示最近一次
				补全)，此值为 -1

							*complete_info_mode*
		mode 值是:
		   ""		     不处于任何补全模式
		   "keyword"	     关键字补全 |i_CTRL-X_CTRL-N|
		   "ctrl_x"	     刚按下 CTRL-X |i_CTRL-X|
		   "scroll"	     |i_CTRL-X_CTRL-E| 或 |i_CTRL-X_CTRL-Y| 滚
				     动
		   "whole_line"	     整行 |i_CTRL-X_CTRL-L|
		   "files"	     文件名 |i_CTRL-X_CTRL-F|
		   "tags"	     标签 |i_CTRL-X_CTRL-]|
		   "path_defines"    定义补全 |i_CTRL-X_CTRL-D|
		   "path_patterns"   头文件补全 |i_CTRL-X_CTRL-I|
		   "dictionary"	     字典 |i_CTRL-X_CTRL-K|
		   "thesaurus"	     同义词词典 |i_CTRL-X_CTRL-T|
		   "cmdline"	     Vim 命令行 |i_CTRL-X_CTRL-V|
		   "function"	     用户定义补全 |i_CTRL-X_CTRL-U|
		   "omni"	     全能补全 |i_CTRL-X_CTRL-O|
		   "spell"	     拼写建议 |i_CTRL-X_s|
		   "eval"	     |complete()| 补全
		   "register"	     寄存器中的单词 |i_CTRL-X_CTRL-R|
		   "unknown"	     其它内部模式

		提供可选的 {what} 列表参数时，仅返回 {what} 中列出的项目。
		{what} 中不支持的项目被安静跳过。

		要获取弹出菜单的位置和大小，可见 |pum_getpos()|。也可以通过
		|CompleteChanged| 事件中的 |v:event| 得到。

		如果出错，返回空 |Dictionary|。

		示例: >
			" 取得所有项目
			call complete_info()
			" 只要 'mode'
			call complete_info(['mode'])
			" 只要 'mode' 和 'pum_visible'
			call complete_info(['mode', 'pum_visible'])

<		也可用作 |method|: >
			GetItems()->complete_info()
<
		返回类型: dict<any>


confirm({msg} [, {choices} [, {default} [, {type}]]])	*confirm()*
		confirm() 弹出对话框，让用户从中进行选择。返回选项的序号。首个
		个选项的序号为 1。
		注意: 仅当编译时加入对话框支持，confirm() 才可用，见
		|+dialog_con|、|+dialog_con_gui| 和 |+dialog_gui|。

		在 |dialog| 里显示 {msg} 消息，并提供可能的选项 {choices}。
		{choices} 不存在或为空时，缺省使用 "&OK" (会经过翻译)。
		{msg} 是字符串，其中 '\n' 用于换行。在有些系统上，字符串显示不
		下时会自动回绕，但并非所有系统都如此。

		{choices} 是字符串，其中 '\n' 用于分隔各个选项，例如 >
			confirm("Save changes?", "&Yes\n&No\n&Cancel")
<		'&' 之后的字符用作快捷键。例如，可以输入 'c' 来选择 "Cancel"。
		快捷键不必是首字符: >
			confirm("file has been modified", "&Save\nSave &All")
<		控制台里，每个选项的首个字符用作缺省的快捷键。忽略大小写。

		可选的 {default} 参数指定按 <CR> 时使用的选项序号。1 使得首选
		项成为缺省，0 则不设定任何缺省。{default} 省略时，默认值为 1。

		可选的 {type} 字符串参数指定对话框的类型。仅在 GTK、Mac、Motif
		和 Win32 GUI 上生效，用于指定图标。可选值为: "Error"、
		"Question"、"Info"、"Warning" 或 "Generic"。仅首字符起作用。
		{type} 省略时，默认值为 "Generic"。

		如果用户按 <Esc>、CTRL-C 或其它合法的中断键中止了对话框，
		confirm() 返回 0。

		示例: >
		   let choice = confirm("想吃点什么？",
					\ "苹果(&A)\n桔子(&O)\n香蕉(&B)", 2)
		   if choice == 0
			echo "快下定决心！"
		   elseif choice == 3
			echo "好吃"
		   else
			echo "我还是喜欢香蕉。"
		   endif
<		GUI 对话框使用按钮。按钮的排列方式取决于 'guioptions' 中的 'v'
		标志位。如果包含，按钮总为竖排。否则，confirm() 会先尝试横向排
		列按钮。放不下时，再改为竖排。有的系统上，无论设置如何，总为横
		排。

		也可用作 |method|: >
			BuildMessage()->confirm("&Yes\n&No")
<
		返回类型: |Number|


copy({expr})						*copy()*
		构造 {expr} 的备份。对于数值和字符串，这与直接使用 {expr} 并无
		不同。
		{expr} 为 |List| 时，建立一个浅备份。这意味着原 |List| 上的修
		改不会影响新建的备份。反之亦然。不过，各项目共用同一对象，所以
		项目的修改会同时影响两个 |List|。
		|Tuple| 或 |Dictionary| 的复制方式与 |List| 类同。
		另见 |deepcopy()|。
		也可用作 |method|: >
			mylist->copy()
<
		返回类型: any，取决于 {expr}


cos({expr})						*cos()*
		返回以弧度测量的 {expr} 的余弦值，类型为 |Float|。
		{expr} 的计算结果必须是 |Float| 或 |Number|。否则返回 0.0。
		示例: >
			:echo cos(100)
<			0.862319 >
			:echo cos(-4.01)
<			-0.646043

		也可用作 |method|: >
			Compute()->cos()
<
		返回类型: |Float|


cosh({expr})						*cosh()*
		返回 {expr} 的双曲余弦值，类型为 |Float|，范围在 [1, inf] 之
		间。
		{expr} 的计算结果必须是 |Float| 或 |Number|。否则返回 0.0。
		示例: >
			:echo cosh(0.5)
<			1.127626 >
			:echo cosh(-0.5)
<			-1.127626

		也可用作 |method|: >
			Compute()->cosh()
<
		返回类型: |Float|


count({comp}, {expr} [, {ic} [, {start}]])		*count()* *E706*
		返回 |String|、|List|、|Tuple| 或 |Dictionary| 类型的 {comp}
		中，等于 {expr} 的元素个数。

		{start} 给出时，从该索引指定的项目开始。{start} 只能用于
		|List| 或 |Tuple|。

		{ic} 给出且为 |TRUE| 时，忽略大小写。

		{comp} 为字符串时返回 {expr} 不重叠出现的次数。{expr} 为空串时
		返回零。

		也可用作 |method|: >
			mylist->count(val)
<
		返回类型: |Number|


cscope_connection([{num} , {dbpath} [, {prepend}]])	*cscope_connection()*
		检查 |cscope| 连接是否存在。无参数时，函数返回:
			0，表示 cscope 不可用 (编译时未启用该特性) 或者没有任
			   何 cscope 连接；
			1，表示至少存在一个 cscope 连接。

		参数给出时，{num} 值指定 cscope 连接是否存在的检查方式:

		{num}	存在检查方式的描述 ~
		-----	------------------------------
		0	等同于无参数 (例如，"cscope_connection()")。
		1	忽略 {prepend}，部分匹配 {dbpath} 字符串。
		2	忽略 {prepend}，完整匹配 {dbpath} 字符串。
		3	使用 {prepend}，部分匹配 {dbpath} 和 {prepend} 字符
			串。
		4	使用 {prepend}，完整匹配 {dbpath} 和 {prepend} 字符
			串。

		注意: 所有字符串比较均对大小写敏感！

		示例。假定我们有如下设置 (来自 ":cs show" 的输出): >

  # pid    database name			prepend path
  0 27664  cscope.out				/usr/local
<
		启动方式					   返回值 ~
		----------					---------- >
		cscope_connection()					1
		cscope_connection(1, "out")				1
		cscope_connection(2, "out")				0
		cscope_connection(3, "out")				0
		cscope_connection(3, "out", "local")			1
		cscope_connection(4, "out")				0
		cscope_connection(4, "out", "local")			0
		cscope_connection(4, "cscope.out", "/usr/local")	1
<
		返回类型: |Number|


cursor({lnum}, {col} [, {off}])				*cursor()*
cursor({list})
		定位光标到第 {lnum} 行第 {col} 列 (按字节计数)。首列列号为 1。

		只有一个参数 {list} 时，用作带两、三或四个参数的 |List|:
			[{lnum}, {col}]
			[{lnum}, {col}, {off}]
			[{lnum}, {col}, {off}, {curswant}]
		这与 |getpos()| 和 |getcurpos()| 的返回值类似，但不包含第一
		项。

		要按字符计数使用 {col} 来定位光标，可用 |setcursorcharpos()|。

		不改变跳转表。
		{lnum} 的用法可见 |getline()|，但 {lnum} 为零除外，此时光标留
		在当前行。
		如果 {lnum} 超过缓冲区的总行数，光标定位在缓冲区末行。
		如果 {col} 超过该行的字节总数，光标定位在该行的末字符上。
		如果 {col} 为零，光标留在当前列。
		{curswant} 给出时，用于设置垂直移动的首选列，否则使用 {col}。

		'virtualedit' 激活时，{off} 指定从该字符开始按屏幕列计算的偏
		移量。例如 <Tab> 内部或行尾之后的位置。
		定位成功时返回 0，否则返回 -1。

		也可用作 |method|: >
			GetCursorPos()->cursor()
<
		返回类型: |Number|


debugbreak({pid})					*debugbreak()*
		专用于中断正在调试的程序。会向进程 {uid} 发送 SIGTRAP。其它进
		程的行为未定义。见 |terminal-debugger|。
		{仅适用于 MS-Windows}

		成功中断了程序会返回 |TRUE|。否则返回 |FALSE|。

		也可用作 |method|: >
			GetPid()->debugbreak()
<
		返回类型: |Number|


deepcopy({expr} [, {noref}])				*deepcopy()* *E698*
		构造 {expr} 的备份。对于数值和字符串，这与直接使用 {expr} 并无
		不同。
		{expr} 为 |List| 时，建立一个完整备份。这意味着原 |List| 上的
		修改不会影响新建的备份。反之亦然。|List| 或 |Dictionary| 项目
		会递归建立备份。这样，修改备份项目就不会影响原 |List| 里的项
		目。
		|Tuple| 或 |Dictionary| 的复制方式与 |List| 类同。

		{noref} 省略或为零时，内含的 |List| 或 |Dictionary| 只复制一
		次。所有引用都指向同一副本。而 {noref} 为 1 时，每出现一次
		|List| 或 |Dictionary| 都会生成一个新的副本。此时如果存在循环
		引用，deepcopy() 将会失败。
							*E724*
		嵌套可达 100 层。如果有项目层级超过最大深度且 {noref} 为 1，深
		备份会失败。
		另见 |copy()|。

		也可用作 |method|: >
			GetObject()->deepcopy()
<
		返回类型: any，取决于 {expr}


delete({fname} [, {flags}])				*delete()*
		{flags} 省略或为空时: 删除名为 {fname} 的文件。

		{fname} 可为符号链接。删除的是符号链接本身，而非其指向的文件。

		{flags} 是 "d" 时: 删除名为 {fname} 的目录。如果目录 {fname}
		非空，操作会失败。

		{flags} 是 "rf" 时: 递归删除名为 {fname} 的目录和其下的所有文
		件。_操作需谨慎_！
		备注: 在 MS-Windows 上，无法删除正在使用的目录。

		返回类型为数值。成功删除文件时返回 0/false，失败或部分失败时返
		回 -1/true。

		要从 |List| 里删除项目，请用 |remove()|。
		要删除缓冲区行，可用 |:delete| 或 |deletebufline()|。

		也可用作 |method|: >
			GetName()->delete()
<
		返回类型: |Number|


deletebufline({buf}, {first} [, {last}])		*deletebufline()*
		删除缓冲区 {buf} 中第 {first} 到 {last} (闭区间) 文本行。
		{last} 省略时，只删除第 {first} 行。
		成功时返回 0，失败时返回 1。

		本函数只能用于已加载的缓冲区。如有必要，可先调用 |bufload()|。

		{buf} 的用法见上述的 |bufname()|。

		{first} 和 {last} 的用法可见 |getline()|。注意 |line()| 指定的
		是当前缓冲区 (译者注: 实际上不接受除 "$" 以外的任何字符串值)。
		"$" 指定缓冲区 {buf} 的末行。

		也可用作 |method|: >
			GetBuffer()->deletebufline(1)
<
		返回类型: |Number|


did_filetype()						*did_filetype()*
		在执行自动命令期间，如果至少触发过一次 FileType 事件，返回
		|TRUE|。在检测文件类型的脚本里可用来防止再次触发 FileType 事
		件。|FileType|
		如果上次执行的是 ":setf FALLBACK"，此处返回 |FALSE|。
		在编辑其它文件时，该计数被重置，因而这里实际检查的是当前缓冲区
		是否触发过 FileType 事件。这使得自动命令可以编辑另一个缓冲区，
		设置其 'filetype' 并载入相应的语法文件。

		返回类型: |Number|


diff({fromlist}, {tolist} [, {options}])		*diff()*
		返回由 {fromlist} 和 {tolist} 中字符串的差异组成的字符串或列
		表。使用 Vim 内部 diff 库来计算差异。

							*E106*
		{options} 里可选的 "output" 项目指定返回的 diff 格式。支持以下
		值:
		    indices	返回每个差异块的起始与结束索引还有字符串计数组
				成的列表。
		    unified	返回字符串形式的合并风格 (unified) diff 输出。
				这是缺省。

		{options} 里的 "output" 项目为 "indices" 时，返回的列表中每项
		都是一个字典，对应一个差异块，包含以下字段:
		    from_idx	此差异块在 {fromlist} 里的起始索引。
		    from_count	此差异块在 {fromlist} 里被新增/删除/修改的字符
				串数目。
		    to_idx	此差异块在 {tolist} 里的起始索引。
		    to_count	此差异块在 {tolist} 里被新增/删除/修改的字符串
				数目。

		{options} 字典参数还能指定比较选项 (类似于 'diffopt')，支持以
		下字段:
		    algorithm		指定使用的比较算法。支持值为 "myers"、
					"minimal"、"patience" 和 "histogram"。
		    context		差异上下文行数。缺省为 0。
		    iblank		忽略全空白行的改动。
		    icase		忽略文本大小写的更改。
		    indent-heuristic	内部比较库使用缩进启发。
		    iwhite		忽略空白字符数目的更改。
		    iwhiteall		忽略所有空白字符的更改。
		    iwhiteeol		忽略行尾空白字符的更改。
		有关这些选项的更多信息，参见 'diffopt'。

		为了计算合并风格的 diff，会先将 {fromlist} 里的所有项目用换行
		符连接成一个字符串，对 {tolist} 也同样处理。因而，合并风格的
		diff 输出会出现行号。

		如果 {fromlist} 和 {tolist} 等同，返回空列表或空串。

		示例: >
		    :echo diff(['abc'], ['xxx'])
		     @@ -1 +1 @@
		     -abc
		     +xxx

		    :echo diff(['abc'], ['xxx'], {'output': 'indices'})
		     [{'from_idx': 0, 'from_count': 1, 'to_idx': 0, 'to_count': 1}]
		    :echo diff(readfile('oldfile'), readfile('newfile'))
		    :echo diff(getbufline(5, 1, '$'), getbufline(6, 1, '$'))
<
		更多例子可见 |diff-func-examples|

		也可用作 |method|: >
			GetFromList->diff(to_list)
<
		返回类型: |String| 或 list<dict<number>> 或 list<any>，取决于
		{options}


diff_filler({lnum})					*diff_filler()*
		返回第 {lnum} 行之上的填充行数目。
		这些填充行对应另一个比较窗口中，在对应位置插入的内容。它们会在
		屏幕上显示，但实际上并不存在于缓冲区中。
		{lnum} 的用法可见 |getline()|。所以 "." 是当前行，"'m" 是位置
		标记 m，等等。
		如果当前窗口未处于比较模式，返回 0。

		也可用作 |method|: >
			GetLnum()->diff_filler()
<
		返回类型: |Number|


diff_hlID({lnum}, {col})				*diff_hlID()*
		返回比较模式下第 {lnum} 行和第 {col} (字节位置) 列所在的高亮
		ID (译者注: 对应 Diff* 高亮组)。当前行如果没有差异，返回零。
		{lnum} 的用法可见 |getline()|。所以 "." 是当前行，"'m" 是位置
		标记 m，等等。
		最左列的列号 {col} 为 1，首行的行号 {lnum} 为 1。
		高亮 ID 可用于 |synIDattr()|，以获取高亮对应的语法信息。

		也可用作 |method|: >
			GetLnum()->diff_hlID(col)
<
		返回类型: |Number|

							*digraph_get()*
digraph_get({chars})					*E1214*
		返回 {chars} 对应的二合字母。{chars} 必须是包含两个字符的字符
		串。如果不是两个字符或者对应的二合字母不存在，报错并返回空串。

		如有需要，字符会从 Unicode 转换为 'encoding' 编码。此种转换必
		须可行，否则可能会失败。

		另见 |digraph_getlist()|。

		示例: >
		" 得到内建的二合字母
		:echo digraph_get('00')		" 返回 '∞'

		" 得到用户定义的二合字母
		:call digraph_set('aa', 'あ')
		:echo digraph_get('aa')		" 返回 'あ'
<
		也可用作 |method|: >
			GetChars()->digraph_get()
<
		返回类型: |String|

		仅当编译时加入 |+digraphs| 特性才有效。如果此特性被关闭，此函
		数会报错。


digraph_getlist([{listall}])				*digraph_getlist()*
		返回二合字母列表。{listall} 参数给出且为 TRUE 时，返回包括系统
		缺省在内的的所有二合字母。否则，只返回用户定义的二合字母。

		如有需要，字符会从 Unicode 转化为 'encoding'。此种转换必须可
		行，有时可能会失败。

		另见 |digraph_get()|。

		示例: >
		" 得到用户定义的二合字母
		:echo digraph_getlist()

		" 得到所有的二合字母，包括缺省的二合字母
		:echo digraph_getlist(1)
<
		也可用作 |method|: >
			GetNumber()->digraph_getlist()
<
		返回类型: list<list<string>>

		仅当编译时加入 |+digraphs| 特性才有效。如果该特性未开启，调用
		本函数会报错。


digraph_set({chars}, {digraph})				*digraph_set()*
		将二合字母 {chars} 加入列表。{chars} 必须是包含两个字符的字符
		串。{digraph} 为包含单个 UTF-8 编码字符的字符串。 *E1215*
		注意，本函数处理输入时_不_忽略组合字符 (译者注: 也就是说，带组
		合字符的基本字符会被视为多个字符，因而不会被接受为合法输入)。
		本函数类似于 |:digraphs| 命令，但可用于空白开始的二合字母。

		{digraph} 成功注册时返回 v:true。失败时报错并返回 v:false。

		要同时定义多个二合字母，可用 |digraph_setlist()|。

		示例: >
			call digraph_set('  ', 'あ')
<
		也可用作 |method|: >
			GetString()->digraph_set('あ')
<
		返回类型: |vim9-boolean|

		仅当编译时加入 |+digraphs| 特性才有效。如果该特性未开启，调用
		本函数会报错。


digraph_setlist({digraphlist})				*digraph_setlist()*
		类似于 |digraph_set()|，但本函数一次可添加多个二合字母。
		{digraphlist} 为列表的列表，每个子列表包含两个字符串，对应于
		|digraph_set()| 中描述的 {chars} 和 {digraph}。 *E1216*
		示例: >
		    call digraph_setlist([['aa', 'あ'], ['ii', 'い']])
<
		功能相当于: >
		    for [chars, digraph] in [['aa', 'あ'], ['ii', 'い']]
			  call digraph_set(chars, digraph)
		    endfor
<		区别在于，如果遇到第一个错误，本函数会立即返回，不再处理后续的
		二合字母。

		也可用作 |method|: >
		    GetList()->digraph_setlist()
<
		返回类型: |vim9-boolean|

		仅当编译时加入 |+digraphs| 特性才有效。如果此特性未开启，调用
		本函数会报错。


echoraw({expr})						*echoraw()*
		按原样输出 {expr}，包括非打印字符。可用于输出终端控制码等内
		容。例如，要关闭 modifyOtherKeys: >
			call echoraw(&t_TE)
<		要再次打开之: >
			call echoraw(&t_TI)
<		使用时要谨慎，否则可能会扰乱终端显示。

		返回类型: |Number|


empty({expr})						*empty()*
		{expr} 为空时，返回数值 1，否则返回 0。
		- |List|、|Tuple| 或 |Dictionary| 没有项目时为空。
		- |String| 长度等于零时为空。
		- |Number| 或 |Float| 值等于零时为空。
		- |v:false|、|v:none| 和 |v:null| 为空，而 |v:true| 不是。
		- |Job| 启动失败时为空。
		- |Channel| 己关闭时为空。
		- |Blob| 长度等于零时为空。
		- |Object| (如果对象存在) 当其 empty() 方法返回真值时为空。见
		  |object-empty()|

		如果 |List| 很长，本函数比先获取长度再与零比较的方法要快得多。

		也可用作 |method|: >
			mylist->empty()
<
		返回类型: |Number|


environ()						*environ()*
		返回所有环境变量构成的字典。可用于检查某个环境变量是否存在: >
			:echo has_key(environ(), 'HOME')
<		注意 变量名可能是驼峰式 (CamelCase)，要忽略大小写，可用: >
			:echo index(keys(environ()), 'HOME', 0, 1) != -1
<
		返回类型: dict<string>


err_teapot([{expr}])					*err_teapot()*
		生成编号为 418 的错误，用于实现 RFC 2324。
		{expr} 给出且作为表达式的计算结果为 TRUE 时，给出 503 错误，指
		示咖啡暂未准备好。
		{expr} 给出时必须为字符串。
		(译者注: 如果 {expr} 为空串或者只有空白字符，不会报错)

		返回类型: |Number|


escape({string}, {chars})				*escape()*
		将 {string} 中出现在 {chars} 集合里的字符用反斜杠转义。例如: >
			:echo escape('c:\program files\vim', ' \')
<		返回: >
			c:\\program\ files\\vim
<		另见 |shellescape()| 和 |fnameescape()|。

		也可用作 |method|: >
			GetText()->escape(' \')
<
		返回类型: |String|


eval({string})						*eval()*
		计算 {string} 并返回其结果。这在将 |string()| 的结果还原为原始
		值时尤其有用。适用于数值、浮点数、字符串、blob 及其复合类型。
		也可用于指向现有函数的 |Funcref|。|Vim9| 脚本中，还可用于通过
		|enum| 的完全限定名获取相应的枚举值。

		也可用作 |method|: >
			argv->join()->eval()
<
		返回类型: any，取决于 {string}


eventhandler()						*eventhandler()*
		处于事件处理器中时返回 1。此时，Vim 在等待用户输入字符时被中
		断，例如当有文件被拖放到 Vim 时。该值为 1 意味着此时不能使用交
		互命令。否则，返回零。

		返回类型: |Number|


executable({expr})					*executable()*
		本函数检查名为 {expr} 的可执行文件是否存在。{expr} 必须是不带
		任何参数的程序名。

		executable() 使用 $PATH 值和/或正常的程序搜索路径。
							*PATHEXT*
		MS-Windows 上，可选地可以直接包含 ".exe"、".bat" 等扩展名。然
		后再尝试 $PATHEXT 里列出的扩展名。这样，如果 "foo.exe" 不存
		在，还可以找到 "foo.exe.bat"。$PATHEXT 未设置时，缺省使用
		".com;.exe;.bat;.cmd"。在 $PATHEXT 中，单独的句号用来表示会尝
		试无扩展名的文件名。同样如果 'shell' 看起来像 Unix 外壳，那么
		Vim 也会尝试无扩展名的文件名。
		MS-Windows 上，只检查文件是否存在且不是目录，并不真正检查文件
		是否可以执行。
		MS-Windows 上，总能找到和 Vim 程序位于同一目录的可执行文件，因
		为该目录已加入 $PATH，执行时必然可以找到 |win32-PATH|。
					*$NoDefaultCurrentDirectoryInExePath*
		MS-Windows 上，使用 cmd.exe 作为 'shell' 时，通常也能找到 Vim
		当前工作目录下的可执行文件，通过置位
		`$NoDefaultCurrentDirectoryInExePath` 环境变量，可关闭此行为。
		为了安全原因，执行像 |:!|、|:make|、|system()| 这样的外部命令
		时，此变量总会被置位。

		返回值为数值，其意义为:
			1	存在
			0	不存在
			-1	此系统中没有实现
		|exepath()| 可用于获取可执行文件的完整路径。

		也可用作 |method|: >
			GetCommand()->executable()
<
		返回类型: |Number|


execute({command} [, {silent}])				*execute()*
		执行 Ex 命令或命令序列，并返回其输出结果，返回类型为字符串。
		{command} 可为字符串或列表。如果是列表，逐行执行命令。
		这或多或少等价于: >
			redir => var
			{command}
			redir END
<		但不会识别 {command} 里的续行。

		可选的 {silent} 参数可取以下的值:
			""		不用 `:silent`
			"silent"	用 `:silent`
			"silent!"	用 `:silent!`
		缺省是 "silent"。注意 用 "silent!" 时，和 `:redir` 不同，略过
		错误信息。使用外部命令时，可能会扰乱屏幕，要避免这一点，可用
		`system()` 代替。
							*E930*
		{command} 里不可用 `:redir`。

		要得到行的列表，可在返回结果上用 `split()`: >
			execute('args')->split("\n")

<		要在当前窗口以外的其它窗口中执行命令，可用 `win_execute()`。

		递归调用时，内层的输出结果不会包含在外层的结果里。

		也可用作 |method|: >
			GetCommand()->execute()
<
		返回类型: |String|


exepath({expr})						*exepath()*
		如果 {expr} 是可执行文件，并且或是绝对路径、或是相对路径，或在
		$PATH 中能找到，返回其完整路径。
		注意 以 "./" 开头的 {expr} 会使用当前目录，对 Vim 来说，某些情
		况下这可能会导致问题: >
			echo exepath(v:progpath)
<		如果 {expr} 在 $PATH 里找不到，或者不可执行，返回空串。

		也可用作 |method|: >
			GetCommand()->exepath()
<
		返回类型: |String|


exists({expr})						*exists()*
		返回数值，{expr} 有定义时返回 |TRUE|，不然返回零。

		备注: 在已编译的 |:def| 函数里，表达式的求值发生在运行时。要在
		编译时计算表达式，可用 `exists_compiled()`。

		要检查特性是否支持，可用 |has()|。
		要检查文件是否存在，可用 |filereadable()|。

		{expr} 参数是字符串，可以使用下列选项之一:
			varname		内部变量 (见 |internal-variables|)。也
			dict.key	可使用 |curly-braces-names|、
			list[i]		|Dictionary| 项目、|List| 项目、类和对
			import.Func	象方法、导入项目等等。但已编译的
			class.Func	`:def` 函数里的局部变量不可用。|Vim9|
			object.Func	脚本里的函数也可用，因为它可用作函数引
			class.varname	用。要小心，计算索引时如果表达式非法，
			object.varname	可能会产生错误信息。例如: >
					   :let l = [1, 2, 3]
					   :echo exists("l[5]")
<					   0 >
					   :echo exists("l[xx]")
<					   E121: Undefined variable: xx
					   0
			&option-name	Vim 选项 (只检查是否存在，而不验证其是
					否可用)
			+option-name	Vim 选项，并且确认可用。
			$ENVNAME	环境变量 (也可以通过和空串比较来实现)
			*funcname	已实现的内建函数 (见 |functions|) 或者
					用户定义函数 (见 |user-functions|)。也
					可使用函数引用变量。
			?funcname	可实现的内建函数；用于检查 "funcname"
					是否合法
			:cmdname	Ex 命令: 内建命令、用户命令或者命令修
					饰符 |:command|。
					返回:
					1  匹配命令的开始
					2  完整匹配命令
					3  匹配多个用户命令
					要检查命令是否受支持，可以检查其返回值
					是否为 2。
			:2match		|:2match| 命令。
			:3match		|:3match| 命令 (通常不应使用，因为它保
					留给内部用途)。
			#event		为该事件定义的自动命令
			#event#pattern	为该事件和特定模式定义的自动命令 (模式
					按本义出现，会和自动命令的模式进行逐字
					符比较)
			#group		自动命令组
			#group#event	在该组里为特定事件定义的自动命令。
			#group#event#pattern
					在该组里为特定事件和模式定义的自动命令。
			##event		支持在自动命令中使用该事件。

		例如: >
			exists("&shortname")
			exists("$HOSTNAME")
			exists("*strftime")
			exists("*s:MyFunc")	" 只适用于老式脚本
			exists("*MyFunc")
			exists("bufcount")
			exists(":Make")
			exists("#CursorHold")
			exists("#BufReadPre#*.gz")
			exists("#filetypeindent")
			exists("#filetypeindent#FileType")
			exists("#filetypeindent#FileType#*")
			exists("##ColorScheme")
<		符号 (&/$/*/#) 和名字之间不能有空格。
		名字之后不应有附加字符，虽然当前某些情况下会忽略这些字符，但
		将来可能更严格检查。因此不要依赖这种行为！
		可以通过的例子: >
			exists(":make")
<		_不_能通过的例子: >
			exists(":make install")

<		注意 参数必须是字符串，而非变量名本身。例如: >
			exists(bufcount)
<		这里不检查变量 "bufcount" 是否存在，而是提取 "bufcount" 的值，
		然后作为 {expr} 判断对应参数是否存在。

		也可用作 |method|: >
			Varname()->exists()
<
		返回类型: |Number|


exists_compiled({expr})					*exists_compiled()*
		类似于 `exists()` 但在编译时检查。可用于在函数未定义时跳过会报
		错的程序块: >
			if exists_compiled('*ThatFunction')
			   ThatFunction('works')
			endif
<		用 `exists()` 时，如果 ThatFunction() 未定义，会报告编译错误。

		{expr} 必须是按本义出现的字符串。 *E1232*
		只能在 |:def| 函数的内部使用。 *E1233*
		不能用于检查参数或局部变量。

		返回类型: |Number|


exp({expr})						*exp()*
		返回 {expr} 的指数函数值，类型为 |Float|，范围在 [0, inf] 之
		间。
		{expr} 的计算结果必须是 |Float| 或者 |Number|。否则返回 0.0。
		示例: >
			:echo exp(2)
<			7.389056 >
			:echo exp(-1)
<			0.367879

		也可用作 |method|: >
			Compute()->exp()
<
		返回类型: |Float|


expand({string} [, {nosuf} [, {list}]])			*expand()*
		扩展 {string} 里的通配符和下列特殊关键字。这里会应用
		'wildignorecase' 设置。

		{list} 给出且为 |TRUE| 时，返回列表。否则返回字符串，有多个匹
		配时，以 <NL> 字符分隔匹配项 [备注: 5.0 版本中曾用空格分隔。但
		如果文件名中包含空格，这种方式会产生歧义]。

		如果扩展失败，返回空串。如果 {string} 以 '%'，'#' 或 '<'
		开始，不返回不存在的文件名。详见下。

		在 |:terminal| 窗口里，'%' 会被扩展为 '!' 后跟当前运行的命令或
		外壳。|terminal-bufname|

		{string} 以 '%'、'#' 或 '<' 开头时，其扩展方式和
		|cmdline-special| 变量相同，并可使用相关修饰符。简要说明如下:

			%		当前文件名
			#		轮换文件名
			#n		轮换文件名 n
			<cfile>		光标所在的文件名
			<afile>		自动命令文件名
			<abuf>		自动命令缓冲区号 (以字符串形式出现！)
			<amatch>	自动命令匹配的名字
			<cexpr>		光标所在的 C 表达式
			<sfile>		正在执行中的脚本文件名或函数名
			<slnum>		正在执行中的脚本行号或函数行号
			<sflnum>	脚本文件行号，即使在函数中亦然
			<SID>		"<SNR>123_"  其中 "123" 是当前脚本 ID
					|<SID>|
			<script>	正在执行中的脚本文件，或者当前函数定义
					所在的脚本文件
			<stack>		调用栈
			<cword>		光标所在的单词
			<cWORD>		光标所在的字串 (WORD)
			<client>	最近收到的消息的 {clientid}
					|server2client()|
		修饰符:
			:p		扩展为完整的路径
			:h		头部 (去掉最后的路径组件)
			:t		尾部 (只保留最后的路径组件)
			:r		根部 (去掉扩展名)
			:e		只保留扩展名

		还支持其它修饰符，完整列表见 |filename-modifiers|。

		例如: >
			:let &tags = expand("%:p:h") .. "/tags"
<		注意 扩展 '%'、'#' 或者 '<' 开头的字符串时，忽略其后的文本。下
		例_不可_行: >
			:let doesntwork = expand("%:h.bak")
<		应该这样: >
			:let doeswork = expand("%:h") .. ".bak"
<		还要 注意 "<cfile>" 和其它形式的扩展只会返回被引用的文件名，而
		不会进一步扩展。比如，如果 "<cfile>" 是 "~/.cshrc"，需要执行另
		一个 expand() 才能把 "~/" 部分扩展为主目录所在路径: >
			:echo expand(expand("<cfile>"))
<
		变量名和其后的修饰符之间不能有空白。|fnamemodify()| 函数可以用
		来修改普通的文件名。

		扩展 '%' 或 '#' 但当前或轮换文件名没有定义时，会返回空串。在无
		名缓冲区上使用 "%:p" 时，会返回当前目录，其后附加一个 '/'。
		设置 'verbose' 时，'%'、'#' 和 <> 项目的扩展在失败时会报错。

		{string} 不以 '%'、'#' 或 '<' 开头时，其扩展方式和命令行上的文
		件名相同。，除非可选的 {nosuf} 参数给出而且为 |TRUE|，应用
		'suffixes' 和 'wildignore' 设置。
		这里可以使用并不存在的文件的名字。"**" 项目可用来遍历目录树。
		例如，要寻找当前目录及其下各级目录里的所有 "README": >
			:echo expand("**/README")
<
		expand() 也可用来扩展只有外壳才能解析的变量和环境变量。不过，
		这种方式可能比较耗时，因为需要调用外壳才能完成扩展。见
		|expr-env-expand|。
		扩展后的变量仍然被当作文件名列表进行处理。如果环境变量扩展失
		败，按原样返回。因而 ":echo expand('$FOOBAR')" 仍会返回
		"$FOOBAR"。

		|glob()| 说明如何查找已有文件。|system()| 说明如何获取外部命令
		的原始输出。

		也可用作 |method|: >
			Getpattern()->expand()
<
		返回类型: |String| 或 list<string>，取决于 {list}


expandcmd({string} [, {options}])			*expandcmd()*
		以与 `:edit` 等 Ex 命令相同的方式，扩展字符串 {string} 里的特
		殊项目。本函数会在 {string} 的任何位置像 |expand()| 那样扩展特
		殊关键字和环境变量。"~user" 和 "~/path" 仅在开始处进行扩展。

		{option} 字典参数支持以下项目:
		    errmsg	设为 TRUE 时，报告扩展时出现的错误。缺省不回显
				错误信息。

		返回扩展后的字符串。如果扩展时出错，返回未经修改的 {string}。

		示例: >
			:echo expandcmd('make %<.o')
			make /path/runtime/doc/builtin.o
			:echo expandcmd('make %<.o', {'errmsg': v:true})
<
		也可用作 |method|: >
			GetCommand()->expandcmd()
<
		返回类型: |String| 或 list<string>，取决于 {list} (译者注: 原
		文如此，应该只会返回 |String|)


extend({expr1}, {expr2} [, {expr3}])			*extend()*
		{expr1} 和 {expr2} 必须都是 |List| 或者都是 |Dictionary|。

		都是 |List| 时: 把 {expr2} 追加到 {expr1} 之后。
		{expr3} 给出时，把 {expr2} 里的项目追加到 {expr1} 中索引为
		{expr3} 的项目之前。{expr3} 为零时，插在首个项目之前。而如果
		{expr3} 等于 len({expr1})，{expr2} 会追加到末尾。
		例如: >
			:echo sort(extend(mylist, [7, 5]))
			:call extend(mylist, [2, 3], 1)
<		如果 {expr1} 和 {expr2} 指向同一个列表，复制的项目数等于列表原
		来的长度。例如，{expr3} 为 1 时，复制列表首值 N 次 (N 为列表原
		来的长度) (译者注: 原文如此，实际验证结果似有不同)。
		|add()| 可用来向列表添加单个元素。要将两个列表连接成一个新列
		表，可用 + 操作符: >
			:let newlist = [1, 2, 3] + [4, 5]
<
		都是 |Dictionary| 时: 把 {expr2} 里的所有项目追加到 {expr1} 之
		后。
		{expr1} 和 {expr2} 包含同一个键时，{expr3} 决定冲突的处理方法:
		{expr3} = "keep": 保留 {expr1} 的值
		{expr3} = "force": 使用 {expr2} 的值
		{expr3} = "error": 给出错误信息				*E737*
		{expr3} 省略时，默认使用 "force"。

		只要 {expr2} 非空，{expr1} 就会被修改。如果不想更改原值，先给
		{expr1} 创建个备份，或者用 |extendnew()| 来生成新的列表/字典。
		{expr2} 保持不变。
		如果 {expr1} 被锁住且 {expr2} 非空，操作失败。
		返回 {expr1}。如果出错，返回 0。

		也可用作 |method|: >
			mylist->extend(otherlist)
<
		返回类型: list<{type}> 或 dict<{type}>，取决于 {expr1} 和
		{expr2}，出错时: |Number|


extendnew({expr1}, {expr2} [, {expr3}])			*extendnew()*
		和 |extend()| 类同，但不会向 {expr1} 添加项目，而是创建并返回
		一个新列表或字典。{expr1} 保持不变。

		返回类型: list<{type}> 或 dict<{type}>，取决于 {expr1} 和
		{expr2}，出错时: |Number|


feedkeys({string} [, {mode}])				*feedkeys()*
		将 {string} 里的字符放入输入队列里，等候处理，就像它们来自映射
		或者用户输入一样。

		缺省，这些字符加到预输入 (typeahead) 缓冲区的尾端，因此，如果
		映射仍在执行，这些字符会在映射内容之后被处理。而 'i' 标志位会
		使它们插入在其它字符之前，从而在映射内容之前先被处理。

		该函数不会等待 {string} 中的键值被处理完毕。

		要在 {string} 中包含特殊键，可用双引号和 "\..." 记法
		|expr-quote|。例如，feedkeys("\<CR>") 会模拟 <Enter> 键击。而
		feedkeys('\<CR>') 则会压入五个字符。
		一个可能有用的特殊代码是 <Ignore>，它可以结束等待输入，但不会
		执行任何操作。				*<Ignore>*

		{mode} 是字符串，包含以下字符标志位:
		'm'	键将进行重映射。这是缺省行为。{mode} 省略时，键也会被
			重映射。
		'n'	键不经过重映射。
		't'	键按用户输入的方式处理；否则像映射结果的方式处理。这会
			影响撤销、打开折叠等行为。
		'L'	底层输入。只用于 Unix 或 GUI。键按来自终端的方式处理。
			忽略其它标志位。		*E980*
			CTRL-C 中断且包含 't' 标志位时，设置内部 "got_int" 标
			志位。
		'i'	插入字符串而非附加 (见上)。
		'x'	执行命令，直至预输入清空为止。和 ":normal!" 类似。可以
			不带 'x' 执行 feedkeys() 数次，然后一次性执行带 'x' 的
			(可以只带空 {string}) 来执行所有预输入。注意 结束时如
			果处于插入模式，Vim 的行为相当于按下 <Esc>，以避免脚本
			在继续前因为等待字符键入而被阻塞。
			注意 在执行命令期间如果调用了 feedkeys() 并引起递归调
			用，所有预输入按键序列都会被最内层的调用所消耗。
		'c'	执行时移除脚本上下文，从而恢复 (缺省的) 老式脚本语法，
			导致 "s:var" 不可用等等情况。注意 如果放入队列的按键序
			列会重新建立脚本上下文，该上下文依然会生效。
		'!'	和 'x' 一起使用时，不会退出插入模式。可用于利用定时器
			稍后再退出插入模式的测试环境。方便测试 CursorHoldI 事
			件。

		返回值总为 0。

		也可用作 |method|: >
			GetInput()->feedkeys()
<
		返回类型: |Number|


filecopy({from}, {to})					*filecopy()*
		将文件 {from} 复制到 {to}。返回数值，文件复制成功时返回 |TRUE|，
		失败时则返回 |FALSE|。
		如果名为 {to} 的文件已存在，本函数会失败。
		注意 本函数 (尚) 不能处理目录。

		该函数在沙盘里不可用 |sandbox|。

		也可用作 |method|: >
			GetOldName()->filecopy(newname)
<
		返回类型: |Number|


filereadable({file})					*filereadable()*
		返回数值，名为 {file} 的文件存在且可读时，返回 |TRUE|。{file}
		不存在或者指向目录时，返回 |FALSE|。{file} 可为任何返回字符串
		的表达式。
		如果不需要检查文件是否可读，可用 |glob()|。
		{file} 按本义使用，如有需要，请先扩展通配符: >
			echo filereadable('~/.vimrc')
			0
			echo filereadable(expand('~/.vimrc'))
			1

<		也可用作 |method|: >
			GetName()->filereadable()
<
		返回类型: |Number|

							*file_readable()*
		已废弃的名字: file_readable()。


filewritable({file})					*filewritable()*
		返回数值，名为 {file} 的文件存在且可写时，返回 1。{file} 不存
		在或者不可写时，返回 0。{file} 指向目录但可写时，返回 2。

		也可用作 |method|: >
			GetName()->filewritable()
<
		返回类型: |Number|


filter({expr1}, {expr2})				*filter()*
		{expr1} 必须是 |List| 、|String|、|Blob| 或者 |Dictionary|。
		{expr1} 是 |List| 或 |Dictionary| 时，对其中的每个项目计算
		{expr2}，结果为零或假值时删除该项目。对 |Blob| 里的每个字节和
		|String| 里的每个字符也采用类似方法。

		{expr2} 必须是 |string| 或 |Funcref|。

		{expr2} 是 |string| 时，{expr2} 内的 |v:val| 包含当前项目的
		值。对 |Dictionary|、|List|、|Blob| 和 |String| 而言，|v:key|
		分别包含当前项目的键、当前项目索引、当前字节索引和当前字符索
		引。
		例如: >
			call filter(mylist, 'v:val !~ "OLD"')
<		删除所有出现 "OLD" 的项目。 >
			call filter(mydict, 'v:key >= 8')
<		删除所有键小于 8 的值。 >
			call filter(var, 0)
<		删除所有值，相当于清空了该 |List| 或 |Dictionary|。

		{expr2} 是 |Funcref| 时，它应接受两个参数:
			1. 当前项目的键或索引。
			2. 当前项目的值。
		需要保留该项目时，此函数应返回 |TRUE|。
		例如要保留列表中奇数项目: >
			func Odd(idx, val)
			  return a:idx % 2 == 1
			endfunc
			call filter(mylist, function('Odd'))
<		使用 |lambda| 可以更简洁。|Vim9| 语法: >
			call filter(myList, (idx, val) => idx * val <= 42)
<		老式脚本语法: >
			call filter(myList, {idx, val -> idx * val <= 42})
<		"val" 如果不用，可以省略: >
			call filter(myList, {idx -> idx % 2 == 1})
<
		|Vim9| 脚本中，返回值必须为真值、假值、零或一。其他值会报告类
		型错误。

		对 |List| 和 |Dictionary| 而言，本操作是原位操作 (直接在输入上
		修改)。如果不想更动原始输入，先创建备份: >
			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')

<		对于 |List| 或 |Dictionary|，返回经过过滤后的 {expr1}，而对于
		|Blob| 或 |String|，则返回新值。
		如果计算 {expr2} 时出错，不再处理 {expr1} 里的后续项目。
		{expr2} 是函数引用时，除非该函数定义时带上 "abort" 标志位，忽
		略函数里的错误。

		也可用作 |method|: >
			mylist->filter(expr2)
<
		返回类型: |String|、|Blob|、list<{type}> 或 dict<{type}>，
		取决于 {expr1}


finddir({name} [, {path} [, {count}]])			*finddir()*
		在 {path} 里查找目录 {name}。支持向下和向上的递归目录搜索。
		{path} 的语法可见 |file-searching|。

		返回首个找到的路径。如果找到的目录在当前目录之下，返回相对路
		径。否则，返回完整路径。
		{path} 省略或为空时，使用 'path'。

		可选的 {count} 给出时，查找 {path} 里 {name} 第 {count} 次出
		现，而非默认的第一次。
		但 {count} 如果为负，会返回所有匹配路径组成的 |List|。

		与 ex 命令 `:find` 的行为基本相同。

		也可用作 |method|: >
			GetName()->finddir()
<
		返回类型: {count} 为负时是 list<string>，否则是 |String|


findfile({name} [, {path} [, {count}]])			*findfile()*
		类似于 |finddir()|，但寻找文件而非目录。
		使用 'suffixesadd' 选项。
		例如: >
			:echo findfile("tags.vim", ".;")
<		会从当前文件所在目录开始向上搜索，直到找到文件 "tags.vim" 为
		止。

		也可用作 |method|: >
			GetName()->findfile()
<
		返回类型: {count} 为负时是 list<string>，否则是 |String|


flatten({list} [, {maxdepth}])				*flatten()*
		将 {list} 展平，最多展平到 {maxdepth} 层。{maxdepth} 省略时返
		回完全展平的 |List|，相当于 {maxdepth} 为极大值。
		{list} 在原位被修改，要想不更动原始输入，可用 |flattennew()|。
		Vim9 脚本中，flatten() 不可用，必须使用 |flattennew()|。
							*E900*
		{maxdepth} 代表展平嵌套列表的最大层数。
		如果 {maxdepth} 为零，不修改 {list}。
		否则，{maxdepth} 必须为正数。

		如果有错，返回数值零。

		示例: >
			:echo flatten([1, [2, [3, 4]], 5])
<			[1, 2, 3, 4, 5] >
			:echo flatten([1, [2, [3, 4]], 5], 1)
<			[1, 2, [3, 4], 5]

		也可用作 |method|: >
			mylist->flatten()
<
		返回类型: list<{type}>


flattennew({list} [, {maxdepth}])			*flattennew()*
		同 |flatten()|，但先创建 {list} 的备份再进行。

		返回类型: list<{type}>


float2nr({expr})					*float2nr()*
		返回 {expr} 的整数部分 (去掉小数部分)，将其转换为数值。
		{expr} 的计算结果必须是 |Float| 或 |Number|。否则返回 0。
		如果 {expr} 值超出 |Number| 的范围，返回 0x7fffffff 或
		-0x7fffffff (有 64-位数值支持时，则为 0x7fffffffffffffff 或
		-0x7fffffffffffffff)。而 NaN 转换为 -0x80000000 (有 64-位数
		值支持时，则为 -0x8000000000000000)。
		示例: >
			echo float2nr(3.95)
<			3  >
			echo float2nr(-23.45)
<			-23  >
			echo float2nr(1.0e100)
<			2147483647  (或 9223372036854775807) >
			echo float2nr(-1.0e150)
<			-2147483647 (或 -9223372036854775807) >
			echo float2nr(1.0e-100)
<			0

		也可用作 |method|: >
			Compute()->float2nr()
<
		返回类型: |Number|


floor({expr})						*floor()*
		返回小于等于 {expr} 的最大整数 (向下取整)，类型为 |Float|。
		{expr} 的计算结果必须是 |Float| 或 |Number|。否则返回 0。
		示例: >
			echo floor(1.856)
<			1.0  >
			echo floor(-5.456)
<			-6.0  >
			echo floor(4.0)
<			4.0

		也可用作 |method|: >
			Compute()->floor()
<
		返回类型: |Float|


fmod({expr1}, {expr2})					*fmod()*
		返回 {expr1} / {expr2} 的余数，此处的除法可能无法精确表示。
		{expr2} 非零时，选取整数 i，返回 {expr1} - i * {expr2}，使得结
		果与 {expr1} 同号且绝对值小于 {expr2} 的绝对值。如果 {expr2}
		为零，则返回零。返回类型为 |Float|。
		{expr1} 和 {expr2} 的计算结果必须是 |Float| 或 |Number|。
		否则返回 0.0。
		示例: >
			:echo fmod(12.33, 1.22)
<			0.13 >
			:echo fmod(-12.33, 1.22)
<			-0.13

		也可用作 |method|: >
			Compute()->fmod(1.22)
<
		返回类型: |Float|


fnameescape({string})					*fnameescape()*
		转义 {string} 以便用作命令的文件名参数。有特殊意义的字符，如
		'%' 和 '|'，会用反斜杠转义。
		多数系统上，会被转义的字符包括 " \t\n*?[{`$\\%#'\"|!<"。而在反
		斜杠可在文件名中合法出现的系统上，哪些字符会被转义取决于
		'isfname'。
		其它被转义的字符包括出现在开头的 '+' 和 '>' 字符 (在 |:edit|
		和 |:write| 之后有特殊意义)，以及单独出现的 "-" (在 |:cd| 之后
		有特殊意义)。
		如果出错，返回空串。
		示例: >
			:let fname = '+some str%nge|name'
			:exe "edit " .. fnameescape(fname)
<		会执行: >
			edit \+some\ str\%nge\|name
<
		也可用作 |method|: >
			GetName()->fnameescape()
<
		返回类型: |String|


fnamemodify({fname}, {mods})				*fnamemodify()*
		根据 {mods} 修改文件名 {fname}。{mods} 是与命令行上文件名所用
		相同格式的修饰符字符串。见 |filename-modifiers|。
		例如: >
			:echo fnamemodify("main.c", ":p:h")
<		返回: >
			/home/user/vim/vim/src
<		如果 {mods} 为空或使用了不支持的修饰符，返回 {fname} 本身。
		如果 {fname} 为空而 {mods} 为 ":h"，会返回 "."，以便 `:cd` 所
		用。这不同于不带缓冲区名的 expand('%:h')，后者会返回空串。
		注意: {fname} 里不能直接包含环境变量，需要先通过 |expand()| 进
		行扩展。

		也可用作 |method|: >
			GetName()->fnamemodify(':p:h')
<
		返回类型: |String|


foldclosed({lnum})					*foldclosed()*
		返回数值，第 {lnum} 行位于已关闭的折叠内部时，返回该折叠的起始
		行号。如果不在任何已关闭的折叠中，返回 -1。
		{lnum} 的用法可见 |getline()|。例如，"." 表示当前行，"'m" 对应
		位置标记 m 的所在行，等等。

		也可用作 |method|: >
			GetLnum()->foldclosed()
<
		返回类型: |Number|


foldclosedend({lnum})					*foldclosedend()*
		返回数值，第 {lnum} 行位于已关闭的折叠内部时，返回该折叠的结束
		行号。如果不在任何已关闭的折叠中，返回 -1。
		{lnum} 的用法可见 |getline()|。例如，"." 表示当前行，"'m" 对应
		位置标记 m 的所在行，等等。

		也可用作 |method|: >
			GetLnum()->foldclosedend()
<
		返回类型: |Number|


foldlevel({lnum})					*foldlevel()*
		返回数值，当前缓冲区中第 {lnum} 行所处的折叠级别。如果位于嵌套
		的折叠中，返回最内层的层级。如果行 {lnum} 不在任何折叠中，返回
		零。这与折叠是打开还是关闭无关。折叠更新时 (来自 'foldexpr')，
		如果折叠还在更新中而相应的折叠级别未知，返回 -1。一个特例是前
		一行的折叠级别通常总是已知的。
		{lnum} 的用法可见 |getline()|。例如，"." 表示当前行，"'m" 对应
		位置标记 m 的所在行，等等。

		也可用作 |method|: >
			GetLnum()->foldlevel()
<
		返回类型: |Number|


foldtext()						*foldtext()*
		返回代替关闭折叠所显示的字符串。这是 'foldtext' 选项使用的缺省
		函数，而且也只应该在计算 'foldtext' 时使用。它使用
		|v:foldstart|、|v:foldend| 和 |v:folddashes| 变量。返回的字符
		串形如: >
			+-- 45 lines: abcdef
<		开头连字符的数目取决于折叠级别。"45" 是折叠包含的行数。
		"abcdef" 是折叠里首个非空白行的文本。去掉开头的空白，"//" 或
		"/*"，还有 'foldmarker' 和 'commentstring' 选项包含的文本。
		用本函数来描绘实际的折叠文本时，行的其余部分会用 'fillchars'
		设置里的 fold 字符来填充。
		如果没有折叠，则返回空串。

		返回类型: |String|
		{仅当编译时加入 |+folding| 特性才有效}


foldtextresult({lnum})					*foldtextresult()*
		返回替代行 {lnum} 所在的已关闭折叠所显示的文本。在合适的上下文
		下，通过计算 'foldtext' 得到。
		如果 {lnum} 不在任何已关闭的折叠中，返回空串。
		{lnum} 的用法可见 |getline()|。例如，"." 表示当前行，"'m" 对应
		位置标记 m 的所在行，等等。
		可用于导出折叠文本，例如在生成 HTML 格式时输出折叠信息。
		{仅当编译时加入 |+folding| 特性才有效}

		也可用作 |method|: >
			GetLnum()->foldtextresult()
<
		返回类型: |String|


foreach({expr1}, {expr2})				*foreach()* *E1525*
		{expr1} 必须是 |List|、|Tuple|、|String|、|Blob| 或者
		|Dictionary|。
		对 {expr1} 其中的每个项目计算 {expr2}。{expr1} 不会被修改；但
		子项目可能会，此行为相当于 |:lockvar| 深度为 1 的加锁。|E741|
		如果需要修改 {expr1}，参见 |map()| 和 |filter()|。

		{expr2} 必须是 |string| 或 |Funcref|。

		{expr2} 是 |string| 时，{expr2} 内的 |v:val| 包含当前项目的
		值。对 |Dictionary|、|List|、|Tuple|、|Blob| 和 |String| 而
		言，|v:key| 分别包含当前项目的键、当前项目索引、当前项目索引、
		当前字节索引和当前字符索引。
		示例: >
			call foreach(mylist, 'used[v:val] = true')
<		会记录在 {expr1} 列表里的所有项目。

		注意 {expr2} 是表达式的结果，其内容又被作为命令运行。因此，这
		里 |literal-string| 比较好用，以避免出现双重反斜杠转义的问题。

		{expr2} 是 |Funcref| 时，它应接受两个参数:
			1. 当前项目的键或索引。
			2. 当前项目的值。
		老式匿名函数如果只接受一个参数，不会报错，而 Vim9 匿名函数会报
		错 "E1106: One argument too many"，参数数目必须匹配。
		忽略函数返回值。

		所有情况下，返回 {expr1}。
		如果计算 {expr2} 时出错，不再处理 {expr1} 的后续项目。
		{expr2} 是函数引用时，除非该函数定义时带上 "abort" 标志位，忽
		略函数里的错误。

		也可用作 |method|: >
			mylist->foreach(expr2)
<
		返回类型: |String|、|Blob|、list<{type}>、tuple<{type}> 或
		dict<{type}>，取决于 {expr1}


foreground()						*foreground()*
		将 Vim 窗口置于前台。从客户端向 Vim 服务器发送命令时常用。
		|remote_send()|
		Win32 系统上此功能未必可用，操作系统并不总允许窗口主动把自己切
		换到前台。可用 |remote_foreground()| 代替。

		返回类型: |Number|
		{仅当使用 Win32、Motif 和 GTK GUI 版本和 Win32 控制台版本时才
		有效}

fullcommand({name} [, {vim9}])				*fullcommand()*
		获取简短缩写命令的完整命令名；关于命令缩写，详见 |20.2|。

		字符串参数 {name} 可包含 `:` 或 [range] 前缀，但这些部分会被忽
		略，也不会出现在返回结果里。
		如果命令不存在、有歧义 (用户定义命令有此可能) 或此缩写被禁用
		|vim9-no-shorten|，返回空串。

		无 {vim9} 参数时使用当前脚本版本。{vim9} 存在且为 FALSE 时使用
		老式脚本规则。{vim9} 存在且为 TRUE 时使用 Vim9 规则，例如 "en"
		不用作 "endif" 的缩写。

		例如，`fullcommand('s')`、`fullcommand('sub')`、
		`fullcommand(':%substitute')` 都返回 "substitute"。

		也可用作 |method|: >
			GetName()->fullcommand()
<
		返回类型: |String|


funcref({name} [, {arglist}] [, {dict}])		*funcref()*
		类似于 |function()|，但返回的函数引用通过引用而非名字来查找函
		数。如果函数 {name} 之后被重定义，这点区别很重要。

		和 |function()| 不同，{name} 必须是已存在的用户函数。也支持自
		动载入函数，但必须已经载入 (如果只想引用函数名而希望避免意外触
		发自动载入脚本，可用 |function()| 代替)。{name} 不能是内建函
		数。
		如果出错，返回 0。

		也可用作 |method|: >
			GetFuncname()->funcref([arg])
<
		返回类型: func(...): any，或出错时 |Number|

							*function()* *partial*
function({name} [, {arglist}] [, {dict}])		*E700* *E923*
		返回指向函数 {name} 的 |Funcref| 变量。{name} 可以是用户定义函
		数，也可以是内建函数的名字。

		{name} 本身也可为函数引用或者偏函数。如果是偏函数，会使用它自
		身保存的字典，而不接受 {dict} 参数。例如: >
			let FuncWithArg = function(dict.Func, [arg])
			let Broken = function(dict.Func, [arg], dict)
<
		如果是函数引用，通过名字 {name} 查找函数，之后该函数如果被重定
		义，通过名字会找到新定义。要确保引用保持不变，可用
		|funcref()|。

		{arglist} 或 {dict} 给出时，会建立偏函数。这意味着函数引用会记
		住参数列表和/或字典，并在调用时使用。

		参数表里的参数会传递给函数。它们出现在其它参数之前，但位于来自
		|method| 的参数之后。例如: >
			func Callback(arg1, arg2, name)
			...
			let Partial = function('Callback', ['one', 'two'])
			...
			call Partial('name')
<		函数的调用相当于: >
			call Callback('one', 'two', 'name')

<		用 |method| 的话: >
			func Callback(one, two, three)
			...
			let Partial = function('Callback', ['two'])
			...
			eval 'one'->Partial('three')
<		函数的调用相当于: >
			call Callback('one', 'two', 'three')

<		function() 调用可以嵌套，为函数引用添加更多参数。新加的参数附
		加到原有参数列表之后。如: >
			func Callback(arg1, arg2, name)
			"...
			let Func = function('Callback', ['one'])
			let Func2 = function(Func, ['two'])
			"...
			call Func2('name')
<		函数的调用相当于: >
			call Callback('one', 'two', 'name')

<		字典只用于带 "dict" 标记的函数。函数调用时，{dict} 会作为
		"self" 传入函数。例如: >
			function Callback() dict
			   echo "called for " .. self.name
			endfunction
			"...
			let context = {"name": "example"}
			let Func = function('Callback', context)
			"...
			call Func()	" 会回显: called for example
<		如果不需额外参数，可以直接使用字典项目形式而不用 function()。
		当 Callback() 的定义采用 context.Callback() 格式时，以下两种写
		法等价: >
			let Func = function('Callback', context)
			let Func = context.Callback

<		可以同时使用参数列表和字典: >
			function Callback(arg1, count) dict
			"...
			let context = {"name": "example"}
			let Func = function('Callback', ['one'], context)
			"...
			call Func(500)
<		函数的调用相当于: >
			call context.Callback('one', 500)
<
		如果出错，返回 0。

		也可用作 |method|: >
			GetFuncname()->function([arg])

<
		返回类型: func(...): any，或出错时 |Number|


garbagecollect([{atexit}])				*garbagecollect()*
		清理不再使用但存在循环引用的 |List| 、|Dictionary|、|Channel|
		和 |Job|。

		几乎无需手动调用本函数，因为 Vim 会在内存不足时或等待用户输入
		超过 'updatetime' 时自动执行相应功能。而对于不存在循环引用的对
		象，一旦不再使用就会立即释放。不过，在长时间运行的脚本里，本函
		数可用于清理大型且存在循环引用的 |List| 和/或 |Dictionary|。

		可选的 {atexit} 参数为一时，即使在 Vim 退出时也会执行垃圾回
		收，除非已经执行过。这可用于检查内存泄漏。

		垃圾回收并非立即进行，它会等待安全的时机，通常是等待用户输入字
		符的时候。要强制立即进行垃圾回收，可用
		|test_garbagecollect_now()|。

		返回类型: |String|


get({list}, {idx} [, {default}])			*get()* *get()-list*
		获取 |List| {list} 里的第 {idx} 个项目。如果对应项目不存在，返
		回 {default}。{default} 默认为零。
		建议用作 |method|: >
			mylist->get(idx)
<
		返回类型: any，取决于 {list}


get({tuple}, {idx} [, {default}])			*get()-tuple*
		获取 |Tuple| {tuple} 里的第 {idx} 个项目。如果对应项目不存在，
		返回 {default}。{default} 默认为零。
		建议用作 |method|: >
			mytuple->get(idx)
<
		返回类型: any，取决于 {tuple}


get({blob}, {idx} [, {default}])			*get()-blob*
		获取 |Blob| {blob} 里的第 {idx} 个字节。如果对应字节不存在，返
		回 {default}。{default} 默认为 -1。
		建议用作 |method|: >
			myblob->get(idx)
<
		返回类型: |Number|


get({dict}, {key} [, {default}])			*get()-dict*
		获取 |Dictionary| {dict} 里键为 {key} 的项目。如果对应项目不存
		在，返回 {default}。{default} 默认为零。有用的例子: >
			let val = get(g:, 'var_name', 'default')
<		会在 g:var_name 存在时，返回其值，不存在时则返回 'default'。
		建议用作 |method|: >
			mydict->get(key)
<
		返回类型: any，取决于 {dict}


get({func}, {what})					*get()-func*
		获取函数引用 {func} 的项目 {what}。{what} 的可能值是:
		  "name"    函数名
		  "func"    函数
		  "dict"    字典
		  "args"    参数列表
		  "arity"   函数可接受的参数数量相关信息的字典。这里会扣除
			    {arglist} 中已提供的参数。包含以下字段:
				required    位置参数数目
				optional    必选参数之外的可选参数数目
				varargs     如果此函数接受可变参数数目 ... 则
					    为 |TRUE|

				注意: 即使 {arglist} 提供的参数数量多于函数引
				用本身期待的参数数量，也不会报错，没有相关检
				测。

		如果出错，返回零。

		建议用作 |method|: >
			myfunc->get(what)
<
		返回类型: any，取决于 {func} 和 {what}


getbufinfo([{buf}])					*getbufinfo()*
getbufinfo([{dict}])
		获取缓冲区的相关信息，返回类型为字典列表。

		不带参数时，返回关于所有缓冲区的信息。

		给出 |Dictionary| 参数时，仅返回匹配相关条件的缓冲区的信息。
		{dict} 中可指定以下键值:
			buflisted	只包含在列表内的缓冲区。
			bufloaded	只包含已加载的缓冲区。
			bufmodified	只包含修改过的缓冲区。

		否则，{buf} 指定特定的单个缓冲区并返回其信息。{buf} 的用法见上
		述 |bufname()|。找到缓冲区时，返回包含单个项目的列表。不然返回
		空列表。

		每个返回的列表项是带有以下项目的字典:
			bufnr		缓冲区号。
			changed		缓冲区已修改过则为 TRUE。
			changedtick	缓冲区发生过的改动次数。
			command		缓冲区属于命令行窗口 |cmdwin| 则为
					TRUE。
			hidden		缓冲区被隐藏则为 TRUE。
			lastused	缓冲区最近一次修改以秒为单位的时间戳。
					格式和 |localtime()| 相同。
					{仅当编译时加入 |+viminfo| 特性才有效}
			listed		缓冲区在列表内则为 TRUE。
			lnum		本缓冲区在当前窗口里显示时的光标行号。
					仅当该缓冲区在此窗口中曾经显示过才会有
					效。如果要查询特定窗口中最近已知的光标
					行号，可用 |line()|: >
						:echo line('.', {winid})
<
			linecount	缓冲区总行数 (仅当缓冲区载入后才有效)
			loaded		缓冲区已载入则为 TRUE。
			name		缓冲区文件的完整路径。
			signs		缓冲区内已放置标号的列表。
					每个列表项是包含以下项目的字典:
					    id	  标号识别符
					    lnum  行号
					    name  标号名
			variables	包含缓冲区局部变量的字典的引用。
			windows		所有显示此缓冲区的 |window-ID| 列表
			popups		所有显示此缓冲区的弹出窗口 |window-ID|
					的列表

		示例: >
			for buf in getbufinfo()
			    echo buf.name
			endfor
			for buf in getbufinfo({'buflisted':1})
			    if buf.changed
				....
			    endif
			endfor
<
		要获取缓冲区局部选项，可用: >
			getbufvar({bufnr}, '&option_name')
<
		也可用作 |method|: >
			GetBufnr()->getbufinfo()
<
		返回类型: list<dict<any>>


getbufline({buf}, {lnum} [, {end}])			*getbufline()*
		返回 {buf} 缓冲区中从第 {lnum} 行到第 {end} 行 (包含) 组成的
		|List|。{end} 省略时，返回单行 {lnum} 组成的 |List|。如果只要
		单行内容，可用 `getbufoneline()`。

		{buf} 的用法见上述 |bufname()|。

		{lnum} 和 {end} 可用 "$" 来表示缓冲区的末行。除此以外，必须用
		数值。

		如果 {lnum} 小于 1 或超过缓冲区的总行数，返回空 |List|。

		{end} 如果超过缓冲区的总行数，视为缓冲区的末行。如果 {end} 小
		于 {lnum}，返回空 |List|。

		本函数只能用于已加载的缓冲区。对未载入或不存在的缓冲区，总是返
		回空 |List|。

		例如: >
			:let lines = getbufline(bufnr("myfile"), 1, "$")

<		也可用作 |method|: >
			GetBufnr()->getbufline(lnum)
<
		返回类型: list<string>


getbufoneline({buf}, {lnum})				*getbufoneline()*
		类似于 `getbufline()`，但只获取单行，且以字符串形式返回。

		返回类型: |String|


getbufvar({buf}, {varname} [, {def}])			*getbufvar()*
		返回缓冲区 {buf} 里选项或局部变量 {varname} 的值。注意 这里不
		能使用 "b:" 前缀。
		{varname} 参数为字符串。
		{varname} 为空时，返回包含该缓冲区里所有缓冲区局部变量的
		|Dictionary|。
		{varname} 为 "&" 时，返回包含该缓冲区里所有缓冲区局部选项的
		|Dictionary|。
		否则，以 "&" 开头 的 {varname} 会返回对应的缓冲区局部选项值。
		也可用于全局选项或缓冲区局部选项，但不能用于全局变量、窗口局部
		变量和窗口局部选项。
		{buf} 的用法见上述 |bufname()|。
		如果缓冲区或者变量不存在，返回 {def} (默认值为空串)。不报错。
		示例: >
			:let bufmodified = getbufvar(1, "&mod")
			:echo "todo myvar = " .. getbufvar("todo", "myvar")

<		也可用作 |method|: >
			GetBufnr()->getbufvar(varname)
<
		返回类型: any，取决于 {varname}


getcellpixels()						*getcellpixels()*
		返回终端上一个屏幕单元的像素尺寸 |List|。
		列表格式是 [xpixel, ypixel]。

		仅对 Unix (终端和 gVim) 和 Windows (仅 gVim) 有效。
		其他系统返回 [] 或报错。
		注意 不同终端返回的尺寸可能稍有不同。在 macOS 上，系统自带的
		Terminal.app 返回以点 (point) 计的尺寸 (未考虑视网膜缩放)，而
		第三方终端返回物理像素尺寸 (已考虑视网膜缩放)。

		返回类型: list<any>


getcellwidths()						*getcellwidths()*
		返回由 |setcellwidths()| 指定的字符范围上的单元宽度覆盖的
		|List|。其格式和 |setcellwidths()| 的参数相同。如果没有字符范
		围上有单元宽度覆盖，返回空列表。

		返回类型: list<any>


getchangelist([{buf}])					*getchangelist()*
		返回缓冲区 {buf} 里的 |changelist|。{buf} 的用法见上述
		|bufname()|。如果缓冲区 {buf} 不存在，返回空列表。

		返回的列表包含两个项目: 改变发生所在位置的列表，以及该列表中的
		当前位置。改变位置列表中的每个列表项是包含以下内容的字典:
			col		列号
			coladd		用于 'virtualedit' 的列偏移
			lnum		行号
		{buf} 是当前缓冲区时，当前位置指向列表中的当前位置。否则，当前
		位置被设为列表总长度。

		也可用作 |method|: >
			GetBufnr()->getchangelist()
<
		返回类型: list<any>


getchar([{expr} [, {opts}]])				*getchar()*
		从用户或输入流中提取单个字符。
		{expr} 省略或为 -1 时，等待直到有字符输入为止。
		{expr} 为 0 时，仅在有字符可用时才获取该字符，否则返回零。
		{expr} 为 1 时，仅检查是否有可用字符，并不读取该字符。没
			有字符时返回零。
		如果希望以字符串形式返回字符，可用 |getcharstr()| 或在 {opts}
		中将 "number" 项设为 |FALSE|。

		{expr} 省略或为零时，返回完整字符或特殊键。如果是单个字符，以
		数值形式返回。可用 |nr2char()| 将其转换为字符串。否则，返回字
		符编码形式构成的字符串。
		如果是特殊键，返回以 0x80 (十进制: 128) 开始的一串字节构成的字
		符串。等价于 "\<Key>"，如 "\<Left>"。如果字符键入时带有修饰键
		(Shift、Control、Alt) 且字符本身不包含该修饰符，返回值也是字符
		串类型。可用 |keytrans()| 将返回的字符串转为可读的形式。

		{expr} 为 0 时如果键入 Esc，会有短暂的延迟，以判断该按键是否是
		转义序列的起始部分。

		{expr} 为 1 时，只返回第一个字节。如果是单字节字符，返回的就是
		该字符自身的数值形式。可用 |nr2char()| 将其转换为字符串。

		|getcharmod()| 可用于获取附加的修饰符。

		可选参数 {opts} 是支持以下项目的字典:

			cursor		字符串，指定等待用户输入字符时的光标行
					为。
					"hide": 隐藏光标。
					"keep": 保持当前光标不变。
					"msg": 移动光标到消息区。
					(缺省: "msg")

			number		为 |TRUE| 时提取到单个字符时返回数值。
					为 |FALSE| 时总把返回值转换为字符串，
					无字符可用时返回空串 (而非 0)。
					(缺省: |TRUE|)

			simplify	为 |TRUE| 时，如果按下的键带有修饰键，
					返回的字符会包含修饰符。例如 CTRL-I 和
					<Tab> 会返回相同的值。
					为 |FALSE| 时，返回的字符不包含修饰
					符。
					(缺省: |TRUE|)

		用户点击鼠标按钮时，返回鼠标事件。鼠标位置可在 |v:mouse_col|、
		|v:mouse_lnum| 、|v:mosue_winid| 和 |v:mouse_win| 里找到。也可
		用 |getmousepos()|。忽略鼠标移动事件。
		下例展示了如何用常规的处理方法来定位鼠标: >
			let c = getchar()
			if c == "\<LeftMouse>" && v:mouse_win > 0
			  exe v:mouse_win .. "wincmd w"
			  exe v:mouse_lnum
			  exe "normal " .. v:mouse_col .. "|"
			endif
<
		使用括号内粘贴模式时，只返回首个字符。粘贴文本的其余部分被丢
		弃。|xterm-bracketed-paste|。

		这里不会有提示信息，需要以其它方式来告知用户去输入一个字符。屏
		幕不重画，例如在改变窗口大小时也是如此。使用弹出窗口时，建议使
		用 |popup-filter|。

		字符不通过映射。
		键码被替换。因而，用户输入 <Del> 键时，你得到 <Del> 的键码，而
		不是原始的字符序列。比如: >
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
<		下例重新定义了 "f"，使之在匹配时忽略大小写: >
			:nmap f :call FindChar()<CR>
			:function FindChar()
			:  let c = nr2char(getchar())
			:  while col('.') < col('$') - 1
			:    normal l
			:    if getline('.')[col('.') - 1] ==? c
			:      break
			:    endif
			:  endwhile
			:endfunction
<
		有时也可能收到模拟的字符事件，例如 |<CursorHold>|。通常情况
		下，可以忽略它们并跳到下一个实际字符: >
			:function GetKey()
			:  let c = getchar()
			:  while c == "\<CursorHold>"
			:    let c = getchar()
			:  endwhile
			:  return c
			:endfunction
<
		返回类型: |Number| 或 |String|


getcharmod()						*getcharmod()*
		返回数值，反映最近用 |getchar()| 或其它方式输入字符时使用的修
		饰符状态。多个修饰符的值会相加:
			2	Shift
			4	Control
			8	Alt (Meta)
			16	Meta (当和 ALT 不同时)
			32	鼠标双击
			64	鼠标三击
			96	鼠标四击 (== 32 + 64)
			128	Command (Mac) 或 Super (GTK)
		只返回字符本身未包含的的修饰符。例如，Shift-a 会得到 "A"，返回
		值不带修饰符。如果没有任何修饰符，返回 0。

		返回类型: |Number|


getcharpos({expr})					*getcharpos()*
		获取字符串 {expr} 所指位置。和 |getpos()| 类同，但返回列表中的
		列号以字符为单位，而非字节索引。
		如果 |getpos()| 返回的列号等于 |v:maxcol| 的极大值，那么相应
		地，getcharpos() 会返回该行最后一个字符的字符索引。

		示例:
		光标在第五行文本 "여보세요" 的 '세' 上时: >
			getcharpos('.')		返回 [0, 5, 3, 0]
			getpos('.')		返回 [0, 5, 7, 0]
<
		也可用作 |method|: >
			GetMark()->getcharpos()
<
		返回类型: list<number>


getcharsearch()						*getcharsearch()*
		以 {dict} 形式返回当前字符搜索相关信息，包含以下条目:

		    char	最近一次字符搜索 (|t|、|f|、|T| 或 |F|) 所用的
				字符；如果尚未进行过字符搜索，返回空串
		    forward	字符搜索的方向；1 表示正向搜索，0 表示反向搜索
		    until	字符搜索的类型；1 表示使用了 |t| 或 |T| 字符搜
				索，0 表示使用了 |f| 或 |F| 字符搜索

		可以用来让 |;| 和 |,| 始终进行正向或反向搜索，而不受上次字符搜
		索方向的影响: >
			:nnoremap <expr> ; getcharsearch().forward ? ';' : ','
			:nnoremap <expr> , getcharsearch().forward ? ',' : ';'
<		另见 |setcharsearch()|。

		返回类型: dict<any>


getcharstr([{expr} [, {opts}]])				*getcharstr()*
		和 |getchar()| 类同，但总是返回字符串形式，且 {opts} 里不允许
		设置 "number"。

		返回类型: |String|


getcmdcomplpat()					*getcmdcomplpat()*
		返回当前命令行的补全模式。
		仅在编辑命令行时有效，所以必须在 |c_CTRL-\_e|、|c_CTRL-R_=| 或
		表达式映射的上下文中使用。
		另见 |getcmdtype()|、|setcmdpos()|、|getcmdline()|、
		|getcmdprompt()|、|getcmdcompltype()| 和 |setcmdline()|。
		如果没有可用的补全，返回空串。

		返回类型: |String|


getcmdcompltype()					*getcmdcompltype()*
		返回当前命令行的补全类型。
		仅在编辑命令行时有效，所以必须在 |c_CTRL-\_e|、|c_CTRL-R_=| 或
		表达式映射的上下文中使用。
		返回的字符串值补全类型可见 |:command-completion|。
		另见 |getcmdtype()|、|setcmdpos()| 、|getcmdline()|、
		|getcmdprompt()|、|getcmdcomplpat()| 和 |setcmdline()|。
		如果没有可用的补全，返回空串。

		要获取为指定字符串所使用的命令行补全的类型，可用
		|getcompletiontype()|。

		返回类型: |String|


getcmdline()						*getcmdline()*
		返回当前命令行的输入。
		仅在编辑命令行时有效，所以必须在 |c_CTRL-\_e|、|c_CTRL-R_=| 或
		表达式映射的上下文中使用。
		例如: >
			:cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
<		另见 |getcmdtype()|、|getcmdpos()|、|setcmdpos()|、
		|getcmdprompt()| 和 |setcmdline()|。
		输入密码或用 |inputsecret()| 时返回空串。

		返回类型: |String|


getcmdpos()						*getcmdpos()*
		返回当前命令行中光标所在的字节索引位置。首列位置为 1。
		仅在编辑命令行时有效，所以必须在 |c_CTRL-\_e|、|c_CTRL-R_=| 或
		表达式映射的上下文中使用。
		否则返回 0。
		另见 |getcmdtype()|、|setcmdpos()|、|getcmdline()|、
		|getcmdprompt()| 和 |setcmdline()|。

		返回类型: |Number|


getcmdprompt()						*getcmdprompt()*
		返回当前命令行在使用 |input()| 或 |confirm()| 等函数时显示的提
		示字符串。
		仅在编辑命令行时有效，所以必须在 |c_CTRL-\_e|、|c_CTRL-R_=| 或
		表达式映射的上下文中使用。
		另见 |getcmdtype()|、|getcmdline()|、|getcmdpos()|、
		|setcmdpos()| 和 |setcmdline()|。

		返回类型: |String|


getcmdscreenpos()					*getcmdscreenpos()*
		返回当前命令行中光标所在的屏幕位置。首屏幕列位置为 1。
		和 |getcmdpos()| 不同，本函数返回的光标位置会把提示字符串的长
		度也计算在内。
		仅在编辑命令行时有效，所以必须在 |c_CTRL-\_e|、|c_CTRL-R_=| 或
		表达式映射的上下文中使用。
		否则返回 0。
		另见 |getcmdpos()|、|setcmdpos()|、|getcmdline()| 和
		|setcmdline()|。

		返回类型: |Number|


getcmdtype()						*getcmdtype()*
		返回当前命令行的类型。可能的返回值是:
		    :	普通 Ex 命令
		    >	调试模式命令 |debug-mode|
		    /	正向搜索命令
		    ?	反向搜索命令
		    @	|input()| 命令
		    -	|:insert| 或 |:append| 命令
		    =	|i_CTRL-R_=|
		仅在编辑命令行时有效，所以必须在 |c_CTRL-\_e|、|c_CTRL-R_=| 或
		表达式映射的上下文中使用。
		否则返回空串。
		另见 |getcmdpos()|、|setcmdpos()| 和 |getcmdline()|。

		返回类型: |String|


getcmdwintype()						*getcmdwintype()*
		返回当前 |command-line-window| 的类型。可能的返回值和
		|getcmdtype()| 相同。如果不在命令行窗口内，返回空串。

		返回类型: |String|


getcompletion({pat}, {type} [, {filtered}])		*getcompletion()*
		返回命令行补全的匹配项列表。字符串参数 {type} 指定补全类型。支
		持的类型如下:

		arglist		参数列表中的文件名
		augroup		自动命令组
		buffer		缓冲区名
		behave		|:behave| 子选项
		breakpoint	|:breakadd| 和 |:breakdel| 子选项
		color		色彩方案
		command		Ex 命令
		cmdline		|cmdline-completion| 结果 (见下)
		compiler	编译器
		cscope		|:cscope| 子选项
		custom,{func}	通过 {func} (返回换行分隔的字符串) 定义的定制
				补全
		customlist,{func} 通过 {func} (返回列表) 定义的定制补全
		diff_buffer	|:diffget| 和 |:diffput| 补全 (处于比较模式的
				缓冲区)
		dir		目录名
		dir_in_path	'cdpath' 里的目录名
		environment	环境变量名
		event		自动命令事件
		expression	Vim 表达式
		file		文件和目录名
		file_in_path	'path' 中的文件和目录名
		filetype	文件类型名 'filetype'
		filetypecmd	|:filetype| 子选项
		function	函数名
		help		帮助主题
		highlight	高亮组
		history		|:history| 子选项
		keymap		键盘映射
		locale		locale 名 (可见 locale -a 的输出)
		mapclear	缓冲区参数 (译者注: 只有一项 "<buffer>")
		mapping		映射名
		menu		菜单
		messages	|:messages| 子选项
		option		选项
		packadd		可选包 |pack-add| 名
		retab		|:retab| 子选项
		scriptnames	执行过的脚本名 |:scriptnames|
		shellcmd	外壳命令
		shellcmdline	带文件名参数的外壳命令行
		sign		|:sign| 子选项
		syntax		语法文件名 'syntax'
		syntime		|:syntime| 子选项
		tag		标签
		tag_listfiles	带文件名的标签 (译者注: 只返回标签，但如果多个
				文件中有相同的标签，标签会列出多次，见
				'wildoptions' 里的 "tagfile")
		user		用户名
		var		用户变量

		{pat} 为空串时返回所有匹配项。否则只返回匹配 {pat} 的项目。
		关于 {pat} 中特殊字符的使用，见 |wildcards|。

		可选的 {filtered} 标志位为 1 时，应用 'wildignore' 来过滤结
		果。否则返回所有匹配项。'wildignorecase' 选项则总是有效。

		'wildoptions' 选项包含 'fuzzy' 时，补全匹配使用模糊匹配，否则
		使用正则表达式匹配。这样本函数将与用户在命令行中的偏好保持一
		致。如果不想如此，可在调用 getcompletion() 前清空
		'wildoptions'，调用结束后再复原。

		{type} 为 "cmdline" 时，返回 |cmdline-completion| 的结果。例
		如，要补全 ":call" 命令之后可能的取值: >
			echo getcompletion('call ', 'cmdline')
<
		如果没有匹配，返回空列表。如果 {type} 为非法值，报错。

		也可用作 |method|: >
			GetPattern()->getcompletion('color')
<
		返回类型: list<string>


getcompletiontype({pat})				*getcompletiontype()*
		返回 {pat} 所使用的命令行补全的类型。如果未找到对应的补全类
		型，返回空串。
		要得到当前命令行的补全类型，可用 |getcmdcompltype()|。

		返回类型: list<string>


getcurpos([{winid}])					*getcurpos()*
		返回光标所在位置。类似于 getpos('.')，但返回列表中包含了额外的
		"curswant" 项:
		    [0, lnum, col, off, curswant] ~
		"curswant" 是一个数值，用于记录垂直移动光标时的首选列。执行
		|$| 命令后，它会被设为等于 |v:maxcol| 的极大值。另见
		|getcursorcharpos()| 和 |getpos()|。
		首个 "bufnum" 项总为零。而 'col' 项返回的是光标的字节索引位
		置。要得到字符位置，可用 |getcursorcharpos()|。

		可选的 {winid} 参数指定窗口。可以使用窗口号或 |window-ID|。返
		回该窗口上最近已知的光标位置，如果缓冲区的当前光标位置不属于当
		前窗口，可能会非法。如果 {winid} 非法，返回零组成的列表。

		可用于保存和恢复光标位置: >
			let save_cursor = getcurpos()
			移动光标
			call setpos('.', save_cursor)
<		注意 此方法只适用于恢复同一窗口内的位置。要恢复更多状态，见
		|winrestview()|。

		也可用作 |method|: >
			GetWinid()->getcurpos()
<
		返回类型: list<number>


getcursorcharpos([{winid}])				*getcursorcharpos()*
		同 |getcurpos()|，但返回列表中的列号是字符索引而不是字节索引。

		示例:
		如果光标在第三行文本 "여보세요" 的 '보' 时: >
			getcursorcharpos()	返回 [0, 3, 2, 0, 3]
			getcurpos()		返回 [0, 3, 4, 0, 3]
<
		也可用作 |method|: >
			GetWinid()->getcursorcharpos()
<
		返回类型: list<number>


getcwd([{winnr} [, {tabnr}]])				*getcwd()*
		返回当前工作目录名，类型为字符串。此处忽略 'autochdir' 设置。

		{winr} 给出时，则返回当前标签页上指定窗口的本地当前目录。
		{winr} 可为窗口号或 |window-ID|。
		{winr} 为 -1 时，返回全局工作目录名。另见 |haslocaldir()|。

		{winr} 和 {tabnr} 同时给出时，返回指定标签页上指定窗口的本地当
		前目录。{winnr} 为 -1 时，返回指定标签页的当前目录。
		{winr} 为零时，使用当前窗口。{tabnr} 为零时，使用当前标签页。
		无参数时，返回当前窗口的实际工作目录。
		如果参数非法，返回空串。

		示例: >
			" 返回当前窗口的工作目录
			:echo getcwd()
			:echo getcwd(0)
			:echo getcwd(0, 0)
			" 返回标签页 2 上窗口 3 的工作目录
			:echo getcwd(3, 2)
			" 返回全局工作目录
			:echo getcwd(-1)
			" 返回标签页 3 上的工作目录
			:echo getcwd(-1, 3)
			" 返回当前标签页上的工作目录
			:echo getcwd(-1, 0)

<		也可用作 |method|: >
			GetWinnr()->getcwd()
<
		返回类型: |String|


getenv({name})						*getenv()*
		返回环境变量 {name} 的值。参数 {name} 为不带前导 '$' 的字符
		串。
		例如: >
			myHome = getenv('HOME')

<		如果该环境变量不存在，返回 |v:null|。这与值为空串的环境变量不
		同，不过有的系统会把空值解读为已删除的变量。另见 |expr-env|。

		也可用作 |method|: >
			GetVarname()->getenv()
<
		返回类型: |String| 或 |Number|


getfontname([{name}])					*getfontname()*
		无参数时，返回正在使用的 normal 字体名，也就是 Normal 高亮组
		|hl-Normal| 使用的字体名。
		参数 {name} 给出时，检查该字符串是否为合法的字体名。如果不是，
		返回空串。否则，返回实际的字体名，但如果 GUI 不支持取得字符的
		实际名称，返回原始的 {name}。
		仅在 GUI 已启动后才能使用，所以不能在 vimrc 和 gvimrc 文件中调
		用。可通过 |GUIEnter| 自动命令在 GUI 启动完成后使用本函数。
		注意 GTK GUI 接受任何字体名，所以不会检查名字的合法性。

		返回类型: |String|


getfperm({fname})					*getfperm()*
		返回指定文件 {fname} 的读、写与执行权限，类型为字符串。
		如果 {fname} 不存在或者它所在的目录无法读取，返回空串。
		返回值的形式是 "rwxrwxrwx"，三组 "rwx" 标志位分别代表文件所有
		者、文件所属组和其它用户的权限。用户没有某权限时，相应的标志位
		被 "-" 代替。例如: >
			:echo getfperm("/etc/passwd")
			:echo getfperm(expand("~/.vimrc"))
<		理想情况下 (出于安全考虑)，应该显示字符串 "rw-r--r--" 甚至
		"rw-------"。

		也可用作 |method|: >
			GetFilename()->getfperm()
<
		返回类型: |String|

		要设置权限，可用 |setfperm()|。


getfsize({fname})					*getfsize()*
		返回文件 {fname} 以字节数计算的大小，类型为数值。
		如果 {fname} 是目录，返回 0。
		如果文件 {fname} 不存在，返回 -1。
		如果文件 {fname} 过大，超出了 Vim 的数值的范围，返回 -2。

		也可用作 |method|: >
			GetFilename()->getfsize()
<
		返回类型: |Number|


getftime({fname})					*getftime()*
		返回文件 {fname} 的最新修改时间 (从 1970 年 1 月 1 日开始计算
		的秒数)，类型为数值。该值可直接传给 |strftime()| 使用。
		另见 |localtime()| 和 |strftime()|。
		如果文件 {fname} 不存在，返回 -1。

		也可用作 |method|: >
			GetFilename()->getftime()
<
		返回类型: |Number|


getftype({fname})					*getftype()*
		返回文件 {fname} 所属类型的描述，类型为字符串。
		如果文件 {fname} 不存在，返回空串。
		下表列出各种不同文件类型对应的返回值:
			普通文件		"file"
			目录			"dir"
			符号链接		"link"
			块设备			"bdev"
			字符设备		"cdev"
			套接字			"socket"
			FIFO			"fifo"
			其它			"other"
		例如: >
			getftype("/home")
<		注意 只有在系统支持时，才会返回 "link" 这样的类型。有的系统只
		支持 "dir" 和 "file"。MS-Windows 上，目录的符号链接返回 "dir"
		而不是 "link"。

		也可用作 |method|: >
			GetFilename()->getftype()
<
		返回类型: |String|


getimstatus()						*getimstatus()*
		返回数值，IME 状态激活时为 |TRUE|，否则为 |FALSE|。
		参见 'imstatusfunc'。

		返回类型: |Number|


getjumplist([{winnr} [, {tabnr}]])			*getjumplist()*
		返回指定窗口的 |jumplist|。

		无参数时，使用当前窗口。
		只带 {winnr} 时，使用当前标签页上的指定窗口。
		{winnr} 也可以是 |window-ID|。
		{winr} 和 {tabnr} 同时给出时，使用指定标签页上的指定窗口。
		如果 {winnr} 或 {tabnr} 非法，返回空列表。

		返回的列表包含两项: 跳转位置列表，以及在该列表中的最近使用的跳
		转位置号。跳转位置列表中的每一项为位置相关信息的字典，包含以下
		内容:
			bufnr		缓冲区号
			col		列号
			coladd		用于 'virtualedit' 的列偏移
			filename	文件名 (如果存在的话)
			lnum		行号

		也可用作 |method|: >
			GetWinnr()->getjumplist()
<
		返回类型: list<any>


getline({lnum} [, {end}])				*getline()*
		{end} 省略时，返回当前缓冲区中第 {lnum} 行文本，类型为字符串。
		例如: >
			getline(1)
<		{lnum} 是不以数字开始的字符串时，调用 |line()| 将把其转换为数
		值。例如，要得到光标所在的行: >
			getline(".")
<		如果 {lnum} 是小于 1 或者大于缓冲区的总行数的数值，返回空串。

		{end} 给出时，返回当前缓冲区从 {lnum} 行到第 {end} 行 (包含)
		组成的 |List|。
		{end} 的用法 和 {lnum} 相同。
		不存在的行会被安静地忽略。
		如果 {end} 小于 {lnum}，返回空 |List|。
		例如: >
			:let start = line('.')
			:let end = search("^$") - 1
			:let lines = getline(start, end)

<		也可用作 |method|: >
			ComputeLnum()->getline()
<
		返回类型: list<string> 或 |String|，取决于 {end}

		要获取其它缓冲区中的文本行，见 |getbufline()| 和
		|getbufoneline()|。


getloclist({nr} [, {what}])				*getloclist()*
		返回窗口 {nr} 的位置列表中所有项目组成的 |List|。{nr} 可为窗口
		号或 |window-ID|。{nr} 为 0 时，使用当前窗口。

		如果给出的窗口本身是位置列表窗口，返回其中显示的位置列表。如果
		窗口号 {nr} 非法，返回空列表。其它的情形类同于 |getqflist()|。

		可选的 {what} 字典参数给出时，以字典形式返回 {what} 中指定的项
		目。

		{what} 支持的项目参见 |getqflist()|。此外，|getloclist()| 还额
		外支持以下项目:

			filewinid	显示位置列表所指文件的窗口 id。仅当调
					用来自位置列表窗口时，此字段才可用。详
					见 |location-list-file-window|。

		如果窗口 {nr} 没有关联的位置列表，返回带缺省值的
		|Dictionary|。
		如果窗口 {nr} 不存在，返回空字典。

		示例 (另见 |getqflist-examples|): >
			:echo getloclist(3, {'all': 0})
			:echo getloclist(5, {'filewinid': 0})
<
		返回类型: list<dict<any>> 或 list<any> (译者注: 原文如此，应为
		dict<any>)


getmarklist([{buf}])					*getmarklist()*
		{buf} 参数省略时，返回包含全局位置标记信息的 |List|。|mark|

		可选的 {buf} 参数给出时，返回局部于缓冲区 {buf} 的位置标记。
		{buf} 的用法可见 |bufname()|。如果 {buf} 非法，返回空列表。

		返回列表的每个列表项是包含以下内容的 |Dict|:
		    mark   带 "'" 前缀的位置标记名
		    pos    位置标记所在位置，类型为 |List|:
				[bufnum, lnum, col, off]
			   详情请参考 |getpos()|。
		    file   文件名

		要获取特定位置标记的信息，参见 |getpos()|。

		也可用作 |method|: >
			GetBufnr()->getmarklist()
<
		返回类型: list<dict<any>> 或 list<any>


getmatches([{win}])					*getmatches()*
		返回当前窗口中由 |matchadd()| 和 |:match| 命令定义的所有匹配组
		成的 |List|。|getmatches()| 常和 |setmatches()| 组合使用，因为
		|setmatches()| 可以恢复 |getmatches()| 保存的匹配列表。
		{win} 给出时，使用对应此窗口号或窗口 ID 的窗口，而非缺省的当前
		窗口。如果 {win} 非法，返回空列表。
		示例: >
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:let m = getmatches()
			:call clearmatches()
			:echo getmatches()
<			[] >
			:call setmatches(m)
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:unlet m
<
		返回类型: list<dict<any>> 或 list<any>


getmousepos()						*getmousepos()*
		返回鼠标最近已知位置的信息，类型为 |Dictionary|。可用于鼠标点
		击的映射或弹出窗口的过滤。字典包含以下项目:
			screenrow	屏幕行号
			screencol	屏幕列号
			winid		点击位置所在的窗口 ID
			winrow		"winid" 窗口里的行号
			wincol		"winid" 窗口里的列号
			line		"winid" 窗口里的文本行号
			column		"winid" 窗口里的文本列号
			coladd		从点击所在字符的起始位置算起，以屏幕列
					计的偏移量
		所有的数值 (译者注: 除 coladd 以外) 从 1 开始。

		如果鼠标不在任何窗口内 (比如在命令行区域或标签页栏 |tabpanel|
		上)，返回字典里只有 "screenrow" 和 "screencol" 有效，其它的值
		均为零。

		如果鼠标位于窗口下方的状态行上或窗口右侧的垂直分割线上，"line"
		和 "column" 的值为零。

		如果点击位置在某行文本的末尾之后，"column" 会是文本的字节长度
		加一。

		如果鼠标位于弹出窗口上方，将该弹出窗口作为点击所在的窗口。

		使用 |getchar()| 时，Vim 变量 |v:mouse_lnum|、|v:mouse_col| 和
		|v:mouse_winid| 也能提供鼠标位置的相应信息。

		返回类型: dict<number>


getmouseshape()						*getmouseshape()*
		返回当前鼠标指针的外型名。如果不支持 |+mouseshape| 特性或外型
		未知，返回空串。
		本函数主要用于测试。

		返回类型: |String|


getpid()						*getpid()*
		返回 Vim 进程的进程 ID，类型为数值。在 Unix 和 MS-Windows 上，
		该值在 Vim 运行期间保持唯一。

		返回类型: |Number|


getpos({expr})						*getpos()*
		获取字符串 {expr} 对应的位置。
		可接受的位置是:				 *E1209*
		    .	    光标位置。
		    $	    当前缓冲区的最后一行。
		    'x	    位置标记 x 的位置 (如果未设置过该标记，所有的返回
			    值均为 0)。
		    w0	    当前窗口可见部分的首行 (如果显示不刷新，如安静 Ex
			    模式下，则为一)。
		    w$	    当前窗口可见部分的末行 (如果无行可见，则为比 "w0"
			    小一的值)。
		    v       不处于可视模式时，表示光标位置。处于可视模式时，则
			    表示可视区域的另一端。一个直观的理解方法是，在可视
			    模式下，"v" 和 ".": 总是互补。"." 指向光标位置，而
			    "v" 指向 |v_o| 会将光标移动到的位置。所以，可用
			    "v" 和 "." 组合进行面向字符的可视模式的各种选区操
			    作。如果光标在面向字符可视区域的结尾，"v" 就指向相
			    同可视区域的起点。而如果光标在面向字符可视区域的起
			    点，"v" 就指向相同可视区域的结尾。"v" 和 |'<| 及
			    |'>| 的不同之处是 "v" 会被即时更新。
		注意 可以使用属于其它文件的位置标记。此时返回的位置属于该标记
		所在的缓冲区。

		返回值为包含四个数值的 |List|:
		    [bufnum, lnum, col, off]
		"bufnum" 通常为零，但如果使用了 '0 或 'A 这类全局位置标记，则
		其值为该位置标记所在的缓冲区号。
		"lnum" 和 "col" 对应缓冲区里的行列位置。首列列号为 1。
		"off" 值通常为零，但如果使用了 'virtualedit'，则其值为从对应字
		符的起始位置算起以屏幕列为单位的偏移量。例如，在制表符的内部或
		在一行文本的末尾之后，该值会为非零。

		要获取光标位置，见 |getcurpos()|。
		返回值列表中的列号是行内的字节位置。要得到行内的字符位置，可用
		|getcharpos()|。

		注意 '< 和 '> 的值和可视模式有关: 当使用 "V" (可视行模式) 时，
		'< 的列号为零，而 '> 的列号是等于 |v:maxcol| 的极大数。
		等于 |v:maxcol| 的极大值用来表示 "在行尾之后"。
		{expr} 如非法，返回全零组成的列表。

		本函数可用来保存和恢复位置标记的位置: >
			let save_a_mark = getpos("'a")
			...
			call setpos("'a", save_a_mark)
<
		另见 |getcharpos()|、|getcurpos()| 和 |setpos()|。

		也可用作 |method|: >
			GetMark()->getpos()
<
		返回类型: list<number>


getqflist([{what}])					*getqflist()*
		返回所有当前快速修复错误组成的 |List|。每个列表项是包含以下项
		目的字典:
			bufnr	与该文件名对应的缓冲区编号，可用 |bufname()|
				获取相应的缓冲区名
			module	果模块名
			lnum	缓冲区里的行号 (首行行号为 1)
			end_lnum
				多行项目的末行行号
			col	列号 (首列列号为 1)
			end_col	范围项目的末列列号
			vcol	|TRUE|: "col" 对应的是可视列
				|FALSE|: "col" 对应的是字节索引
			nr	错误号
			pattern	用于定位错误的搜索模式
			text	错误描述
			type	错误类型，如 'E'、'1' 等。
			valid	|TRUE|: 该错误信息能被识别
			user_data
				和项目关联的定制数据，可为任何类型。

		错误列表如果不存在或者为空，返回空列表。如果快速修复列表项不对
		应合法的缓冲区，则其 "bufnr" 值为零 (注意 有些函数中，缓冲区号
		为零代表轮换缓冲区，为了区别，可能需要显式检查零值)。

		应用: 在多个文件里搜索指定模式的匹配，并对匹配项进行处理: >
			:vimgrep /theword/jg *.c
			:for d in getqflist()
			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text
			:endfor
<
		可选的 {what} 字典参数给出时，以字典形式返回 {what} 中指定的项
		目。{what} 支持以下字符串条目:
			changedtick	|quickfix-changedtick| 记录列表被修改
					的总次数
			context	获取 |quickfix-context|
			efm	解析 "lines" 时使用的 errorformat。缺省使用
				'errorformat' 选项值。
			id	获取对应给定标识符 |quickfix-ID| 的快速修复列
				表的相关信息。零代表当前列表或 "nr" 指定的列表
			idx	获取由 'id' 或 'nr' 指定的快速修复列表中，此索
				引指定的项目信息。如果设为零，使用当前项目。
				见 |quickfix-index|
			items	获取快速修复列表的所有项目
			lines	用 'efm' 解析给出的文本行列表，并返回生成的项
				目。值只支持 |List| 类型。不修改当前快速修复列
				表。见 |quickfix-parse|。
			nr	获取对应指定编号的快速修复列表的信息；零代表当
				前快速修复列表，"$" 代表最后一个快速修复列表
			qfbufnr 快速修复窗口所显示的缓冲区号。如果快速修复缓冲
				区不存在，返回 0。见 |quickfix-buffer|。
			size	本快速修复列表的项目总数
			title	获取列表标题 |quickfix-title|
			winid	获取快速修复的窗口 ID |window-ID|
			all	上述所有的快速修复属性
		使用 {what} 参数时，忽略其中非字符串类型的条目。要获取某个特定
		项之值，需先将该值初始化为零。
		"nr" 省略时，使用当前快速修复列表。
		"nr" 和非零 "id" 同时给出时，优先使用 "id" 指定的列表。
		要取得快速修复栈的列表总数，设置 {what} 中的 'nr' 为 "$"。这
		样，返回字典中的 "nr" 值即表示快速修复栈的大小。
		"lines" 给出时，忽略除了 "efm" 之外的其它条目。返回的字典中会
		包含 "items" 项，其值包含所有已解析完成的项目组成的列表。

		返回值为字典，包含以下条目:
			changedtick	|quickfix-changedtick| 记录列表被修改
					的总次数
			context	快速修复列表的上下文，见 |quickfix-context|
				如果不存在，设为 ""。
			id	快速修复列表 ID |quickfix-ID|。如果不存在，设
				为 0。
			idx	快速修复列表中的项目索引。如果不存在，设为 0。
			items	快速修复列表的所有项目。如果不存在，设为空列
				表。
			nr	快速修复列表的列表号。如果不存在，设为 0
			qfbufnr 快速修复窗口所显示的缓冲区号。如果不存在，设为
				0。
			size	快速修复列表的项目总数。如果不存在，设为 0。
			title	快速修复列表标题文本。如果不存在，设为 ""。
			winid	快速修复的窗口 ID |window-ID|。如果不存在，设
				为 0

		(译者注: getqflist() 大致相当于 getqflist({'items':0}.items )
		示例 (另见 |getqflist-examples|): >
			:echo getqflist({'all': 1})
			:echo getqflist({'nr': 2, 'title': 1})
			:echo getqflist({'lines' : ["F1:10:L10"]})
<
		返回类型: list<dict<any>> 或 list<any> (译者注: 原文如此，应为
		dict<any>)



getreg([{regname} [, 1 [, {list}]]])			*getreg()*
		返回寄存器 {regname} 的内容，类型为字符串。例如: >
			:let cliptext = getreg('*')
<		如果未设置过 {regname} 对应的寄存器，返回空串。
		{regname} 参数必须为字符串。 *E1162*

		getreg('=') 会返回表达式寄存器最近一次计算的结果 (可在映射中使
		用)。
		getreg('=', 1) 则会返回表达式自身而非计算结果，以便将来用
		|setreg()| 恢复该寄存器的内容。对于其它寄存器，此额外参数被忽
		略，所以给出此参数也无妨。

		{list} 给出且为 |TRUE| 时，返回列表而非字符串。每个列表项对应
		寄存器内容的一行文本。如果寄存器内容里可能包含零字节，这种形式
		会比较安全: 而如果不给出第三个参数，返回字符串，并且 NL 和零字
		节都会用 NL (换行符) 表示 (见 |NL-used-for-Nul|)。
		如果未设置过 {regname} 对应的寄存器，返回空列表。

		{regname} 为 "" 时，使用无名寄存器 '"'。
		{regname} 省略时，使用 |v:register|。
		|Vim9-script| 中，{regname} 必须为单个字符。

		也可用作 |method|: >
			GetRegname()->getreg()
<
		返回类型: |String| 或 list<string>，取决于 {list}


getreginfo([{regname}])					*getreginfo()*
		返回字典，包含寄存器 {regname} 的详细信息。包含以下条目:
			regcontents	寄存器 {regname} 内容行组成的列表，相
					当于 |getreg|({regname}, 1, 1)。
			regtype		寄存器 {regname} 的类型，见
					|getregtype()|。
			isunnamed	布尔标志位，当前无名寄存器指向此寄存器
					时为 v:true。
			points_to	用于无名寄存器，给出其当前指向的寄存器
					的单字母名 (见 |quotequote|)。例如，用
					`dd` 删除一行后，此字段设为 "1"，也就
					是包含最近删除文本的寄存器。

		{regname} 参数为字符串。如果 {regname} 非法或未设置过对应的寄
		存器，返回空列表。
		{regname} 为 "" 或 "@" 时，使用无名寄存器 '"'。
		{regname} 省略时，使用 |v:register|。
		返回的字典可作为参数，直接传递给 |setreg()|。
		|Vim9-script| 中，{regname} 必须为单个字符。

		也可用作 |method|: >
			GetRegname()->getreginfo()
<
		返回类型: dict<any>


getregion({pos1}, {pos2} [, {opts}])			*getregion()*
		返回缓冲区从 {pos1} 到 {pos2} 位置的文本行字符串列表。

		{pos1} 和 {pos2} 必须为带四个数值的 |List|。列表格式可见
		|getpos()|。可以指定另一缓冲区的位置，但请先查看
		|getregion-notes| 的限制说明。

		可选参数 {opts} 是支持以下项目的字典:

			type		指定区域的选择类型。可用值见
					|getregtype()|，但其中的宽度可以省略，
					且不能用空串。
					(缺省: "v")

			exclusive	结束位置为开的则为 |TRUE|。
					(缺省: 使用 'selection' 选项值)

		|visualmode()| 可用来获取最近的选择类型。可视模式当前激活时，
		|mode()| 可用来获取当前的可视模式 (例如可在 |:vmap| 里使用)。
		本函数可用于通过 |characterwise-visual| 这种开始和结束位置可能
		处于不同列的选择方式来获取文本。

							*getregion-notes*
		请注意:
		- {pos1} 和 {pos2} 的先后顺序无关紧要。总是返回从左上角到右下
		  角的内容。
		- 'virtualedit' 打开时，区域会跨越行尾，生成的行会以空格填充。
		- 区域为面向列块模式时，如果开始或结束位置位于多单元字符中间
		  时，不包括该多单元字符，选中的部分以空格代替。
		- 如果  {pos1} 和 {pos2} 不处于同一缓冲区，返回空列表。
		- {pos1} 和 {pos2} 必须属于 |bufloaded()| 的缓冲区。
		- 计算在当前窗口上下文下进行，如果缓冲区在不同的 'virtualedit'
		  或 'list' 设置的其它窗口中显示，结果可能不一致。
		- 指定开区间的选择区，但 {pos1} 和 {pos2} 相同时，返回包含单个
		  字符的列表，就像选择区是闭区间那样，这与可视模式下处理空的开
		  选择区的方式相同。

		示例: >
			:xnoremap <CR>
			\ <Cmd>echow getregion(
			\ getpos('v'), getpos('.'), #{ type: mode() })<CR>
<
		也可用作 |method|: >
			getpos('.')->getregion(getpos("'a"))
<
		返回类型: list<string>


getregionpos({pos1}, {pos2} [, {opts}])			*getregionpos()*
		和 |getregion()| 类同，但返回 {pos1} 和 {pos2} 定界的缓冲区文
		本片段对应位置的列表。
		每个片段表示一行上中的一个位置对: >
			[[{start_pos}, {end_pos}], ...]
<
		位置是包含四个数值的 |List|:
		    [bufnum, lnum, col, off]
		"bufnum" 为缓冲区号。
		"lnum" 和 "col" 对应缓冲区里的行列位置。首列列号为 1。
		起始位置的 "off" 值如果非零，指定从字符的起始位置算起以屏幕列
		为单位的偏移量。如 <Tab> 的内部和一行文本的末尾之后，该值会为
		非零。类似地，结束位置的 "off" 值如果非零，指定该字符的首个不
		在选择区的屏幕单元偏移量，否则，该字符的所有单元都在选择区内。

		除了 |getregion()| 支持的选项以外，{opts} 还支持下列值:

			eol		|TRUE| 代表 "col" 用行长加一来指示行尾
					之后的位置。
					|FALSE| 代表位置被局限在行范围内，对空
					行或选择区完全在行尾之后，两个位置的
					"col" 都使用 0 值。
					(缺省: |FALSE|)

		也可用作 |method|: >
			getpos('.')->getregionpos(getpos("'a"))
<
		示例可见高亮-抽出插件 |52.6|

		返回类型: list<list<list<number>>>


getregtype([{regname}])					*getregtype()*
		返回寄存器 {regname} 的类型，返回类型是字符串。
		可能值是:
		    "v"			|characterwise| (面向字符) 的文本
		    "V"			|linewise| (面向行) 的文本
		    "<CTRL-V>{width}"	|blockwise-visual| (面向列块) 的文本
		    ""			空或者未知的寄存器
		<CTRL-V> 是单个字符，其值为 0x16。
		{regname} 参数为字符串。
		{regname} 为 "" 时，使用无名寄存器 '"'。
		{regname} 省略时，使用 |v:register|。
		|Vim9-script| 中，{regname} 必须为单个字符。

		也可用作 |method|: >
			GetRegname()->getregtype()
<
		返回类型: |String|


getscriptinfo([{opts}])					*getscriptinfo()*
		返回包含所有已执行的 Vim 脚本的信息列表，依执行时间的顺序排
		列，类似于 `:scriptnames` 显示的结果。

		可选的字典参数 {opts} 支持以下可选项目:
		    name	匹配脚本名的模式。指定此项目而不指定 "sid"
				时，返回名字匹配 "name" 模式的脚本的信息。
		    sid		脚本 ID |<SID>|。指定此项目时，只返回 ID 为
				"sid" 的脚本的信息，忽略 "name" 项目。

		返回列表中的每个列表项是包含以下项目的 |Dict|:
		    autoload	脚本用 `import autoload` 载入但尚未真正执行则
				为真 (见 |import-autoload|)。
		    functions   在脚本中定义的局部于本脚本的函数名列表。仅当
				{opts} 中用 "sid" 项目指定了特定脚本时，此项目
				上才会出现。
		    name	Vim 脚本文件名。
		    sid		脚本 ID |<SID>|。
		    sourced	脚本如为链接，链接到的实际执行脚本的脚本 ID。
				否则为零。
		    variables   在脚本中定义的局部于本脚本的变量列表。仅当
				{opts} 中用 "sid" 项目指定了特定脚本时，此项目
				才会出现。
				注意 这是备份，不可用此字典来修改脚本局部变量
				的值。
		    version	Vim 脚本版本号 (|scriptversion|)

		示例: >
			:echo getscriptinfo({'name': 'myscript'})
			:echo getscriptinfo({'sid': 15})[0].variables
<
		返回类型: list<dict<any>>


getstacktrace()						*getstacktrace()*
		返回 Vim 脚本的当前栈追踪。
		栈追踪是列表，其中每个列表项为包含以下项目的 |Dictionary|:
		    funcref	堆栈位于函数内时，该函数的引用，否则省略此项。
		    event	堆栈位于自动命令事件内时，对应事件的描述字符
				串，否则省略此项。
		    lnum	堆栈在脚本中的行号。
		    filepath	堆栈在脚本中的文件路径。

		返回类型: list<dict<any>>


gettabinfo([{tabnr}])					*gettabinfo()*
		{tabnr} 省略时，返回包含所有标签页信息的 |List|。每个列表项是
		如下所述的 |Dictionary|。否则，{tabnr} 指定标签页号，返回一个
		仅含该标签页相关信息的单元素列表。如果该标签页不存在，返回空列
		表。

		每个列表项是包含以下项目的 |Dictionary|:
			tabnr		标签页号
			variables	一个指向该标签页局部变量字典的引用
			windows		标签页中所有 |window-ID| 的列表。

		也可用作 |method|: >
			GetTabnr()->gettabinfo()
<
		返回类型: list<dict<any>>


gettabvar({tabnr}, {varname} [, {def}])			*gettabvar()*
		获取局部于标签页 {tabnr} 的名为 {varname} 的变量值。|t:var|
		标签页的编号从一开始。
		{varname} 参数为字符串。{varname} 为空时，返回包含该标签页里所
		有标签页局部变量的字典。
		注意 这里必须使用不带 "t:" 前缀的变量名。
		如果指定的标签页或者变量不存在，返回 {def} (默认为空串)。不会
		有错误消息。

		也可用作 |method|: >
			GetTabnr()->gettabvar(varname)
<
		返回类型: any，取决于 {varname}


gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])	*gettabwinvar()*
		得到标签页 {tabnr} 里局部于窗口 {winnr} 的名为 {varname} 的变
		量值。
		{varname} 参数为字符串。{varname} 为空时，返回包含该窗口里所有
		窗口局部变量的字典。
		{varname} 为 "&" 时，返回包含该窗口里所有窗口局部选项的
		|Dictionary|。
		否则，以 "&" 开头 的 {varname} 会返回对应的窗口局部选项值。
		注意 {varname} 必须为不带 "w:" 前缀的变量名。
		标签页的编号从一开始。对于当前标签页，可用 |getwinvar()| 来获
		取对应的窗口变量。
		{winnr} 可为窗口号或 |window-ID|。
		{winnr} 为零时，使用当前窗口。
		也可用于全局选项、缓冲区局部选项和窗口局部选项，但不能用于全局
		变量或者缓冲区局部变量。
		如果指定的标签页、窗口或者变量不存在，返回 {def} (默认为空
		串)。不会有错误消息。
		例如: >
			:let list_is_on = gettabwinvar(1, 2, '&list')
			:echo "myvar = " .. gettabwinvar(3, 1, 'myvar')
<
		要得到指定窗口里所有的窗口局部变量，可用: >
			gettabwinvar({tabnr}, {winnr}, '&')

<		也可用作 |method|: >
			GetTabnr()->gettabwinvar(winnr, varname)
<
		返回类型: any，取决于 {varname}


gettagstack([{winnr}])					*gettagstack()*
		返回窗口 {winnr} 的标签栈，类型为字典。
		{winnr} 可为窗口号或 |window-ID|。
		{winnr} 省略时，使用当前窗口。
		如果窗口 {winnr} 不存在，返回空字典。

		返回字典包含如下项目:
			curidx		栈的当前索引。栈顶为 (length + 1)。栈
					底为 1。
			items		栈项目的列表。每个列表项是字典，见下。
			length		栈项目的总数。

		栈中的每个项目是包含以下条目的字典:
			bufnr		当前跳转所在的缓冲区号
			from		标签跳转之前所在的光标位置。|getpos()|
					说明返回列表的格式。
			matchnr		当前的匹配标签编号。用于同一名字有多个
					匹配标签的情形。
			tagname		标签名

		|tagstack| 说明标签栈的更多信息。

		也可用作 |method|: >
			GetWinnr()->gettagstack()
<
		返回类型: dict<any>


gettext({text} [, {package}])				*gettext()*
		对字符串 {text} 进行翻译。
		用于 Vim 脚本。要生成消息翻译时，由 `xgettext` 对 {text} 进行
		提取，翻译者会把翻译后的消息加到 .po 文件，调用 gettext() 时，
		Vim 会依此查找翻译内容。
		{text} 推荐使用双引号括起，因为 `xgettext` 不理解单引号字符串
		里的转义。

		给出 {package} 时，只寻找特定于该包的翻译。主要用于第三方 Vim
		脚本。需要在使用 gettext() 函数前先用 |bindtextdomain()| 来指
		定翻译所在的路径。

		返回类型: |String|


getwininfo([{winid}])					*getwininfo()*
		返回窗口信息，返回值是字典的 |List|。

		{winid} 给出时，返回一个仅含指定窗口 ID 对应的窗口的信息的单元
		素 |List|。窗口是 |popup| 窗口时，返回该弹出窗口的信息。如果窗
		口不存在，返回空列表。

		{winid} 省略时，返回所有标签页中所有窗口 (但不包括 |popup| 窗
		口) 的信息。

		每个列表项是包含以下条目的 |Dictionary|:
			botline		最后一行完整显示的缓冲区行号
			bufnr		窗口中显示的缓冲区号
			height		窗口高度 (窗口工具条 winbar 不计算在
					内)
			leftcol		显示的首列列号；仅用于 'wrap' 关闭时
			loclist		显示位置列表时为 1
					{仅当加入 |+quickfix| 特性才有效}
			quickfix	快速修复或位置列表窗口则为 1
					{仅当加入 |+quickfix| 特性才有效}
			status_height	状态行高度 (0 或 1)
			tabnr		标签页号
			terminal	终端窗口则为 1
					{仅当加入 |+terminal| 特性才有效}
			textoff		文本前由 'foldcolumn'、'signcolumn' 和
					行号所占据的列数
			topline		窗口中显示的首行缓冲区行号
			variables	一个指向该窗口局部变量字典的引用
			width		窗口宽度
			winbar		窗口有工具条时为 1，反之为 0
			wincol		窗口最左侧的屏幕列号，相当于
					|win_screenpos()| 中的 "col"
			winid		|window-ID|
			winnr		窗口号
			winrow		窗口最顶侧的屏幕行号，相当于
					|win_screenpos()| 中的 "row"

		也可用作 |method|: >
			GetWinnr()->getwininfo()
<
		返回类型: list<dict<any>>


getwinpos([{timeout}])					*getwinpos()*
		返回两个数值组成的 |List|，相当于 |getwinposx()| 和
		|getwinposy()| 返回值的混合:
			[x-pos, y-pos]
		{timeout} 可指定以毫秒为单位的等待终端反馈的超时。默认为 100
		毫秒。对于远程终端，可考虑更长的超时。
		如果取值小于 10 且在指定时限内没有收到反馈，返回上次已有的报告
		位置。可用于在轮询位置信息的同时执行其他并发操作: >
			while 1
			  let res = getwinpos(1)
			  if res[0] >= 0
			    break
			  endif
			  " 干些话
			endwhile
<

		也可用作 |method|: >
			GetTimeout()->getwinpos()
<
		返回类型: list<number>


getwinposx()						*getwinposx()*
		返回 GUI Vim 窗口左侧的 X 坐标 (以像素为单位)，类型为数值。也
		适用于 xterm (使用 100 毫秒超时)。
		如果无法取得该信息 (例如在 Wayland 后台上)，返回 -1。
		返回值可用于 `:winpos`。

		返回类型: |Number|


getwinposy()						*getwinposy()*
		返回 GUI Vim 窗口顶部的 Y 坐标 (以像素为单位)，类型为数值。也
		适用于 xterm (使用 100 毫秒超时)。
		如果无法取得该信息 (例如在 Wayland 后台上)，返回 -1。
		返回值可用于 `:winpos`。

		返回类型: |Number|


getwinvar({winnr}, {varname} [, {def}])			*getwinvar()*
		和 |gettabwinvar()| 类同，但只用当前标签页。
		例如: >
			:let list_is_on = getwinvar(2, '&list')
			:echo "myvar = " .. getwinvar(1, 'myvar')

<		也可用作 |method|: >
			GetWinnr()->getwinvar(varname)
<
		返回类型: any，取决于 {varname}


glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])	*glob()*
		扩展 {expr} 里的文件通配符。|wildcards| 说明其中特殊字符的使用
		方法。

		除非可选的 {nosuf} 参数给出且为 |TRUE|，否则会应用 'suffixes'
		和 'wildignore' 选项: 跳过匹配任何 'wildignore' 模式的名字，而
		'suffixes' 会影响匹配结果的排序方式。
		'wildignorecase' 则始终生效。

		{list} 给出且为 |TRUE| 时，返回包含所有匹配文件的 |List|。使用
		列表的优点是可以正确处理包含换行符的文件名。
		否则返回的是字符串，有多个匹配项时，各项之间以 <NL> 字符分隔。

		如果扩展失败，返回空串或空列表。

		如果需要进行更复杂的操作，例如限制匹配项的数目，可以考虑
		|readdir()| 。

		扩展结果不包含不存在的文件句。符号链接只有在指向已存在的文件时
		才会包含在扩展结果内。但 {alllinks} 参数给出且为 |TRUE| 时，所
		有符号链接都会被包含。

		多数系统上，可以用反引号来执行外部命令，并将其输出作为文件名。
		例如: >
			:let tagfiles = glob("`find . -name tags -print`")
			:let &tags = substitute(tagfiles, "\n", ",", "g")
<		反引号包围的程序的输出结果必须每项一行。每项的内部可以包含空
		格。

		|expand()| 说明如何扩展特殊 Vim 变量。|system()| 说明如何获取
		外部命令的原始输出。

		也可用作 |method|: >
			GetExpr()->glob()
<
		返回类型: |String| 或 list<string> 或 list<any>，取决于 {list}


glob2regpat({string})					 *glob2regpat()*
		将 |glob()| 所用的文件模式转换为搜索模式。结果可用来匹配包含文
		件名的字符串。例如 >
			if filename =~ glob2regpat('Make*.mak')
<		等价于: >
			if filename =~ '^Make.*\.mak$'
<		{string} 为空串时，返回 "^$"，用于匹配空串。
		备注 结果与所用系统有关。MS-Windows 上反斜杠通常用作路径分隔
		符。

		也可用作 |method|: >
			GetExpr()->glob2regpat()
<
		返回类型: |String|

							*globpath()*
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
		在 {path} 的所有目录下，用 |glob()| 扩展字符串 {expr}，并连接
		所有的返回结果。例如: >
			:echo globpath(&rtp, "syntax/c.vim")
<
		{path} 是由逗号分隔的目录名列表。每个目录名会附加在 {expr} 之
		前，然后如同 |glob()| 那样被扩展。必要的话，会自动插入路径分隔
		符。
		如果目录名中需要包含逗号，可用反斜杠转义。注意 在 MS-Windows
		上，目录名结尾可能带有反斜杠。如果要在后面加上逗号进行分隔，先
		去掉结尾的反斜杠。
		如果某个目录对应的扩展失败，不会有错误信息。

		除非可选的 {nosuf} 参数给出且为 |TRUE|，否则会应用 'suffixes'
		和 'wildignore' 选项: 跳过匹配任何 'wildignore' 模式的名字，而
		'suffixes' 影响匹配结果的排序方式。

		{list} 给出且为 |TRUE| 时，返回包含所有匹配文件的列表。列表的
		优点是可以正确处理包含换行符的文件名，
		否则返回的是字符串，有多个匹配项时，各项之间以 <NL> 字符分隔。
		例如: >
			:echo globpath(&rtp, "syntax/c.vim", 0, 1)
<
		{alllinks} 的用法可见 |glob()|。

		可以用 "**" 项目在目录树里进行搜索。例如，要在 'runtimepath'
		和其下所有目录里查找 "README.txt" 文件: >
			:echo globpath(&rtp, "**/README.txt")
<		不支持向上搜索和 "**" 的深度限制，所以 'path' 的各种用法不一定
		总能正确工作。

		也可用作 |method|，基是作为第二个参数传递的: >
			GetExpr()->globpath(&rtp)
<
		返回类型: |String| 或 list<string> 或 list<any>，取决于 {list}


has({feature} [, {check}])				*has()*
		{check} 省略或为零时: 如果支持特性 {feature}，返回 1，否则返回
		零，类型为数值。{feature} 参数是不区分大小写的字符串。见下面的
		|feature-list|。

		{check} 给出且非零时: 如果特性 {feature} 可以支持，返回 1，否
		则返回零，类型为数值。可用于检查 {feature} 是否有拼写错误，也
		可用于检测死代码。需要注意，旧版本的 Vim 不识别新加入的特性，
		而当前版本的 Vim 也不会识别已废弃的特性。

		另见 |exists()| 和 |exists_compiled()|。

		注意 如果某特性不可用，相应的代码可能会有语法错误，Vim 可能会
		跳过该行的其余部分，从而导致其中后续的 `endif` 被忽略。因此，
		建议让 `endif` 单起一行: >
			if has('feature')
			  let x = this->breaks->without->the->feature
			endif
<		如果将 `endif` 移到第二行而成为 "| endif"，它不会被识别到。

		返回类型: |Number|


has_key({dict}, {key})					*has_key()*
		|Dictionary| {dict} 里存在键为 {key} 的项目时返回 TRUE，不然返
		回 FALSE，类型为数值。
		{key} 参数是字符串。|Vim9| 脚本中也接受数值 (并转换为字符串)，
		不接受其它类型。而老式脚本中，所有类型都会自动转换为字符串。

		也可用作 |method|: >
			mydict->has_key(key)
<
		返回类型: |Number|


haslocaldir([{winnr} [, {tabnr}]])			*haslocaldir()*
		返回数值:
		    1   窗口用 |:lcd| 设置过局部目录时
		    2   标签页用 |:tcd| 设置过局部目录时
		    0   其它。

		无参数时使用当前窗口。
		有 {winr} 时，使用当前标签页的指定窗口。
		同时有 {winr} 和 {tabnr} 时，使用指定标签页的指定窗口。
		{winr} 可为窗口号或 |window-ID|。
		{winnr} 为 -1 时，它被忽略，只使用标签页。
		如果参数非法，返回 0。
		示例: >
			if haslocaldir() == 1
			  " 窗口局部目录的情况
			elseif haslocaldir() == 2
			  " 标签页局部目录的情况
			else
			  " 全局目录的情况
			endif

			" 当前窗口
			:echo haslocaldir()
			:echo haslocaldir(0)
			:echo haslocaldir(0, 0)
			" 当前标签页的窗口 n
			:echo haslocaldir(n)
			:echo haslocaldir(n, 0)
			" 标签页 m 的窗口 n
			:echo haslocaldir(n, m)
			" 标签页 m
			:echo haslocaldir(-1, m)
<
		也可用作 |method|: >
			GetWinnr()->haslocaldir()
<
		返回类型: |Number|


hasmapto({what} [, {mode} [, {abbr}]])			*hasmapto()*
		返回数值，当存在一个映射，其右侧表达式 (被映射到的部分) 的某个
		位置包含 {what}，并且该映射在 {mode} 指定的模式下有效时，返回
		TRUE。
		参数 {what} 和 {mode} 为字符串。
		{abbr} 给出且为 |TRUE| 时，使用缩写而不是映射。不要忘记指定插
		入和/或命令行模式。
		寻找匹配时，同时检查全局映射和局部于当前缓冲区的映射。
		如果没有匹配的映射，返回 FALSE。
		{mode} 识别下列字符:
			n	普通模式
			v	可视和选择模式
			x	可视模式
			s	选择模式
			o	操作符等待模式
			i	插入模式
			l	Language-Argument ("r"、"f"、"t" 等等) 模式
			c	命令行模式
		{mode} 省略时，使用 "nvo"。

		该函数可用于在脚本中检查是否存在使用了特定函数的映射。例如: >
			:if !hasmapto('\ABCdoit')
			:   map <Leader>d \ABCdoit
			:endif
<		这里，只有当指向 "\ABCdoit" 的映射还不存在时，才会创建该映射。

		也可用作 |method|: >
			GetRHS()->hasmapto()
<
		返回类型: |Number|


histadd({history}, {item})				*histadd()*
		把字符串 {item} 加入历史 {history}。后者可以是:
							*hist-names*
			"cmd"	 或 ":"	  命令行历史
			"search" 或 "/"   搜索模式历史
			"expr"   或 "="   输入表达式历史
			"input"  或 "@"	  输入行历史
			"debug"  或 ">"   调试命令历史
			空		  当前或最后使用的历史
		{history} 字符串无须是完整名字，一个字符即可。
		如果 {item} 已存在于历史中，它会被移动到最新的位置。
		返回数值: 操作成功时返回 TRUE，否则返回 FALSE。

		例如: >
			:call histadd("input", strftime("%Y %b %d"))
			:let date=input("Enter date: ")
<		该函数在沙盘里不可用 |sandbox|。

		也可用作 |method|，基是作为第二个参数传递的: >
			GetHistory()->histadd('search')
<
		返回类型: |Number|


histdel({history} [, {item}])				*histdel()*
		清除 {history}，换而言之，删除它所有的项目。|hist-names| 说明
		{history} 所有的可能值。

		{item} 计算结果为字符串时，它被看作正则表达式。从历史里删除所
		有匹配该模式的项目 (如果有的话)。
		除非使用 "\c" |/\c|，否则必须匹配大小写。
		{item} 的计算结果为数值时，它被解释为索引值，见
		|:history-indexing|。删除相应的项目 (如果有的话)。

		返回结果为数值: 操作成功时为 TRUE，否则返回 FALSE。

		例如:
		清除表达式寄存器历史: >
			:call histdel("expr")
<
		删除所有 "*" 开始的搜索历史: >
			:call histdel("/", '^\*')
<
		下面三者是等价的: >
			:call histdel("search", histnr("search"))
			:call histdel("search", -1)
			:call histdel("search", '^' .. histget("search", -1) .. '$')
<
		要删除最近的搜索模式，从而使 "n" 命令和 'hlsearch' 使用倒数第
		二个模式: >
			:call histdel("search", -1)
			:let @/ = histget("search", -1)
<
		也可用作 |method|: >
			GetHistory()->histdel()
<
		返回类型: |Number|


histget({history} [, {index}])				*histget()*
		返回历史 {history} 里的第 {index} 项内容，类型为字符串。
		|hist-names| 说明 {history} 所有的可能值，而
		|:history-indexing| 说明 {index} 的用法。
		如果相应项目不存在，返回空串。
		{index} 省略时，返回历史里最近使用的项目。

		例如:
		重做历史里的倒数第二个搜索。 >
			:execute '/' .. histget("search", -2)

<		定义 Ex 命令 ":H {num}"，以重新执行 |:history| 输出的第 {num}
		项命令。 >
			:command -nargs=1 H execute histget("cmd", 0+<args>)
<
		也可用作 |method|: >
			GetHistory()->histget()
<
		返回类型: |String|


histnr({history})					*histnr()*
		返回 {history} 里当前项目的编号。|hist-names| 说明 {history}
		所有的可能值。
		如果有错，返回 -1。

		例如: >
			:let inp_index = histnr("expr")

<		也可用作 |method|: >
			GetHistory()->histnr()
<
		返回类型: |Number|


hlID({name})						*hlID()*
		返回名为 {name} 的高亮组的 ID。如果该高亮组不存在，返回零。
		可用于提取高亮组的信息。比如，要得到 "Comment" 组的背景颜色: >
	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")
<							*highlightID()*
		已废弃的名字: highlightID()。

		也可用作 |method|: >
			GetName()->hlID()
<
		返回类型: |Number|


hlexists({name})					*hlexists()*
		名为 {name} 的高亮组存在时返回 TRUE。该组不必包含任何具体的高
		亮设置，只要定义过即可。一些语法项目可能已经引用了该组。
							*highlight_exists()*
		已废弃的名字: highlight_exists()。

		也可用作 |method|: >
			GetName()->hlexists()
<
		返回类型: |Number|


hlget([{name} [, {resolve}]])				*hlget()*
		返回包含所有高亮组属性的列表。可选的 {name} 给出时，只返回指定
		高亮组的属性的列表。如果高亮组 {name} 不存在，返回空列表。

		可选的 {resolve} 参数设为 v:true 而且高亮组 {name} 链接到另一
		个组时，会递归解析链接并返回最终目标高亮组的属性。

		返回列表里的每个列表项是包含以下条目的字典:
			cleared	布尔型标志位，高亮组属性被清除或还未指定时设为
				v:true。见 |highlight-clear|。
			cterm	cterm 属性。见 |highlight-cterm|。
			ctermbg	cterm 背景色。见 |highlight-ctermbg|。
			ctermfg	cterm 前景色。见 |highlight-ctermfg|。
			ctermul	cterm 下划线颜色。见 |highlight-ctermul|。
			default	布尔型标志位，高亮组链接是缺省链接时设为
				v:true。见 |highlight-default|。
			font	高亮组字体。见 |highlight-font|。
			gui	gui 属性。见 |highlight-gui|。
			guibg	gui 背景色。见 |highlight-guibg|。
			guifg	gui 前景色。见 |highlight-guifg|。
			guisp	gui 特殊颜色。见 |highlight-guisp|。
			id	高亮组 ID。
			linksto	链接目标高亮组名。见 |:highlight-link|。
			name	高亮组名。见 |group-name|。
			start	start 终端转义码。见 |highlight-start|。
			stop	stop 终端转义码。见 |highlight-stop|。
			term	终端属性。见 |highlight-term|。

		上述字典里的 'term'、'cterm' 和 'gui' 项目本身为字典，包含以下
		可选布尔型项目: 'bold'、'standout'、'underline'、'undercurl'、
		'italic'、'reverse'、'inverse' 和 'strikethrough'。

		示例: >
			:echo hlget()
			:echo hlget('ModeMsg')
			:echo hlget('Number', v:true)
<
		也可用作 |method|: >
			GetName()->hlget()
<
		返回类型: list<dict<any>>


hlset({list})						*hlset()*
		建立或修改一组高亮组的属性。{list} 中的每个列表项对应一个高亮
		组的属性字典。

		此字典支持的条目列表见 |hlget|。除此以外，此字典还支持以下附加
		条目:

			force		布尔型标志位，为真时强制为带属性的已有
					高亮组建立链接。

		'name' 条目指定高亮组名，而忽略 'id' 条目 (如有提供)。如果指定
		名字的高亮组不存在，建立之。否则，修改该已有高亮组的属性。

		'term'、'cterm' 或 'gui' 条目指定空字典时，清除对应的属性。
		'cleared' 条目设为 v:true 时，清除高亮组的所有属性。

		'linksto' 条目可用来链接一个高亮组到另一高亮组。见
		|:highlight-link|。

		成功时返回零，而失败时返回 -1。

		示例: >
			" 为 Visual 高亮组加入 bold 属性
			:call hlset([#{name: 'Visual',
					\ term: #{reverse: 1 , bold: 1}}])
			:call hlset([#{name: 'Type', guifg: 'DarkGreen'}])
			:let l = hlget()
			:call hlset(l)
			" 清除 Search 高亮组
			:call hlset([#{name: 'Search', cleared: v:true}])
			" 清除高亮组的 'term' 属性
			:call hlset([#{name: 'Title', term: {}}])
			" 建立 MyHlg 组，链接到 DiffAdd
			:call hlset([#{name: 'MyHlg', linksto: 'DiffAdd'}])
			" 删除 MyHlg 组的链接
			:call hlset([#{name: 'MyHlg', linksto: 'NONE'}])
			" 清除属性和链接
			:call hlset([#{name: 'MyHlg', cleared: v:true,
					\ linksto: 'NONE'}])
<
		也可用作 |method|: >
			GetAttrList()->hlset()
<
		返回类型: |Number|


hostname()						*hostname()*
		返回运行 Vim 的机器名，类型为字符串。如果机器名超过 256 个字符，
		会被截短。

		返回类型: |String|


iconv({string}, {from}, {to})				*iconv()*
		返回将文本 {string} 从编码 {from} 转换到编码 {to} 后的新字符
		串。
		如果转换完全失败，返回空串。如果只有部分字符无法转换，这些无法
		转换的字符会以 "?" 代替。
		编码名可为 iconv() 库函数接受的任何名字，见 ":!man 3 iconv"。
		大多数转换需要 Vim 编译时加入 |+iconv| 特性。不然，只支持
		UTF-8 和 latin1 之间的相互转换。
		这可以用来显示包含特殊字符的消息。不管 'encoding' 设为何值，总
		可以用 UTF-8 书写消息，然后使用: >
			echo iconv(utf8_str, "utf-8", &enc)
<		注意 Vim 使用 UTF-8 进行所有的 Unicode 编码，从/到 UCS-2 的转
		换都自动改为使用 UTF-8。因为有 NUL 字节的关系，字符串中也不能
		直接使用 UCS-2。

		也可用作 |method|: >
			GetText()->iconv('latin1', 'utf-8')
<
		返回类型: |String|


id({item})						*id()*
		返回和 {item} 相关联而非与 {item} 内容绑定的唯一字符串。仅当
		{item} 存在且被引用时才有效，且仅在生成该值的 vim 实例中有效。
		基本想法是 `id({item})` 不应随 {item} 内容的改变而改变。通过本
		函数，字典可用对象的身份作为 `key`，而非基于对象值的比较。

		此操作不新增 {item} 的引用，也没有函数可以把 `id` 转换为
		{item} 本身。如果需要，可自行创建一个从 `id` 到 {item} 的映
		射。下例 >
		    var referenceMap: dict<any>
		    var id = item->id()
		    referenceMap[id] = item
<		这会新增 {item} 的引用，从而防止它被垃圾回收，同时提供了通过
		`id` 获取 {item} 的方法。

		{item} 可为列表、元组、字典、对象、作业、通道或 blob。如果
		{item} 不是这些可接受的类型之一或其值为 null，则返回空串。

		也可用作 |method|: >
			GetItem()->id()
<
		返回类型: |String|


indent({lnum})						*indent()*
		返回当前缓冲区第 {lnum} 行的缩进量，类型为数值。缩进量以空格计
		算，因而和 'tabstop' 的值有关。{lnum} 的用法可见 |getline()|。
		如果 {lnum} 非法，返回 -1。在 |Vim9| 脚本中，此时会报错。

		也可用作 |method|: >
			GetLnum()->indent()
<
		返回类型: |Number|


index({object}, {expr} [, {start} [, {ic}]])		*index()*
		寻找 {object} 中的 {expr}，并返回其索引。要通过匿名函数来选择
		项目，可见 |indexof()|。

		{object} 为 |List| 或 |Tuple| 时，返回与 {expr} 相等的元素的最
		小索引。这里不进行自动转换，字符串 "4" 不同于数值 4，数值 4 也
		不等同于浮点数 4.0。'ignorecase' 的值此处不适用，大小写是否敏
		感由 {ic} 参数决定。

		{object} 为 |Blob| 时，返回与 {expr} 相等的字节的最小索引。

		{start} 给出时，从索引为 {start} 的项目开始查找 (可以为负，用
		于表示相对于 {object} 末尾的索引)。

		{ic} 给出且为 |TRUE| 时，忽略大小写。否则，大小写必须匹配。

		如果在 {object} 里找不到 {expr}，返回 -1。
		示例: >
			:let idx = index(words, "the")
			:if index(numbers, 123) >= 0

<		也可用作 |method|: >
			GetObject()->index(what)
<
		返回类型: |Number|


indexof({object}, {expr} [, {opts}])			*indexof()*
		返回 {object} 中使 {expr} 结果为 v:true 的项目的索引。
		{object} 必须为 |List|、|Tuple| 或 |Blob|。

		{object} 为 |List| 或 |Tuple| 时，会为其中的每个项目依次计算
		{expr}，直到某项计算的结果为 v:true 为止，返回该项目的索引。

		{object} 为 |Blob| 时，会为其中的每个字节依次计算 {expr}，直到
		某字节计算的结果为 v:true 为止，返回该字节的索引。

		{expr} 必须为 |string| 或 |Funcref|。

		{expr} 为 |string| 时: 如果 {object} 为 |List| 或 |Tuple|,
		则 {expr} 中的 |v:key| 包含当前项目的索引，而 |v:val|
		为当前项目的值。而如果 {object} 为 |Blob|，{expr} 中的 |v:key|
		包含当前字节的索引，而 |v:val| 为当前字节的值。

		{expr} 为 |Funcref| 时，它必须接受两个参数:
			1. 当前项目的键值或索引。
			2. 当前项目的值。
		找到项目时函数必须返回 |TRUE|，此时搜索停止。

		可选参数 {opts} 为字典，包含以下项目:
		    startidx	从带此索引的项目开始计算 {expr}；可为负值，表
				示相对于 {object} 末尾的索引
		如果 {expr} 在所有项目上的计算结果均为 v:false，返回 -1。
		示例: >
			:let l = [#{n: 10}, #{n: 20}, #{n: 30}]
			:echo indexof(l, "v:val.n == 20")
			:echo indexof(l, {i, v -> v.n == 30})
			:echo indexof(l, "v:val.n == 20", #{startidx: 1})

<		也可用作 |method|: >
			mylist->indexof(expr)
<
		返回类型: |Number|


input({prompt} [, {text} [, {completion}]])		*input()*
		返回用户在命令行上输入的内容，类型为字符串。参数 {prompt} 用作
		提示字符串，可以为空串 (代表没有提示)。提示字符串中可以用 '\n'
		来换行。
		提示字符串使用 |:echohl| 设置的高亮。
		输入方式与命令行类似，也支持相同的编辑命令和映射。但 input()
		输入使用单独的历史。
		示例: >
			:if input("咖啡还是啤酒？") == "啤酒"
			:  echo "干杯！"
			:endif
<
		可选的 {text} 参数给出时，用作缺省的应答，就像用户已经输入了一
		样。例如: >
			:let color = input("Color? ", "white")

<		可选的 {completion} 参数指定输入支持的补全类型。不给出时就不会
		使用补全。支持的补全类型和用户定义命令通过 "-complete=" 参数能
		给出的类型相同。详情见 |:command-completion|。例如: >
			let fname = input("File: ", "", "file")
<
		注意: 在只能运行于 GUI 模式的版本里 (比如 Win32 GUI)，本函数不
		能在启动文件里使用。
		注意: input() 在映射里调用时，它会消耗该映射剩余的字符，因为映
		射的处理就像那些字符被键盘输入一样。为避免这种情况，在调用
		input() 前使用 |inputsave()|，结束后再调用 |inputrestore()|。
		另一个方法是避免在映射的后段直接提供任何字符，而使用
		|:execute| 或 |:normal| 来执行相应操作。

		使用映射的例子: >
			:nmap \x :call GetFoo()<CR>:exe "/" .. Foo<CR>
			:function GetFoo()
			:  call inputsave()
			:  let g:Foo = input("enter search pattern: ")
			:  call inputrestore()
			:endfunction

<		也可用作 |method|: >
			GetPrompt()->input()
<
		返回类型: |String|


inputdialog({prompt} [, {text} [, {cancelreturn}]])	*inputdialog()*
		和 |input()| 类同，但在运行 GUI 且支持文本对话框时，会弹出一个
		对话框窗口来输入文本。
		例如: >
		   :let n = inputdialog("value for shiftwidth", shiftwidth())
		   :if n != ""
		   :  let &sw = n
		   :endif
<		对话框被取消时，返回 {cancelreturn}，默认为空串。
		输入 <Enter> 和按 OK 按钮的效果相同。而按 <Esc> 和按 Cancel 按
		钮的效果相同。
		备注: 不支持命令行补全。

		也可用作 |method|: >
			GetPrompt()->inputdialog()
<
		返回类型: |String|


inputlist({textlist})					*inputlist()*
		{textlist} 必须是字符串组成的 |List|。本函数会显示此 |List| 中
		的每一项，每个字符串一行。用户会看到提示，需要输入一个数值作为
		选择，返回此数值。
		打开了命令行的鼠标支持 ('mouse' 为 "a" 或包含 "c") 时，用户也
		可以用鼠标点击项目来进行选择。首项字符串返回 0。在首个项目的上
		方点击时，会返回负数。而在提示行上点击时，会返回 {textlist} 的
		列表长度加一。
		请确保 {textlist} 项目数少于 'lines'，否则无法正常使用。建议在
		每个字符串的开头添加项目编号，并将首项用作提示信息。例如: >
			let color = inputlist(['Select color:', '1. red',
				\ '2. green', '3. blue'])

<		也可用作 |method|: >
			GetChoices()->inputlist()
<
		返回类型: |Number|


inputrestore()						*inputrestore()*
		恢复先前由 |inputsave()| 保存的预输入。调用次数应该和之前使用
		|inputsave()| 的次数相同，不过调用更多次也无妨。
		如果没有可以恢复的内容，返回 TRUE，否则，返回 FALSE。

		返回类型: |Number|


inputsave()						*inputsave()*
		保存预输入 (也包括来自映射的字符) 并清空，以便之后的输入提示能
		直接从用户获取输入。输入后应该用配套的 |inputrestore()| 进行恢
		复。本操作可以多次使用，每次保存都应对应一次 |inputrestore()|
		调用。
		如果内存不足，返回 TRUE，否则，返回 FALSE。

		返回类型: |Number|


inputsecret({prompt} [, {text}])			*inputsecret()*
		本函数和 |input()| 函数类同，但有两个例外:
		a) 用户的输入会显示为一串星号 ("*")，从而保证输入保密，还有
		b) 用户的输入不会记录在输入历史 |history| 栈中。
		返回用户在命令行上根据提示实际输入的应答，类型为字符串。
		备注: 不支持命令行补全。

		也可用作 |method|: >
			GetPrompt()->inputsecret()
<
		返回类型: |String|


insert({object}, {item} [, {idx}])			*insert()*
		{object} 为 |List| 或 |Blob| 时，在其开始处插入 {item}。

		{idx} 给出时，{item} 的插入位置在索引 {idx} 对应的项目之前。
		{idx} 为零或省略时，插入发生在首个项目之前。{idx} 也可用负值，
		见 |list-index|。例如，-1 会使插入发生在末项之前。

		返回新产生的 |List| 或 |Blob|。例如: >
			:let mylist = insert([2, 3, 5], 1)
			:call insert(mylist, 4, -1)
			:call insert(mylist, 6, len(mylist))
<		用 |add()| 可以更简洁地实现最后一个示例。
		注意 如果 {item} 是 |List|，它会被作为单个项目来插入。要连接多
		个 |List|，可用 |extend()|。

		也可用作 |method|: >
			mylist->insert(item)
<
		返回类型: |Number|

							*instanceof()* *E614*
instanceof({object}, {class})				*E616* *E693*
		{object} 参数为 {class} 指定的 |Class|、|Interface| 或类
		|:type| 别名的直接或间接实例则返回 |TRUE|。
		{class} 为可变参数时，{object} 为其中一个指定类的实例则返回
		|TRUE|。
		示例: >
			instanceof(animal, Dog, Cat)

<		也可用作 |method|: >
			myobj->instanceof(mytype)
<
		返回类型: |Number|


interrupt()						*interrupt()*
		中断脚本的执行。效果类似于用户按下 CTRL-C。多数命令会停止执
		行，而控制权将还给用户。此功能常用于系统进行低层操作 (如执行自
		动命令等) 时中断脚本。例如: >
		:function s:check_typoname(file)
		:   if fnamemodify(a:file, ':t') == '['
		:       echomsg '可能有输入错误'
		:       call interrupt()
		:   endif
		:endfunction
		:au BufWritePre * call s:check_typoname(expand('<amatch>'))
<
		返回类型: void


invert({expr})						*invert()*
		按位取反。参数会转换为数值。列表、字典或浮点数参数会报错。
		示例: >
			:let bits = invert(bits)

<		也可用作 |method|: >
			:let bits = bits->invert()
<
		返回类型: |Number|


isabsolutepath({path})					*isabsolutepath()*
		{path} 为绝对路径则返回 |TRUE|。
		Unix 上，绝对路径是指 '/' 开始的路径。
		MS-Windows 上，绝对路径是指由可选的驱动器前缀前导，后跟 '\' 或
		'/' 的路径。UNC 路径总是绝对的。
		示例: >
			echo isabsolutepath('/usr/share/')	" 1
			echo isabsolutepath('./foobar')		" 0
			echo isabsolutepath('C:\Windows')	" 1
			echo isabsolutepath('foobar')		" 0
			echo isabsolutepath('\\remote\file')	" 1
<
		也可用作 |method|: >
			GetName()->isabsolutepath()
<
		返回类型: |Number|


isdirectory({directory})				*isdirectory()*
		名为 {directory} 的目录存在则返回 |TRUE|。{directory} 不存在或
		者不是目录时，返回 |FALSE|。{directory} 可为任何表达式，会转换
		为字符串。

		也可用作 |method|: >
			GetName()->isdirectory()
<
		返回类型: |Number|


isinf({expr})						*isinf()*
		{expr} 为正无穷大时，返回 1，负无穷大返回 -1，否则返回 0。 >
			:echo isinf(1.0 / 0.0)
<			1 >
			:echo isinf(-1.0 / 0.0)
<			-1

		也可用作 |method|: >
			Compute()->isinf()
<
		返回类型: |Number|


islocked({expr})					*islocked()* *E786*
		{expr} 是已加锁的变量名则返回 |TRUE|。
		字符串 {expr} 必须是变量名、|List| 项目名或 |Dictionary| 条目
		名，而不是变量本身！例如: >
			:let alist = [0, ['a', 'b'], 2, 3]
			:lockvar 1 alist
			:echo islocked('alist')		" 1
			:echo islocked('alist[1]')	" 0

<		如果 {expr} 指向的变量不存在，返回 -1。如果 {expr} 使用了子列
		表、越界或不存在的列表或字典索引，会报错。用 |exists()| 可以检
		查变量是否存在。
		Vim9 脚本里，本函数不适用于局部函数变量。

		也可用作 |method|: >
			GetName()->islocked()
<
		返回类型: |Number|


isnan({expr})						*isnan()*
		{expr} 为值等于 NaN 的浮点数则返回 |TRUE|。 >
			echo isnan(0.0 / 0.0)
<			1

		也可用作 |method|: >
			Compute()->isnan()
<
		返回类型: |Number|


items({expr})						*items()*
		返回 {expr} 里所有键/索引-值组对构成的 |List|。每个 |List| 项
		是包含两个项目的列表:
		- 对 |Dict| 而言: 键和值
		- 对 |List|、|Tuple|、|Blob| 和 |String| 而言: 索引和值
		对于 |Dict| 类型，返回的 |List| 项的顺序是不固定的。而对于其它
		类型，返回的 |List| 会依索引值升序排列。

		另见 |keys()| 和 |values()|。

		示例: >
			let mydict = #{a: 'red', b: 'blue'}
			for [key, value] in items(mydict)
			   echo $"{key} = {value}"
			endfor
			echo items([1, 2, 3])
			echo items(('a', 'b', 'c'))
			echo items("foobar")
			echo items(0z0102)
<
		也可用作 |method|: >
			mydict->items()
<
		返回类型: list<list<any>> 或 list<any>


job_ 函数文档在这里: |job-functions-details|


join({expr} [, {sep}])					*join()*
		将 {expr} 的所有项目连接成一个字符串。{expr} 可为 |List| 或
		|Tuple|。
		{sep} 给出的分隔符放置在项目之间。缺省为单个空格。
		注意 返回值尾部不加 {sep}。如果确实需要: >
			let lines = join(mylist, "\n") .. "\n"
<		字符串项会照原样使用。而 |List|、|Tuple| 和 |Dictionary| 项会
		用与 |string()| 类似的方式转换为字符串。
		逆函数是 |split()|。

		也可用作 |method|: >
			mylist->join()
<
		返回类型: |String|


js_decode({string})					*js_decode()*
		和 |json_decode()| 类同，但有以下区别:
		- 对象的键名不需用引号括起。
		- 字符串可以用单引号括起。
		- 数组里允许出现空项 (即两个逗句之间没有内容)，此时会返回
		  v:none 项。

		也可用作 |method|: >
			ReadObject()->js_decode()
<
		返回类型: any，取决于 {varname}


js_encode({expr})					*js_encode()*
		和 |json_encode()| 类同，但有以下区别:
		- 对象的键名不用引号括起。
		- 数组里的 v:none 项会生成两个逗号之间没有内容的空项。
		例如，Vim 对象:
			[1,v:none,{"one":1},v:none] ~
		会被编码为:
			[1,,{one:1},,] ~
		而 |json_encode()| 会生成:
			[1,null,{"one":1},null] ~
		本函数生成的编码也是合法的 JavaScript，且比 JSON 更高效，尤其
		是使用含可选项的数组时更是如此。

		也可用作 |method|: >
			GetObject()->js_encode()
<
		返回类型: |String|


json_decode({string})					*json_decode()* *E491*
		对 JSON 格式的字符串进行解码，返回等价的 Vim 值。JSON 和 Vim
		值的关系参见 |json_encode()|。
		解码是容错的:
		- 数组和对象拖尾的逗号被忽略，例如 "[1, 2, ]" 等同于
		  "[1, 2]"。
		- 对象中接受整数键，例如 {1:2} 等同于 {"1":2}。
		- 识别更多形式的浮点数，例如 "1." 等同于 "1.0"，而 "001.2" 等
		  同于 "1.2"。并接受特殊浮点值 "Infinity"、"-Infinity" 和
		  "NaN" (大小写不敏感)。
		- 忽略整数的前导零，例如 "012" 等同于 "12"，而 "-012" 等同于
		  "-12"。
		- 按本义的名字 null、true 或 false 对大小写不敏感，例如 "NULL"
		  等同于 "null"，"True" 等同于 "true"。
		- 接受字符串中未转义的控制字符 U+0000 到 U+001F，例如 "	"
		  (字符串中的制表符) 等同于 "\t"。
		- 接受空或只有空白组成的 JSON 表达式，生成 v:none。
		- 非法的两字符转义序列会忽略反斜杠，例如 "\a" 会被解码为 "a"。
		- JSON 字符串中，完整的 Unicode 代理对 (surrogate pair) 通常应
		  为 12 个字符的序列，例如 "\uD834\uDD1E"，但 json_decode() 会
		  安静地接受不完整的代理对，例如 "\uD834" 或 "\uD834\u"。
							*E938*
		对象里的重复键值，虽然在 rfc7159 中合法，但 json_decode() 不接
		受，因为转换结果必须是合法的 Vim 类型，例如，下例会解码失败:
		{"a":"b", "a":"c"}

		也可用作 |method|: >
			ReadObject()->json_decode()
<
		返回类型: any，取决于 {varname}


json_encode({expr})					*json_encode()*
		对 {expr} 进行 JSON 编码，返回字符串。
		使用的编码格式遵循:
		https://tools.ietf.org/html/rfc7159.html
		不同的 Vim 值类型对应的转换方式如下:	*E1161*
		   |Number|		十进制数
		   |Float|		浮点数
		   Float nan		"NaN"
		   Float inf		"Infinity"
		   Float -inf		"-Infinity"
		   |String|		双引号括起 (可为 null)
		   |Funcref|		不接受，报错
		   |List|		视作数组 (可为 null)；若递归使用: []
		   |Tuple|		视作数组 (可为 null)；若递归使用: []
		   |Dict|		视作对象 (可为 null)；若递归使用: {}
		   |Blob|		视作由成员字节构成的数组
		   v:false		"false"
		   v:true		"true"
		   v:none		"null"
		   v:null		"null"
		备注 NaN 和 Infinity 被接受并作为值传递。这在 JSON 标准里并未
		规定，但若干实现能够处理。如果相应的实现不支持，则会报错。
		如果字符串里包含非法字符，它们被字符 0xfffd 替代。

		也可用作 |method|: >
			GetObject()->json_encode()
<
		返回类型: |String|


keys({dict})						*keys()*
		返回由 {dict} 里的所有键组成的 |List|。列表项的顺序不固定。另
		见 |items()| 和 |values()|。

		也可用作 |method|: >
			mydict->keys()
<
		返回类型: list<string>


keytrans({string})					*keytrans()*
		将键值的内部字节表示转换为 |:map| 可接受的形式。如 >
			:let xx = "\<C-Home>"
			:echo keytrans(xx)
<			<C-Home>

		也可用作 |method|: >
			"\<C-Home>"->keytrans()
<
		返回类型: |String|


len({expr})						*len()* *E701*
		返回参数的长度，类型为数值。
		{expr} 为字符串或数值时，返回其使用的字节数目，等同于
		|strlen()|。
		{expr} 为 |List| 时，返回其项目数量。
		{expr} 为 |Tuple| 时，返回其项目数量。
		{expr} 为 |Blob| 时，返回其字节数。
		{expr} 为 |Dictionary| 时，返回其项目数量。
		{expr} 为 |Object| 时，调用该对象的 len() 方法 (如有) 来计算其
		长度 (|object-len()|)。
		否则返回零。

		也可用作 |method|: >
			mylist->len()
<
		返回类型: |Number|

							*libcall()*
libcall({libname}, {funcname}, {argument})		*E364* *E368*
		调用在运行库 {libname} 中的函数 {funcname}，并传递单个参数
		{argument}。
		可用于调用库函数，尤其是那些专为 Vim 准备的函数。由于只能传递
		单个参数，所以可调用的标准库函数相当有限。
		调用后的结果是函数返回的字符串。如果函数返回 NULL，在 Vim 里会
		以空串 "" 出现。
		如果函数返回数值，请使用 |libcallnr()|！
		{argument} 为数值时，作为 int 类型传给函数；{argument} 为字符
		串时，则作为 null 结尾的字符串类型传入。
		该函数不能在 |restricted-mode| 里运行。

		libcall() 方便用户自行编写 Vim 的 '插件式' 扩展，而无须重新编
		译 Vim。它并_不_是用来调用系统函数的工具！如果尝试如此，Vim 很
		有可能会崩溃。

		Win32 上，用户编写的函数必须由 DLL 提供，且使用标准 C 调用惯例
		(而非_ Windows 系统 DLL 使用的 Pascal 惯例)。函数必须只能接受
		单个参数，该参数只能是字符指针或是长整数，而且必须返回字符指针
		或者 NULL。返回的字符指针必须在函数返回后仍然指向有效内存 (比
		如 DLL 的静态数据区)。如果指针指向动态分配的内存区域，会导致内
		存泄漏。函数内部使用静态缓冲区应该可以，这些缓冲区会在 DLL 卸
		载时才会被释放。

		警 告: 如果函数返回的是无效指针，Vim 会崩溃！这包括函数返回数
		值的情况，因为 Vim 会把数值当作指针看待。
		Win32 系统上，{libname} 必须是不带 ".DLL" 后缀的 DLL 文件名。
		只有在 DLL 不位于常规搜索路径时，才需要指定完整路径。
		Unix 上: 编译用户插件时，生成的目标代码必须是位置无关代码
		('PIC')。
		{仅在使用 Win32 和若干支持 |+libcall| 特性的 Unix 版本中有效}
		例如: >
			:echo libcall("libc.so", "getenv", "HOME")

<		也可用作 |method|，基是作为第三个参数传递的: >
			GetValue()->libcall("libc.so", "getenv")
<

libcallnr({libname}, {funcname}, {argument})		*libcallnr()*
		和 |libcall()| 类同，但所调用的函数会回 int 而非字符串。
		{仅在使用 Win32 和若干支持 |+libcall| 特性的 Unix 版本中有效}
		例如: >
			:echo libcallnr("/usr/lib/libc.so", "getpid", "")
			:call libcallnr("libc.so", "printf", "Hello World!\n")
			:call libcallnr("libc.so", "sleep", 10)
<
		也可用作 |method|，基是作为第三个参数传递的: >
			GetValue()->libcallnr("libc.so", "printf")
<
		返回类型: |String|


line({expr} [, {winid}])				*line()*
		返回 {expr} 给定的文件位置所在的行号，类型为数值。{expr} 参数
		是字符串。
		可接受的位置参见 |getpos()|。

		若需列号，可用 |col()|。若同时需要行列号，可用 |getpos()|。

		可选的 {winid} 参数用于指定取值的窗口，默认使用当前窗口。

		如果 {expr} 或 {winid} 非法，返回 0。

		例如: >
			line(".")		光标所在的行号
			line(".", winid)	同上，但取自窗口 "winid"
			line("'t")		位置标记 t 的行号
			line("'" .. marker)	名为 marker 的位置标记的行号
<
		一个具体的应用场景是，打开文件后，可以跳转到该文件中光标上次停
		留的位置。参见 |last-position-jump|。

		也可用作 |method|: >
			GetValue()->line()
<
		返回类型: |Number|


line2byte({lnum})					*line2byte()*
		返回当前缓冲区第 {lnum} 行从缓冲区开头计算的字节数。计算包括换
		行符，但换行符对应的字节数取决于当前缓冲区的 'fileformat' 选
		项。首行的行号为 1。结果受 'encoding' 影响，但忽略
		'fileencoding'。
		{lnum} 也可以取值文件末行之后的一行: >
			line2byte(line("$") + 1)
<		会返回缓冲区的大小加一。'fileencoding' 为空时，这等于文件大小
		加一。{lnum} 的用法可见 |getline()|。如果 {lnum} 非法或者编译
		时关闭了 |+byte_offset| 特性，返回 -1。
		另见 |byte2line()|、|go| 和 |:goto|。

		也可用作 |method|: >
			GetLnum()->line2byte()
<
		返回类型: |Number|


lispindent({lnum})					*lispindent()*
		返回第 {lnum} 行根据 lisp 缩进规则应有的缩进量，见 'lisp'。
		缩进量以空格计算，因而和 'tabstop' 的值有关。
		{lnum} 的用法可见 |getline()|。
		如果 {lnum} 非法，返回 -1。在 |Vim9| 脚本中，此时会报错。

		也可用作 |method|: >
			GetLnum()->lispindent()
<
		返回类型: |Number|


list2blob({list})					*list2blob()*
		返回一个由 {list} 中所有数值组成的 blob。例如: >
			list2blob([1, 2, 3, 4])	returns 0z01020304
			list2blob([])		returns 0z
<		如果出错，返回空 blob。如果有负值或大于 255 的值，报错
		*E1239* 。

		|blob2list()| 是其逆操作。

		也可用作 |method|: >
			GetList()->list2blob()
<
		返回类型: |Blob|


list2str({list} [, {utf8}])				*list2str()*
		把 {list} 中的每个数值视为字符代码，转换为相应字符后连接成字符
		串。例如: >
			list2str([32])		返回 " "
			list2str([65, 66, 67])	返回 "ABC"
<		相当于如下 (较慢) 的实现: >
			join(map(list, {nr, val -> nr2char(val)}), '')
<		|str2list()| 是其逆操作。

		{utf8} 省略或为零时，返回字符串会使用当前的 'encoding'。
		而 {utf8} 为 TRUE 时，总是使用 UTF-8 编码。
		使用 UTF-8 编码时，组合字符能够被正确处理: >
			list2str([97, 769])	返回 "á"
<
		如果出错，返回空串。

		也可用作 |method|: >
			GetList()->list2str()
<
		返回类型: |String|


list2tuple({list})					*list2tuple()*
		根据列表项目的浅备份创建一个新的元组。示例: >
			list2tuple([1, 2, 3])		返回 (1, 2, 3)
<		|tuple2list()| 是其逆操作。

		本函数不会递归地将 {list} 内部的列表项目转换为为元组。注意 列
		表和元组共享相同的项目引用，如果任何一个项目被修改，元组和列表
		都会受到影响。

		如果出错，返回空元组。

		也可用作 |method|: >
			GetList()->list2tuple()
<
		返回类型: tuple<{type}> (取决于给定 |List| 的项目类型)


listener_add({callback} [, {buf} [, {unbuffered}]])	*listener_add()*
		为缓冲区 {buf} 添加回调函数，当缓冲区发生改动时执行。
		{buf} 可为缓冲区名或编号，合法值可见 |bufname()|。默认使用当前
		缓冲区。
		返回可用于传递给 |listener_remove()| 的唯一 ID。

		新增回调之前，如果 {buf} 已注册过回调，会先调用等价于 >
		    listener_flush({buf})
<		的操作，确保新监听器不会接收到在它加入之前尚待处理的改动。

		调用 {callback} 时，会传入五个参数:
		    bufnr	发生改动的缓冲区
		    start	改动区域的起始行号
		    end		改动区域之后的首行行号
		    added	新增行数，删除行时为负数
		    changes	包含改动细节的项目列表

		示例: >
	    func Listener(bufnr, start, end, added, changes)
	      echo 'lines ' .. a:start .. ' until ' .. a:end .. ' changed'
	    endfunc
	    call listener_add('Listener', bufnr)

<		"changes" 列表只读。其中每个列表项为包含以下条目的字典:
		    lnum	改动区域的起始行号
		    end		改动区域之后的首行行号
		    added	新增行数，删除行时为负数
		    col		第 "lnum" 行中受影响的起始列号；如果未知或整行
				都受影响，则为一；此处按字节计数，首列列号为
				一。
		插入新行 (不含已有行被分割，例如在插入模式下键入 CR 这样的情
		况) 时，值为:
		    lnum	新行会被添加在该行的上方
		    end		等于 "lnum"
		    added	插入的行数
		    col		1
		删除行时，值为:
		    lnum	被删除的起始行号
		    end		删除发生之前，被删除的首 (译者注: 应为末？) 行
				之后的首行行号
		    added	负值，表示删除的行数
		    col		1
		行发生改动时:
		    lnum	改动起始行的行号
		    end		改动末行之后的首行行号
		    added	0
		    col		改动发生的起始列号，或 1

		{unbuffered} 为 |FALSE| 或省略时，调用 {callback} 的时刻为:

		1. 屏幕刚刚刷新之前。
		2. |listener_flush()| 被调用时。
		3. 发生了会改变行数的改动，使得 changes 列表里的某些行号失效。

		列表项依改动发生的先后顺序排列，最近发生的改动出现在最后。

		因为上面列出的触发回调的第三个原因，传递给回调的行号未必能保证
		有效。尤其是，end 值可能会大于 line('$') + 1。如果这会导致问
		题，将 {unbuffered} 设为 |TRUE|。

		{unbuffered} 为 |TRUE| 时，每次改动都会触发 {callback}。
		changes 列表只有单一列表项，其中字典里的 "start" (译者注: 应为
		"lnum"，不过，相应的回调参数名是 "start")、"end" 和 "added" 值
		和对应的回调参数相同。调用回调时，使用的行号一定是合法的，但之
		后发生的改动可能会使这些行号失效，所以不建议将它们保存以备后
		用。

		{callback} 调用时，锁定文本，见 |textlock|。如果回调里需要改动
		缓冲区，可用定时器 |timer_start()| 在回调结束之后再执行所需的
		改动。

		{callback} 中不能调用 listener_add()。 *E1569*

		缓冲区初次载入时，不调用 {callback}。为此可用 |BufReadPost| 自
		动命令事件来处理缓冲区的初始文本。
		缓冲区被卸载时，也不调用 {callback}，为此可用 |BufUnload| 自动
		事件。

		如果 {callback} 或 {buf} 非法，返回零。

		也可用作 |method|，基是作为第二个参数传递的: >
			GetBuffer()->listener_add(callback)
<
		返回类型: |Number|


listener_flush([{buf}])					*listener_flush()*
		执行缓冲区 {buf} 里的所有监听器回调。但没有待处理的改动时，回
		调不会执行。

		{buf} 可为缓冲区名或编号，合法值可见 |bufname()|。默认使用当前
		缓冲区。

		也可用作 |method|: >
			GetBuffer()->listener_flush()
<
		返回类型: |Number|


listener_remove({id})					*listener_remove()*
		删除先前通过 |listener_add()| 添加的监听器。
		如果指定 {id} 的监听器不存在，返回 FALSE，成功移除监听器 {id}
		后返回 TRUE。

		也可用作 |method|: >
			GetListenerId()->listener_remove()
<
		返回类型: |Number|


localtime()						*localtime()*
		返回当前时间 (从 1970 年 1 月 1 日开始计算的秒数)。另见
		|strftime()|、|strptime()| 和 |getftime()|。

		返回类型: |Number|


log({expr})						*log()*
		返回 {expr} 的自然对数 (即以 e 为底)，类型为 |Float|。
		{expr} 的计算结果必须是 (0, inf] 区间内的 |Float| 或
		|Number|。
		如果 {expr} 不是 |Float| 或 |Number|，返回 0.0。
		示例: >
			:echo log(10)
<			2.302585 >
			:echo log(exp(5))
<			5.0

		也可用作 |method|: >
			Compute()->log()
<
		返回类型: |Float|


log10({expr})						*log10()*
		返回 {expr} 以 10 为底的对数，类型为 |Float|。
		{expr} 的计算结果必须是 |Float| 或 |Number|。
		如果 {expr} 不是 |Float| 或 |Number|，返回 0.0。
		示例: >
			:echo log10(1000)
<			3.0 >
			:echo log10(0.01)
<			-2.0

		也可用作 |method|: >
			Compute()->log10()
<
		返回类型: |Float|


luaeval({expr} [, {expr}])				*luaeval()*
		运行 Lua 表达式 {expr}，把返回值转换为对应的 Vim 数据类型。可
		选的第二个 {expr} 用来指定额外的参数，可在第一个 {expr} 中以
		_A 形式访问。
		字符串按原样返回。
		布尔值对象会转换为数值。
		数值会转换为 |Float|。
		通过 vim.eval() 得到的字典和列表会按原样返回。
		更多细节可见 |lua-luaeval|。
		注意 `:def` 定义的函数内部的局部变量对 {expr} 不可见。

		也可用作 |method|: >
			GetExpr()->luaeval()
<
		返回类型: any，取决于 {expr}

		{仅当编译时加入 |+lua| 特性才有效}


map({expr1}, {expr2})					*map()*
		{expr1} 必须是 |List| 、|String|、|Blob| 或 |Dictionary|。
		{expr1} 是 |List| 或 |Dictionary| 时，{expr1} 里的每个项目会被
		{expr2} 的计算结果替代。对 |Blob| 里的每个字节和 |String| 里的
		每个字符 (包括组合字符)，也会用同样的方法被替代。
		如果项目的类型发生变化，可以考虑用 |mapnew()| 来创建新的列表或
		字典。在 Vim9 脚本里，这是必须的做法。

		{expr2} 必须是 |String| 或 |Funcref|。

		{expr2} 是 |String| 时，{expr2} 内的 |v:val| 包含当前项目的
		值。对 |Dictionary|、|List|、|Blob| 和 |String| 而言，|v:key|
		分别包含当前项目的键、当前项目索引、当前字节索引和当前字符索
		引。
		例如: >
			:call map(mylist, '"> " .. v:val .. " <"')
<		在 "mylist" 里，每个列表项的前面加上 "> "，后面加上 " <"。

		注意 {expr2} 既是一个表达式的计算结果，又被用作一个表达式来进
		行计算。通常最好使用 |literal-string| 来避免反斜杠被加倍。当
		然，' 引号仍然需要加倍处理。

		{expr2} 是 |Funcref| 时，它应接受两个参数:
			1. 当前项目的键或索引。
			2. 当前项目的值。
		在老式脚本里，匿名函数如果只接受一个参数，不会报错。但在 Vim9
		脚本里，此时会报错 "E1106: One argument too many"，因为参数数
		目必须匹配。

		函数必须返回项目的新值。例如要改变每个值为 "键-值": >
			func KeyValue(key, val)
			  return a:key .. '-' .. a:val
			endfunc
			call map(myDict, function('KeyValue'))
<		使用 |lambda| 可以更简洁 (译者注: 以下均为老式脚本语法): >
			call map(myDict, {key, val -> key .. '-' .. val})
<		"val" 如果不用，可以省略: >
			call map(myDict, {key -> 'item: ' .. key})
<		"key" 如果不用，不可以省略但可以使用短名: >
			call map(myDict, {_, val -> 'item: ' .. val})
<
		对 |List| 或 |Dictionary| 而言，本操作是原位操作 (直接在输入上
		修改)。如果不想更动原始输入，先创建备份: >
			:let tlist = map(copy(mylist), ' v:val .. "\t"')

<		对于 |List| 或 |Dictionary|，返回经过映射处理后修改过的
		{expr1}，而对于 |Blob| 或 |String|，则返回新值。
		如果计算 {expr2} 时出错，不再处理 {expr1} 里的后续项目。
		{expr2} 是函数引用时，除非该函数定义时带上 "abort" 标志位，忽
		略函数里的错误。

		也可用作 |method|: >
			mylist->map(expr2)
<
		返回类型: |String|、|Blob|、list<{type}> 或 dict<{type}>，
		取决于 {expr1}


maparg({name} [, {mode} [, {abbr} [, {dict}]]])		*maparg()*
		{dict} 省略或为零时，返回名为 {name} 在 {mode} 模式下的映射的
		右侧内容 (rhs)。返回的字符串中，特殊字符会使用和 ":map" 命令输
		出的同样方式进行翻译。{dict} 为 TRUE 时，返回下面描述的字典。
		要想获取所有映射的列表，可用 |maplist()|。

		名为 {name} 的映射不存在时，如果 {dict} 为 FALSE 则返回空串，
		否则返回空字典。而名为 {name} 的映射的右侧内容为空时，返回
		"<Nop>"。

		{name} 可包含特殊键名，就像在 ":map" 命令中一样。

		{mode} 可以使用下列字符串之一:
			"n"	普通模式
			"v"	可视模式 (包括选择模式)
			"o"	操作符等待模式
			"i"	插入模式
			"c"	命令行模式
			"s"	选择模式
			"x"	可视模式
			"l"	语言映射 |language-mapping|
			"t"	终端作业模式
			""	普通、可视和操作符等待模式。
		{mode} 省略时使用 "" 指定的模式。

		{abbr} 给出且为 |TRUE| 时，使用缩写而不是映射。

		{dict} 给出且为 |TRUE| 时，返回包含映射详细信息的字典。字典包
		含如下条目:				*mapping-dict*
		  "lhs"	     映射的 {lhs}，采用用户输入表示
		  "lhsraw"   映射的 {lhs}，采用原始字节表示
		  "lhsrawalt" 映射的 {lhs}，采用原始字节的替代表示，仅当其与
			      "lhsraw" 不同时才会出现
		  "rhs"	     映射的 {rhs}，采用用户输入表示。
		  "silent"   |:map-silent| 映射则为 1，否则为 0。
		  "noremap"  映射的 {rhs} 不能重映射则为 1。
		  "script"   映射使用 <script> 定义则为 1。
		  "expr"     表达式映射 (|:map-<expr>|) 则为 1。
		  "buffer"   缓冲区本地映射 (|:map-local|) 则为 1。
		  "mode"     映射定义使用的模式。除了上述的模式以外，还会使用:
			     " "     普通、可视和操作符等待模式
			     "!"     插入和命令行模式
				     (|mapmode-ic|)
		  "sid"	     脚本局部 ID，用于 <sid> 映射 (|<SID>|)。负值用于
			     特殊上下文。
		  "scriptversion"  脚本版本。|Vim9| 脚本返回 999999。
		  "lnum"     "sid" 中的行号，行号未知时为零。
		  "nowait"   不等待其它更长的映射 (|:map-<nowait>|) 则为 1。
		  "abbr"     使用缩写 |abbreviations| 时则为真。
		  "mode_bits" "mode" 的 Vim 内部二进制表示。|mapset()| 忽略
			     本条目，只使用 "mode"。用法举例可见 |maplist()|。
			     其值来自 src/vim.h，将来可能会改变。

		|mapset()| 可使用此字典来恢复映射。

		首先检查当前缓冲区的局部映射，如果没有找到，再检查全局映射。
		本函数可以在按键已经被映射的情况下，仍然对它进行新的映射，同时
		保留原来映射的内容。示意如下: >
			exe 'nnoremap <Tab> ==' .. maparg('<Tab>', 'n')

<		也可用作 |method|: >
			GetKey()->maparg('n')
<
		返回类型: |String| 或 dict<any>，取决于 {dict}


mapcheck({name} [, {mode} [, {abbr}]])			*mapcheck()*
		检查是否有模式 {mode} 下名字匹配 {name} 的映射。参见
		|maparg()| 了解 {mode} 和 {name} 里的特殊键名。
		{abbr} 给出且为 |TRUE| 时，使用缩写而不是映射。
		映射名以 {name} 开始，或者映射名等于 {name} 的起始部分，都算匹
		配成功。

			匹配映射	"a"     "ab"    "abc" ~
		   mapcheck("a")	是	是	 是
		   mapcheck("abc")	是	是	 是
		   mapcheck("ax")	是	否	 否
		   mapcheck("b")	否	否	 否

		和 |maparg()| 相较，mapcheck() 会使用 {name} 的部分匹配来查找
		映射，而 |maparg()| 只查找名字和 {name} 完全一致的映射。
		如果没有 {name} 开始的映射，返回空串。如果只有一个匹配的映射，
		返回该映射的右侧内容。如果有多个匹配，返回其中任意一个的右侧内
		容。当映射右侧内容为空时，返回 "<Nop>"。
		首先检查当前缓冲区的局部映射，如果没有找到，再检查全局映射。
		该函数可用于判断是否可以安全地添加映射而不会产生歧义。例如: >
	:if mapcheck("_vv") == ""
	:   map _vv :set guifont=7x13<CR>
	:endif
<		在已有 "_v" 或者 "_vvv" 映射时，此检查就可以防止再添加 "_vv"
		映射，以避免冲突。

		也可用作 |method|: >
			GetKey()->mapcheck('n')
<
		返回类型: |String|


maplist([{abbr}])					*maplist()*
		返回所有映射组成的 |List|。每个列表项是和 |maparg()| 返回值相
		同的 |Dict|，参见 |mapping-dict|。{abbr} 给出且为 |TRUE| 时，
		使用缩写而不是映射。

		显示右侧内容使用 'MultiMatch' 的所有映射的示例: >
			vim9script
			echo maplist()->filter(
				(_, m) => match(m.rhs, 'MultiMatch') >= 0)
<		要找到特定 |:map-modes| 的所有映射需要点技巧。这里可以借助
		|mapping-dict| 里的 "mode_bits"。例如，普通、插入或命令行模式
		对应的 mode_bits 是 0x19。要找到这些模式下的所有映射: >
			vim9script
			var saved_maps = []
			for m in maplist()
			    if and(m.mode_bits, 0x19) != 0
				saved_maps->add(m)
			    endif
			endfor
			echo saved_maps->mapnew((_, m) => m.lhs)
<		要查询 mode_bits 的值，可以参考 Vim 源代码 src/vim.h 里的相应
		定义，也可以在运行时用 |:map-commands| 和 "maplist()" 来获取。
		例如: >
			vim9script
			omap xyzzy <Nop>
			var op_bit = maplist()->filter(
			    (_, m) => m.lhs == 'xyzzy')[0].mode_bits
			ounmap xyzzy
			echo printf("Operator-pending mode bit: 0x%x", op_bit)
<
		返回类型: list<dict<any>>


mapnew({expr1}, {expr2})				*mapnew()*
		和 |map()| 类同，但生成并返回新的列表或字典而不是替换 {expr1}
		里的项目。原始的 {expr1} 保持不变。不过，{expr2} 仍然可能对其
		中的项目进行修改，如果不想如此，先用 |deepcopy()| 再进行操作。

		返回类型: |String|、|Blob|、list<{type}> 或 dict<{type}>，
		取决于 {expr1}


mapset({mode}, {abbr}, {dict})				*mapset()*
mapset({dict})
		通过 |maparg()| 或 |maplist()| 返回的字典来恢复映射。
		dict.buffer 为真时，在当前缓冲区上恢复缓冲区本地映射；调用者应
		确保当前缓冲区就是期望的那个缓冲区。此特性可以把一个缓冲区里的
		映射复制到另一个缓冲区。
		dict.mode 值可以恢复适用于多个模式的单个映射，例如 mode 值
		'!'、' '、'nox' 或 'v' 就是如此。 *E1276*

		第一种形式使用的 {mode} 和 {abbr} 应和原先调用 |maparg()| 时所
		用的值保持一致。 *E460*
		此时，使用 {mode} 来定义映射所在的模式，而不是 {dict} 中的
		"mode" 项目。
		保存和恢复映射的示例: >
			let save_map = maparg('K', 'n', 0, 1)
			nnoremap K 其它映射值
			...
			call mapset('n', 0, save_map)
<		注意 要恢复像 `:map!` 这样在多个模式下定义的映射，需要针对每个
		模式分别保存/恢复映射，因为每个模式下映射的右侧内容可能不同。

		第二种形式只需提供一个参数 {dict}，mode 和 abbr 会直接从该字典
		中获取。
		示例: >
			vim9script
			var save_maps = maplist()->filter(
						(_, m) => m.lhs == 'K')
			nnoremap K somethingelse
			cnoremap K somethingelse2
			# ...
			unmap K
			for d in save_maps
			    mapset(d)
			endfor
<
		返回类型: |Number|


match({expr}, {pat} [, {start} [, {count}]])		*match()*
		{expr} 为 |List| 时，返回匹配 {pat} 的首个列表项的索引。每个列
		表项视作字符串，|List| 和 |Dictionary| 子项目按其回显的形式参
		与匹配。

		否则，{expr} 视作字符串。返回 {expr} 里匹配 {pat} 的起始位置
		(按字节计算的偏移量)，类型为数值。

		如果匹配到的是首个字符或首个 |List| 项，返回的索引为零。如果没
		有匹配，返回 -1。

		要获取子匹配项，可见 |matchlist()|。
		例如: >
			:echo match("testing", "ing")	" 返回 4
			:echo match([1, 'x'], '\a')	" 返回 1
<		{pat} 的用法可见 |string-match|。
							*strpbrk()*
		Vim 并未提供 strpbrk() 函数。但可以按下面方式自行实现: >
			:let sepidx = match(line, '[.,;: \t]')
<							*strcasestr()*
		Vim 也并未提供 strcasestr() 函数。但可以通过在模式里加入 "\c"
		以忽略大小写来实现: >
			:let idx = match(haystack, '\cneedle')
<
		{start} 给出时，从字符串的第 {start} 个字节位置或从列表中索引
		为 {start} 的项开始搜索。
		不过，返回的索引仍然从首个字符/列表项开始算起。比如: >
			:echo match("testing", "ing", 2)
<		返回结果是 "4"。 >
			:echo match("testing", "ing", 4)
<		返回结果还是 "4"。 >
			:echo match("testing", "t", 2)
<		返回 "3"。
		对字符串而言，如果 {start} > 0，其行为相当于该字符串从第
		{start} 个字节后开始，因而 "^" 会从 {start} 位置开始匹配。
		但如果同时也给出了 {count}，行为会有所不同，此时先进行正常的完
		整匹配，然后忽略前 {start} 个字节中的那些匹配 (有一点复杂，这
		是为了后向兼容)。
		对字符串而言，如果 {start} < 0，则视作 0 处理。而对列表而言，
		负索引代表从列表尾部开始计数。
		如果 {start} 越界 (对于字符串 {start} > strlen({expr})，对于
		|List| {start} > len({expr}))，返回 -1。

		{count} 给出时，使用第 {count} 个匹配。对字符串而言，找到一个
		匹配后，下一次匹配会从该匹配开始位置的下一个字符开始搜索。所以
		下例返回 1: >
			echo match("testing", "..", 0, 2)
<		对 |List| 而言，搜索则从下一个项目开始。
		注意 如果同时也给出了 {count}，{start} 使用的方式有所改变。见
		上。

							*match-pattern*
		参见 |pattern|，了解可接受的匹配模式。
		'ignorecase' 选项用来设定模式匹配是否忽略大小写。这里_不_考虑
		'smartcase'。模式匹配总是假定置位了 'magic' 而 'cpoptions' 为
		空。
		注意 优先考虑较早位置的匹配，所以当使用 "*" (任意数目的匹配)
		时，模式倾向于匹配字符串开头处的零匹配，而不是文本中间的最长匹
		配。

		(译者注: match() 系列函数简单对照可见下表:
			函数	输入	匹配	返回值	子匹配	多匹配	带信息
		|match()|	串/列表	正则	始索引	✗	首个	✗
		|matchbufline()|缓冲区	正则	列表	✓	所有	✓
		|matchend()|	串/列表	正则	末索引	✗	首个	✗
		|matchfuzzy()|	列表	模糊	列表	✗	所有	✗
		|matchfuzzypos()| 列表	模糊	列表	✗	所有	✓
		|matchlist()|	字符串	正则	列表	✓	首个	✗
		|matchstr()|	串/列表	正则	字符串	✗	首个	✗
		|matchstrlist()| 列表	正则	列表	✓	所有	✓
		|matchstrpos()|	串/列表	正则	列表	✗	首个	✓
		)

		也可用作 |method|: >
			GetText()->match('word')
			GetList()->match('word')
<
		返回类型: |Number|

							*matchadd()* *E290*
							*E798* *E799* *E801*
							*E957*
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
		定义模式 (一个 "匹配")，在当前窗口用高亮组 {group} 高亮。返回
		标识号 (ID)，该 ID 可用于 |matchdelete()|，以删除相应的匹配。
		ID 局部于窗口。
		匹配是大小写敏感和带魔术的，但 {pattern} 里可以显式关闭大小写
		敏感性和魔术性。这里不考虑 'magic'、'smartcase' 和
		'ignorecase' 选项。
		"Conceal" 值是特别的，它会使匹配被隐藏。

		可选的 {priority} 参数指定匹配的优先级。高优先级的匹配会覆盖低
		优先级匹配的高亮显示。优先级用整数指定 (负整数也无不可)。默认
		优先级为 10。'hlsearch' 的优先级为零，因此所有正数优先级的匹配
		都可以覆盖它。语法高亮 (见 'syntax') 采用不同的机制，效果上来
		说，无论何种优先级的匹配都会覆盖语法的高亮。

		可选的 {id} 参数请求特定的匹配 ID。如果指定的 ID 已占用，会报
		错并且不会添加新的匹配。ID 用正整数指定 (不含零)。ID 1、2 和 3
		分别为 |:match|、|:2match| 和 |:3match| 命令保留。ID 3 为
		|matchparen| 插件保留。

		{id} 省略或为 -1 时，|matchadd()| 自动选择一个可用的 ID，从
		1000 开始。

		可选的 {dict} 参数允许更多自定义。目前，可制用来指定匹配特定的
		隐藏字符，使用 |hl-Conceal| 高亮组的匹配会用此来替代显示。该字
		典包含以下成员:

			conceal	    替代匹配显示的特殊字符 (只用于使用
				    |hl-Conceal| 高亮组的匹配，见
				    |:syn-cchar|)
			window	    不使用当前窗口，而使用指定窗口号或窗口 ID
				    的其它窗口。

		本函数可添加的匹配的数目不限，而 |:match| 系列命令则有此局限。

		如果出错，返回 -1。

		示例: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchadd("MyGroup", "TODO")
<		要删除该模式: >
			:call matchdelete(m)

<		|getmatches()| 会列出 |matchadd()| 和 |:match| 定义的所有匹配
		的列表。|clearmatches()| 可一次删除所有的匹配。

		也可用作 |method|: >
			GetGroup()->matchadd('TODO')
<
		返回类型: |Number|

							*matchaddpos()*
matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
		和 |matchadd()| 类同，但指定位置列表 {pos} 而非匹配模式。本函
		数比 |matchadd()| 更高效，因为无需处理正则表达式，而且会设置缓
		冲区重画屏幕的行边界。主要用于需要频繁快速增删匹配的场合，如括
		号匹配的高亮显示。

		{pos} 是一组位置的列表。每个位置可以是以下形式之一:
		- 数值。表示在指定行高亮整行。首行的行号为 1。
		- 单数值列表。如 [23]。同样表示在指定行高亮整行。
		- 双数值列表，如 [23, 11]。表示在指定位置高亮单个字符。前者为
		  行号，后者为列号 (首列列号为 1，必须对应 |col()| 返回的字节
		  索引)。
		- 三数值列表，如 [23, 11, 3]。同上，但第三个值指定高亮的字节长
		  度，而不是默认的 1。

		如果出错，返回 -1。

		示例: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchaddpos("MyGroup", [[23, 24], 34])
<		模式的删除: >
			:call matchdelete(m)

<		|getmatches()| 返回 |matchaddpos()| 加入的匹配。

		也可用作 |method|: >
			GetGroup()->matchaddpos([23, 11])
<
		返回类型: |Number|


matcharg({nr})						*matcharg()*
		选择第 {nr} 号匹配，它们分别用 |:match|、|:2match| 或
		|:3match| 命令设置。
		返回包含两个项目的 |List|:
			使用的高亮组名
			使用的模式。
		如果 {nr} 不是 1、2 或 3，返回空 |List|。
		如果未曾设置过该匹配，返回 ['', '']。
		本函数用来保存和恢复 |:match|。
		用 |:match| 系列命令定义的高亮匹配只限三个。而 |matchadd()| 无
		此限制。

		也可用作 |method|: >
			GetMatch()->matcharg()
<
		返回类型: list<string>


matchbufline({buf}, {pat}, {lnum}, {end}, [, {dict}])	*matchbufline()*
		返回在指定缓冲区 {buf} 的第 {lnum} 到 {end} 行之间，所有匹配模
		式 {pat} 的匹配项组成的 |List|。

		{lnum} 和 {end} 或者是行号，或者代表 {buf} 末行的 "$" 字符串。

		{dict} 参数支持以下项目:
		    submatches	为真则包含子匹配项信息 (|/\(|)

		返回列表中，对应每个匹配项，返回包含以下条目的 |Dict|:
		    byteidx	匹配起始位置的字节索引
		    lnum	匹配所在的行号
		    text	匹配内容字符串
		注意 一行上可能有多处匹配。

		本函数只能用于已加载的缓冲区。如有必要，可先调用 |bufload()|。

		|match-pattern| 说明模式相关选项设定的效果。

		如果 {buf} 不是合法缓冲区、缓冲区未加载，或者 {lnum} 或 {end}
		不合法，报错并返回空 |List|。

		示例: >
		    " 假定 5 号缓冲区第 3 行是 "a"
		    :echo matchbufline(5, '\<\k\+\>', 3, 3)
		    [{'lnum': 3, 'byteidx': 0, 'text': 'a'}]
		    " 假定 10 号缓冲区第 4 行是 "tik tok"
		    :echo matchbufline(10, '\<\k\+\>', 1, 4)
		    [{'lnum': 4, 'byteidx': 0, 'text': 'tik'},
		     {'lnum': 4, 'byteidx': 4, 'text': 'tok'}]
<
		{submatch} 给出且为 v:true 时，返回字典中还会出现 "submatches"
		条目，包含 "\1"、"\2" 等子匹配项组成的列表。例如: >
		    " 假定 2 号缓冲区第 2 行是 "acd"
		    :echo matchbufline(2, '\(a\)\?\(b\)\?\(c\)\?\(.*\)', 2, 2
						\ {'submatches': v:true})
		    [{'lnum': 2, 'byteidx': 0, 'text': 'acd', 'submatches':
		    ['a', '', 'c', 'd', '', '', '', '', '']}]
<		"submatches" 列表永远包含 9 个项目。如果某个子匹配项空缺，对应
		的位置会返回空串。

		也可用作 |method|: >
			GetBuffer()->matchbufline('mypat', 1, '$')
<
		返回类型: list<dict<any>> 或 list<any> (译者注: 应只有前者)

							*matchdelete()*
matchdelete({id} [, {win})				*E802* *E803*
		删除先前用 |matchadd()| 或 |:match| 诸命令定义的 ID 为 {id} 的
		匹配。成功时返回 0，否则返回 -1。示例见 |matchadd()|。
		|clearmatches()| 可一次删除所有的匹配。
		{win} 给出时，使用指定编号或 ID 的窗口，而非默认的当前窗口。

		也可用作 |method|: >
			GetMatch()->matchdelete()
<
		返回类型: |Number|


matchend({expr}, {pat} [, {start} [, {count}]])		*matchend()*
		和 |match()| 类同，但返回匹配之后首个字符的位置，而非匹配的起
		始位置。例如: >
			:echo matchend("testing", "ing")
<		返回 "7"。
							*strspn()* *strcspn()*
		Vim 并未提供 strspn() 或 strcspn() 函数，但可用 matchend() 自
		行实现: >
			:let span = matchend(line, '[a-zA-Z]')
			:let span = matchend(line, '[^a-zA-Z]')
<		区别是，如果没有匹配，本函数会返回 -1。

		{start} 给出时，其用法和 |match()| 中的 {start} 参数相同。 >
			:echo matchend("testing", "ing", 2)
<		返回 "7"。 >
			:echo matchend("testing", "ing", 5)
<		返回 "-1"。
		{expr} 为 |List| 时，返回值和 |match()| 的相同。

		也可用作 |method|: >
			GetText()->matchend('word')
<
		返回类型: |Number|


matchfuzzy({list}, {str} [, {dict}])			*matchfuzzy()*
		{list} 为字符串列表时，返回包含 {list} 中所有与 {str} 模糊匹配
		的字符串 |List|。返回的列表按照匹配分数从高到低排序。

		可选的 {dict} 参数总是支持以下条目:
		    matchseq	给出时，只返回与 {str} 里字符出现的顺序一致的
				匹配。
		    limit	{list} 里返回的匹配数量上限。零代表不设限制。

		{list} 为字典列表时，可选的 {dict} 参数还另外支持以下条目:
		    key		用于模糊匹配 {str} 的项目键。该项目的值必须为
				字符串类型。
		    text_cb	对 {list} 中每个项目，都会调用本条目指定的
				|Funcref| 以获取用于模糊匹配的文本。本函数应接
				受一个字典项目作为参数，并返回该项目中用于模糊
				匹配的文本。

		{str} 视作字符串常量，_不_会进行正则表达式匹配。{str} 能接受的
		最大长度为 256。

		{str} 包含由空白分隔的多个单词时，返回的列表仅包含那些同时包含
		所有这些单词的字符串。

		如果没有字符串匹配、有出错、或者 {str} 的长度超过 256，返回空
		列表。

		{limit} 给出时，matchfuzzy() 会在 {list} 中寻找不超过指定限额
		的匹配项，排序后返回。

		关于模糊匹配，详见 |fuzzy-matching| 。

		示例: >
		   :echo matchfuzzy(["clay", "crow"], "cay")
<		返回 ["clay"]. >
		   :echo getbufinfo()->map({_, v -> v.name})->matchfuzzy("ndl")
<		返回和 "ndl" 模糊匹配的缓冲区名列表。 >
		   :echo getbufinfo()->matchfuzzy("ndl", {'key' : 'name'})
<		返回名字和 "ndl" 模糊匹配的缓冲区信息字典的列表。 >
		   :echo getbufinfo()->matchfuzzy("spl",
						\ {'text_cb' : {v -> v.name}})
<		返回名字和 "spl" 模糊匹配的缓冲区信息字典的列表。 >
		   :echo v:oldfiles->matchfuzzy("test")
<		返回和 "test" 模糊匹配的文件名的列表。 >
		   :let l = readfile("buffer.c")->matchfuzzy("str")
<		返回在 "buffer.c" 文件中，和 "str" 模糊匹配的行的列表。 >
		   :echo ['one two', 'two one']->matchfuzzy('two one')
<		返回 ['two one', 'one two']。 >
		   :echo ['one two', 'two one']->matchfuzzy('two one',
						\ {'matchseq': 1})
<		返回 ['two one']。

		返回类型: list<string> 或 list<any>


matchfuzzypos({list}, {str} [, {dict}])			*matchfuzzypos()*
		和 |matchfuzzy()| 类同，但返回一个包含三个子列表项的列表，分别
		为，由匹配字符串组成的列表、由 {str} 中匹配字符的字符位置组成
		的列表、以及由匹配分数组成的列表。可用 |byteidx()| 把字符位置
		转为字节位置。

		{str} 在字符串中有多个匹配时，仅返回对应最佳匹配的那组字符位
		置。

		如果没有字符串匹配或有出错，返回包含三个空子列表项的列表。

		示例: >
			:echo matchfuzzypos(['testing'], 'tsg')
<		返回 [['testing'], [[0, 2, 6]], [99]] >
			:echo matchfuzzypos(['clay', 'lacy'], 'la')
<		返回 [['lacy', 'clay'], [[0, 1], [1, 2]], [153, 133]] >
			:echo [{'text': 'hello', 'id' : 10}]
			  \ ->matchfuzzypos('ll', {'key' : 'text'})
<		返回 [[{'id': 10, 'text': 'hello'}], [[2, 3]], [127]]

		返回类型: list<list<any>>


matchlist({expr}, {pat} [, {start} [, {count}]])	*matchlist()*
		和 |match()| 类同，但返回 |List|。列表第一项是匹配字符串，和
		|matchstr()| 的返回值相同。其后的列表项为子匹配项，类似
		|:substitute| 的 "\1"、"\2" 等。如果某个可选的子匹配项空缺，对
		应的位置会用空串填充。例如: >
			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
<		返回: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']
		如果没有匹配，返回空列表。

		本函数也支持传入列表，但没什么实际用处 (译者注: 返回匹配的首个
		列表项内容后跟 9 个空串)。

		也可用作 |method|: >
			GetText()->matchlist('word')
<
		返回类型: list<string> 或 list<any>


matchstr({expr}, {pat} [, {start} [, {count}]])		*matchstr()*
		和 |match()| 类同，但返回匹配的字符串而非索引。例如: >
			:echo matchstr("testing", "ing")
<		返回 "ing"。
		如果没有匹配，返回 ""。
		{start} 给出时，其用法和 |match()| 中的 {start} 参数相同。 >
			:echo matchstr("testing", "ing", 2)
<		返回 "ing"。 >
			:echo matchstr("testing", "ing", 5)
<		返回 ""。
		{expr} 为 |List| 时，返回匹配的列表项。返回值保持原有类型，因
		而不一定是字符串。

		也可用作 |method|: >
			GetText()->matchstr('word')
<
		返回类型: |String|


matchstrlist({list}, {pat} [, {dict}])			*matchstrlist()*
		返回 {list} 里所有匹配 {pat} 的项目组成的 |List|。
		{list} 必须为字符串 |List|。而 {pat} 用来匹配 {list} 中的每个
		字符串。

		{dict} 参数支持以下项目:
		    submatches	为真则包含子匹配项信息 (|/\(|)

		返回列表中，对应每个匹配项，返回包含以下条目的 |Dict|:
		    byteidx	匹配起始位置的字节索引。
		    idx		匹配所在的 {list} 列表项的索引。
		    text	匹配内容字符串。
		    submatches	子匹配项列表。仅当 {dict} 里的 "submatches" 设
				为 v:true 时才会返回。

		|match-pattern| 说明模式相关选项设定的效果。

		示例: >
		    :echo matchstrlist(['tik tok'], '\<\k\+\>')
		    [{'idx': 0, 'byteidx': 0, 'text': 'tik'},
		     {'idx': 0, 'byteidx': 4, 'text': 'tok'}]
		    :echo matchstrlist(['a', 'b'], '\<\k\+\>')
		    [{'idx': 0, 'byteidx': 0, 'text': 'a'},
		     {'idx': 1, 'byteidx': 0, 'text': 'b'}]
<
		{submatch} 给出且为 v:true 时，返回字典中还会出现 "submatches"
		条目，包含 "\1"、"\2" 等子匹配项组成的列表。例如: >
		    :echo matchstrlist(['acd'], '\(a\)\?\(b\)\?\(c\)\?\(.*\)',
						\ #{submatches: v:true})
		    [{'idx': 0, 'byteidx': 0, 'text': 'acd',
		      'submatches': ['a', '', 'c', 'd', '', '', '', '', '']}]
<		"submatches" 列表永远包含 9 个项目。如果某个子匹配项空缺，对应
		的位置会返回空串。

		也可用作 |method|: >
			GetListOfStrings()->matchstrlist('mypat')
<
		返回类型: list<dict<any>> 或 list<any>


matchstrpos({expr}, {pat} [, {start} [, {count}]])	*matchstrpos()*
		和 |matchstr()| 类同，但同时返回匹配的字符串以及匹配的始末位
		置。例如: >
			:echo matchstrpos("testing", "ing")
<		返回 ["ing", 4, 7]。
		如果没有匹配，返回 ["", -1, -1]。
		{start} 给出时，其用法和 |match()| 中的 {start} 参数相同。 >
			:echo matchstrpos("testing", "ing", 2)
<		返回 ["ing", 4, 7]。 >
			:echo matchstrpos("testing", "ing", 5)
<		返回 ["", -1, -1]。
		{expr} 为 |List| 时，返回匹配的列表项内容、匹配 {pat} 的首个列
		表项的索引，匹配的开始位置以及匹配的结束位置。 >
			:echo matchstrpos([1, '__x'], '\a')
<		返回 ["x", 1, 2, 3]。
		返回值保持原有类型，因而不一定是字符串。

		也可用作 |method|: >
			GetText()->matchstrpos('word')
<
		返回类型: list<any>


max({expr})						*max()*
		返回 {expr} 中所有元素的最大值。例如: >
			echo max(["apples", "pears", "oranges"])

<		{expr} 可为 |List|、|Tuple| 或 |Dictionary|。为字典时，返回字
		典中所有值的最大值。如果 {expr} 不是列表、元组或字典，或者其中
		某个元素不能用作数值，报错。空 |List|、|Tuple| 或 |Dictionary|
		返回零。

		也可用作 |method|: >
			mylist->max()
<
		返回类型: any，取决于 {expr}


menu_info({name} [, {mode}])				*menu_info()*
		返回指定模式 {mode} 下的名为 {name} 的菜单项信息。须指定不带快
		捷键字符 ('&') 的菜单名。{name} 为 "" 时，返回顶层菜单名列表
		(译者注: 返回字典中仅有 submenus 项，包含所有的顶层菜单名)。

		{mode} 可为下列字符串之一:
			"n"	普通模式
			"v"	可视模式 (包括选择模式)
			"o"	操作符等待模式
			"i"	插入模式
			"c"	命令行模式
			"s"	选择模式
			"x"	可视模式
			"t"	终端作业模式
			""	普通、可视和操作符等待模式
			"!"	插入和命令行模式
		{mode} 省略时使用 "" 作为模式。

		返回包含以下条目的 |Dictionary|:
		  accel		菜单项加速文本 |menu-text|
		  display	显示名 (不带 '&' 的名字)
		  enabled	该菜单项处于打开状态则为 v:true
				参见 |:menu-enable|
		  icon		图标文件名 (用于工具栏) |toolbar-icon|
		  iconidx	内建图标的索引
		  modes		该菜单项所属的模式。除了上列的模式以外，还可用
				以下字符:
				" "	普通、可视和操作符等待模式
		  name		菜单项名。
		  noremenu	菜单项的 {rhs} 不能重映射则为 v:true，否则为
				v:false。
		  priority	菜单项的顺序优先级 |menu-priority|
		  rhs		菜单项的右侧内容。返回字符串中的特殊字符会按与
				":menu" 命令列表输出同样的方式进行翻译。当菜单
				的 {rhs} 为空时，返回 "<Nop>"。
		  script	{rhs} 允许局部于脚本的重映射则为 v:true，否则
				为 v:false。见 |:menu-script|。
		  shortcut	快捷键 (即菜单名中 '&' 后面的字符)
				|menu-shortcut|
		  silent	菜单项创建时如果使用了 <silent> 参数则为
				v:true |:menu-silent|
		  submenus	所有子菜单名组成的 |List|。仅当菜单项有子菜单
				时才会出现。

		如果未找到对应的菜单项，返回空字典。

		示例: >
			:echo menu_info('Edit.Cut')
			:echo menu_info('File.Save', 'n')

			" 显示缓冲区里的整个菜单树
			func ShowMenu(name, pfx)
			  let m = menu_info(a:name)
			  call append(line('$'), a:pfx .. m.display)
			  for child in m->get('submenus', [])
			    call ShowMenu(a:name .. '.' .. escape(child, '.'),
							\ a:pfx .. '    ')
			  endfor
			endfunc
			new
			for topmenu in menu_info('').submenus
			  call ShowMenu(topmenu, '')
			endfor
<
		也可用作 |method|: >
			GetMenuName()->menu_info('v')
<
		返回类型: dict<any>


min({expr})						*min()*
		返回 {expr} 中所有元素的最小值。例如: >
			echo min(["apples", "pears", "oranges"])

<		{expr} 可为 |List|、|Tuple| 或 |Dictionary|。为字典时，返回字
		典中所有值的最小值。如果 {expr} 不是列表、元组或字典，或者其中
		某个元素不能用作数值，报错。空 |List|、|Tuple| 或 |Dictionary|
		返回零。

		也可用作 |method|: >
			mylist->min()
<
		返回类型: any，取决于 {expr}


mkdir({name} [, {flags} [, {prot}]])			*mkdir()* *E739*
		创建目录 {name}。

		{flags} 给出时，必须为字符串。空串无效果。

		{flags} 包含以下字符标志位:
		 "p"	必要时会建立中间目录
		 "D"	当前函数结束时会删除 {name}，但不会递归删除 |:defer|
		 "R"	当前函数结束时会递归删除 {name} |:defer|

		注意 {name} 拥有多个路径层级且使用 "p" 标志位时，有些中间目录
		可能已经存在。此时只有实际新创建的那一层目录及其下创建的目录会
		被调度删除。如用: >
			call mkdir('subdir/tmp/autoload', 'pR')
<		而 "subdir" 已存在时，那么被调度删除的将是 "subdir/tmp"，相当
		于: >
			defer delete('subdir/tmp', 'rf')
<		注意 如果延迟删除的调度操作失败，目录将不会被删除。这种情况应
		该只有内存溢出时才会出现。

		{prot} 给出时，用于设置新目录的权限。缺省为 0o755 (rwxr-xr-x:
		用户自己可读写，其他人可读)。用 0o700 可使其他人不可读。此权限
		只用于新创建的目录。注意: 在 Unix 上，{prot} 会受到 umask 的影
		响。
		示例: >
			:call mkdir($HOME .. "/tmp/foo/bar", "p", 0o700)

<		该函数在沙盘里不可用 |sandbox|。

		如果目录已存在且传递了 "p" 标志位，不会报错 (从 Vim 8.0.1708
		起生效)。如果没有 "p" 标志位，同样操作会失败。

		调用成功时返回 TRUE，目录创建失败或部分失败则返回 FALSE。

		未必在所有系统上都支持。要确认当前系统上是否可用，可以使用: >
			:if exists("*mkdir")

<		也可用作 |method|: >
			GetName()->mkdir()
<
		返回类型: |Number|


mode([{expr}])						*mode()*
		返回指示当前 Vim 模式的字符串。
		{expr} 给出且其计算结果为非零数值或非空字符串时
		(|non-zero-arg|)，返回完整模式名，否则，只返回模式首个字母。
		另见 |state()|。

		   n	    普通模式
		   no	    操作符等待模式
		   nov	    操作符等待模式 (强制面向字符 |o_v|)
		   noV	    操作符等待模式 (强制面向行 |o_V|)
		   noCTRL-V 操作符等待模式 (强制面向列块 |o_CTRL-V|)；
				CTRL-V 此处是单个字符
		   niI	    |Insert-mode| 用 |i_CTRL-O| 进入的普通模式
		   niR	    |Replace-mode| 用 |i_CTRL-O| 进入的普通模式
		   niV	    |Virtual-Replace-mode| 用 |i_CTRL-O| 进入的普通模
			    式
		   nt	    终端普通模式 (启动插入时会转到终端作业模式)
		   v	    面向字符的可视模式
		   vs	    选择模式用 |v_CTRL-O| 进入的面向字符的可视模式
		   V	    面向行的可视模式
		   Vs	    选择模式用 |v_CTRL-O| 进入的面向行的可视模式
		   CTRL-V   面向列块的可视模式
		   CTRL-Vs  选择模式用 |v_CTRL-O| 进入的面向列块的可视模式
		   s	    面向字符的选择模式
		   S	    面向行的选择模式
		   CTRL-S   面向列块的选择模式
		   i	    插入模式
		   ic	    插入模式补全 |compl-generic|
		   ix	    插入模式 |i_CTRL-X| 补全
		   R	    替换模式 |R|
		   Rc	    替换模式补全 |compl-generic|
		   Rx	    替换模式 |i_CTRL-X| 补全
		   Rv	    虚拟替换模式 |gR|
		   Rvc	    虚拟替换模式补全 |compl-generic|
		   Rvx	    虚拟替换模式 |i_CTRL-X| 补全
		   c	    命令行编辑模式
		   ct	    终端作业模式下的命令行编辑模式
		   cr	    命令行编辑替换模式 |c_<Insert>|
		   cv	    Vim Ex 模式 |gQ|
		   cvr	    Vim Ex 替换模式 |c_<Insert>|
		   ce	    普通 Ex 模式 |Q|
		   r	    hit-enter 提示
		   rm	    -- more -- 提示
		   r?	    |:confirm| 及类似命令的查询
		   !	    执行外壳或外部命令时
		   t	    终端作业模式: 键入传给作业时

		可用于 'statusline' 选项 (译者注: 另见 'showmode') 或
		|remote_expr()|。在多数其它情况下，本函数只会返回 "c" 或 "n"。
		注意 将来可能会加入更多模式和更多特定模式。因此，建议不要直接
		和整个字符串作比较，最好只比较开头一个或几个字符。
		另见 |visualmode()|。

		也可用作 |method|: >
			DoFull()->mode()
<
		返回类型: |String|


mzeval({expr})						*mzeval()*
		运行 MzScheme 表达式 {expr}，把返回值转换为对应的 Vim 数据类
		型。
		数值和字符串按原样返回。
		组对 (pair) (包含列表 (list) 和非常规列表 (improper list)) 和
		向量 (vector) 会转换为 Vim |List|。
		哈希表 (hash table) 会转换为 Vim |Dictionary|，其键会转换为字
		符串。
		所有其它类型都会根据 display 函数的返回值转换为字符串。
		示例: >
		    :mz (define l (list 1 2 3))
		    :mz (define h (make-hash)) (hash-set! h "list" l)
		    :echo mzeval("l")
		    :echo mzeval("h")
<
		注意 `:def` 定义的函数内部的局部变量对 {expr} 不可见。

		也可用作 |method|: >
			GetExpr()->mzeval()
<
		返回类型: any，取决于 {expr}

		{仅当编译时带 |+mzscheme| 特性才有效}


nextnonblank({lnum})					*nextnonblank()*
		从第 {lnum} 行开始查找，返回首个非空白行 (译者注: 空白行指仅由
		空格或制表符组成的行，和空行不同) 的行号。例如: >
			if getline(nextnonblank(1)) =~ "Java"
<		如果 {lnum} 非法，或者从该行开始都没有非空白行，返回零。
		{lnum} 用法可见 |getline()|。
		另见 |prevnonblank()|。

		也可用作 |method|: >
			GetLnum()->nextnonblank()
<
		返回类型: |Number|


ngettext({single}, {plural}, {number}[, {domain})	*ngettext()*
		根据语言的单复数形式规则 (译者注: {single} 指定单数形式的消
		息，{plural} 指定复数形式的消息，{number} 指定消息所指事物的数
		量。注意 有些语言有多种复数形式，具体翻译结果可能取决于数量。
		另外，如果找不到当前语言对 {single} 的翻译，则在 {number} 为 1
		时返回 {single}，否则返回 {plural}，不经翻译)，返回指定消息正
		确的翻译字符串。例如: >
			ngettext("File", "Files", 2)  # 返回 "Files"
<
		也可用作 |method| (译者注: 基是作为第三个参数传递的): >
			1->ngettext("File", "Files")  # 返回 "File"
<
		{domain} 参数可见 |gettext()|。

		返回类型: |String|


nr2char({expr} [, {utf8}])				*nr2char()*
		返回单字符字符串，字符的数值为 {expr}。例如: >
			nr2char(64)		返回 "@"
			nr2char(32)		返回 " "
<		{utf8} 省略或为零时，使用当前 'encoding'。为 "utf-8" 时: >
			nr2char(300)		返回带有弓形的 I "Ĭ"
<		{utf8} 为 TRUE 时，则总返回 utf-8 字符。
		注意 文件中的 NUL 字符须用 nr2char(10) 来指定。因为 NUL 在 Vim
		内部用换行符来表示。本来，nr2char(0) 才是真正的 NUL，但 NUL 会
		终结字符串，因而结果会变成空串。
		要把字符值组成的列表转换为字符串，可用: >
		    let list = [65, 66, 67]
		    let str = join(map(list, {_, val -> nr2char(val)}), '')
<		结果是: "ABC"

		也可用作 |method|: >
			GetNumber()->nr2char()
<
		返回类型: |String|


or({expr}, {expr})					*or()*
		对两个参数进行按位或。参数会被转换为数值。参数如果是列表、字典
		或浮点数会报错。
		另见 `and()` 和 `xor()`。
		示例: >
			:let bits = or(bits, 0x80)
<		也可用作 |method|: >
			:let bits = bits->or(0x80)

<		理据: 之所以要定义函数，而不是像很多语言那样直接使用 "|" 字符
		作为操作符，是因为 Vi 传统上一直用 "|" 来分隔命令。在很多情况
		下，判断 "|" 是操作符还是命令分隔符容易产生歧义。

		返回类型: |Number|


pathshorten({path} [, {len}])				*pathshorten()*
		将路径 {path} 里的各层目录名缩短并返回其结果。路径尾部的文件名
		保持不变。路径中的其余部分则都会被缩短为 {len} 个字符。{len}
		省略或小于 1 时，默认为 1 (保留单个字母)。每个部分中，如果有引
		导的 '~' 和 '.'，它们不受影响。例如: >
			:echo pathshorten('~/.vim/autoload/myfile.vim')
<			~/.v/a/myfile.vim ~
>
			:echo pathshorten('~/.vim/autoload/myfile.vim', 2)
<			~/.vi/au/myfile.vim ~
		该路径是否实际存在无关紧要。
		如果出错，返回空串。

		也可用作 |method|: >
			GetDirectories()->pathshorten()
<
		返回类型: |String|


perleval({expr})					*perleval()*
		在标量上下文下运行 Perl 表达式 {expr}，把返回值转换为对应的
		Vim 数据类型。如果返回值转换失败，会返回其 Perl 表示方式，类型
		为字符串。
		备注: 如果需要数组或哈希表，{expr} 必须返回其引用。
		例如: >
			:echo perleval('[1 .. 4]')
<			[1, 2, 3, 4]

		注意 `:def` 定义的函数内部的局部变量对 {expr} 不可见。

		也可用作 |method|: >
			GetExpr()->perleval()
<
		返回类型: any，取决于 {expr}

		{仅当编译时加入 |+perl| 特性才有效}


popup_ 函数文档在这里: |popup-functions|


pow({x}, {y})						*pow()*
		返回 {x} 的 {y} 次方，类型为 |Float|。
		{x} 和 {y} 的计算结果必须是 |Float| 或 |Number|。否则返回
		0.0。
		示例: >
			:echo pow(3, 3)
<			27.0 >
			:echo pow(2, 16)
<			65536.0 >
			:echo pow(32, 0.20)
<			2.0

		也可用作 |method|: >
			Compute()->pow(3)
<
		返回类型: |Number|


preinserted()						*preinserted()*
		因为 'completeopt' 包含 "preinsert"，或 'completeopt' 包含
		"longest" 且 'autocomplete' 已激活，从而在光标之后插入了文本
		(即预输入) 后，返回非零值。否则返回零。

		返回类型: |Number|


prevnonblank({lnum})					*prevnonblank()*
		从第 {lnum} 行开始反向查找，返回首个非空白行 (译者注: 空白行见
		|nextnonblank()|) 的行号。例如: >
			let ind = indent(prevnonblank(v:lnum - 1))
<		如果 {lnum} 非法，或者从首行到该行都没有非空白行，返回零。
		{lnum} 用法可见 |getline()|。
		另见 |nextnonblank()|。

		也可用作 |method|: >
			GetLnum()->prevnonblank()
<
		返回类型: |Number|


printf({fmt}, {expr1} ...)				*printf()*
		按照 {fmt} 指定的格式化字符串进行排版，其中每个 "%" 项被对应的
		参数排版后的形式替换。返回排版后的字符串。例如: >
			printf("%4d: E%d %.30s", lnum, errno, msg)
<		可能的返回结果:
			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~

		也可用作 |method|，基是作为第二个参数传递的: >
			Compute()->printf("result: %d")
<
		要以列表形式来传递所有的参数，可用 `call()`。

		常用的项目有:
		  %s	字符串
		  %6S	右对齐到 6 个显示单元的字符串
		  %6s	右对齐至 6 个字节的字符串
		  %.9s  截短到 9 个字节的字符串
		  %c    单个字节
		  %d    十进制数
		  %5d   十进制数，用空格补足到 5 个字符
		  %x    十六进制数
		  %04x  十六进制数，用 0 补足到 4 个字符
		  %X    十六进制数，用大写的十六进制字母
		  %o    八进制数
		  %08b	二进制数，用 0 补足到 8 个字符
		  %f	浮点数，形如 12.23、inf、-inf 或 nan
		  %F	浮点数，形如 12.23、INF、-INF 或 NAN
		  %e	浮点数，形如 1.23e3、inf、-inf 或 nan
		  %E	浮点数，形如 1.23E3、INF、-INF 或 NAN
		  %g    浮点数，根据其值大小，选择使用 %f 或 %e 格式
		  %G    浮点数，根据其值大小，选择使用 %F 或 %E 格式
		  %%    % 字符本身

		转换规格说明以 '%' 开始，以转换类型结束。所有其它的字符会按原
		样复制到结果中。

		转换规格说明以 "%" 开始。其后的参数依序如下:

		      % [pos-argument] [flags] [field-width] [.precision] type

		pos-argument
			不多于一个的位置参数标识符。形式为 {n$}，其中 n >= 1。

		flags
			零或多个下列标志位:

		    #	      使用 "替代形式" 进行转换。对 c、d 和 s 转换，此
			      选项没有效果。对 o 转换，会加宽数值的精度域，使
			      得输出字符串的首个字符总是 0 (除非显示的值为零，
			      且显式使用精度 0)。
			      对 b 和 B 转换，非零值会在前面加上字符串 "0b"
			      (如果是 B 转换，则加 "0B")。
			      对 x 和 X 转换，非零值会在前面加上字符串 "0x"
			      (如果是 X 转换，则加 "0X")。

		    0 (零)    以 0 填充。所有的转换都会在值的左侧补 0 而不是补
			      空格。对数值类型 (d、b、B、o、x 和 X) 转换，如果
			      和精度同时给出，精度优先。

		    -	      负域宽度标志位；转换后的值被左对齐到字段边界上。
			      而右侧用空格填充，而不是在左侧用空格或 0 填充。
			      如果和 0 标志位同时给出，本标志位优先。

		    ' ' (空格)
			      对带符号转换 (d)，如果为正数在左侧加上空格。

		    +	      对带符号转换，数值之前总加上符号。如果和空格标志
			      位同时给出，本标志位优先。

		field-width
			可选的十进制数字串，指定最小字段宽度。如果转换后的值的
			字节数不足该宽度，在左侧 (如果给定左对齐标志位，则在右
			侧) 用空格填充到字段宽度。对 S 转换，字段宽度则以显示
			单元计数。

		.precision
			可选的精度，形式为句号 '.' 后跟一个可选的数字串。数字
			串省略时假设精度为零。对 d、o、x 和 X 转换，精度指定显
			示的最少数字位数、对 s 转换，指定显示字符串的最大字符
			数，对 S 转换，指定显示字符串的最大显示单元数。对浮点
			数，指定小数点后的位数。

		type
			单个字符，指定要进行的转换类型，见下。

		字段宽度和精度 (或两者) 都可以用星号 '*' 代替数字串。此时，会
		由一个数值参数来指定字段宽度或精度。负值的字段宽度视作指定左对
		齐标志位并用其绝对值作为字段宽度；负值的精度会被忽略。例如: >
			:echo printf("%d: %.*s", nr, width, line)
<		会限制 "line" 指定文本的显示长度，不超过由 "width" 指定的字符
		数。

		如果要排版的参数同时使用了位置参数标识符和 '*' 来指示需要数值
		参数来指定宽度或精度，则后者也必须指定 {n$} 形式的位置参数标识
		符。见 |printf-$|。

		转换标识符和它们的含义如下:

				*printf-d* *printf-b* *printf-B* *printf-o*
				*printf-x* *printf-X*
		dbBoxX	数值参数被转换为其带符号十进制 (d)，无符号二进制 (b 和
			B)、无符号八进制 (o) 或无符号十六进制 (x 和 X) 记法。x
			转换采用字母 "abcdef"；而 X 转换采用 "ABCDEF" 字母。
			精度给出时会指定显示的最少数字位数；如果转换后的值不需
			要那么多数位，左侧会用 0 填充。
			无论何种情况，数值字段都不会因为未给出或者小于实际宽度
			的字段宽度所截短；如果转换后的值宽于指定的字段宽度，字
			段会自动扩展以容纳该值。
			'h' 修饰符指示参数为 16 位。
			'l' 修饰符指示参数为长整型，具体是 32 位还是 64 位取决
			于你的系统。
			'll' 修饰符指示参数为 64 位。
			b 和 B 转换标识符不接受宽度修饰符，默认为 64 位整型。
			这些修饰符通常用处不大。如果类型可从参数推知，修饰符将
			被忽略。

		i	d 的别名
		D	ld 的别名
		U	lu 的别名
		O	lo 的别名

							*printf-c*
		c	数值参数被转换为字节，写入相应的字符。

							*printf-s*
		s	对字符串参数，使用其文本。精度给出时，使用不多于给定数
			目的字节数。
			对非字符串参数，使用与 ":echo" 相同的格式把它自动转换
			为文本。
							*printf-S*
		S	对字符串参数，使用其文本。精度给出时，使用不多于给定数
			目的显示单元数。

							*printf-f* *E807*
		f F	浮点数参数被转换为形如 123.456 的字符串。精度指定小数
			点后面的位数。精度为零时省略小数点本身。精度省略时缺省
			为 6。极大数 (超出范围或被零除的结果) 用 %f 会显示
			"inf" 或 "-inf" (%F 则相应显示 INF 或 -INF)。
			"0.0 / 0.0" 用 %f 会显示 "nan" (%F 则显示 NAN)。
			示例: >
				echo printf("%.2f", 12.115)
<				12.12
			注意 舍入方式取决于系统库。如果不确定，可用
			|round()|。

							*printf-e* *printf-E*
		e E	浮点数参数被转换为形如 1.234e+03 (用 'E' 的话则为
			1.234E+03) 的字符串。精度指定小数点后面的位数，和 'f'
			一样。

							*printf-g* *printf-G*
		g G	浮点数参数在 0.001 (含) 和 10000000.0 (不含) 之间时采
			用 'f' 转换，否则采用 'e' (用 'g' 时) 或 'E' (用 'G'
			时) 转换。精度省略时，除了小数点之后的那个零以外，不显
			示多余的零和 '+' 号。因而，10000000.0 会显示为 1.0e7。

							*printf-%*
		%	写入 '%'。不接受参数。这里完整的转换规格说明是 "%%"。

		对于期待数值参数的标识符，也接受字符串参数并进行自动转换。
		对于期待浮点数或字符串参数的标识符，也接受数值参数并进行自动转
		换。
		其它参数类型都会报错。

							*E766* *E767*
		{exprN} 参数的数量必须和 "%" 项目的数量完全匹配。不论参数不足
		还是过多，都会报错。至多可用 18 个参数。

							*printf-$*
		在某些语言中，为了提高可读性，错误和资讯消息可能需要使用与英语
		原文不同的单词顺序。为此，可用位置参数来完成调换单词顺序的翻
		译。例如: >

		    #, c-format
		    msgid "%s returning %s"
		    msgstr "返回值 %2$s 来自 %1$s"
<
		此例中，输出句子里的两个字符串参数颠倒了顺序。 >

		    echo printf(
			"In The Netherlands, vim's creator's name is: %1$s %2$s",
			"Bram", "Moolenaar")
<		    In The Netherlands, vim's creator's name is: Bram Moolenaar >

		    echo printf(
			"In Belgium, vim's creator's name is: %2$s %1$s",
			"Bram", "Moolenaar")
<		    In Belgium, vim's creator's name is: Moolenaar Bram

		可用 '*' 标识符来通过参数指定宽度 (还有精度)。此时，如果字段使
		用了位置参数，字段宽度 (精度) 也必须使用位置参数。 >

		    echo printf("%1$*2$.*3$d", 1, 2, 3)
<		    001 >
		    echo printf("%2$*3$.*1$d", 1, 2, 3)
<		      2 >
		    echo printf("%3$*1$.*2$d", 1, 2, 3)
<		    03 >
		    echo printf("%1$*2$.*3$g", 1.4142, 2, 3)
<		    1.414

		可以通过混合直接值或者位置参数来给出宽度和/或精度: >

		    echo printf("%1$4.*2$f", 1.4142135, 6)
<		    1.414214 >
		    echo printf("%1$*2$.4f", 1.4142135, 6)
<		    1.4142 >
		    echo printf("%1$*2$.*3$f", 1.4142135, 6, 2)
<		      1.41

		字段宽度或精度过长导致字符串超过 1 MiB (1024*1024 = 1048576)
		个字符时。会出现溢出错误 |E1510|。

							*E1500*
		不能混合位置和非位置参数: >
		    echo printf("%s%1$s", "One", "Two")
<		    E1500: Cannot mix positional and non-positional arguments:
		    %s%1$s

							*E1501*
		格式化字符串里，位置参数不能被跳过: >
		    echo printf("%3$s%1$s", "One", "Two", "Three")
<		    E1501: format argument 2 unused in $-style format:
		    %3$s%1$s

							*E1502*
		[field-width] (或 [precision]) 可以重用相同的参数: >
		    echo printf("%1$d 带宽度 %2$d 显示为: %1$0*2$d", 1, 2)
<		    1 带宽度 2 显示为: 01

		但不能用于不同的类型: >
		    echo printf("%1$d 带宽度 %2$ld 显示为: %1$0*2$d", 1, 2)
<		    E1502: Positional argument 2 used as field width reused as
		    different type: long int/int

							*E1503*
		使用位置参数时，如果给出了错误位置，报错: >
		    echo printf("%1$d 带宽度 %2$d 显示为: %1$0*2$.*3$d", 1, 2)
<		    E1503: Positional argument 3 out of bounds: %1$d 带宽度
		    %2$d 显示为: %1$0*2$.*3$d

		有多个错误时，只报首个错误: >
		    echo printf("%1$0*2$.*3$d %4$d", 1, 2)
<		    E1503: Positional argument 3 out of bounds: %1$0*2$.*3$d
		    %4$d

							*E1504*
		位置参数可以重用: >
		    echo printf("%1$s %2$s %1$s", "一", "二")
<		    一 二 一

		但不能用于不同的类型: >
		    echo printf("%1$s %2$s %1$d", "一", "二")
<		    E1504: Positional argument 1 type used inconsistently:
		    int/string

							*E1505*
		格式化字符串的其他杂项错误会报此错: >
		    echo printf("%1$d 带宽度 %2$d 显示为: %01$*2$.3$d", 1, 2)
<		    E1505: Invalid format specifier: %1$d 带宽度 %2$d 显示为:
		    %01$*2$.3$d

							*E1507*
		此内部错误表示在解析位置格式参数时出现了已知错误之外的其他问
		题。请给 Vim 发送错误报告，并提供当时使用的完整格式化字符串和
		参数。

		返回类型: |String|


prompt_getprompt({buf})					*prompt_getprompt()*
		返回提示缓冲区 {buf} 的实际提示文本。{buf} 可为缓冲区名或号。
		见 |prompt-buffer|。

		如果缓冲区不存在或不是提示缓冲区，返回空串。

		也可用作 |method|: >
			GetBuffer()->prompt_getprompt()
<
		返回类型: |String|

		{仅当编译时加入 |+channel| 特性才有效}


prompt_setcallback({buf}, {expr})			*prompt_setcallback()*
		将提示缓冲区 {buf} 的提示回调设为 {expr}。{expr} 为空串时删除
		回调。只对 'buftype' 为 "prompt" 的 {buf} 有效。
		(译者注: {expr} 可为函数名、匿名函数、函数引用或偏函数)

		本回调会在按下回车时触发。此时当前缓冲区必然是提示缓冲区。在回
		调触发前，会加入一行新的提示行，因此，触发该回调的提示行将会成
		为倒数第二行。
		如果回调要为缓冲区增加新文本，必须在最后一行之前插入，因为末行
		将是当前提示所在的位置。此操作可以异步进行。
		调用回调时会传一个参数，给出用户在提示后输入的文本。如果用户直
		接按下回车，该参数将会是空串。
		示例: >
		   func s:TextEntered(text)
		     if a:text == 'exit' || a:text == 'quit'
		       stopinsert
		       " 复位 'modified'，这样缓冲区才可以被关闭。
		       " 此处假定没有值得保存的内容。
		       set nomodified
		       close
		     else
		       " 应用 "a:text" 的实际操作，此例只是重复显示一次。
		       call append(line('$') - 1, 'Entered: "' .. a:text .. '"')
		     endif
		   endfunc
		   call prompt_setcallback(bufnr(), function('s:TextEntered'))

<		也可用作 |method|: >
			GetBuffer()->prompt_setcallback(callback)

<		{仅当编译时加入 |+channel| 特性才有效}


prompt_setinterrupt({buf}, {expr})			*prompt_setinterrupt()*
		将提示缓冲区 {buf} 的中断回调设为 {expr}。{expr} 为空串时删除
		回调。只对 'buftype' 为 "prompt" 的 {buf} 有效。
		(译者注: {expr} 可为函数名、匿名函数、函数引用或偏函数)

		本回调会在插入模式下按 CTRL-C 时触发。如果没有设置回调，Vim 会
		像在其它缓冲区中一样直接退出插入模式。

		也可用作 |method|: >
			GetBuffer()->prompt_setinterrupt(callback)
<
		返回类型: |Number|

		{仅当编译时加入 |+channel| 特性才有效}


prompt_setprompt({buf}, {text})				*prompt_setprompt()*
		将提示缓冲区 {buf} 的提示文本设为 {text}。{text} 通常会以空格
		结尾。(译者注: 缺省提示文本为 "% ")
		结果只对 'buftype' 为 "prompt" 的 {buf} 可见。示例: >
			call prompt_setprompt(bufnr(), 'command: ')
<
		也可用作 |method|: >
			GetBuffer()->prompt_setprompt('command: ')
<
		返回类型: |Number|

		{仅当编译时加入 |+channel| 特性才有效}


prop_ 函数文档在这里: |text-prop-functions|

pum_getpos()						*pum_getpos()*
		如果没有弹出菜单 (见 |ins-completion-menu|) 可见，返回空
		|Dictionary|，否则返回包含弹出菜单相关条目的 |Dictionary|:
			height		可见项目的数目
			width		屏幕单元格数
			row		顶部屏幕行号 (首行行号为 0)
			col		最左侧屏幕列号 (首列列号为 0)
			size		项目总数
			scrollbar	滚动条为可见则为 |TRUE|

		这里的值和 |CompleteChanged| 事件触发时 |v:event| 中的对应值一
		致。

		返回类型: dict<any>


pumvisible()						*pumvisible()*
		弹出菜单可见时返回非零，否则返回零。见 |ins-completion-menu|。
		可以用来跳过某些操作，以免删除弹出菜单。

		返回类型: |Number|


py3eval({expr} [, {locals}])				*py3eval()*
		运行 Python 表达式 {expr}，把返回值转换为对应的 Vim 的数据类
		型。
		{locals} 字典给出时，定义在表达式中可用的局部变量。字典的键是
		变量名，而值是变量值。对于 |Dictionary|、|List| 和 |Tuple| 类
		型的值，它们会以引用形式传递，因此在表达式中可能会被修改 (类似
		于使用了 |python-bindeval| 时的行为)。
		数值和字符串按原样返回 (不过，字符串会先经过复制，对于 Unicode
		字符串，还会额外按照 'encoding' 指定的编码进行转换)。
		列表会返回 Vim |List| 类型。
		元组会返回 Vim |Tuple| 类型。
		字典会返回 Vim |Dictionary| 类型，字典的键会转换为字符串。
		注意 `:def` 定义的函数内部的局部变量对 {expr} 不可见。

		也可用作 |method|: >
			GetExpr()->py3eval()
			'b",".join(l)'->py3eval({'l': ['a', 'b', 'c']})
<
		返回类型: any，取决于 {expr}

		{仅当编译时加入 |+python3| 特性才有效}

							*E858* *E859*
pyeval({expr} [, {locals}])				*pyeval()*
		运行 Python 表达式 {expr}，把返回值转换为对应的 Vim 数据类型。
		{locals} 见 |py3eval()|。
		数值和字符串按原样返回 (字符串经过复制)。
		列表会返回 Vim |List| 类型。
		元组会返回 Vim |Tuple| 类型。
		字典会返回 Vim |Dictionary| 类型，如果出现非字符串键值，报错。
		注意 `:def` 定义的函数内部的局部变量对 {expr} 不可见。

		也可用作 |method|: >
			GetExpr()->pyeval()
<
		返回类型: any，取决于 {expr}

		{仅当编译时加入 |+python| 特性才有效}


pyxeval({expr} [, {locals}])				*pyxeval()*
		运行 Python 表达式 {expr}，把返回值转换为对应的 Vim 数据类型。
		{locals} 见 |py3eval()|。
		使用 Python 2 或 3，见 |python_x| 和 'pyxversion'。
		另见: |pyeval()|、|py3eval()|

		也可用作 |method|: >
			GetExpr()->pyxeval()
<
		返回类型: any，取决于 {expr}

		{仅当编译时加入 |+python| 或 |+python3| 特性才有效}


rand([{expr}])						*rand()* *random*
		用 {expr} 作为种子，使用 xoshiro128** 算法生成并返回一个伪随机
		数。返回值为 32 位数值，为了统一起见，即使是 64 位系统上也是如
		此。
		{expr} 可用 |srand()| 初始化，并在每次 rand() 调用时更新。
		{expr} 省略时，使用并更新一个内部的种子值。
		如果  {expr} 非法，返回 -1。

		示例: >
			:echo rand()
			:let seed = srand()
			:echo rand(seed)
			:echo rand(seed) % 16  " 随机数 0 - 15
<
		返回类型: |Number|

							*E726* *E727*
range({expr} [, {max} [, {stride}]])			*range()*
		返回数值的 |List|:
		- 仅给出 {expr} 时: [0, 1, ..., {expr} - 1]
		- 同时给出 {max} 时: [{expr}, {expr} + 1, ..., {max}]
		- 还给出 {stride} 时: [{expr}, {expr} + {stride}, ..., {max}]
		  (每次为 {expr} 递增 {stride}，但不会超过 {max})。
		如果最大值 {max} 恰好比开始值 {expr} 小一，返回空列表。如果再
		小，就会报错。
		例如: >
			range(4)		" [0, 1, 2, 3]
			range(2, 4)		" [2, 3, 4]
			range(2, 9, 3)		" [2, 5, 8]
			range(2, -2, -1)	" [2, 1, 0, -1, -2]
			range(0)		" []
			range(2, 0)		" 出错！
<
		也可用作 |method|: >
			GetExpr()->range()
<
		返回类型: list<number>


readblob({fname} [, {offset} [, {size}]])		*readblob()*
		以二进制方式读取文件 {fname}，并返回 |Blob|。
		{offset} 给出时，从指定的偏移开始读取文件。如果给出的是负值，
		指定从文件尾开始计算的偏移。如果要读取文件最后的 12 个字节: >
			readblob('file.bin', -12)
<		{size} 给出时，只读取指定的长度。如果要读取文件开始的 100 个字
		节: >
			readblob('file.bin', 0, 100)
<		{size} 为 -1 或省略时，读取从 {offset} 开始的全部数据。
		Unix 上，本函数也可用于从字符设备中读取数据，须显式指定 {size}。
		仅当设备支持定位时，才可指定 {offset}。否则必须将其设为零。例
		如要从串行终端读取 10 个字节: >
			readblob('/dev/ttyS0', 0, 10)
<		如果文件不能打开，，会报错并返回空 |Blob|。
		如果偏移超过文件尾，会返回空 blob。
		如果尝试读取的字节数超过实际可用的字节数，读取结果会被截短。
		另见 |readfile()| 和 |writefile()|。

		返回类型: |Blob|


readdir({directory} [, {expr} [, {dict}]])		*readdir()*
		返回 {directory} 中的文件和目录名的列表。如果不需要复杂的处
		理，如限制匹配的数目等，也可用 |glob()|。
		列表会经过排序 (排序时大小写敏感)，要改变排序的顺序，见下
		{dict} 参数。

		{expr} 省略时包含所有的项目。
		{expr} 给出时，会对每一项计算其值，以决定如何处理该项:
			{expr} 结果为 -1 时，不处理后续的项目。
			{expr} 结果为 0 时，不把本项加入列表。
			{expr} 结果为 1 时，把本项加入列表。
		总是排除 "." 和 ".." 项目 (译者注: 因而不会进行 {expr} 计算)。
		每次计算 {expr} 时，|v:val| 会被设为当前项目名。
		{expr} 是函数时，将当前项目名作为参数传递。例如，要获取所有以
		".txt" 结尾的文件列表: >
		  readdir(dirname, {n -> n =~ '.txt$'})
<		要跳过隐藏和备份文件: >
		  readdir(dirname, {n -> n !~ '^\.\|\~$'})
<							*E857*
		可选的 {dict} 参数允许更多自定义。目前可用于指定排序是否进行以
		及如何进行。此字典包含以下条目:

		    sort    如何对系统返回值进行排序。
			    合法值是:
				"none"	    不排序 (最快速的方法)
				"case"	    大小写敏感排序 (根据每个字符的字节
					    值，技术上使用 strcmp() 实现)
					    (这是缺省行为)
				"icase"	    大小写不敏感排序 (技术上使用
					    strcasecmp() 实现)
				"collate"   按 "POSIX" 或 "C" |locale| 的排序
					    规则排序 (技术上使用 strcoll() 实
					    现)
			    其它值会被忽略，但不会报错。

		例如，要获取当前目录下所有文件的列表，而不对各个文件排序: >
		  readdir('.', '1', #{sort: 'none'})
<		要想得到目录树: >
		  function! s:tree(dir)
		      return {a:dir : map(readdir(a:dir),
		      \ {_, x -> isdirectory(x) ?
		      \		 {x : s:tree(a:dir .. '/' .. x)} : x})}
		  endfunction
		  echo s:tree(".")
<
		如果出错，返回空列表。

		也可用作 |method|: >
			GetDirName()->readdir()
<
		返回类型: list<string> 或 list<any>


readdirex({directory} [, {expr} [, {dict}]])		*readdirex()*
		|readdir()| 的扩展版。
		返回 {directory} 中的文件和目录信息字典的列表。
		可用于在读取目录列表的同时获得这些文件和目录的属性。这比先调用
		|readdir()|，再对每个文件和目录分别调用 |getfperm()|、
		|getfsize()|、|getftime()| 和 |getftype()| 要快得多，尤其是在
		MS-Windows 上。
		列表缺省会按名字排序 (排序时大小写敏感)，可选的 {dict} 参数可
		用来改变排序的方式，见 |readdir()|。

		对每个文件和目录项目，返回的信息字典会包含以下条目:
			group	项目所在的组名。(仅用于 Unix)
			name	项目名。
			perm	项目权限。见 |getfperm()|。
			size	项目大小。见 |getfsize()|。
			time	项目时间戳。见 |getftime()|。
			type	项目类型。
				Unix 上，大致与 |getftype()| 相当，但有以下例
				外:
				    指向目录的符号链接	"linkd"
				    其它符号链接	"link"
				MS-Windows 上:
				    普通文件		"file"
				    目录		"dir"
				    连接点		"junction"
				    指向目录的符号链接	"linkd"
				    其它符号链接	"link"
				    其它重解析点	"reparse"
			user	项目拥有者的名字。(仅用于 Unix)
		Unix 上，项目是符号链接时，字典会包含链接目标的信息 ("type" 项
		除外)。MS-Windows 上，出于性能方面的原因，同样情况会包含的是符
		号链接本身的信息。

		{expr} 省略时包含所有的项目。
		{expr} 给出时，会对每一项计算其值，以决定如何处理该项:
			{expr} 结果为 -1 时，不处理后续的项目。
			{expr} 结果为 0 时，不把本项加入列表。
			{expr} 结果为 1 时，把本项加入列表。
		总是排除 "." 和 ".." 项目 (译者注: 因而不会进行 {expr} 计算)。
		每次计算 {expr} 时，|v:val| 会被设为当前项目的 |Dictionary|。
		{expr} 是函数时，将当前项目字典作为参数传递。例如，要获取所有
		以 ".txt" 结尾的文件列表: >
		  readdirex(dirname, {e -> e.name =~ '.txt$'})
<
		例如，要获取当前目录下所有文件的列表，而不对各个文件排序: >
		  readdirex(dirname, '1', #{sort: 'none'})
<
		也可用作 |method|: >
			GetDirName()->readdirex()
<
		返回类型: list<dict<any>> 或 list<any>


readfile({fname} [, {type} [, {max}]])			*readfile()*
		读取文件 {fname} 并返回文件行组成的 |List|。文件按 NL 字符分
		行。对于以 CR 分隔的 Macintosh 文件，会返回单个长行 (除非其中
		出现了 NL)。
		文件中的所有 NUL 字符会被 NL 字符替代。
		{type} 为 "b" 时，会使用二进制模式。此时:
		- 末行以 NL 结尾时，会附加额外的一个空列表项。
		- 不删除 CR 字符。
		否则的话:
		- 删除出现在 NL 之前的 CR 字符。
		- 末行是否以 NL 结尾没有影响。
		- 'encoding' 为 Unicode 编码时，删除文本中可能存在的 UTF-8 字
		  节顺序标识。
		{max} 给出时，指定读取的最大行数。可用于只想检查文件开始若干行
		这样的场合，例如前 10 行: >
			:for line in readfile(fname, '', 10)
			:  if line =~ 'Date' | echo line | endif
			:endfor
<		{max} 为负时，返回从文件尾部算起的 -{max} 行，行数不足时返回整
		个文件。
		如果 {max} 为零，返回空列表。
		注意 {max} 省略时，整个文件将被读到内存。
		也请 注意 这里不会自动识别文件编码。如有需要，可先把文件读到缓
		冲区里再进行处理。
		已废弃的功能 (请用 |readblob()| 替代): {type} 为 "B" 时，返回
		未经修改的文件二进制数据，类型为 |Blob|。
		如果文件不能打开，报错并返回空列表。
		另见 |writefile()|。

		也可用作 |method|: >
			GetFileName()->readfile()
<
		返回类型: list<string> 或 list<any>


redraw_listener_add({opts})				*redraw_listener_add()*
		添加回调函数形式的监听器，在重画周期的指定时间执行。
							*E1571*
		{opts} 是包含待定义回调函数的字典。必须提供至少一个回调。
		返回可用于传递给 |redraw_listener_remove()| 的唯一 ID。

		{opts} 可包含以下条目:

		    on_start	每次屏幕重画开始前先调用此回调。不接受参数，不
				返回任何值。
		    on_end	每次屏幕重画结束后调用此回调。不接受参数，不
				返回任何值。

		本函数的一个理想用途是与 unbuffered 参数设为 TRUE 的
		|listener_add()|配合使用。后者提供的回调可以在缓冲区发生改动时
		更新状态，而在下次即将重画前，本函数提供的回调仅在该状态发生变
		化时，才渲染该状态。试图在每次缓冲区改动时都渲染或重画将会非常
		低效。
							*E1570*
		在 {opts} 里定义的回调中，不能调用 redraw_listener_add()。

		也可用作 |method|: >
			GetOpts()->redraw_listener_add()
<
		返回类型: |Number|


redraw_listener_remove({id})				*redraw_listener_remove()*
		删除先前通过 |redraw_listener_add()| 添加的重画监听器。
		如果指定 {id} 的监听器不存在，返回 FALSE，成功移除监听器 {id}
		后返回 TRUE。

		也可用作 |method|: >
			GetRedrawListenerId()->redraw_listener_remove()
<
		返回类型: |Number|


reduce({object}, {func} [, {initial}])			*reduce()* *E998*
		对 {object} 中的每个项目调用 {func}，其中 {object} 可为
		|String|、|List|、|Tuple| 或 |Blob|。调用 {func} 时传入两个参
		数: 之前的累积结果和当前项目。处理完所有项目后，返回最终的累积
		结果。 *E1132*

		{initial} 为初始值。省略时使用 {object} 的首个项目作为初始值，
		而从第二个项目开始调用 {func}。如果 {initial} 未给出且
		{object} 为空，则无法计算结果，此时会报错 E998。

		示例: >
			echo reduce([1, 3, 5], { acc, val -> acc + val })
			echo reduce(['x', 'y'], { acc, val -> acc .. val }, 'a')
			echo reduce(0z1122, { acc, val -> 2 * acc + val })
			echo reduce('xyz', { acc, val -> acc .. ',' .. val })
<
		也可用作 |method|: >
			echo mylist->reduce({ acc, val -> acc + val }, 0)
<
		返回类型: |String|、|Blob|、list<{type}> 或 dict<{type}>，
		取决于 {object} 和 {func}


reg_executing()						*reg_executing()*
		返回当前正在执行的单字母寄存器名。如果没有正在执行的寄存器，返
		回空串。见 |@|。

		返回类型: |String|


reg_recording()						*reg_recording()*
		返回当前正在记录的单字母寄存器名。如果没有正在记录的寄存器，返
		回空串。见 |q|。

		返回类型: |String|


reltime()						*reltime()*
reltime({start})
reltime({start}, {end})
		返回一个表示时间值的项目。此项目为列表，其成员内容因系统而异。
		Vim 9 脚本中，其类型为 list<any>。
		此项目可被传递给 |reltimestr()| 以转换为字符串，或传递给
		|reltimefloat()| 以转换为浮点数。例如，要查看 Work() 函数花费
		的时间: >
			var startTime = reltime()
			Work()
			echo startTime->reltime()->reltimestr()
<
		参数省略时，返回当前时间 (具体表示方式依赖系统，不能用作挂钟
		(wall-clock) 时间，如果需要挂钟时间，可用 |localtime()|)。
		带一个参数时，返回从 {start} 到现在所经过的时间。
		带两个参数时，返回从 {start} 到 {end} 所经过的时间。
		{start} 和 {end} 参数必须为先前调用 reltime() 的返回值。
		如果出错，在老式脚本里会返回空列表，而在 Vim9 脚本里则会报错。

		也可用作 |method|: >
			GetStart()->reltime()
<
		返回类型: list<number>

		{仅当编译时加入 |+reltime| 特性才有效}


reltimefloat({time})					*reltimefloat()*
		返回代表 {time} 中的时间值的浮点数。
		示例: >
			let start = reltime()
			call MyFunction()
			let seconds = reltimefloat(reltime(start))
<		有关操作开销，可见 |reltimestr()| 处的注释。
		另见 |profiling|。
		如果出错，在老式脚本里会返回 0.0，而在 Vim9 脚本里会报错。

		也可用作 |method|: >
			reltime(start)->reltimefloat()
<
		返回类型: |Float|

		{仅当编译时加入 |+reltime| 特性才有效}


reltimestr({time})					*reltimestr()*
		返回代表 {time} 中的时间值的字符串。
		返回形式是秒数，后面紧跟一个句号和毫秒数。例如: >
			let start = reltime()
			call MyFunction()
			echo reltimestr(reltime(start))
<		注意 所有命令本身的额外开销也会计算在时间里。
		时间的准确度取决于系统。|reltimefloat()| 会给出最高准确度，在
		一些系统里可达纳秒级。
		返回结果会包含前导空格，方便字符串能更好地对齐。如果不需要前导
		空格，可用 |split()| 进行删除。 >
			echo split(reltimestr(reltime(start)))[0]
<		另见 |profiling|。
		如果出错，在老式脚本里会返回空串，而在 Vim9 脚本里会报错。

		也可用作 |method|: >
			reltime(start)->reltimestr()
<
		返回类型: |String|

		{仅当编译时加入 |+reltime| 特性才有效}

							*remote_expr()* *E449*
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
		发送 {string} 到 {server}。{server} 参数是字符串，另见
		|{server}|。

		待发送的字符串视作表达式，返回的是其在远端执行的结果。这个结果
		必须是字符串或 |List|。其它类型都会被转换为字符串。|List| 也会
		将各项用换行符连接转换成字符串 (末项之后不添加换行符)，就像用
		join(expr, "\n") 那样。

		{idvar} 给出且非空时，该参数应是一个变量名，调用后，返回的
		{serverid} 会保存在此变量中，供之后调用 |remote_read()| 时使
		用。

		{timeout} 给出时，在给定的秒数后读取超时。缺省超时为 600 秒。

		另见 |clientserver| |RemoteReply|。
		该函数在沙盘里不可用 |sandbox|。
		{仅当编译时加入 |+clientserver| 特性才有效}
		注意: 如果发生任何错误，错误信息都会在本地产生，并返回空串。

		变量都会在全局命名空间中计算，与当前激活的函数无关。只有在调试
		模式下，才会同时对函数局部变量和参数进行求值。

		例如: >
			:echo remote_expr("gvim", "2+2")
			:echo remote_expr("gvim1", "b:current_syntax")
<
		也可用作 |method|: >
			ServerName()->remote_expr(expr)
<
		返回类型: |String| 或 list<{type}>


remote_foreground({server})				*remote_foreground()*
		把名为 {server} 的 Vim 服务器带到前台。{server} 参数是字符串，
		另见 |{server}|。
		这相当于: >
			remote_expr({server}, "foreground()")
<		Win32 系统除外。该平台上由客户端完成实际操作，因为 Win32 系统
		不总是允许服务器将自己切换到前台。注意: 如果服务器窗口已最小
		化，该系统上不会自动恢复窗口，而 |foreground()| 则会。
		该函数在沙盘里不可用 |sandbox|。

		也可用作 |method|: >
			ServerName()->remote_foreground()
<
		返回类型: |Number|

		{仅可用在 Win32、Motif 和 GTK GUI 版本和 Win32 的控制台版本}


remote_peek({serverid} [, {retvar}])			*remote_peek()*
		{serverid} 有可用的字符串应答时，返回正值。{retvar} 给出时，复
		制任意一个 (如有多个) 应答字符串到 {retvar} 指定的变量。
		{retvar} 必须是一个指定变量名的字符串。
		没有可用的应答时，返回 0。
		如果出错，返回 -1。
		另见 |clientserver|。
		该函数在沙盘里不可用 |sandbox|。
		{仅当编译时加入 |+clientserver| 特性才有效}
		示例: >
		   :let repl = ""
		   :echo "PEEK: " .. remote_peek(id, "repl") .. ": " .. repl

<		也可用作 |method|: >
			ServerId()->remote_peek()
<
		返回类型: |Number|


remote_read({serverid}, [{timeout}])			*remote_read()*
		返回从 {serverid} 发送的存在时间最长的应答，并将其删除。除非给
		出了以秒为单位的 {timeout}，该调用会一直等待直到有应答为止。如
		果没有应答或出错，返回空串。
		另见 |clientserver|。
		该函数在沙盘里不可用 |sandbox|。
		{仅当编译时加入 |+clientserver| 特性才有效}
		例如: >
			:echo remote_read(id)

<		也可用作 |method|: >
			ServerId()->remote_read()
<
		返回类型: |String|


remote_send({server}, {string} [, {idvar}])		*remote_send()* *E241*
		发送 {string} 到 {server}。{server} 参数是字符串，另见
		|{server}|。

		发送的字符串为输入键的序列。函数立即返回。Vim 服务器端不会对键
		进行映射 |:map|。

		{idvar} 给出且非空时，该参数应是一个变量名，调用后，返回的
		{serverid} 会保存在此变量中，供之后调用 |remote_read()| 时使
		用。

		另见 |clientserver| |RemoteReply|。
		该函数在沙盘里不可用 |sandbox|。
		{仅当编译时加入 |+clientserver| 特性才有效}

		注意: 如果发生任何错误，错误信息都会在服务器端产生，并可能扰乱
		服务器的显示。
		例如: >
		:echo remote_send("gvim", ":DropAndReply " .. file,
		 \ "serverid") .. remote_read(serverid)

		:autocmd NONE RemoteReply *
		 \ echo remote_read(expand("<amatch>"))
		:echo remote_send("gvim", ":sleep 10 | echo " ..
		 \ 'server2client(expand("<client>"), "HELLO")<CR>')
<
		也可用作 |method|: >
			ServerName()->remote_send(keys)
<
		返回类型: |String|

							*remote_startserver()*
remote_startserver({name})				*E941* *E942*
		本进程将成为名为 {name} 的服务器。{name} 不能为空串。
		如果进程已作为服务器运行，也即 |v:servername| 不为空时，操作会
		失败。

		也可用作 |method|: >
			ServerName()->remote_startserver()
<
		返回类型: |Number|

		{仅当编译时加入 |+clientserver| 特性才有效}


remove({list}, {idx})					*remove()*
remove({list}, {idx}, {end})
		{end} 未给出时: 删除 {list} |List| 里索引为 {idx} 的列表项并返
		回该项目。
		{end} 给出时: 删除从指定索引区间 {idx} 到 {end} (闭区间) 的列
		表项，并返回这些项目组成的 |List|。如果 {idx} 和 {end} 指向相
		同列表项，返回单项目列表。而如果 {end} 指向在 {idx} 之前的项
		目，报错。
		|list-index| 说明 {idx} 和 {end} 可能的取值。
		如果出错，返回零。
		例如: >
			:echo "last item: " .. remove(mylist, -1)
			:call remove(mylist, 0, 9)
<
		要删除文件，请用 |delete()|。

		也可用作 |method|: >
			mylist->remove(idx)
<
		返回类型: any，取决于 {list}


remove({blob}, {idx})
remove({blob}, {idx}, {end})
		{end} 未给出时: 删除 {blob} |Blob| 里索引为 {idx} 的字节并返回
		该字节。
		{end} 给出时: 删除从从指定索引区间 {idx} 到 {end} (闭区间) 的
		字节，并返回这些字节构成的的 |Blob|。如果 {idx} 和 {end} 指向
		相同的字节，返回单字节构成的 |Blob|。而如果 {end} 指向在 {idx}
		之前的字节，报错。
		如果出错，返回零。
		示例: >
			:echo "last byte: " .. remove(myblob, -1)
			:call remove(mylist, 0, 9)
<
		返回类型: |Number|


remove({dict}, {key})
		删除 {dict} 里键为 {key} 的项目并返回其值。例如: >
			:echo "removed " .. remove(dict, "one")
<		如果 {dict} 里没有键 {key}，报错。
		如果出错，返回零。

		返回类型: any，取决于 {dict}


rename({from}, {to})					*rename()*
		将名为 {from} 的文件换名为 {to}。也可用来在文件系统间移动文
		件。文件成功换名时，返回零，失败则返回非零。
		注意 如果 {to} 文件已存在，原有文件被覆盖且没有警告。
		该函数在沙盘里不可用 |sandbox|。

		也可用作 |method|: >
			GetOldName()->rename(newname)
<
		返回类型: |Number|


repeat({expr}, {count})					*repeat()*
		将 {expr} 重复 {count} 次，并返回连接后的结果。例如: >
			:let separator = repeat('-', 80)
<		如果 {count} 为零或负，返回相应类型的空值。
		{expr} 为 |List|、|Tuple| 或 |Blob| 类型时，返回连接 {expr} 重
		复 {count} 次后的结果。例如: >
			:let longlist = repeat(['a', 'b'], 3)
<		会返回 ['a', 'b', 'a', 'b', 'a', 'b']。

		也可用作 |method|: >
			mylist->repeat(count)
<
		返回类型: |String|、|Blob|、list<{type}> 或 tuple<{type}>，取
		决于 {expr}


resolve({filename})					*resolve()* *E655*
		在 MS-Windows 上，当 {filename} 为快捷方式 (.lnk 文件) 时，返
		回简化后的快捷方式指向的路径。当 {filename} 为符号链接或连接点
		(junction point) 时，返回目的地的完整路径。如果该连接
		(junction) 的目的地已被删除，返回 {filename} 自身。
		在 Unix 上，会递归解析 {filename} 的所有路径部分的符号链接，直
		到得到最简化的路径为止。为避免循环链接，符号链接的解析最多进行
		100 次迭代。
		在其它系统上，返回简化后的 {filename}。
		路径简化的工作由 |simplify()| 完成。和 |simplify()| 一样，
		resolve() 会保留指向当前目录的首个路径部分 (只要结果仍然是相对
		路径)，也保留拖尾的路径分隔符。

		也可用作 |method|: >
			GetName()->resolve()
<
		返回类型: |String|


reverse({object})					*reverse()*
		反转 {object} 项目的顺序。{object} 必须是 |List|、|Tuple|、
		|Blob| 或者 |String|。对于列表或 blob，直接对 {object} 进行原
		位修改，返回 {object} 本身。
		对于元组，返回新元组。
		对于字符串，返回新字符串。
		如果 {object} 既不是列表、元组、blob，也不是字符串，返回零。
		对列表和 blob，如果不想更动原始输入，先创建备份: >
			:let revlist = reverse(copy(mylist))
<		也可用作 |method|: >
			mylist->reverse()
<
		返回类型: |String|、|Blob|、list<{type}> 或 tuple<{type}>，取
		决于 {object}


round({expr})						*round()*
		返回最接近于 {expr} 的整数，返回类型为 |Float|。如果 {expr} 恰
		好位于两个整数的正中间，选择 (译者注: 绝对值) 较大 (远离零) 的
		整数。
		{expr} 的计算结果必须是 |Float| 或 |Number|。否则返回 0.0。
		示例: >
			echo round(0.456)
<			0.0  >
			echo round(4.5)
<			5.0 >
			echo round(-4.5)
<			-5.0

		也可用作 |method|: >
			Compute()->round()
<
		返回类型: |Float|


rubyeval({expr})					*rubyeval()*
		运行 Ruby 表达式 {expr}，把返回值转换为对应的 Vim 数据类型。
		数值、浮点数和字符串按原样返回 (字符串经过复制)。
		数组会返回 Vim |List| 类型。
		哈希表会返回 Vim |Dictionary| 类型。
		所有其它对象都会根据 "Object#to_s" 方法的返回值转换为字符串。
		注意 `:def` 定义的函数内部的局部变量对 {expr} 不可见。

		也可用作 |method|: >
			GetRubyExpr()->rubyeval()
<
		返回类型: any，取决于 {expr}

		{仅当编译时加入 |+ruby| 特性才有效}


screenattr({row}, {col})				*screenattr()*
		和 |screenchar()| 类同，但返回属性。该数值比较随意，仅可用于和
		其他位置的属性进行比较。
		如果行号或列号越界，返回 -1。

		也可用作 |method|: >
			GetRow()->screenattr(col)
<
		返回类型: |Number|


screenchar({row}, {col})				*screenchar()*
		返回屏幕 [row, col] 位置上的字符，类型为数值。可用于屏幕上任意
		位置，包括状态行，窗口分隔符和命令行。左上角的行号和列号均为
		一。
		返回字符不包括组合字符。对双字节编码，可能仅返回首个字节。
		主要用于调试。
		如果行号或列号越界，返回 -1。

		也可用作 |method|: >
			GetRow()->screenchar(col)
<
		返回类型: |Number|


screenchars({row}, {col})				*screenchars()*
		返回数值 |List|。列表中的首个数值和 |screenchar()| 的返回值相
		同。后续的数值是附加在基础字符之上的组合字符。
		主要用于测试。
		如果行号或列号越界，返回空列表。

		也可用作 |method|: >
			GetRow()->screenchars(col)
<
		返回类型: list<number> 或 list<any>


screencol()						*screencol()*
		返回当前光标的屏幕列号，类型为数值。最左列的列号为 1。
		主要用于调试。

		注意: 本函数始终返回当前屏幕列号，所以如果直接在命令中使用 (例
		如 ":echo screencol()")，返回的是命令行中的屏幕列号，在命令执
		行时永远为 1。在文件中要获取当前光标位置，可用下面这些映射: >
			nnoremap <expr> GG ":echom " .. screencol() .. "\n"
			nnoremap <silent> GG :echom screencol()<CR>
			nnoremap GG <Cmd>echom screencol()<CR>
<
		返回类型: |Number|


screenpos({winid}, {lnum}, {col})			*screenpos()*
		返回窗口 {winid} 在缓冲区行 {lnum} 和列 {col} 上的文本字符所在
		的屏幕位置，类型为字典。{col} 是从一开始的字节索引。
		字典有以下成员:
			row	屏幕行号
			col	首个屏幕列号
			endcol	末个屏幕列号
			curscol	光标所在的屏幕列号
		如果指定位置不可见，所有的字典值均为零。
		当字符占据多于一个屏幕单元格时，"endcol" 和 "col" 的值会不同。
		例如，对于制表符，"col" 可能是 1 而 "eolcol" 会是 8。
		"curscol" 值是光标将要放置的屏幕位置。对于制表符，此值和
		"endcol" 相同。而对于双宽字符，则和 "col" 相同。
		此处忽略 |conceal| 特性，列号的计算假定 'conceallevel' 为零。
		要得到考虑了 |conceal| 的列号，可以将光标放在合适的位置，然后
		使用 |screencol()|。
		如果字符位于关闭的折叠里，返回折叠首个字符的屏幕位置，不使用
		{col}。
		如果 {winid} 非法，返回空字典。

		也可用作 |method|: >
			GetWinid()->screenpos(lnum, col)
<
		返回类型: dict<number> 或 dict<any>


screenrow()						*screenrow()*
		返回当前光标的屏幕行号，类型为数值。顶行的行号为 1。
		主要用于调试。
		作为替代，也可用 |winline()|。

		注意: 和 |screencol()| 存在相同的限制。

		返回类型: |Number|


screenstring({row}, {col})				*screenstring()*
		返回屏幕 [row, col] 位置上的基本字符和所有组合字符组成的字符
		串。与 |screenchars()| 类似，但返回字符组成的字符串，而非字符
		列表。
		主要用于测试。
		如果行号或列号越界，返回空串。

		也可用作 |method|: >
			GetRow()->screenstring(col)
<
		返回类型: |String|

							*search()*
search({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
		搜索正则表达式模式 {pattern}。搜索从当前光标位置 (光标位置可用
		|cursor()| 设置) 开始。

		找到匹配后，返回匹配所在的行号。
		如果找不到匹配，返回 0 并且不移动光标。不会给出错误信息。
		要取得匹配的具体字符串，可用 |matchbufline()|。

		{flags} 为包含以下字符标志位的字符串:
		'b'	反向 (Backward) 搜索，而非正向搜索
		'c'     接受光标 (Cursor) 位置上的匹配
		'e'	光标移动到匹配的结束位置 (End)
		'n'	不 (Not) 移动光标
		'p'	返回匹配的子模式 (Pattern) 号 (见下)
		's'	在光标前次所在位置上设置 (Set) ' 位置标记
		'w'	在文件末尾搜索失败时，回绕 (Wrap) 到文件开头继续搜索
		'W'	不在文件末尾处回绕 (no Wrap)
		'z'	从光标列开始搜索，而非第零 (Zero) 列
		如果 'w' 和 'W' 都没有给出，回绕与否取决于 'wrapscan' 选项。

		's' 标志位给出时，只有光标发生了移动才会设置 ' 位置标记。's'
		标志位不能和 'n' 标志位一起使用。

		适用 'ignorecase'、'smartcase' 和 'magic' 选项的规则。

		'cpo' 中包含 'c' 标志位时，下次搜索将从当前匹配的结束位置之后
		开始。否则，下次搜索会从当前匹配开始位置的下一列开始。这会影响
		有重叠匹配的情况。详见 |cpo-c|。插入 "\ze" 也可改变匹配的结束
		位置，见 |/\ze|。

		'z' 标志位未给出时，正向搜索总是从第零列开始，然后跳过光标之前
		的匹配。
		'z' 标志位给出时，反向搜索总是从第零列开始，因而会跳过光标之前
		的任何匹配 (除非从文件尾回绕)。(译者注: 技术细节: 'z' 用于指定
		在光标所在行上从哪个位置开始 (正向) 搜索，然后根据搜索方向是正
		向还是反向，排除光标之前或之后的匹配。由于 'z' 指定从光标列开
		始搜索，而反向搜索会排除光标之后的匹配，因而在当前行将找不到任
		何匹配。在其他行上，搜索总是从第 0 列开始)

		{stopline} 参数给出时，在搜索完该行后结束搜索。可用于限制搜索
		的行范围。例如: >
			let match = search('(', 'b', line("w0"))
			let end = search('END', '', line("w$"))
<		{stopline} 给出且非零时，隐含搜索不会在文件尾处回绕。零值相当
		于该参数未给出。

				*E1285* *E1286* *E1287* *E1288* *E1289*
		{timeout} 参数给出时，在给出的毫秒数后搜索超时。例如，
		{timeout} 为 500 则搜索将在半秒钟后中止。该值不能为负。零值相
		当于该参数未给出。

		注意: 超时仅考虑搜索过程本身，不考虑 {skip} 表达式占用的计算时
		间。
		{仅当在编译时加入 |+reltime| 特性才有效}

		{skip} 表达式给出时，在光标位于匹配开始位置时计算此表达式。计
		算结果非零时，会跳过此匹配。例如，可用于跳过注释或字符串内部的
		匹配。
		{skip} 可以是作为表达式计算的字符串、函数引用或匿名函数。
		{skip} 省略或为空时，接受所有匹配。
		计算 {skip} 时如果出错，搜索会中断并返回 -1。
							*search()-sub-match*
		'p' 标志位给出时，返回值为首个匹配的 \(\) 子模式的编号
		加一。如果没有子模式能匹配但整个模式匹配，返回一。
		要获取列号而不仅是行号，可用 |searchpos()|。

		除非使用了 'n' 标志位，否则光标会定位在匹配文本上。

		示例 (遍历参数列表里的所有文件): >
		    :let n = 1
		    :while n <= argc()	    " 循环遍历参数列表里的每个文件
		    :  exe "argument " .. n
		    :  " 从文件最后一个字符开始，这样第一个搜索可以通过回绕找
		    :  " 到文件开始的匹配
		    :  normal G$
		    :  let flags = "w"
		    :  while search("foo", flags) > 0
		    :    s/foo/bar/g
		    :	 let flags = "W"
		    :  endwhile
		    :  update		    " 如果修改过，写入文件
		    :  let n = n + 1
		    :endwhile
<
		使用一些标志位的示例: >
		    :echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
<		这会在光标所在位置或之后的位置寻找关键字 "if"、"else" 和
		"endif"。因为给出了 'p' 标志位，函数会根据最先匹配的关键字相应
		地返回 1、2 或 3。如果没有找到任何一个，则返回 0。例如，假定光
		标在下行的第一个单词上:
		    if (foo == 0) | let foo = foo + 1 | endif ~
		本函数会返回 1。如果没有 'c' 标志位，函数会找到 "endif" 并返回
		3。如果没有 'e' 标志位，且光标在 "if" 的 "f" 上，同样也会如
		此。'n' 标志位告诉函数不移动光标。

		也可用作 |method|: >
			GetPattern()->search()
<
		返回类型: |Number|


searchcount([{options}])				*searchcount()*
		获取或更新最近搜索计数，相当于不带 "S" 标志位的 'shortmess' 所
		显示的内容。即便 'shortmess' 包含 "S" 标志位，本函数同样适用。

		返回 |Dictionary|。如果之前没有设置过搜索模式且 {options} 里未
		指定 "pattern"，此字典为空。

		  键		类型		意义 ~
		  current	|Number|	当前的匹配位置；
						光标位置在首个匹配之前则为 0
		  exact_match	|Boolean|	{options} 里的 "pos" 位置 (缺
						省为光标所在位置) 如果在
						"current" 匹配文本之上，则为
						1，否则为 0
		  total		|Number|	匹配总数
		  incomplete	|Number|	0: 搜索全部完成
						1: 重计算超时
						2: 超出了最大匹配数

		{options} 见下。

		要取得最近一次按下 |n| 或 |N| 时的搜索计数，可调用本函数，并传
		递 {options} 值 `recompute: 0`。因为 'maxsearchcount' 的存在，
		有时这可能会返回错误的信息。如果计数超出 'maxsearchcount'，结
		果只会报告 'maxsearchcount' + 1。如果要得到正确的信息，可在
		{options} 里指定 `recompute: 1`: >

			" 如果有很多匹配，result == 'maxsearchcount' + 1
			let result = searchcount(#{recompute: 0})

			" 以下则返回正确结果 (recompute 缺省为 1)
			let result = searchcount()
<
		本函数可用于在 'statusline' 中加入计数: >
			function! LastSearchCount() abort
			  let result = searchcount(#{recompute: 0})
			  if empty(result)
			    return ''
			  endif
			  if result.incomplete ==# 1     " 超时
			    return printf(' /%s [?/??]', @/)
			  elseif result.incomplete ==# 2 " 超过最大匹配数
			    if result.total > result.maxcount &&
			    \  result.current > result.maxcount
			      return printf(' /%s [>%d/>%d]', @/,
			      \		    result.current, result.total)
			    elseif result.total > result.maxcount
			      return printf(' /%s [%d/>%d]', @/,
			      \		    result.current, result.total)
			    endif
			  endif
			  return printf(' /%s [%d/%d]', @/,
			  \		result.current, result.total)
			endfunction
			let &statusline ..= '%{LastSearchCount()}'

			" 如果只想在 'hlsearch' 打开时显示计数，可以这样
			" let &statusline ..=
			" \   '%{v:hlsearch ? LastSearchCount() : ""}'
<
		本函数也可用于更新搜索计数，例如在 |CursorMoved| 或
		|CursorMovedI| 自动命令中使用: >

			autocmd CursorMoved,CursorMovedI *
			  \ let s:searchcount_timer = timer_start(
			  \   200, function('s:update_searchcount'))
			function! s:update_searchcount(timer) abort
			  if a:timer ==# s:searchcount_timer
			    call searchcount(#{
			    \ recompute: 1, maxcount: 0, timeout: 100})
			    redrawstatus
			  endif
			endfunction
<
		也可用 {options} 里的 "pattern" 来统计在当前缓冲区里匹配指定模
		式的文本数目: >

			" 统计此缓冲区中匹配 '\<foo\>' 的文本数目
			" (注意 这也会更新搜索计数)
			let result = searchcount(#{pattern: '\<foo\>'})

			" 要恢复旧模式的旧搜索计数，可再次搜索
			call searchcount()
<
		{options} 必须为 |Dictionary|。可包含的条目有:
		  键		类型		含义 ~
		  recompute	|Boolean|	为 |TRUE| 时，就像执行了 |n|
						或 |N| 那样重新计算搜索计数。
						否则，返回最近的计算结果 (上次
						执行 |n| 或 |N| 时 (假定
						'shortmess' 里不带 "S")，或者
						上次执行本函数时)。
						(缺省: |TRUE|)
		  pattern	|String|	用新模式来重新计算，除非和原有
						的模式 |@/| 相同。
						效果和在调用本函数前先执行以下
						命令相同 (译者注: 区别在于本函
						数并不会修改 |@/| 的值) >
						  let @/ = pattern
<						(缺省: |@/|)
		  timeout	|Number|	0 或负数代表无超时。否则，在给
						定的毫秒数后重计算会超时
						(缺省: 0)
		  maxcount	|Number|	0 或负数代表无限制。否则，指定
						重计算时的最大匹配数。如果搜索
						超过此数，"total" 值会成为
						`maxcount + 1`
						(缺省: 'maxsearchcount')
		  pos		|List|		重计算时设定的位置，形如
						`[lnum, col, off]`。
						改变此值会相应改变 "current"
						的返回位置。见 |cursor()|、
						|getpos()|
						(缺省: 光标所在位置)

		也可用作 |method|: >
			GetSearchOpts()->searchcount()
<
		返回类型: dict<number>


searchdecl({name} [, {global} [, {thisblock}]])		*searchdecl()*
		搜索名为 {name} 的声明。

		{global} 参数非零时，按照 |gD| 的方式工作，寻找文件中的首个匹
		配。否则按照 |gd| 的方式工作，寻找函数里的首个匹配。

		{thisblock} 参数非零时，会忽略那些在光标之前结束的 {} 代码块里
		的匹配。这可以避免匹配到只在其他作用域里有效的变量声明。

		光标会移动到找到的匹配位置上。
		成功时返回零，而失败时返回非零。
		例如: >
			if searchdecl('myvar') == 0
			   echo getline('.')
			endif
<
		也可用作 |method|: >
			GetName()->searchdecl()
<
		返回类型: |Number|

							*searchpair()*
searchpair({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		搜索嵌套的 start-end 组对匹配。可用来查找和一个 "if" 配对的
		"endif"，并跳过两者间其它嵌套的 if/endif 组对。
		搜索从光标开始。默认为正向搜索，{flags} 里包含 'b' 时，则执行
		反向搜索。
		找到匹配时，光标移动到匹配位置，并返回匹配所在的行号。如果没有
		找到匹配，返回 0 或者 -1，光标不会移动。也不会给出错误信息。

		{start}、{middle} 和 {end} 都是模式，见 |pattern|。这些模式里
		不能包含 \( \) 对，但可以使用 \%( \)。{middle} 非空时，在指定
		的搜索方向上如果找到了该模式，就停留在该位置，但会跳过位于嵌套
		的 start-end 组对里面的匹配。一个典型的应用是: >
			searchpair('\<if\>', '\<else\>', '\<endif\>')
<		如果 {middle} 为空，"else" 会被跳过。

		{flags} 里，'b'、'c'、'n'、's'、'w' 和 'W' 标志位的使用方式和
		|search()| 中相同。此外，还可用:
		'r'	重复 (Repeat) 搜索，直到没有更多匹配为止；这样就会找到
			最外层的组对。隐含使用 'W' 标志位。
		'm'	返回找到的匹配 (Match) 个数，而非匹配位置的行号；使用
			'r' 时匹配个数可能会 > 1。
		备注: 最好使用 'W' 标志位，以避免搜索在文件末尾处回绕。

		找到 {start}、{middle} 或 {end} 的匹配时，在光标位于匹配开始位
		置时，会计算 {skip} 表达式。计算结果非零时，会跳过该匹配。例
		如，可用于跳过注释内部的匹配。
		{skip} 省略或为空时，接受所有匹配。
		计算 {skip} 时如果出错，搜索会中断并返回 -1。
		{skip} 可以是字符串、匿名函数、函数引用或偏函数。其它类型会报
		错。
		`:def` 函数里，如果 {skip} 参数为字符串常量，它会被编译为指令
		的一部分。

		{stopline} 和 {timeout} 见 |search()|。

		适用 'ignorecase' 选项，但忽略 'magic'，模式使用时假设它总是打
		开。

		从当前光标位置的下一个 (取决于搜索方向) 字符开始，搜索
		{start}、{middle} 或 {end} 的匹配。比如: >
			if 1
			  if 2
			  endif 2
			endif 1
<		假定当光标在 "if 2" 的 "i" 上时，开始正向搜索，会找到
		"endif 2"。而如果光标在 "if 2" 之前的一个字符上，那么会找到的
		是 "endif 1"。虽然先找到的是 "if 2"，但它被认为是从 "if 2" 开
		始到 "endif 2" 结束的嵌套 if/endif 组对的一部分，因而会被跳
		过。
		反向搜索且 {end} 匹配多于一个字符时，可以考虑在模式末尾加上
		"\zs"，这样在光标位于 {end} 匹配中间某位置时，仍然可以找到匹配
		的 {start} 匹配 (译者注: 可以理解为当光标位于 {end} 匹配的中间
		位置时，被视为已超出了组对范围，而加入 "\zs" 后，{end} 的匹配
		位置变成了实际结束模式之后零宽度位置，因此光标仍被视为留在组对
		的内部)。

		例如，要找到 Vim 脚本里的 "endif" 命令: >

	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
			\ 'getline(".") =~ "^\\s*\""')

<		光标必须位于待匹配的 "if" 之上或之后。注意 这里使用了单引号字
		符串以避免反斜杠加倍。skip 表达式只会跳过从行首开始的注释，但
		无法识别命令之后的注释。另外，一行中间出现的单词 "en" 或 "if"
		也被当作匹配。
		另一个例子，搜索和 "}" 配对的 "{": >

	:echo searchpair('{', '', '}', 'bW')

<		光标必须位于待匹配的 "}" 之上或之前。如果要额外跳过被语法高亮
		识别为字符串常量中的匹配: >

	:echo searchpair('{', '', '}', 'bW',
	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
<
		返回类型: |Number|

							*searchpairpos()*
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		和 |searchpair()| 类同，但返回匹配位置构成的 |List| 而不仅仅是
		行号。|List| 的首项是匹配位置的行号，第二项是匹配位置以字节索
		引计算的列号。如果没有找到匹配，返回 [0, 0]。 >

			:let [lnum,col] = searchpairpos('{', '', '}', 'n')
<
		|match-parens| 提供一个更复杂更有用的例子。

		返回类型: list<number>

							*searchpos()*
searchpos({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
		和 |search()| 类同，但返回匹配位置构成的 |List| 而不仅仅是行
		号。|List| 的首项是匹配位置的行号，第二项是匹配位置以字节索引
		计算的列号。如果没有找到匹配，返回 [0, 0]。
		例如: >
	:let [lnum, col] = searchpos('mypattern', 'n')

<		'p' 标志位给出时，返回列表里会有一个附加项目，包含匹配的子模式
		号加一，见 |search()-sub-match|。例如: >
	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
<		此例中，如果找到了小写字母 |/\l|，"submatch" 会等于 2，而如果
		找到了大写字母 |/\u|，会等于 3。

		也可用作 |method|: >
			GetPattern()->searchpos()
<
		返回类型: list<number>


server2client({clientid}, {string})			*server2client()*
		向指定的 {clientid} 发送应答字符串。最近刚发送过请求字符串的
		{clientid} 可以通过 expand("<client>") 获取。
		{仅当在编译时加入 |+clientserver| 特性才有效}
		成功时返回零，而失败时返回 -1。
		备注:
		应当在接收下一个命令前先保存此客户端 id。换而言之，必须在当前
		接收到的客户端命令返回之前，以及在调用任何会等待用户输入的命令
		之前先保存好此 id。
		另见 |clientserver|。
		示例: >
			:echo server2client(expand("<client>"), "HELLO")

<		也可用作 |method|: >
			GetClientId()->server2client(string)
<
		返回类型: |Number|


serverlist()						*serverlist()*
		返回以换行符分隔的字符串，包含所有的可用服务器名。
		如果没有服务器可用或者该信息无法取得，返回空串。另见
		|clientserver|。
		{仅当编译时加入 |+clientserver| 特性才有效}
		示例: >
			:echo serverlist()
<
		返回类型: |String|


setbufline({buf}, {lnum}, {text})			*setbufline()*
		设置缓冲区 {buf} 的第 {lnum} 行文本为 {text}。相当于为指定缓冲
		区调用 |setline()|。

		本函数只能用于已加载的缓冲区。如有必要，可先调用 |bufload()|。

		要插入行，可用 |appendbufline()|。
		{lnum} 中现有的文本属性都会被消除。

		{text} 可以是字符串，用来设置单行文本，也可以是字符串列表，用
		来设置多行文本。如果列表范围超出缓冲区的末行，超出部分会自动作
		为新行添加。如果列表为空，不会对缓冲区作任何修改，并返回零。

		{buf} 的用法见上述 |bufname()|。

		{lnum} 的用法可见 |setline()|。"$" 指定 {buf} 缓冲区的末行。
		如果 {lnum} 正好位于末行的下一行，{text} 会被添加在末行之后。

		如果 {buf} 不是合法缓冲区、缓冲区未加载或 {lnum} 不合法，返回
		1。|Vim9| 脚本里会报错。
		成功时返回 0。

		也可用作 |method|，基是作为第三个参数传递的: >
			GetText()->setbufline(buf, lnum)
<
		返回类型: |Number|


setbufvar({buf}, {varname}, {val})			*setbufvar()*
		将名为 {varname} 的选项或缓冲区 {buf} 的局部变量设置为 {val}。
		也可用于全局或者窗口局部选项，但不能用于全局或者窗口局部变量。
		如果设置了窗口局部选项，其全局值不会被修改。
		{buf} 的用法见上述 |bufname()|。
		{varname} 参数是字符串。注意 这里不能使用 "b:" 前缀 (译者注:
		选项须以 "&" 开头)。
		示例: >
			:call setbufvar(1, "&mod", 1)
			:call setbufvar("todo", "myvar", "foobar")
<		该命令在沙盘里不可用 |sandbox|。

		也可用作 |method|，基是作为第三个参数传递的: >
			GetValue()->setbufvar(buf, varname)
<
		返回类型: |Number|


setcellwidths({list})					*setcellwidths()*
		指定不同字符范围的显示宽度覆盖值。用于在终端显示时告知 Vim 宽
		字符以屏幕单元计的显示宽度。此设置会覆盖 'ambiwidth' 的效果。
		示例: >
		   call setcellwidths([
				\ [0x111, 0x111, 1],
				\ [0x2194, 0x2199, 2],
				\ ])

<		{list} 参数为列表，每个列表项是由三个数值组成的子列表:
		[{low}, {high}, {width}]。		*E1109* *E1110*
		"low" 和 "high" 可以相同，此时表示单个字符。否则，则表示从
		"low" 到 "high" (闭区间) 的字符范围。	*E1111* *E1114*
		只能指定值为 0x80 和更高的字符。

		"width" 只能是 1 或 2，指定字符以屏幕单元计的显示宽度。
							*E1112*
		如果参数不合法或范围相互有重叠，报错。	*E1113*

		如果新值导致 'fillchars' 或 'listchars' 非法 (译者注: 这些选项
		只接受单宽字符)，拒绝新值并报错。

		要清除现有的覆盖值，可传递空 {list}: >
		   setcellwidths([]);

<		用 $VIMRUNTIME/tools/emoji_list.vim 脚本可查看已知表情符号的显
		示效果。移动光标穿过文本，检查一下每个表情符号，确认终端实际显
		示的单元宽度是否与 Vim 记录的宽度一致。如果显示不正确，请相应
		调整 {list} 参数。

		返回类型: |Number|


setcharpos({expr}, {list})				*setcharpos()*
		和 |setpos()| 类同，但使用字符索引而非字节索引来指定行内的列
		号。

		示例:
		假定第 8 行的文本是 "여보세요"，执行: >
			call setcharpos('.', [0, 8, 4, 0])
<		会定位光标在第四个字符 '요' 上。 >
			call setpos('.', [0, 8, 4, 0])
<		会定位光标在第二个字符 '보' 上。

		也可用作 |method|: >
			GetPosition()->setcharpos('.')
<
		返回类型: |Number|


setcharsearch({dict})					*setcharsearch()*
		用 {dict} 设置当前字符搜索相关信息，该字典包含以下条目:

		    char	下次执行 |,| 或 |;| 命令使用的字符；空串会清除
				字符搜索
		    forward	字符搜索的方向；1 表示正向搜索，0 表示反向搜索
		    until	字符搜索的类型；1 表示使用了 |t| 为 |T| 字符搜
				索，0 表示使用了 |f| 或 |F| 字符搜索

		可用于在脚本中保存/恢复用户的字符搜索相关信息: >
			:let prevsearch = getcharsearch()
			:" 执行会改写用户搜索上下文的命令
			:call setcharsearch(prevsearch)
<		另见 |getcharsearch()|。

		也可用作 |method|: >
			SavedSearch()->setcharsearch()
<
		返回类型: dict<any>


setcmdline({str} [, {pos}])				*setcmdline()*
		将命令行设置为 {str}，并设置光标字节位置为 {pos}。
		{pos} 省略时，光标会定位于文本之后。
		成功时返回 0，如果当前不在编辑命令行，返回 1。

		也可用作 |method|: >
			GetText()->setcmdline()
<
		返回类型: |Number|


setcmdpos({pos})					*setcmdpos()*
		将命令行上的光标设置到字节位置 {pos}。首列位置为 1。
		|getcmdpos()| 可获取当前的光标位置。
		只有在编辑命令行时有效，所以必须在 |c_CTRL-\_e|、|c_CTRL-R_=|
		或带 '=' 的 |c_CTRL-R_CTRL-R| 里使用。对于 |c_CTRL-\_e| 和带
		'=' 的 |c_CTRL-R_CTRL-R|，先把命令行设为表达式的内容之后，再设
		置光标位置。而对于 |c_CTRL-R_=|，在计算表达式之后，先设置光标
		位置，再插入表达式返回的文本。
		如果指定的数值非常大，光标会移动到行尾。如果小于 1，则结果没有
		定义。
		成功时返回 0，如果当前不在编辑命令行，返回 1。

		也可用作 |method|: >
			GetPos()->setcmdpos()
<
		返回类型: |Number|


setcursorcharpos({lnum}, {col} [, {off}])		*setcursorcharpos()*
setcursorcharpos({list})
		和 |cursor()| 类同，但使用字符索引而非字节索引来指定行内的列
		号。

		示例:
		假定第 4 行的文本是 "여보세요"，执行: >
			call setcursorcharpos(4, 3)
<		会定位光标在第三个字符 '세' 上。 >
			call cursor(4, 3)
<		会定位光标在第一个字符 '여' 上。

		也可用作 |method|: >
			GetCursorPos()->setcursorcharpos()
<
		成功设置指定位置时返回 0，否则返回 -1。
		返回类型: |Number|


setenv({name}, {val})					*setenv()*
		将名为 {name} 的环境变量设置为 {val}。例如: >
			call setenv('HOME', '/home/myhome')

<		{val} 为 |v:null| 时，删除该环境变量。
		另见 |expr-env|。

		也可用作 |method|，基是作为第二个参数传递的: >
			GetPath()->setenv('PATH')
<
		返回类型: |Number|


setfperm({fname}, {mode})				*setfperm()* *chmod*
		设置 {fname} 的文件权限为 {mode}。
		{mode} 必须是包含 9 个字符的字符串。形如 "rwxrwxrwx"，每组
		"rwx" 标志位分别代表文件所有者、文件所属组和其它用户的权限。
		'-' 字符代表关闭指定权限，其他字符代表开启权限。不支持多字节字
		符。

		例如，"rw-r-----" 意味着用户可读写，组成员只读，其他用户不可访
		问。"xx-x-----" 的作用相同。

		成功时返回非零，失败时返回零。

		也可用作 |method|: >
			GetFilename()->setfperm(mode)
<
		要读取权限，可见 |getfperm()|。

		返回类型: |Number|


setline({lnum}, {text})					*setline()*
		设置当前缓冲区第 {lnum} 行的内容为 {text}。要插入新行，可用
		|append()|。要设置其它缓冲区里的行，可用 |setbufline()|。
		{lnum} 中现有的文本属性都会被消除。见 |text-prop-cleared|

		{lnum} 的用法可见 |getline()|。
		如果 {lnum} 正好位于末行的下一行，{text} 会被添加在末行之后。
		{text} 可以是任何类型或任何类型的列表，每个项目都会被转换为字
		符串。如果 {text} 为空列表，不会对缓冲区作任何修改，并返回
		FALSE。

		成功时返回 FALSE。失败时 (多数是因为 {lnum} 非法) 返回 TRUE。
		|Vim9| 脚本里如果 {lnum} 非法，会报错。

		例如: >
			:call setline(5, strftime("%c"))

<		{text} 为 |List| 时，用其中的列表项来设置从第 {lnum} 行开始的
		多行文本。例如: >
			:call setline(5, ['aaa', 'bbb', 'ccc'])
<		等价于: >
			:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
			:  call setline(n, l)
			:endfor

<		注意: 本函数不设置 '[ 和 '] 位置标记。

		也可用作 |method|，基是作为第二个参数传递的: >
			GetText()->setline(lnum)
<
		返回类型: |Number|


setloclist({nr}, {list} [, {action} [, {what}]])	*setloclist()*
		创建、替代或新增项目到窗口 {nr} 的位置列表。
		{nr} 可以是窗口号或 |window-ID|。{nr} 为零时，使用当前窗口。

		如果指定的是位置列表窗口，会修改在该窗口中显示的位置列表。如
		果窗口号 {nr} 非法，返回 -1。
		其它同 |setqflist()|。
		另见 |location-list|。

		{action} 的用法可见 |setqflist-action|。

		可选的 {what} 字典参数给出时，只设置 {what} 中列出的项目。关于
		{what} 支持的键列表，参见 |setqflist()|。

		也可用作 |method|，基是作为第二个参数传递的: >
			GetLoclist()->setloclist(winnr)
<
		返回类型: |Number|


setmatches({list} [, {win}])				*setmatches()*
		恢复 |getmatches()| 为当前窗口保存的匹配列表。成功时返回 0，否
		则返回 -1。恢复匹配列表前，先清除所有的现有匹配。示例见
		|getmatches()|。
		{win} 给出时，使用带此编号或 ID 的窗口，而非当前窗口。

		也可用作 |method|: >
			GetMatches()->setmatches()
<
		返回类型: |Number|


setpos({expr}, {list})					*setpos()*
		根据字符串 {expr} 的内容，设置光标或位置标记位置。可选值有:
			.	光标
			'x	位置标记 x

		{list} 必须是带四个或五个数值的 |List|:
		    [bufnum, lnum, col, off]
		    [bufnum, lnum, col, off, curswant]

		"bufnum" 是缓冲区号。零代表当前缓冲区。设置大写位置标记时，
		"bufnum" 会是位置标记的一部分。对其它的位置标记，它会用于指定
		设置位置标记的缓冲区。|bufnr()| 函数可用来把文件名转化为缓冲区
		号。
		设置光标和 ' 位置标记时，忽略 "bufnum"，因为它们和窗口相关，而
		不是和缓冲区相关。
		不修改跳转表。

		"lnum" 和 "col" 给出缓冲区里的行列位置。首列列号为 1。"lnum"
		为零时，会删除位置标记。如果  "col" 小于 1，会以 1 代替。列号
		要使用字符计数而不是字节计数，用 |setcharpos()|。

		"off" 值仅在激活 'virtualedit' 时才使用。这是从对应字符的起始
		位置算起以屏幕列为单位的偏移量。例如，在制表符的内部或在一行文
		本末尾之后的某个位置。

		"curswant" 值只在设置光标位置时才使用。它指定垂直移动光标时的
		首选列。"curswant" 省略时，不设置首选列。如果给出此值但用于设
		置位置标记，不会有任何效果。

		备注 对于 '< 和 '> (即可视选择的起止位置)，改变它们的行号可能
		会使两者在实际中被调换，以保证 '< 始终在 '> 之前。

		成功设置指定位置时返回 0，否则返回 -1。
		如果 {expr} 不合法，报错。

		另见 |setcharpos()|、|getpos()| 和 |getcurpos()|。

		本函数并不能恢复垂直移动使用的首选列 (译者注: 似已过时且和前述
		的 "curswant" 参数的描述不一致)；如果用它设置了光标位置，|j|
		和 |k| 动作会跳转到上次的列上！|cursor()| 可用来同时设置光标位
		置和首选列。另见 |winrestview()| 里的 "curswant" 键。

		也可用作 |method|: >
			GetPosition()->setpos('.')
<
		返回类型: |Number|


setqflist({list} [, {action} [, {what}]])		*setqflist()*
		创建、替代或新增项目到快速修复表。

		可选的 {what} 字典参数给出时，只设置 {what} 中列出的项目而忽略
		首个参数 {list}。{what} 支持的项目见下。
							*setqflist-what*
		{what} 省略时，使用 {list} 里的项目。每个列表项是一个字典。忽
		略 {list} 里非字典的项目。字典可以包含以下条目:

		    bufnr	缓冲区号；必须为合法缓冲区的编号
		    filename	文件名；仅当 "bufnr" 不存在或者不合法时才使用
		    module	模块名；给出时，在快速修复错误窗口里用来取代文
				件名
		    lnum	缓冲区里的行号
		    end_lnum	项目跨越多行时末行的行号
		    pattern	用于定位错误的搜索模式
		    col		列号
		    vcol	非零: "col" 代表显示单元
				零: "col" 代表字节索引
		    end_col	项目跨越多列时末列的列号
		    nr		错误号
		    text	错误描述
		    type	错误类型，如 'E'、'W' 等。
		    valid	此错误信息已被识别
		    user_data   项目关联的定制数据，可为任意类型。

		"col"、"vcol"、"nr"、"type" 和 "text" 条目可选。"lnum" 或
		"pattern" 条目两者之一用来定位匹配的错误行。
		如果 "filename" 和 "bufnr" 条目都不存在，或者 "lnum" 和
		"pattern" 条目都不存在，那么此列表项不被当作错误行处理。
		"pattern" 和 "lnum" 同时给出时，优先使用 "pattern"。
		"valid" 条目省略时，当 "bufnr" 为合法缓冲区或 "filename" 存在
		时，自动置位 valid 标志位。
		{list} 为空时，快速修复列表会被清除。
		注意 此列表和 |getqflist()| 的返回值不尽相同。

		{action} 值:				*setqflist-action*
							*E927*
		'a'	将 {list} 里的项目加入已有的快速修复列表。如果快速修复
			列表尚不存在，会建立新表。

		'r'	用 {list} 里的项目来替换当前快速修复列表里的项目。也可
			用于清除快速修复列表: >
				:call setqflist([], 'r')
<
		'u'	和 'r' 类似，但试图保留快速修复列表里的当前选择。
		'f'	释放快速修复堆栈上的所有快速修复列表。

		{action} 省略或为 ' ' 时，建立新表。在栈上当前快速修复列表的位
		置之后加入新的快速修复列表，同时释放其后的所有列表。要在栈的尾
		部加入新快速修复列表，请将 {what} 中的 "nr" 设为 "$"。

		{what} 支持以下条目:
		    context	快速修复列表的上下文。见 |quickfix-context|
		    efm		解析 "lines" 时使用的 errorformat。缺省使用
				'errorformat' 选项值。见 |quickfix-parse|
		    id		快速修复列表的标识号 |quickfix-ID|
		    idx		{id} 或 {nr} 指定的快速修复列表中，当前项的索
				引。设为 '$' 时，将列表的末项设为当前项。见
				|quickfix-index|
		    items	快速修复项目的列表，同 {list} 参数。
		    lines	文本行列表，此列表会用 {efm} 条目 (译者注: 原
				文作 'errorformat'，似不妥) 进行解析，并将其结
				果项目加入快速修复列表 {nr} 或 {id}。此条目只
				支持 |List| 类型。见 |quickfix-parse|
		    nr		快速修复堆栈上的快速修复列表编号；零代表当前快
				速修复列表，而 "$" 代表最后的快速修复列表。
		    quickfixtextfunc
				获取在快速修复窗口中显示文本的函数。支持函数
				名、函数引用或匿名函数。此函数的具体实现方法和
				示例可参见 |quickfix-window-function|。
		    title	快速修复列表的标题。见 |quickfix-title|
		{what} 中出现的尚不支持的条目会被忽略。
		"nr" 省略时，默认修改当前快速修复列表。要创建新的快速修复列
		表，可将 "nr" 设为比快速修复栈当前大小大一的值。
		在修改现有快速修复列表时，为了确保操作的是正确的列表，应该使用
		"id" 而不是 "nr" 来指定列表。

		示例 (另见 |setqflist-examples|): >
		   :call setqflist([], 'r', {'title': 'My search'})
		   :call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})
		   :call setqflist([], 'a', {'id':qfid, 'lines':["F1:10:L10"]})
<
		成功时返回零，而失败时返回 -1。

		本函数可用来独立于 'errorformat' 的设置创建快速修复列表。使用
		`:cc 1` 之类的命令可跳转到列表中第一个条目。

		也可用作 |method|，基是作为第二个参数传递的: >
			GetErrorlist()->setqflist()
<
		返回类型: |Number|


setreg({regname}, {value} [, {options}])		*setreg()*
		将寄存器 {regname} 的值设为 {value}。
		{regname} 为 "" 或 "@" 时，使用无名寄存器 '"'。
		{regname} 参数为字符串。|Vim9-script| 里 {regname} 必须为单个
		字符。

		{value} 可以是 |getreg()| 或 |getreginfo()| 返回的任何类型，包
		括字符串、|List| 或 |Dict|。
		{options} 包含 "a" 或者 {regname} 为大写时，该值被附加于现有值
		之后，而非替代现有值。

		{options} 还可以指定寄存器新的类型规格:
		    "c" 或 "v"	      |characterwise| (面向字符) 模式
		    "l" 或 "V"	      |linewise| (面向行) 模式
		    "b" 或 "<CTRL-V>" |blockwise-visual| (面向列块) 模式
		如果在 "b" 或 "<CTRL-V>" 之后紧跟一个数值，该数值会用作选择区
		的宽度 - 如果省略数值，那么列块的宽度会自动设为选择区中最长行
		的字符数 (其中 <Tab> 被视作单个字符)。

		{options} 未指定寄存器类型规格时，如果 {value} 为字符串，缺省
		使用字符模式，除非 {value} 以 <NL> 结尾，此时使用行模式。而如
		果 {value} 为列表，缺省会使用行模式。不会自动选择列块模式。
		成功时返回零，而失败时返回非零。

							*E883*
		备注: 在设置搜索和表达式寄存器 (译者注: |'/| 和 |'=|) 时，不能
		使用两个或更多项目的 |List|。
		      |List|。无项目的列表相当于空串。

		示例: >
			:call setreg(v:register, @*)
			:call setreg('*', @%, 'ac')
			:call setreg('a', "1\n2\n3", 'b5')
			:call setreg('"', { 'points_to': 'a'})

<		本例说明如何使用函数来保存和恢复寄存器: >
			:let var_a = getreginfo()
			:call setreg('a', var_a)
<		或: >
			:let var_a = getreg('a', 1)
			:let var_amode = getregtype('a')
			    ....
			:call setreg('a', var_a, var_amode)

<		备注: 如果在调用 |getreg()| 时不给出第三个参数，就无法可靠地恢
		复寄存器的原始内容，因为此时，换行符和 Nul 字节都会用换行符表
		示，见 |NL-used-for-Nul|)。

		也可以通过向寄存器附加空串来改变寄存器类型，而不修改其原有内
		容: >
			:call setreg('a', '', 'al')

<		也可用作 |method|，基是作为第二个参数传递的: >
			GetText()->setreg('a')
<
		返回类型: |Number|


settabvar({tabnr}, {varname}, {val})			*settabvar()*
		将标签页 {tabnr} 名为 {varname} 的局部变量设置为 {val}。
		|t:var|
		{varname} 参数是字符串。
		注意 自动命令会被阻塞，某些副作用可能不会触发，比如设置
		'filetype' 的时候就不会触发相应的自动命令 (译者注: 本函数不能
		用于设置选项，所以此备注并无意义)。
		注意 这里不能使用 "t:" 前缀。
		标签页的编号从一开始。
		该命令在沙盘里不可用 |sandbox|。

		也可用作 |method|，基是作为第三个参数传递的: >
			GetValue()->settabvar(tab, name)
<
		返回类型: |Number|


settabwinvar({tabnr}, {winnr}, {varname}, {val})	*settabwinvar()*
		将名为 {varname} 的选项或在标签页 {tabnr} 中的窗口 {nr} 的局部
		变量设置为 {val}。
		标签页编号从一开始。对于当前标签页，可直接用 |setwinvar()|。
		{winnr} 可以是窗口号或 |window-ID|。{winnr} 为零时，使用当前窗
		口。
		注意 自动命令会被阻塞，某些副作用可能不会触发，比如设置
		'filetype' 或 'syntax' 的时候就不会触发相应的自动命令。
		也可用于全局或者缓冲区局部选项，但不能用于全局或者缓冲区局部变
		量。如果设置了缓冲区局部选项，其全局值不会被修改。
		注意 这里不能使用 "w:" 前缀 (译者注: 选项须以 "&" 开头)。
		示例: >
			:call settabwinvar(1, 1, "&list", 0)
			:call settabwinvar(3, 2, "myvar", "foobar")
<		该命令在沙盘里不可用 |sandbox|。

		也可用作 |method|，基是作为第四个参数传递的: >
			GetValue()->settabwinvar(tab, winnr, name)
<
		返回类型: |Number|


settagstack({nr}, {dict} [, {action}])			*settagstack()*
		用 {dict} 来修改窗口 {nr} 的标签栈。
		{nr} 可为窗口号或 |window-ID|。

		要查阅 {dict} 支持项目的列表，可参考 |gettagstack()| 的返回字
		典。"curidx" 的修改在标签栈项目修改之前生效。
							*E962*
		{action} 参数决定如何修改标签栈:
		- {action} 省略或为 'r' (Replace) 时，标签栈被整体替换。
		- {action} 为 'a' (Append) 时，将 {dict} 中的新项压进标签栈。
		- {action} 是 't' (Truncate) 时，删除标签栈的当前项 (可被
		  {dict} 中设置的 "curidx" 项覆盖) 及之后的所有项目，然后将
		  {dict} 中的新项压进标签栈。

		修改完成后，当前索引被设为标签栈的新长度加一。

		成功时返回零，而失败则返回 -1。

		示例 (更多示例可见 |tag-stack-examples|):
		    清空窗口 3 的标签栈: >
			call settagstack(3, {'items' : []})

<		    保存并恢复标签栈: >
			let stack = gettagstack(1003)
			" 完成一些别的操作
			call settagstack(1003, stack)
			unlet stack
<
		也可用作 |method|，基是作为第二个参数传递的: >
			GetStack()->settagstack(winnr)
<
		返回类型: |Number|


setwinvar({winnr}, {varname}, {val})			*setwinvar()*
		和 |settabwinvar()| 类同，但只用于当前标签页。
		示例: >
			:call setwinvar(1, "&list", 0)
			:call setwinvar(2, "myvar", "foobar")

<		也可用作 |method|，基是作为第三个参数传递的: >
			GetValue()->setwinvar(winnr, name)
<
		返回类型: |Number|


sha256({expr})						*sha256()*
		返回  {expr} 的 SHA256 校验码，类型为 64 位十六进制字符串。
		{expr} 可以是字符串或 blob。

		也可用作 |method|: >
			GetText()->sha256()
			GetBlob()->sha256()
<
		返回类型: |String|

		{仅当编译时加入 |+cryptv| 特性才有效}


shellescape({string} [, {special}])			*shellescape()*
		转义 {string} 以便用作外壳命令的参数。
		当 'shell' 的值包含 powershell (MS-Windows) 或 pwsh
		(MS-Windows、Linux 和 macOS) 时，返回用单引号包围的 {string}，
		并将其内部的单引号加倍。
		在 MS-Windows 上，如果未置位 'shellslash'，返回用双引号包围的
		{string}，并将 {string} 内的双引号加倍。
		否则，返回用单引号包围的 {string}，并把其内部所有的 "'" 替换为
		"'\''"。

		{special} 参数为 Vim 命令中使用的关键字进行额外转义。当它给出
		且不是零值或空串时 (|non-zero-arg|)，特殊项目如 "!"、"%"、"#"
		和 "<cword>" 等 (见 |expand()| 中列出的项目) 会在前面加上反斜
		杠。|:!| 命令在执行时，会把该反斜杠删除。

		同样在 {special} 为 |non-zero-arg| 情况下，当 'shell' 以 "csh"
		结尾时，"!" 字符也会被转义。这是因为 csh 和 tcsh 即使在单引号
		内，仍然会使用 "!" 用于历史替换。

		同样在 {special} 为 |non-zero-arg| 情况下，<NL> 也会被转义。
		当 'shell' 以 "csh" 结尾时，<NL> 会被转义两次。

		当 'shell' 以 "fish" 结尾时，"\" 字符会被转义。这是因为 fish
		把 "\" 用作单引号内的转义字符。

		|:!| 命令的示例: >
		    :exe '!dir ' .. shellescape(expand('<cfile>'), 1)
<		返回光标下目录名对应目录中的文件列表。|system()| 的示例: >
		    :call system("chmod +w -- " .. shellescape(expand("%")))
<		另见 |::S|。

		也可用作 |method|: >
			GetCommand()->shellescape()
<
		返回类型: |String|


shiftwidth([{col}])					*shiftwidth()*
		返回 'shiftwidth' 的有效值。通常直接返回 'shiftwidth' 的值，但
		如果其值为零，会返回 'tabstop' 的值。本函数最初是在 2012 年由
		7.3.694 补丁版本引入，因此现在基本所有版本都已支持 (不过可选的
		{col} 参数是 8.1.542 版本以后才引入的)。

		参数 {col} 给出时，指定列号，返回该列号所对应的 'shiftwidth'
		值。这与 'vartabstop' 特性有关。如果打开了 'vartabstop' 设置但
		{col} 省略，默认列号为 1。

		也可用作 |method|: >
			GetColumn()->shiftwidth()
<
		返回类型: |Number|


sign_ 函数文档在这里: |sign-functions-details|。


simplify({filename})					*simplify()*
		在不改变含义的前提下，尽可能简化文件名。不会解析 (MS-Windows
		上) 快捷方式或者 (Unix 上) 符号链接。本函数会保留 {filename}
		中指向当前目录的首个路径部分，也保留拖尾的的路径分隔符。在
		Unix 上，"//path" 会被原样保留，而 "///path" 会被简化为
		"/path" (这符合 posix 规范)。
		示例: >
			simplify("./dir/.././/file/") == "./file/"
<		注意: "dir/.." 的组合仅在 "dir" 是可遍历目录或者不存在时才会被
		一起删除。Unix 上，如果 "dir" 是指向同一目录下的符号链接，该组
		合也会被删除。
		要在路径名简化前先解析所有牵涉到的符号链接，请用 |resolve()|。

		也可用作 |method|: >
			GetName()->simplify()
<
		返回类型: |String|


sin({expr})						*sin()*
		返回以弧度测量的 {expr} 的正弦值，类型为 |Float|。
		{expr} 的计算结果必须是 |Float| 或 |Number|。否则返回 0.0。
		示例: >
			:echo sin(100)
<			-0.506366 >
			:echo sin(-4.01)
<			0.763301

		也可用作 |method|: >
			Compute()->sin()
<
		返回类型: |Float|


sinh({expr})						*sinh()*
		返回 {expr} 的双曲正弦值，类型为 |Float|，范围在 [-inf, inf]
		之间。
		{expr} 的计算结果必须是 |Float| 或 |Number|。否则返回 0.0。
		示例: >
			:echo sinh(0.5)
<			0.521095 >
			:echo sinh(-0.9)
<			-1.026517

		也可用作 |method|: >
			Compute()->sinh()
<
		返回类型: |Float|


slice({expr}, {start} [, {end}])			*slice()*
		和 |slice| 切片表达式 "expr[start : end]" 类同，但使用开区间
		("end" 项不包含)。而且对于字符串，使用的总是字符索引而非字节索
		引，和 |vim9script| 里对切片的处理规则一致。另外，组合字符被视
		为前导的基准字符的一部分。
		{end} 省略时，切片会继续到 {expr} 结束。
		{end} 为 -1 时，会排除末项。
		如果 {start} 或 {end} 非法，返回空值。

		也可用作 |method|: >
			GetList()->slice(offset)
<
		返回类型: list<{type}> 或 tuple<{type}>


sort({list} [, {how} [, {dict}]])			*sort()* *E702*
		对 {list} 中的项目进行排序，直接原位修改列表。返回 {list}。

		如果不想更动原始输入，先创建备份: >
			:let sortedlist = sort(copy(mylist))

<		{how} 省略或为字符串时，sort() 按照每个项目的字符串表示形式进
		行排序。数值排在字符串之后，|List| 排在数值之后。要给当前缓冲
		区中的文本排序，用 |:sort|。

		{how} 给出且为 'i' 时，忽略大小写。老式脚本里，为了后向兼容，
		此值为一时也会忽略大小写。为零时不忽略大小写。

		{how} 给出且为 'l' 时，按照当前排序规则 locale 来进行排序 (实
		现细节: 用 strcoll() 来进行字符串比较)。关于如何查看或设置排序
		规则 locale，见 |:language| (译者注: 简体中文按中文拼音排序)。
		|v:collate| 也可用于检查当前 locale。按 locale 的排序通常忽略
		大小写。示例: >
			" 英语 locale 下，ö 的排位顺序与 o 相近。
			:language collate en_US.UTF8
			:echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')
<			['n', 'o', 'O', 'ö', 'p', 'z'] ~
>
			" 而在瑞典 locale 下，ö 则排在 z 之后。
			:language collate sv_SE.UTF8
			:echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')
<			['n', 'o', 'O', 'p', 'z', 'ö'] ~
		Mac 上，此功能不能正常工作。

		{how} 给出且为 'n' 时，按数值顺序排序 (实现细节: 用 strtod()
		函数来解析数值。因此，字符串、列表、字典和函数引用均会被视作
		0)。注意 不能用来排序数位组成的字符串！

		{how} 给出且为 'N' 时，按数值顺序排序。和 'n' 类似，但数位组成
		的字符串会被正确地解析为相应数值。

		{how} 给出且为 'f' 时，按数值顺序排序。所有值的类型必须是数值
		或浮点数。

		{how} 为 |Funcref| 或函数名时，调用该函数来进行项目比较。调用
		函数时传递两个项目作为参数，函数返回 0 代表两项相等，返回 1 或
		更大的正值代表第一个项目应排在第二个项目之后，返回 -1 或更小的
		负值则代表第一个项目应排在第二个项目之前。

		{dict} 用于带 "dict" 属性的函数，此字典在函数中会用作局部变量
		"self"。|Dictionary-function|

		此排序算法是稳定排序，具有相同值 (无论比较时是按数值或是按字符
		串) 的项目会保留原有顺序不变。例如，按数值顺序排序时，所有的文
		本字符串会紧挨在一起，按原列表中出现的顺序排列。

		也可用作 |method|: >
			mylist->sort()

<		另见 |uniq()|。

		例如: >
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			eval mylist->sort("MyCompare")
<		如果不考虑溢出的情况，这个简单的例子可用更简洁的方式来进行比
		较: >
			func MyCompare(i1, i2)
			   return a:i1 - a:i2
			endfunc
<		简单的表达式也可用匿名函数: >
			eval mylist->sort({i1, i2 -> i1 - i2})
<
		返回类型: list<{type}>


sound_clear()						*sound_clear()*
		停止播放所有声音。

		在有些 Linux 系统上，可能需要 libcanberra-pulse 包，否则声音不
		会停止。

		返回类型: |Number|

		{仅当编译时加入 |+sound| 特性才有效}


sound_playevent({name} [, {callback}])			*sound_playevent()*
		播放由 {name} 定义的声音。支持的事件名取决于系统。通常使用的是
		XDG 声音名。Ubuntu 上，可在
		/usr/share/sounds/freedesktop/stereo 中找到相应名字。例如: >
			call sound_playevent('bell')
<		MS-Windows 上，{name} 可为 SystemAsterisk、SystemDefault、
		SystemExclamation、SystemExit、SystemHand、SystemQuestion、
		SystemStart、SystemWelcome 等等。
		macOS 上，{name} 指向 /System/Library/Sounds 里的相应文件 (如
		"Tink")。也可使用如 ~/Library/Sounds 等目录中安装的用户自定义
		声音文件。

		{callback} 给出时，在声音播放结束后调用。传递的首个参数是声音
		ID，第二个参数是播放状态:
			0	声音播放到结束
			1	声音被中断
			2	声音启动后出错
		示例: >
		   func Callback(id, status)
		     echomsg "sound " .. a:id .. " finished with " .. a:status
		   endfunc
		   call sound_playevent('bell', 'Callback')

<		MS-Windows 上: 本函数不支持 {callback}。

		返回声音 ID，该值可被传递给 `sound_stop()`。
		如果声音播放失败，返回零。

		也可用作 |method|: >
			GetSoundName()->sound_playevent()
<
		返回类型: |Number|

		{仅当编译时加入 |+sound| 特性才有效}


sound_playfile({path} [, {callback}])			*sound_playfile()*
		和 |sound_playevent()| 类同，但播放指定的声音文件 {path}。
		{path} 必须是完整路径。Ubuntu 上可用下列命令来查找可播放的文
		件: >
		    :!find /usr/share/sounds -type f | grep -v index.theme

<		也可用作 |method|: >
			GetSoundPath()->sound_playfile()
<
		返回类型: |Number|

		{仅当编译时加入 |+sound| 特性才有效}


sound_stop({id})					*sound_stop()*
		停止播放声音 {id}。{id} 必须是先前由 |sound_playevent()| 或
		|sound_playfile()| 返回的 id 值。

		在有些 Linux 系统上，可能需要 libcanberra-pulse 包，否则声音不
		会停止。

		MS-Windows 上，不能用本函数来停止 |sound_playevent()| 启动的事
		件声音。为此，只能用 |sound_clear()|。

		也可用作 |method|: >
			soundid->sound_stop()
<
		返回类型: |Number|

		{仅当编译时加入 |+sound| 特性才有效}


soundfold({word})					*soundfold()*
		返回 {word} 的按发音折叠的等价形式。使用当前窗口的 'spelllang'
		中首个支持按发音折叠的语言。'spell' 必须置位。如果没有可用的支
		持按发音折叠的语言，会按原样返回 {word}。
		可用来提供拼写建议。注意 本函数可能会很慢。

		也可用作 |method|: >
			GetWord()->soundfold()
<
		返回类型: |String|


spellbadword([{sentence}])				*spellbadword()*
		参数省略时: 返回光标所在位置或其后的第一个有拼写错误的单词。光
		标会移动到这个坏词的起始处。如果当前光标行上没有坏词，返回空
		串，并且光标会不移动。

		参数给出时: 返回 {sentence} 里第一个有拼写错误的单词。如果没有
		拼写错误，返回空串。

		返回值是包含两个项目的列表:
		- 有拼写错误的单词，如果没有则为空串。
		- 拼写错误的类型:
			"bad"		拼写错误
			"rare"		偏僻词
			"local"		只在其它区域里合法的单词
			"caps"		单词应该大写开头
		例如: >
			echo spellbadword("the quik brown fox")
<			['quik', 'bad'] ~

		使用当前窗口的拼写信息和 'spelllang' 的值。

		也可用作 |method|: >
			GetText()->spellbadword()
<
		返回类型: list<string>


spellsuggest({word} [, {max} [, {capital}]])		*spellsuggest()*
		返回 |List|，包含可作为 {word} 替代的拼写建议。
		{max} 给出时，设置返回建议的数目上限。默认不超过 25 个建议。

		{capital} 参数给出且非零时，只给出大写开头的拼写建议。可在
		'spellcapcheck' 匹配之后的单词上使用此功能。

		{word} 可以是一个有拼写错误的单词，后跟其它文本。这样方便把错
		误分开的单词重新连接回来。返回的建议里同时会包含附加文本，以便
		对整行进行替换。

		{word} 也可以是个好词。此时会返回和其类似的单词。建议里不会包
		含 {word} 自身，但可能会出现其大写开头的形式。

		使用当前窗口的拼写信息、'spelllang' 和 'spellsuggest' 的值。

		也可用作 |method|: >
			GetWord()->spellsuggest()
<
		返回类型: list<string> 或 list<any>


split({string} [, {pattern} [, {keepempty}]])		*split()*
		将 {string} 拆分，并用拆分结果构造一个 |List|。
		{pattern} 省略或为空时，每个空白分隔的字符序列会成为一个列表
		项。
		否则，在每个匹配 {pattern} 的位置拆分字符串，匹配内容被删除。
		此处不适用 'ignorecase'，要忽略大小写，须在模式里加上 \c。
		|/\c|
		如果列表的首末项目为空，除非 {keepempty} 参数给出且非零。删除
		这些空项目。
		其它空项目在 {pattern} 匹配至少一个字符或者 {keepempty} 非零时
		会被保留。
		例如: >
			:let words = split(getline('.'), '\W\+')
<		要将字符串拆分到每个字符: >
			:for c in split(mystring, '\zs')
<		如果想要保留分隔符，可以在模式尾部加上 '\zs': >
			:echo split('abc:def:ghi', ':\zs')
<			['abc:', 'def:', 'ghi'] ~
		要拆分首项可能为空的表格行: >
			:let items = split(line, ':', 1)
<		逆函数是 |join()|。

		也可用作 |method|: >
			GetString()->split()
<
		返回类型: list<string>


sqrt({expr})						*sqrt()*
		返回 {expr} 的非负平方根，类型为 |Float|。
		{expr} 的计算结果必须是 |Float| 或 |Number|，否则返回 0.0。
		如果 {expr} 为负，返回 NaN (Not a Number，非数)。
		示例: >
			:echo sqrt(100)
<			10.0 >
			:echo sqrt(-4.01)
<			nan
		显示的 "nan" 可能会随具体的系统库有所变化。

		也可用作 |method|: >
			Compute()->sqrt()
<
		返回类型: |Float|


srand([{expr}])						*srand()*
		初始化 |rand()| 使用的种子:
		- {expr} 省略时，如果 /dev/urandom 可用，将其值用作种子，否
		  则，种子采用 time(NULL)，也就是 epoch 时间；后者只有秒级精确
		  度。
		- {expr} 给出时，必须是数值。用作初始种子值。这可用于测试或需
		  要可预测序列的场合。

		示例: >
			:let seed = srand()
			:let seed = srand(userinput)
			:echo rand(seed)
<
		返回类型: list<number>


state([{what}])						*state()*
		返回包含当前状态的字符串。主要用于要进行一些不太安全的操作的回
		调。大致的工作流程是:
		- 回调先调用 state()，检查工作是否安全。
		  是:  马上开始进行工作。
		  否:  加入工作队列，新增 |SafeState| 和/或 |SafeStateAgain|
		       自动命令 (|SafeState| 会在顶层触发，而 |SafeStateAgain|
		       会在处理完信息和回调后触发)。
		- SafeState 或 SafeStateAgain 触发时，会执行先前定义的自动命
		  令，那里可以调用 `state()` 来检查工作现在是否可以进行，如果
		  是，从队列中删除该工作项并开始执行。
		  队列为空时，删除自动命令。
		另见 |mode()|。

		{what} 给出时，只加入该字符串中出现的字符。例如，下例会检查屏
		幕是否有过滚动: >
			if state('s') == ''
			   " 屏幕还未滚动
<
		以下字符指示当前状态，一般而言，每个字符代表一种不同的忙碌操作
		正在进行:
		    m	映射、|:normal| 命令、|feedkeys()| 或其它庞大的命令在
			进行中
		    o	操作符等待状态，如在 |d| 之后
		    a	插入模式自动补全激活时
		    x	执行自动命令时
		    w	处于阻塞等待，如 |ch_evalexpr()|、|ch_read()| 或
			|ch_readraw()| 读入 json 时
		    S	不触发 |SafeState| 或 |SafeStateAgain| 的情形，如在
			|f| 命令或计数之后
		    c	执行回调时，也包括计时器 (递归调用时会重复此字符多次，
			最多会是 "ccc")
		    s	屏幕已经为消息滚动过

		返回类型: |String|


str2blob({list} [, {options}])				*str2blob()*
		将字符串列表 {list} 里的字符序列转换为字节序列，返回类型为
		blob。

		每个列表项在转换后会加上 <NL> 字节。而字符串里的换行符会被转换
		为 <NUL> 字节。

		参数 {options} 是 |Dict|，支持以下项目:
		    encoding	构造 blob 前，会先使用此编码进行字符转换。
				类型为 |String|。可用值见 |encoding-names|。

		{options} 省略时，根据当前 'encoding' 设置，将字符序列转换为字
		节序列。

		如果字符编码失败，报错且返回空 blob。

		如果 {list} 为空，返回空 blob。

		另见 |blob2str()|

		示例: >
		    str2blob(["ab"])		返回 0z6162
		    str2blob(["«»"])		返回 0zC2ABC2BB
		    str2blob(["a\nb"])		返回 0z610062
		    str2blob(["a","b"])		返回 0z610A62
		    str2blob(["«»"], {'encoding': 'latin1'}) 返回 0zABBB
		    str2blob(readfile('myfile.txt'))
<
		也可用作 |method|: >
			GetListOfStrings()->str2blob()
<
		返回类型: |Blob|


str2float({string} [, {quoted}])			*str2float()*
		将字符串 {string} 转换为浮点数。其规则与表达式中使用浮点数的解
		析方式大致相同，见 |floating-point-format|，但略微宽松一点。例
		如，接受 "1e40"，而表达式语法要求必须书写 "1.0e40"。也接受十六
		进制形式 "0x123"，但不支持其它进制的形式，如二进制或八进制。
		{quoted} 给出且非零时，忽略小数点之前的内嵌单引号，举例来说，
		接受 "1'000.0"，也就是一千。
		忽略浮点数之后出现的文本，不报错。
		小数点始终是 '.'，与当前 locale 无关。遇到逗号会终止浮点数解
		析: 例如，"12,345.67" 会被解析为 12.0。要去除千分位分隔符，可
		用 |substitute()|: >
			let f = str2float(substitute(text, ',', '', 'g'))
<
		如果转换失败，返回 0.0。

		也可用作 |method|: >
			let f = text->substitute(',', '', 'g')->str2float()
<
		返回类型: |Float|


str2list({string} [, {utf8}])				*str2list()*
		将字符串 {string} 中的每个字符转换为对应的数值，返回包含这些数
		值的列表。例如: >
			str2list(" ")		返回 [32]
			str2list("ABC")		返回 [65, 66, 67]
<		|list2str()| 是其逆操作。

		{utf8} 省略或为零时，使用当前 'encoding'。
		而 {utf8} 为 TRUE 时，总是使用 UTF-8 编码。使用 UTF-8 时，组合
		字符就能正常工作: >
			str2list("á")		返回 [97, 769]

<		也可用作 |method|: >
			GetString()->str2list()
<
		返回类型: list<number>


str2nr({string} [, {base} [, {quoted}]])		*str2nr()*
		将字符串 {string} 转换为数值。
		{base} 是数值转换的基底，可以为 2、8、10 或 16。
		{quoted} 给出且非零时，忽略内嵌的单引号，举例来说，接受
		"1'000'000"，也就是一百万。

		{base} 省略时，使用基底 10。这也意味着开头的零不会触发八进制解
		析，此行为与 Vim 从字符串到数值的隐含转化不同。例如: >
			let nr = str2nr('0123')
<
		{base} 为 16 时，忽略开头的 "0x" 或 "0X"。如果使用别的基底，同
		样的情况会返回零。类似地，{base} 为 8 时，忽略开头的 "0"、"0o"
		或 "0O"，{base} 为 2 时，忽略开头的 "0b" 或 "0B"。
		忽略数值之后出现的文本，不出错。

		如果 {string} 为空或出错，返回 0。

		也可用作 |method|: >
			GetText()->str2nr()
<
		返回类型: |Number|


strcharlen({string})					*strcharlen()*
		返回字符串 {string} 的字符数量，类型为数值。组合字符不会单独计
		算。|strchars()| 可计算将组合字符分别计算的字符数目。

		如果 {string} 为空或出错，返回 0。

		另见 |strlen()|、|strdisplaywidth()| 和 |strwidth()|。

		(译者注: 字符串长度相关函数简单对照可见下表:
			函数		单位	组合字符	制表位相关
		|strcharlen()|		字符	✗		✗
		|strchars()|		字符	可选		✗
		|strdisplaywidth()|	显示列	✗		✓
		|strlen()| (|len()|)	字节	✓		✗
		|strutf16len()|		UTF-16	可选		✗
		|strwidth()|		显示列	✗		✗
		)

		也可用作 |method|: >
			GetText()->strcharlen()
<
		返回类型: |Number|


strcharpart({src}, {start} [, {len} [, {skipcc}]])	*strcharpart()*
		和 |strpart()| 类同，但使用字符索引和字符长度，而非字节索引和
		字节长度。
		{skipcc} 省略或为零时，组合字符会单独计算。
		{skipcc} 设为 1 时，组合字符被视作其前导的基准字符的一部分，而
		不单独计算。这和 |slice()| 类似。
		使用字符索引时，如果选择的字符不存在，返回值里会忽略该字符，但
		仍算作一个字符长度。例如: >
			strcharpart('abc', -1, 2)
<		会返回 'a'。

		如果出错，返回空串。

		也可用作 |method|: >
			GetText()->strcharpart(5)
<
		返回类型: |String|


strchars({string} [, {skipcc}])				*strchars()*
		返回字符串 {string} 的字符数量，类型为数值。
		{skipcc} 省略或为零时，组合字符会单独计算。
		{skipcc} 设为 1 时，计算时会忽略组合字符。|strcharlen()| 总是
		采用这种方式。

		如果出错，返回零。

		另见 |strlen()|、|strdisplaywidth()| 和 |strwidth()|。

		{skipcc} 只在 7.4.755 版本之后才出现。可定义如下后向兼容的包装
		函数: >
		    if has("patch-7.4.755")
		      function s:strchars(str, skipcc)
			return strchars(a:str, a:skipcc)
		      endfunction
		    else
		      function s:strchars(str, skipcc)
			if a:skipcc
			  return strlen(substitute(a:str, ".", "x", "g"))
			else
			  return strchars(a:str)
			endif
		      endfunction
		    endif
<
		也可用作 |method|: >
			GetText()->strchars()
<
		返回类型: |Number|


strdisplaywidth({string} [, {col}])			*strdisplaywidth()*
		返回字符串 {string} 从屏幕列 {col} 开始时 (首列的列号为零) 在
		屏幕上占据的显示单元的数目，类型为数值。{col} 省略时默认为零。
		否则给出字符串起始位置的屏幕列号。这会影响制表符的计算方式。
		使用当前窗口里的选项设置。其中一些影响显示的选项会对返回值有影
		响，如 'tabstop' 和 'display'。
		{string} 包含东亚二义性宽度字符类时，'ambiwidth' 也会影响返回
		值。
		如果出错，返回零。
		另见 |strlen()|、|strwidth()| 和 |strchars()|。

		也可用作 |method|: >
			GetText()->strdisplaywidth()
<
		返回类型: |Number|


strftime({format} [, {time}])				*strftime()*
		返回将指定的日期和时间按照 {format} 字符串排版后的字符串。
		{time} 给出时使用指定的时间，默认使用当前时间。可接受的
		{format} 格式取决于系统。这意味着本函数不可移植！具体的格式请
		参见 C 函数 strftime() 的参考手册。返回结果的最大长度是 80 个
		字符。
		另见 |localtime()|、|getftime()| 和 |strptime()|。
		可用 |:language| 命令来改变时间显示语言。
		示例: >
		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997
		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25
		  :echo strftime("%y%m%d %T")	   970427 11:53:55
		  :echo strftime("%H:%M")	   11:55
		  :echo strftime("%c", getftime("file.c"))
						   显示 file.c 的修改时间。
<		并非所有系统都支持本函数。要确认是否可用: >
			:if exists("*strftime")

<		也可用作 |method|: >
			GetFormat()->strftime()
<
		返回类型: |String|


strgetchar({str}, {index})				*strgetchar()*
		获取 {str} 中的第 {index} 个字符对应的数值。索引以零为基底，采
		用字符索引而非字节索引。组合字符会单独计算。|nr2char()| 可用来
		将返回的数值转换为字符串。
		如果 {index} 非法，返回 -1。
		另见 |strcharpart()| 和 |strchars()|。

		也可用作 |method|: >
			GetText()->strgetchar(5)
<
		返回类型: |Number|


stridx({haystack}, {needle} [, {start}])		*stridx()*
		返回 {needle} 字符串在 {haystack} 字符串中首次出现的字节位置。
		{start} 给出时，从指定的字节位置开始搜索。可用来寻找下一个匹
		配: >
			:let colon1 = stridx(line, ":")
			:let colon2 = stridx(line, ":", colon1 + 1)
<		搜索对大小写敏感。
		要使用模式搜索，可用 |match()|。
		如果 {needle} 在 {haystack} 里没有出现过，返回 -1。
		另见 |strridx()|。示例: >
		  :echo stridx("An Example", "Example")	     3
		  :echo stridx("Starting point", "Start")    0
		  :echo stridx("Starting point", "start")   -1
<							*strstr()* *strchr()*
		stridx() 相当于 C 函数 strstr()。如果使用单个字符，则相当于
		strchr()。

		也可用作 |method|: >
			GetHaystack()->stridx(needle)
<
		返回类型: |Number|


string({expr})						*string()*
		返回 {expr} 转换后的字符串。{expr} 为数值、浮点数、字符串、
		blob 或它们的复合形式时，使用 |eval()| 可以将字符串转换回原来
		的值。
			{expr} 类型	返回值 ~
			字符串		'string' (其中的单引号加倍)
			数值		123
			浮点数		123.123456 或 1.23456e8
			函数引用	function('name')
			blob		0z00112233.44556677.8899
			列表		[item, item]
			元组		(item, item)
			字典		{key: value, key: value}
			类		class SomeName
			对象		object of SomeName {lnum: 1, col: 3}
			枚举		enum Enumname
			枚举值		enum name.value {name: str,
					ordinal: nr}

		|List|、|Tuple| 或 |Dictionary| 中如有递归引用，该递归引用会被
		替换为 "[...]"、"(...)" 或 "{...}"。在此返回值上运行 |eval()|
		会出错。

		{expr} 为对象时，调用其 string() 方法以得到该对象的文本表示。
		如果对象中该方法未定义，返回对象的缺省表示。|object-string()|

		也可用作 |method|: >
			mylist->string()

<		另见 |strtrans()|。

		返回类型: |String|


strlen({string})					*strlen()*
		返回字符串 {string} 的字节长度，类型为数值。
		参数为数值时，会先把它转化为字符串。其它类型会报错并返回零。
		要计算多字节字符的数目，可用 |strchars()|。
		另见 |len()|、|strdisplaywidth()| 和 |strwidth()|。

		也可用作 |method|: >
			GetString()->strlen()
<
		返回类型: |Number|


strpart({src}, {start} [, {len} [, {chars}]])		*strpart()*
		返回 {src} 从第 {start} 个字节开始，字节长度为 {len} 的子字符
		串。
		{chars} 给出且为 TRUE 时，{len} 指定字符位置的数目 (组合字符不
		单独计算，因此 "1" 代表一个基本字符，可后跟任意多个的组合字
		符)，而非字节长度。
		对于 {start} 而言，如果希望按字符数而非字节数来计算，请用
		|strcharpart()|。

		如果选择的字节并不存在，返回值里会简单忽略这些字节，不会报错。
		{len} 省略时，子串会从 {start} 开始，直到 {src} 的结尾。 >
			strpart("abcdefg", 3, 2)    == "de"
			strpart("abcdefg", -2, 4)   == "ab"
			strpart("abcdefg", 5, 4)    == "fg"
			strpart("abcdefg", 3)       == "defg"

<		注意: 首个字符对应的 {start} 为零。比如，要得到光标所在的字
		符: >
			strpart(getline("."), col(".") - 1, 1, v:true)
<
		如果出错，返回空串。

		也可用作 |method|: >
			GetText()->strpart(5)
<
		返回类型: |String|


strptime({format}, {timestring})			*strptime()*
		返回符合 {format} 指定格式的 {timestring} 解析后得到的日期和时
		间的 unix 时间戳，类型为数值。

		可接受的 {format} 取决于系统，这意味着本函数不可移植！具体格式
		见 C 函数 strptime() 的手册页。特别要注意避免 "%c"。$TZ 的值也
		相关。

		如果 {timestring} 不能用 {format} 格式解析，返回零。如果无法确
		定 {timestring} 的具体格式，可以尝试使用不同的 {format} 值直到
		返回非零值为止。

		另见 |strftime()|。
		示例: >
		  :echo strptime("%Y %b %d %X", "1997 Apr 27 11:49:23")
<		  862156163 >
		  :echo strftime("%c", strptime("%y%m%d %T", "970427 11:53:55"))
<		  Sun Apr 27 11:53:55 1997 >
		  :echo strftime("%c", strptime("%Y%m%d%H%M%S", "19970427115355") + 3600)
<		  Sun Apr 27 12:53:55 1997

		也可用作 |method|: >
			GetFormat()->strptime(timestring)
<
		并非所有系统都支持本函数。要确认是否可用: >
			:if exists("*strptime")
<
		返回类型: |Number|


strridx({haystack}, {needle} [, {start}])		*strridx()*
		返回 {needle} 字符串在 {haystack} 字符串中最后一次出现的字节位
		置。
		{start} 给出时，超出指定的字节位置之外的匹配被忽略。可用来寻找
		上一个匹配: >
			:let lastcomma = strridx(line, ",")
			:let comma2 = strridx(line, ",", lastcomma - 1)
<		搜索对大小写敏感。
		要使用模式搜索，可用 |match()|。
		如果 {needle} 在 {haystack} 里没有出现过，返回 -1。
		如果 {needle} 为空，返回 {haystack} 的长度。
		另见 |stridx()|。示例: >
		  :echo strridx("an angry armadillo", "an")	     3
<							*strrchr()*
		如果使用单个字符，相当于 C 函数 strrchr()。

		也可用作 |method|: >
			GetHaystack()->strridx(needle)
<
		返回类型: |Number|


strtrans({string})					*strtrans()*
		返回将 {string} 里所有的不可显示字符翻译成可显示 'isprint' 形
		式的字符串，翻译方式和这些字符在窗口里的显示形式一致。例如: >
			echo strtrans(@a)
<		会显示 'a' 寄存器值，其中的换行符显示为 "^@" 而非开启新行。

		如果出错，返回空串。

		也可用作 |method|: >
			GetString()->strtrans()
<
		返回类型: |String|


strutf16len({string} [, {countcc}])			*strutf16len()*
		返回字符串 {string} (转换为 utf-16 后) 的 utf-16 代码单元数，
		类型为数值。

		{countcc} 为真时，组合字符会单独计算。
		{countcc} 省略或为假时，计算时会忽略组合字符。

		如果出错，返回零。

		另见 |strlen()| 和 |strcharlen()|。
		示例: >
		    echo strutf16len('a')		返回 1
		    echo strutf16len('©')		返回 1
		    echo strutf16len('😊')		返回 2
		    echo strutf16len('ą́')		返回 1
		    echo strutf16len('ą́', v:true)	返回 3
<
		也可用作 |method|: >
			gettext()->strutf16len()
<
		返回类型: |Number|


strwidth({string})					*strwidth()*
		返回字符串 {string} 在屏幕上占据的显示单元的数目，类型为数值。
		制表符算作一个单元。如果不想如此，可用 |strdisplaywidth()|。
		{string} 包含东亚二义性宽度字符类时，'ambiwidth' 也会影响返回
		值。
		如果出错，返回零。
		另见 |strlen()|、|strdisplaywidth()| 和 |strchars()|。

		也可用作 |method|: >
			GetString()->strwidth()
<
		返回类型: |Number|


submatch({nr} [, {list}])				*submatch()* *E935*
		只能在 |:substitute| 命令或 |substitute()| 函数中使用的替代表
		达式内使用。
		返回匹配文本的第 {nr} 个子匹配。{nr} 为 0 时，返回整个匹配文
		本。
		注意 字符串中的 NL 既可以代表多行匹配里的换行符，也可以代表实
		际文件中的 NUL 字符。
		另见 |sub-replace-expression|。

		{list} 给出且非零时，submatch() 返回字符串列表，和带两个参数的
		|getline()| 类似 (译者注: 带三个参数的 |getreg()| 可能是更合适
		的例子。带此选项时，多行文本会被拆分为不同的列表项)。文本中的
		NL 只会代表文件中的 NUL 字符。
		只有在 |:substitute| 的情况下，才会返回多于一个项目，
		|substitute()| 中，此列表总是包含一或零个项目，因为那里不会有
		真正的换行符。

		|substitute()| 被递归调用时，只能得到当前 (最深一层) 调用的子
		匹配。

		如果出错，返回空串或空列表。

		例如: >
			:s/\d\+/\=submatch(0) + 1/
			:echo substitute(text, '\d\+', '\=submatch(0) + 1', '')
<		找到行内第一个数值，返回时加上 1。
		换行符会用 <NL> 表示。

		也可用作 |method|: >
			GetNr()->submatch()
<
		返回类型: |String| 或 list<string>，取决于 {list}


substitute({string}, {pat}, {sub}, {flags})		*substitute()*
		返回将 {string} 中 {pat} 的首个匹配替代为 {sub} 的新字符串。
		{flags} 为 "g" 时，{string} 里的所有 {pat} 匹配都会被替代。
		否则，{flags} 必须为 ""。

		本函数的行为和不带任何标志位的 |:substitute| 命令类似。但此处
		{pat} 的匹配总假定 'magic' 选项已置位且 'cpoptions' 为空 (为了
		确保脚本的可移植性)。
		'ignorecase' 仍然适用，但 |/\c| 或 |/\C| 可用来直接指定是否忽
		略或匹配大小写并忽略 'ignorecase' 的设置。'smartcase' 不适用。
		{pat} 的用法可见 |string-match|。

		注意 {sub} 里字符有特殊含义 |sub-replace-special|。比如，要将
		文本替代为 "\n" (两个字符)，要用 "\\\\n" 或 '\\n'。那里也说明
		了 {sub} 和 |:substitute| 行为的若干差异，包括 {sub} 里的 '~'
		不会被换成前一个 {sub}。

		如果 {pat} 在 {string} 里找不到匹配，返回未经修改的 {string}。

		示例: >
		   :let &path = substitute(&path, ",\\=[^,]*$", "", "")
<		会删除 'path' 选项里的最后一个目录名。 >
		   :echo substitute("testing", ".*", "\\U\\0", "")
<		会返回 "TESTING"。

		{sub} 参数以 \= 开始时，其余部分被视为一个表达式，见
		|sub-replace-expression|。示例: >
		   :echo substitute(s, '%\(\x\x\)',
			   \ '\=nr2char("0x" .. submatch(1))', 'g')

<		{sub} 为函数引用时，会调用该函数，传递一个可选参数，返回作为替
		代结果的字符串。示例: >
		   :echo substitute(s, '%\(\x\x\)', SubNr, 'g')
<		传递的可选参数是包含完整匹配及多达九个子匹配的列表，就像
		|submatch()| 的那些返回值那样。示例: >
		   :echo substitute(s, '%\(\x\x\)', {m -> '0x' .. m[1]}, 'g')

<		如果出错，返回空串。

		也可用作 |method|: >
			GetString()->substitute(pat, sub, flags)
<
		返回类型: |String|


swapfilelist()						*swapfilelist()*
		返回指定目录下能找到的交换文件名的列表，其内容和 "vim -r" 的输
		出相同。参见 |-r| 命令参数。'directory' 选项决定要检视的目录。
		如果只想看到当前目录下的交换文件，可临时设置 'directory' 为句
		号 (当前目录): >
			let save_dir = &directory
			let &directory = '.'
			let swapfiles = swapfilelist()
			let &directory = save_dir
<
		返回类型: list<string>


swapinfo({fname})					*swapinfo()*
		返回关于交换文件 {fname} 的信息字典。可用的条目是:
			version Vim 版本
			user	用户名
			host	主机名
			fname	原始文件名
			pid	创建交换文件的 Vim 进程的 PID
			mtime	以秒为单位的文件最近修改时间
			inode	可选: 文件的 INODE 值
			dirty	文件被修改过则为 1，否则为 0
		注意 "user" 和 "host" 被缩短为最多 39 个字节。
		如果失败，加入 "error" 条目，说明相关原因:
			Cannot open file: 文件找不到或不能访问
			Cannot read file: 不能读入首块
			Not a swap file: 没有包含正确的块 ID
			Magic number mismatch: 首块包含的信息不正确

		也可用作 |method|: >
			GetFilename()->swapinfo()
<
		返回类型: dict<any> 或 dict<string>


swapname({buf})						*swapname()*
		返回缓冲区 {buf} 所用的交换文件路径。
		{buf} 的用法见上述 |bufname()|。
		缓冲区 {buf} 是当前缓冲区时，结果相当于 |:swapname| (除非没
		有交换文件)。
		如果缓冲区 {buf} 没有交换文件，返回空串。

		也可用作 |method|: >
			GetBufname()->swapname()
<
		返回类型: |String|


synID({lnum}, {col}, {trans})				*synID()*
		返回当前窗口第 {lnum} 行第 {col} 列所在的语法 ID，类型为数值。
		语法 ID 可用于 |synIDattr()| 和 |synIDtrans()|，用以得到文本的
		语法信息。

		最左列的列号 {col} 为 1。首行的行号 {lnum} 为 1。适用
		'synmaxcol' 选项，如果指定行超出该设置，返回零。
		注意 如果指定位置在行末最后一个字符之后 (插入模式下这是一个合
		法的光标位置)，synID() 会返回零。{lnum} 的用法见 |getline()|。

		{trans} 为 |TRUE| 时，透明项目 |:syn-transparent| 被简约为它们
		实际显露的项目。可用于获取实际使用的颜色。{trans} 为 |FALSE|
		时，则返回透明项目本身。可用于获取实际有效的语法项目 (比如，在
		括号内部)。
		警告: 本函数可能很慢。要获得最佳性能，建议按顺序从前往后遍历文
		件。

		如果出错，返回零。

		例如 (回显光标所在的语法项目名): >
			:echo synIDattr(synID(line("."), col("."), 1), "name")
<
		返回类型: |Number|


synIDattr({synID}, {what} [, {mode}])			*synIDattr()*
		返回语法 ID {synID} 的 {what} 属性，类型为字符串。可用于得到语
		法项目的相关信息。
		{mode} 可为 "gui"、"cterm" 或 "term"，返回所选显示模式下的属性。
		{mode} 省略或者为非法值时，使用当前激活的显示模式 (GUI、cterm
		或 term)。
		|synIDtrans()| 可用来跟随链接的高亮组 (译者注: 建议始终跟随，
		不然对于有链接的高亮组，除了 "name" 外，其他项目值均为空)。
		{what}		结果 ~
		"name"		语法项目名
		"fg"		前景色 (GUI: 颜色设置时使用的色彩名，cterm: 字
				符串形式的色彩号，term: 空串)
		"bg"		背景色 (用法同 "fg")
		"font"		用于 GUI 的字体名 |highlight-font|
		"sp"		用于 GUI 的特殊颜色 (用法同 "fg")
				|highlight-guisp|
		"ul"		用于 cterm 的下划线颜色: 字符串形式的数值
		"fg#"		用于 GUI，和 "fg" 类似，但返回 "#RRGGBB" 形式
		"bg#"		和 "bg" 类同，用法同 "fg#"
		"sp#"		和 "sp" 类同，用法同 "fg#"
		"bold"		粗体则为 "1"
		"italic"	斜体则为 "1"
		"reverse"	反显则为 "1"
		"inverse"	反显则为 "1" (= reverse)
		"standout"	突出则为 "1"
		"underline"	下划线则为 "1"
		"undercurl"	下曲线则为 "1"
		"strike"	删除线则为 "1"
		"nocombine"	指定了 nocombine 则为 "1"

		如果出错，返回空串。

		示例 (回显光标所在的语法项目的颜色): >
	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
<
		也可用作 |method|: >
	:echo synID(line("."), col("."), 1)->synIDtrans()->synIDattr("fg")
<
		返回类型: |String|


synIDtrans({synID})					*synIDtrans()*
		返回 {synID} 翻译后的语法 ID，类型为数值。这是用于实际高亮字符
		的语法组 ID。本函数会跟随 ":highlight link" 的目标高亮组，必要
		时递归进行，直到找到最终实际使用的组为止。
		(译者注: 对未链接到其他语法组的语法组，会直接返回它自身)。

		如果出错，返回零。

		也可用作 |method|: >
	:echo synID(line("."), col("."), 1)->synIDtrans()->synIDattr("fg")
<
		返回类型: |Number|


synconcealed({lnum}, {col})				*synconcealed()*
		返回指定位置的可隐藏区域信息，类型为包含三个值的 |List|:
		1. 首个项目当 {lnum} 和 {col} 指定位置上的字符不在可隐藏区域时
		   为 0，否则为 1。{lnum} 的用法可见 |getline()|。
		2. 第二个项目为字符串。当首项为 1 时，第二项包含用于替代被隐藏
		   文本的实际显示文本，其显示效果视乎 'conceallevel' 和
		   'listchars' 的当前值而定。
		3. 第三个也即最后一个项目是在指定行内，代表不同语法区域的序列
		   号。如果出现了两个连续的使用相同替代字符的可隐藏区域，此序
		   列号可用于检测指定列是否是一个新的可隐藏区域的开始。例如，
		   假定一行文本是 "123456"，"23" 和 "45" 分别被隐藏，而替代字
		   符都是 "X"，则:
			调用			返回值 ~
			synconcealed(lnum, 1)   [0, '', 0]
			synconcealed(lnum, 2)   [1, 'X', 1]
			synconcealed(lnum, 3)   [1, 'X', 1]
			synconcealed(lnum, 4)   [1, 'X', 2]
			synconcealed(lnum, 5)   [1, 'X', 2]
			synconcealed(lnum, 6)   [0, '', 0]

		注意: 本函数不考虑 |matchadd()| 高亮项目，因为语法和匹配高亮是
		两种不同的机制 |syntax-vs-match|。

		返回类型: list<any>


synstack({lnum}, {col})					*synstack()*
		返回当前窗口在 {lnum} 和 {col} 指定位置上的语法项目的堆栈，类
		型为 |List|。{lnum} 的用法可见 |getline()|。每个列表项是一个语
		法 ID，类型和 |synID()| 返回的相同。
		列表的第一项对应最外层区域，其后每项依次是被前一项包含的语法项
		目。列表最后一项通常就是 |synID()| 返回的语法 ID，除非该位置不
		是完整被高亮 (译者注: 例如，在行末字符之后的位置上，本函数会返
		回该行结束时所在的语法项目，而 |synID()| 会返回 0)，或者它是一
		个透明项目。
		本函数可用于调试语法文件。
		显示光标所在的语法项目栈的示例: >
			for id in synstack(line("."), col("."))
			   echo synIDattr(id, "name")
			endfor
<		如果 {lnum} 和 {col} 指定的位置非法，返回空列表。不过，行末字
		符之后的位置以及空行的首列都被认为是合法的位置。

		返回类型: list<number> 或 list<any>


system({expr} [, {input}])				*system()* *E677*
		返回外壳命令 {expr} 的输出结果，类型为 |String|。要得到 |List|
		形式的输出结果，见 |systemlist()|。

		{input} 给出且为 |String| 时，该字符串会写入一个临时文件，并作
		为标准输入传给外壳命令。字符串会照原样写入，因此需要自行确保
		使用合适的换行符。
		{input} 给出且为 |List| 时，同样会写入临时文件，其行为类似于
		|writefile()| 使用 {binary} 设为 "b" 的方式 (也就是，列表项之
		间写入换行符，而列表项内部的换行符会被改写为 NUL)。
		{input} 给出且为数值时，该数值为对应已存在的缓冲区的合法缓冲区
		号。该缓冲区的内容会被逐行写入临时文件，每行以 NL 结尾，文本内
		的 NL 会被改写为 NUL 字符。

		不使用管道，也不使用 'shelltemp' 选项。

		如果加上了前缀 |:silent|，终端不设为加工 (cooked) 模式。这里假
		定命令不需要用户输入，从而避免屏幕上显示多余的字符，也就无需使
		用 |CTRL-L| 来清屏。 >
			:silent let f = system('ls *.vim')
<
		注意: |shellescape()|、|expand()| 里使用 |::S| 或
		|fnamemodify()| 都可以转义命令参数里的特殊字符。{expr} 里的换
		行可能会使命令失败。'shellquote' 和 'shellxquote' 里列出的字符
		也可能会引起麻烦。
		本函数不用于执行交互命令。

		返回字符串。示例: >
		    :let files = system('ls ' .. shellescape(expand('%:h')))
		    :let files = system('ls ' .. expand('%:h:S'))

<		为了使返回结果更独立于所用的系统，外壳输出的结果会被过滤，在
		Macintosh 上，<CR> 会被替换成 <NL>，而在 DOS 系列的系统上，
		<CR><NL> 会被替换成 <NL>。
		为了避免返回字符串在 NUL 处被截断，输出结果里所有的 NUL 的字符
		都会被替换为 SOH (0x01)。

		执行的命令是根据多个选项以下述方法构造的:
		'shell' 'shellcmdflag' 'shellxquote' {expr} 'shellredir'
			\ {tmp} 'shellxquote'
		({tmp} 是自动生成的一个临时文件名)。
		(译者注: 实际为一行，这里分为两行只是为了排版方便)
		Unix 上，{expr} 会用小括号包围，用于支持连接的多条命令。

		以加工 ("cooked") 模式执行命令，这样可用 CTRL-C 来中止命令 (至
		少在 Unix 上是如此)。

		返回的错误代码可以在 |v:shell_error| 里找到。
		该函数不能在 |restricted-mode| 里运行。

		注意 如果上面提到的选项包含错误值，本函数可能会执行失败。此
		外，使用某些安全代理应用时，也有报告显示本函数可能会失败。
		和 ":!cmd" 不同，不会自动检查文件有否被外部应用改变。要强制该
		检查，可用 |:checktime|。

		也可用作 |method|: >
			:echo GetCmd()->system()
<
		返回类型: |String|


systemlist({expr} [, {input}])				*systemlist()*
		和 |system()| 类同，但返回由行组成的 |List| (通过将命令的输出
		结果用 NL 字符拆分得到)，输出结果里的 NUL 会被转换为 NL。其行
		为和 |readfile()| 使用 {binary} 参数设为 "b" 的方式基本相同，
		区别在于如果结果以 NL 结尾，不会产生额外的空列表项。
		注意 MS-Windows 上，可能会产生拖尾的 CR 字符。

		如果要看到 "echo hello" 和 "echo -n hello" 的区别，不能用本函
		数，但可用 |system()| 和 |split()|: >
			echo system('echo hello')->split('\n', 1)
<
		如果出错，返回空串。

		也可用作 |method|: >
			:echo GetCmd()->systemlist()
<
		返回类型: list<string>


tabpagebuflist([{arg}])					*tabpagebuflist()*
		返回和当前标签页里每个窗口相关联的缓冲区编号组成的 |List|。
		{arg} 给出所使用的标签页编号。默认使用当前标签页。
		如果 {arg} 非法，返回数值零。
		要得到所有标签页里的所有缓冲区的列表，可用: >
			let buflist = []
			for i in range(tabpagenr('$'))
			   call extend(buflist, tabpagebuflist(i + 1))
			endfor
<		注意 相同缓冲区号可能重复出现，因为同一缓冲区可能会在多个窗口
		里可见。

		也可用作 |method|: >
			GetTabpage()->tabpagebuflist()
<
		返回类型: list<number>


tabpagenr([{arg}])					*tabpagenr()*
		返回当前标签页号，类型为数值。首个标签页的编号为 1。

		可选参数 {arg} 支持以下值:
			$	最后一个标签页的编号 (即标签页总数)。
			#	最近访问标签页的编号 (|g<Tab>| 对应)。如果先前
				没有访问过其他标签页，返回 0。
		标签页号可用于 |:tab| 命令。

		如果出错，返回零。

		返回类型: |Number|


tabpagewinnr({tabarg} [, {arg}])			*tabpagewinnr()*
		和|winnr()| 类同，但使用标签页 {tabarg}。
		{tabarg} 指定要使用的标签页号。
		{arg} 的用法和 |winnr()| 相同:
		- 省略时，会返回当前窗口号，也就是转到该标签页时会转到的窗口。
		- 为 "$" 时，会返回窗口的总数。
		- 为 "#" 时，会返回上次访问的窗口编号 |CTRL-W_p|。
		有用的例子: >
		    tabpagewinnr(1)	    " 标签页 1 的当前窗口
		    tabpagewinnr(4, '$')    " 标签页 4 的窗口总数
<		如果 {tabarg} 非法，返回零。

		也可用作 |method|: >
			GetTabpage()->tabpagewinnr()
<
		返回类型: |Number|


tagfiles()						*tagfiles()*
		返回当前缓冲区用于搜索标签的文件名 |List|。这是 'tags' 选项经
		过扩展后的内容。

		返回类型: list<string> 或 list<any>


taglist({expr} [, {filename}])				*taglist()*
		返回所有匹配正则表达式 {expr} 的标签组成的 |List|。

		{filename} 给出时，指定当前文件，从而像 |:tselect| 一样，影响
		多个匹配间的优先顺序。见 |tag-priority|。{filename} 必须是文件
		的完整路径。

		每个列表项是一个字典，包含至少以下条目:
			name		标签名。
			filename	标签定义所在的文件名。可能是相对于当前
					目录的相对路径，也可能是完整路径。
			cmd		可用于在文件内定位标签的 Ex 命令。
			kind		标签类型。该条目的可能值取决于特定于语
					言的类型值。只存在于
					Universal/Exuberant ctags 或 hdrtag 生
					成的标签文件。
			static		标签特定于文件 (即静态标签) 则为
					TRUE。详见 |static-tag|。
		可能还有一些额外条目，取决于标签文件的内容: access、
		implementation、inherits 和 signature。关于这些字段的信息参见
		ctags 文档。C 代码里还可能出现字段 "struct"、"class" 和 "enum"，
		它们给出标签所在实体的名字。

		ex 命令 "cmd" 可以是 ex 搜索模式、行号或者行号后跟字节位置 (译
		者注: 最后一种是 emacs 标签格式)。

		如果没有任何标签匹配，返回空列表。

		要得到标签的准确匹配，{expr} 里必须使用锚点 '^' 和 '$'。这也可
		以加快函数的工作速度。
		关于标签搜索的正则表达式模式，详见 |tag-regexp|。

		关于 Vim 如何定位标签文件，可见 'tags' 。
		关于不同的 ctags 工具生成的标签文件格式，可见
		|tags-file-format|。

		也可用作 |method|: >
			GetTagpattern()->taglist()
<
		返回类型: list<dict<any>> 或 list<any>


tan({expr})						*tan()*
		返回以弧度测量的 {expr} 的正切值，类型为 |Float|，范围在
		[-inf, inf] 之间。
		{expr} 的计算结果必须是 |Float| 或 |Number|。否则返回 0.0。
		示例: >
			:echo tan(10)
<			0.648361 >
			:echo tan(-4.01)
<			-1.181502

		也可用作 |method|: >
			Compute()->tan()
<
		返回类型: |Float|


tanh({expr})						*tanh()*
		返回 {expr} 的双曲正切值，类型为 |Float|，范围在 [-1, 1] 之
		间。
		{expr} 的计算结果必须是 |Float| 或 |Number|。否则返回 0.0。
		示例: >
			:echo tanh(0.5)
<			0.462117 >
			:echo tanh(-1)
<			-0.761594

		也可用作 |method|: >
			Compute()->tanh()
<
		返回类型: |Float|

							*tempname()*
tempname()						*temp-file-name*
		返回一个当前不存在的文件名，类型是字符串。可用作临时文件。本函
		数会确保至少连续 26 次调用不会生成重复的文件名。例如: >
			:let tmpfile = tempname()
			:exe "redir > " .. tmpfile
<		在 Unix 上，该文件会放置在用户个人的目录下 |tempfile|，Vim 退
		出时会自动递归删除该文件，而在其他系统上，退出时不会自动清除临
		时文件。
		在 MS-Windows 上，'shellslash' 选项置位，或者 'shellcmdflag'
		以 '-' 开头且 'shell' 不包含 powershell 或 pwsh 时，使用正斜
		杠。

		返回类型: |String|


term_ 函数文档在这里: |terminal-functions-details|


terminalprops()						*terminalprops()*
		返回由 Vim 根据 |t_RV| 请求的响应内容检测到的终端属性组成的
		|Dictionary|。原始响应可见 |v:termresponse|。如果
		|v:termresponse| 为空，多数条目的值会是 'u'，代表未知。
		   cursor_style		是否可发送 |t_RS| **
		   cursor_blink_mode	是否可发送 |t_RC| **
		   underline_rgb	|t_8u| 是否可用 **
		   mouse		支持的鼠标类型
		   kitty		是否检测到 Kitty 终端

		** 值 'u' 代表未知，'y' 代表是，'n' 代表否

		如果没有 |+termresponse| 特性，返回空字典。

		"cursor_style" 是 'y' 时，会发送 |t_RS| 以请求当前光标风格。
		"cursor_blink_mode" 是 'y' 时，会发送 |t_RC| 以请求当前光标闪
		烁状态。
		|t_u7| 非空时，也会置位 "cursor_style" 和
		"cursor_blink_mode"，此时 Vim 会在启动时检测 |t_RS| 和 |t_RC|
		是否可发送。

		"underline_rgb" 不是 'y' 时，|t_8u| 会设为空。这会避免把它发送
		到 xterm 以清除色彩。

		"mouse" 对应的值 'u' 代表鼠标类型未知。

		另见:
		- 'ambiwidth' - 由 |t_u7| 自动检测。
		- |v:termstyleresp| 和 |v:termblinkresp|，对应 |t_RS| 和
		  |t_RC| 的响应。

		返回类型: dict<string>


test_ 函数文档在这里: |test-functions-details|


timer_info([{id}])					*timer_info()*
		返回定时器信息组成的列表。
		{id} 给出时，只返回指定定时器的信息。如果不存在编号为 {id} 的
		定时器，会返回空列表。
		{id} 省略时，返回所有定时器的信息。

		每个定时器的信息以 |Dictionary| 形式保存，包含以下条目:
		    "id"	    定时器 ID
		    "time"	    定时器开始时间
		    "remaining"	    定时器剩余时间
		    "repeat"	    定时器剩余激活的次数；-1 代表永远
		    "callback"	    回调
		    "paused"	    定时器暂停则为 1，否则为 0

		也可用作 |method|: >
			GetTimer()->timer_info()
<
		返回类型: list<dict<any>> 或 list<any>

		{仅当编译时加入 |+timers| 特性才有效}


timer_pause({timer}, {paused})				*timer_pause()*
		暂停或恢复定时器。暂停的定时器在到期时不会调用回调。恢复定时器
		时，只要已经过足够的时间，回调几乎会立即被调用。

		暂停定时器可用于短期跳过它的回调调用。

		{paused} 计算为非零数值或非空字符串时，定时器会被暂停，否则定
		时器会被恢复。见 |non-zero-arg|。

		也可用作 |method|: >
			GetTimer()->timer_pause(1)
<
		返回类型: |Number|

		{仅当编译时加入 |+timers| 特性才有效}

							*timer_start()*
timer_start({time}, {callback} [, {options}])		 *timer* *timers*
		新建定时器，并返回定时器 ID。

		{time} 是以毫秒为单位的等待时间。表示回调被调用的最短间隔。如
		果系统繁忙或 Vim 当前不在等待输入，实际等待时间可能会更长。可
		用零值，此时回调会在 Vim 回到主循环时立即执行。

		{callback} 是要调用的函数。可以是函数名或 |Funcref|。调用时会
		传递一个参数，定时器 ID。只有在 Vim 等待输入时，回调才会调用。
		如果回调想显示信息，可以查看 |popup_notification()|，可用于避
		免信息显示干扰用户正在进行的操作。

		{options} 是字典。支持的条目有:
		   "repeat"	重复调用回调的次数。-1 代表永远。此项省略时，
				默认调用回调一次。
				如果回调函数连续三次出错，取消重复。这可以避免
				错误信息累积过多，从而导致 Vim 无法正常使用。

		如果出错，返回 -1。

		示例: >
			func MyHandler(timer)
			  echo 'Handler called'
			endfunc
			let timer = timer_start(500, 'MyHandler',
				\ {'repeat': 3})
<		会使用 500 毫秒间隔，调用 MyHandle() 三次。

		也可用作 |method|: >
			GetMsec()->timer_start(callback)

<		该命令在沙盘里不可用 |sandbox|。

		返回类型: |Number|

		{仅当编译时加入 |+timers| 特性才有效}


timer_stop({timer})					*timer_stop()*
		停止一个定时器。不再调用定时器回调。
		{timer} 是 |timer_start()| 返回的定时器 ID，所以必须是数值。如
		果 {timer} 不存在，不报错。

		也可用作 |method|: >
			GetTimer()->timer_stop()
<
		返回类型: |Number|

		{仅当编译时加入 |+timers| 特性才有效}


timer_stopall()						*timer_stopall()*
		停止所有定时器。不再调用所有的定时器回调。用于定时器工作不正常
		的场合。如果没有任何定时器，不报错。

		返回类型: |Number|

		{仅当编译时加入 |+timers| 特性才有效}


tolower({expr})						*tolower()*
		将 {expr} 字符串中的所有的大写字符变为小写，返回转换后的新字符
		串 (和在字符串上应用 |gu| 的效果相同)。如果出错，返回空串。

		也可用作 |method|: >
			GetText()->tolower()
<
		返回类型: |String|


toupper({expr})						*toupper()*
		将 {expr} 字符串中的所有的小写字符变为大写，返回转换后的新字符
		串 (和在字符串上应用了 |gU| 的效果相同)。如果出错，返回空串。

		也可用作 |method|: >
			GetText()->toupper()
<
		返回类型: |String|


tr({src}, {fromstr}, {tostr})				*tr()*
		将 {src} 字符串中的所有 {fromstr} 里出现的字符替换为 {tostr}
		字符串里相同位置的字符，返回转换后的新字符串。也就是说，
		{fromstr} 的第一个字符被翻译成 {tostr} 的第一个字符，依次类
		推。这和 unix 命令 "tr" 的效果完全相同。
		本函数能正确处理多字节字符。

		如果出错，返回空串。

		例如: >
			echo tr("hello there", "ht", "HT")
<		返回 "Hello THere" >
			echo tr("<blob>", "<>", "{}")
<		返回 "{blob}"

		也可用作 |method|: >
			GetText()->tr(from, to)
<
		返回类型: |String|


trim({text} [, {mask} [, {dir}]])			*trim()*
		从 {text} 的开头和/或结尾删除 {mask} 里出现的字符，返回新字符
		串。

		{mask} 省略或为空串时，默认是从 0x00 到 0x20 为止的所有字符
		(包括 Tab、空格、NL 和 CR)，加上不换行空格 0xa0。

		可选的 {dir} 参数指定删除字符的位置:
			0	同时从 {text} 的开头和结尾删除
			1	只从 {text} 的开头删除
			2	只从 {text} 的结尾删除
		省略时，同时从两端删除。

		本函数能正确处理多字节字符。
		如果出错，返回空串。

		示例: >
			echo trim("   some text ")
<		返回 "some text" >
			echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") .. "_TAIL"
<		返回 "RESERVE_TAIL" >
			echo trim("rm<Xrm<>X>rrm", "rm<>")
<		返回 "Xrm<>X" (不删除中间部分的字符) >
			echo trim("  vim  ", " ", 2)
<		返回 "  vim"

		也可用作 |method|: >
			GetText()->trim()
<
		返回类型: |String|


trunc({expr})						*trunc()*
		返回绝对值小于等于 {expr} 的最大整数 (向零取整)，类型为
		|Float|。
		{expr} 的计算结果必须是 |Float| 或 |Number|。否则返回 0.0。
		示例: >
			echo trunc(1.456)
<			1.0  >
			echo trunc(-5.456)
<			-5.0  >
			echo trunc(4.0)
<			4.0

		也可用作 |method|: >
			Compute()->trunc()
<
		返回类型: |Float|


tuple2list({tuple})					*tuple2list()*
		根据元组项目的浅备份创建一个新的列表。示例: >
			tuple2list((1, 2, 3))		返回 [1, 2, 3]
<		|list2tuple()| 是其逆操作。

		本函数不会递归地将 {tuple} 内部的元组项目转换为列表。注意 列表
		和元组共享相同的项目引用，如果任何一个项目被修改，元组和列表都
		会受到影响。

		如果出错，返回空列表。

		也可用作 |method|: >
			GetTuple()->tuple2list()
<
		返回类型: list<{type}> (取决于给出的 |Tuple|)


type({expr})						*type()*
		返回 {expr} 的类型值，类型为数值。
		不要直接使用数值，建议使用包含此值的等价 v:t_ 变量:
			数值:	    0  |v:t_number|
			字符串:	    1  |v:t_string|
			函数引用:   2  |v:t_func|
			列表:	    3  |v:t_list|
			字典:	    4  |v:t_dict|
			浮点数:	    5  |v:t_float|
			布尔值:	    6  |v:t_bool| (v:false 和 v:true)
			None:	    7  |v:t_none| (v:null 和 v:none)
			作业:	    8  |v:t_job|
			通道:	    9  |v:t_channel|
			blob:	   10  |v:t_blob|
			类:	   12  |v:t_class|
			对象:	   13  |v:t_object|
			类型别名:  14  |v:t_typealias|
			枚举:	   15  |v:t_enum|
			枚举值:    16  |v:t_enumvalue|
			元组:	   17  |v:t_tuple|
		为了后向兼容，本函数可以这样用: >
			:if type(myvar) == type(0)
			:if type(myvar) == type("")
			:if type(myvar) == type(function("tr"))
			:if type(myvar) == type([])
			:if type(myvar) == type({})
			:if type(myvar) == type(0.0)
			:if type(myvar) == type(v:false)
			:if type(myvar) == type(v:none)
<		要检查 v:t_ 诸变量是否存在，可用: >
			:if exists('v:t_number')

<		也可用作 |method|: >
			mylist->type()
<
		返回类型: |Number|


typename({expr})					*typename()*
		返回 {expr} 的类型字符串描述。
		例如: >
			echo typename([1, 2, 3])
<			list<number> ~

		返回类型: |String|


undofile({name})					*undofile()*
		返回用于名为 {name} 的文件的撤销文件名。本函数会使用 'undodir'
		选项，并在其中寻找实际存在的目录。它不检查该撤销文件是否实际存
		在。
		{name} 总会被扩展为完整路径，因为内部就是这么使用的。
		如果 {name} 为空，返回空串，因为无名缓冲区不写入任何撤销文件。
		可用于 |:wundo| 和 |:rundo|。
		如果编译时没有 |+persistent_undo| 选项，总是返回空串。

		也可用作 |method|: >
			GetFilename()->undofile()
<
		返回类型: |String|


undotree([{buf}])					*undotree()*
		返回 {buf} 指定的缓冲区 (省略时默认为当前缓冲区) 的撤销树的当
		前状态。
		返回值是包含以下条目的 |Dictionary|:
		  "seq_last"	已使用过的最大撤销序列号。
		  "seq_cur"	撤销树中当前位置的序列号。如果有改变被撤销过，
				此值会和 "seq_last" 不同。
		  "time_cur"	用于 |:earlier| 和相关命令的最近时间。
				用 |strftime()| 可以转换成可读的格式。
		  "save_last"	最后的文件写入编号。如果没有写入过则为零。
		  "save_cur"	撤销树当前位置的编号。
		  "synced"	最后的撤销块已经同步则为非零值。这在等待用户输
				入时会发生。见 |undo-blocks|。
		  "entries"	关于撤销块的信息的字典的列表。

		"entries" 列表的首值是最老的撤销项目，依次类推。每个列表项是包
		含以下条目的字典:
		  "seq"		撤销序列号。和 |:undolist| 显示的相同。
		  "time"	改变发生的时间。用 |strftime()| 可以转换成可读
				的格式。
		  "newhead"	只出现在最后加入的项目里。为 1 时标识这里是最
				后的改变位置，也是未来改变要加入的开始位置。
		  "curhead"	只出现在最后撤销的项目里。为 1 时标识这里是撤
				销树当前的位置，该块将用于 redo 命令。如果在最
				后改变之后没有撤销动作，此条目不出现。
		  "save"	只出现在文件写入前最后的块里。表示写入计数。首
				次写入的编号为 1，最后一次是上面提及的
				"save_last"。
		  "alt"		替代项。这又是一个撤销块的列表。每个项目又可以
				有自己的 "alt" 项目。

		返回类型: dict<any>


uniq({list} [, {func} [, {dict}]])			*uniq()* *E882*
		删除 {list} 里相邻重复项的第二个及之后的重复项，直接原位修改列
		表。返回 {list}。如果不想更动原始输入，先创建备份: >
			:let newlist = uniq(copy(mylist))
<		缺省的比较函数使用每个项目的字符串表示形式。{func} 和 {dict}
		的用法可见 |sort()|。
		要删除当前缓冲区里的重复文本，可见 |:uniq|。

		如果 {list} 不是 |List|，返回零。

		也可用作 |method|: >
			mylist->uniq()
<
		返回类型: list<{type}>


uri_decode({string})					*uri_decode()*
		返回 {string} 的 URI 解码形式。逆转百分号编码 (把 "%3D" 这样的
		序列还原为其对应的字符)。

		解码遵循如下标准的百分符解码规则:
		    - "%HH" 会被替换为十六进制 HH 对应的字符。
		    - 解码的字节序列构成合法的 UTF-8 时，会合并为对应的字符。
		      否则，保留原先的字节序列不变。
		    - 非法或不完整的编码 (如 "%GZ"、"%3" 或拖尾的 "%") 保持不
		      变。

		{string} 为空时返回空串。

		示例: >
			:echo uri_decode('c%3A%5Cmy%5Cdir%5Cfoo%20bar')
			c:\my\dir\foo bar
			:echo uri_decode('%CE%B1%CE%B2%CE%B3')
			αβγ
<
		也可用作 |method|: >
			mystr->uri_decode()
<
		Return type: |String|

uri_encode({string})					*uri_encode()*
		返回 {string} 的 URI 编码形式。URI 编码会把不安全或保留的字符
		替换为百分号编码的序列。

		编码遵循如下标准的百分符编码规则:
		    - 字母数字字符 [0-9A-Za-z] 保持不变。
		    - "-"、"_"、"." 和 "~" 也保持不变。
		    - 所有其它字符会被替换为 "%HH"，其中的 HH 是两位十六进制大
		      写数字。
		    - 已有的百分符编码序列不作修改。

		{string} 为空时返回空串。

		示例: >
			:echo uri_encode('c:\my\dir\foo bar')
			c%3A%5Cmy%5Cdir%5Cfoo%20bar
			:echo uri_encode('key=value&name=αβγ')
			key%3Dvalue%26name%3D%CE%B1%CE%B2%CE%B3
<
		也可用作 |method|: >
			mystr->uri_encode()
<
		返回类型: |String|


utf16idx({string}, {idx} [, {countcc} [, {charidx}]])	*utf16idx()*
		和 |charidx()| 类同，但返回 {string} 里第 {idx} 个字节对应的
		(转换为 UTF-16 后) UTF-16 代码单元索引。

		{charidx} 给出且为 TRUE 时，{idx} 用于给出字符串 {string} 里的
		字符索引而非字节索引。
		出现在 UTF-8 序列中间位置的 {idx} 会向下取整，到该序列的开始位
		置。

		如果参数非法或者 {string} 不足 {idx} 个字节，返回 -1。如果正好
		有 {idx} 个字节，返回整个字符串以 UTF-16 代码单元计的长度。

		想了解如何从 UTF-16 索引得到字节索引，可参见 |byteidx()| 和
		|byteidxcomp()|，而要从 UTF-16 索引得到字符索引，可见
		|charidx|。
		详见 |string-offset-encoding|。
		示例: >
			echo utf16idx('a😊😊', 3)	返回 2
			echo utf16idx('a😊😊', 7)	返回 4
			echo utf16idx('a😊😊', 1, 0, 1)	返回 2
			echo utf16idx('a😊😊', 2, 0, 1)	返回 4
			echo utf16idx('aą́c', 6)		返回 2
			echo utf16idx('aą́c', 6, 1)	返回 4
			echo utf16idx('a😊😊', 9)	返回 -1
<
		也可用作 |method|: >
			GetName()->utf16idx(idx)
<
		返回类型: |Number|


values({dict})						*values()*
		返回 {dict} 中所有值组成的 |List|。|List| 项目的顺序不固定。另
		见 |items()| 和 |keys()|。
		如果 {dict} 不是 |Dict|，返回零。

		也可用作 |method|: >
			mydict->values()
<
		返回类型: list<any>


virtcol({expr} [, {list} [, {winid}]])			*virtcol()*
		返回 {expr} 给定的文件位置里的屏幕列号，类型为数值。也就是说，
		此行从开头到该位置所在字符的结束位置为止占据的屏幕单元总数。如
		果该位置是一个 <Tab>，返回值会是 <Tab> 占据的最后一个屏幕列。
		例如在第 1 列 <Tab> 当 'ts' 设为 8 时，会返回 8。这里忽略
		|conceal| 的影响。
		关于字节位置，见 |col()|。

		{expr} 的用法见 |getpos()| 和 |col()|。
		{expr} 为 "$" 时，代表光标行的行尾，所以返回值会是光标行的总屏
		幕单元数加一。

		使用 'virtualedit' 时，{expr} 可以用 [lnum, col, off] 形式，其
		中 "off" 为从对应字符的起始位置算起以屏幕列为单位的偏移量。例
		如，在制表符的内部或在一行文本末尾之后的某个位置。"off" 省略
		时，默认为零。当前模式下使用了虚拟编辑时，也可能返回行尾之后的
		位置。另见 'virtualedit'

		{list} 给出且非零时，返回由字符占据的首末两个屏幕位置组成的列
		表。

		可选的 {winid} 参数给出时，从该窗口取值而不是默认的当前窗口。

		注意 {expr} 中如果使用位置标记，只能使用当前文件里的位置标记。

		示例: >
			" 假定文本为 "foo^Lbar"，光标在 "^L" 上:

			virtcol(".")	" 返回 5
			virtcol(".", 1)	" 返回 [4, 5]
			virtcol("$")	" 返回 9

			" 假定文本为 "	  there"，'t 位置标记在 'h' 上:

			virtcol("'t")	" 返回 6
<
		首屏幕列的列号为 1。如果出错，返回 0 或 [0,0]。

		下面给出一个更高级的示例，用于计算并显示所有行中的最大行长: >
		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))

<		也可用作 |method|: >
			GetPos()->virtcol()
<
		返回类型: |Number|


virtcol2col({winid}, {lnum}, {col})			*virtcol2col()*
		返回窗口 {winid} 在缓冲区行 {lnum} 和虚拟列 {col} 所在的字符的
		字节索引，类型为数值。

		缓冲区行 {lnum} 为空行时，返回 0。

		{col} 超过 {lnum} 行上最后的虚拟列时，返回最后虚拟列所在字符的
		字节索引。

		对于多字节字符，返回该字符首个字节的字节索引。

		{winid} 参数可以是窗口号或 |window-ID|。如果为零，使用当前窗
		口。

		如果窗口 {winid} 不存在，或者缓冲区行 {lnum} 或虚拟列 {col} 非
		法，返回 -1。

		另见 |screenpos()|、|virtcol()| 和 |col()|。

		也可用作 |method|: >
			GetWinid()->virtcol2col(lnum, col)
<
		返回类型: |Number|


visualmode([{expr}])					*visualmode()*
		返回当前缓冲区最近使用的可视模式的描述字符串。尚未进入过可视模
		式时，会返回空串，一旦使用过可视模式，会返回 "v"、"V" 或
		"<CTRL-V>" (单个 CTRL-V 字符)，分别代表面向字符、面向行、和面
		向列块的可视模式。
		例如: >
			:exe "normal " .. visualmode()
<		会进入和上次相同的可视模式。在脚本里也可用本函数来根据最近的可
		视模式采取不同的行动。
		如果当前正处于可视模式中，用 |mode()| 才能得到当前的可视模式
		(例如可在 |:vmap| 中应用)。
		{expr} 给出并且计算结果是非零数值或非空字符串时，将会清除先前
		记录的最近可视模式，并返回被清除的旧值。见 |non-zero-arg|。

		返回类型: |String|


wildmenumode()						*wildmenumode()*
		wildmenu 打开则返回 |TRUE|，否则返回 |FALSE|。参见 'wildmenu'
		和 'wildmode'。
		可用在映射中，以便优雅地处理 'wildcharm' 选项 (只对
		|mapmode-c| 映射有意义)。

		例如要使 <C-J> 在 wildmode 下的行为像 <Down> 一样，可用: >
    :cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"
<
		(备注: 需要 'wildcharm' 先设置为合适的值，此例中设为 <Tab>)。

		返回类型: |Number|


wildtrigger()						*wildtrigger()*
		启动命令行上的通配扩展，采用 'wildmode' 和 'wildoptions' 设置
		所定义的行为。

		本函数也会在搜索模式下打开补全，如 |/|、|?|、|:s|、|:g|、|:v|
		和 |:vimgrep|。

		和手动按下 'wildchar' 不同的是，本函数在找不到匹配时不会响铃，
		一般操作会更安静。这样更适合自动触发补全。

		注意: 在浏览命令行历史后，wildtrigger() 的首个调用会是空操作；
		需要第二次调用才会启动扩展。这是为了支持命令行自动补全中的历史
		浏览。

		见 |cmdline-completion|。

		返回值永远是 0。

		返回类型:|Number|


win_execute({id}, {command} [, {silent}])		*win_execute()*
		和 `execute()` 类同，但在指定 {id} 的窗口上下文中执行。该窗口
		会被临时设为当前窗口，但不触发窗口改变的自动命令，也不会改变目
		录。执行 {command} 时，自动命令会触发，这里可能有意想不到的副
		作用。如有必要，可用 `:noautocmd`。
		示例: >
			call win_execute(winid, 'set syntax=python')
<		这和 `setwinvar()` 类似，但后者不触发自动命令也不实际显示语法
		高亮。
							*E994*
		在弹出窗口中，有些命令无法使用。
		如果指定窗口 {id} 不存在，不报错且返回空串。

		也可用作 |method|，基是作为第二个参数传递的: >
			GetCommand()->win_execute(winid)
<
		返回类型: |String|


win_findbuf({bufnr})					*win_findbuf()*
		返回显示缓冲区 {bufnr} 的所有窗口的 |window-ID| 组成的
		|List|。
		如果没有这样的窗口，返回空列表。

		也可用作 |method|: >
			GetBufnr()->win_findbuf()
<
		返回类型: list<number> 或 list<any>


win_getid([{win} [, {tab}]])				*win_getid()*
		返回指定窗口的 |window-ID|。
		{win} 省略时，默认使用当前窗口。否则使用指定编号的窗口。顶部窗
		口的窗口号为 1。
		{tab} 省略时，默认使用当前标签页，否则使用指定编号为 {tab} 的
		标签页。首个标签页的标签页号为一。
		如果指定窗口不存在，返回零。

		也可用作 |method|: >
			GetWinnr()->win_getid()
<
		返回类型: |Number|


win_gettype([{nr}])					*win_gettype()*
		返回窗口类型:
			"autocmd"	自动命令窗口。用于执行自动命令的临时窗
					口。
			"command"	命令行窗口 |cmdwin|
			(空)		正常窗口
			"loclist"	|location-list-window|
			"popup"		弹出窗口 |popup|
			"preview"	预览窗口 |preview-window|
			"quickfix"	|quickfix-window|
			"unknown"	窗口 {nr} 不存在

		{nr} 省略时，默认返回当前窗口的类型。
		{nr} 给出时，给出窗口号或 |window-ID|，返回指定窗口的类型。

		另见 'buftype' 选项。例如，在弹出窗口中运行终端时，'buftype'
		会是 "terminal"，而 win_gettype() 会返回 "popup"。

		也可用作 |method|: >
			GetWinid()->win_gettype()
<
		返回类型: |String|


win_gotoid({expr})					*win_gotoid()*
		切换到 ID 为 {expr} 的窗口。可能会同时切换当前标签页。
		成功时返回 TRUE，如果指定窗口不存在，返回 FALSE。

		也可用作 |method|: >
			GetWinid()->win_gotoid()
<
		返回类型: |Number|


win_id2tabwin({expr})					*win_id2tabwin()*
		对 ID 为 {expr} 的窗口，返回其标签页号和窗口号组成的列表:
		[tabnr, winnr]。
		如果指定窗口不存在，返回 [0, 0]。

		也可用作 |method|: >
			GetWinid()->win_id2tabwin()
<
		返回类型: list<number>


win_id2win({expr})					*win_id2win()*
		返回 ID 为 {expr} 的窗口的窗口号。
		如果在当前标签页下找不到指定窗口，返回零。

		也可用作 |method|: >
			GetWinid()->win_id2win()
<
		返回类型: |Number|


win_move_separator({nr}, {offset})			*win_move_separator()*
		将窗口 {nr} 的垂直分割线 (也就是其右边界) 移动 {offset} 列，就
		像用鼠标拖动的效果一样。{nr} 可为窗口号或 |window-ID|。正值的
		{offset} 会向右移动，而负值的 {offset} 会向左移动。移动窗口的
		垂直分割线会改变指定窗口的宽度，也会改变和它紧贴着同一分割线的
		相邻窗口的宽度。实际移动幅度可能小于指定的位移 (如因为维持
		'winminwidth' 的需要)。
		指定窗口存在时，返回 TRUE，否则返回 FALSE。
		指定最右侧的窗口或者全宽窗口会失败，因为此时其右侧没有分割线。
		只适用于当前标签页。 *E1308*

		也可用作 |method|: >
			GetWinnr()->win_move_separator(offset)
<
		返回类型: |Number|


win_move_statusline({nr}, {offset})			*win_move_statusline()*
		将窗口 {nr} 的状态行 (也就是其下边界) 移动 {offset} 行，就像用
		鼠标拖动的效果一样。{nr} 可为窗口号或 |window-ID|。正值的
		{offset} 会向下移动，而负值的 {offset} 会向上移动。移动窗口的
		状态行会改变指定窗口的高度，也会改变紧贴着该状态行的相邻窗口的
		高度。实际移动幅度可能小于指定的位移 (如因为维持
		'winminheight' 的需要)。
		指定窗口存在时，返回 TRUE，否则返回 FALSE。
		只适用于当前标签页。

		也可用作 |method|: >
			GetWinnr()->win_move_statusline(offset)
<
		返回类型: |Number|


win_screenpos({nr})					*win_screenpos()*
		返回窗口 {nr} 的屏幕位置: [row, col]，类型为两个数值的列表。首
		个窗口的位置一般总是 [1, 1]，除非有 (译者注: 非 GUI) 标签页
		行，此时会是 [2, 1]。
		{nr} 可为窗口号或 |window-ID|。零代表当前窗口。
		如果指定窗口不存在，返回 [0, 0]。

		也可用作 |method|: >
			GetWinid()->win_screenpos()
<
		返回类型: list<number>


win_splitmove({nr}, {target} [, {options}])		*win_splitmove()*
		暂时切换到窗口 {target}，然后移动窗口 {nr}，使其成为紧贴
		{target} 的新分割窗口。
		和 |:split| 之类的命令不同，不会创建新窗口 (移动后窗口 {nr} 保
		持其窗口 ID 不变)。

		{nr} 和 {target} 都可以是窗口号或 |window-ID|。而且两者都必须
		位于当前标签页中。

		成功时返回零，而失败时返回非零。

		{options} 是包含以下可选条目的 |Dictionary|:
		  "vertical"	为 TRUE 时垂直分割，类似于 |:vsplit|。
		  "rightbelow"	为 TRUE 时，新分割窗口会出现在下方或右方 (垂直
				分割)。为 FALSE 时，新分割窗口会出现在上方或左
				方 (垂直分割)。省略时，默认使用 'splitbelow'
				和 'splitright' 的值。

		也可用作 |method|: >
			GetWinid()->win_splitmove(target)
<
		返回类型: |Number|


winbufnr({nr})						*winbufnr()*
		返回窗口 {nr} 中当前显示的缓冲区的编号。{nr} 可以是窗口号或
		|window-ID|。
		{nr} 为零时，返回当前窗口显示的缓冲区号。
		如果窗口 {nr} 不存在，返回 -1。
		示例: >
  :echo "当前窗口的文件是 " .. bufname(winbufnr(0))
<
		也可用作 |method|: >
			FindWindow()->winbufnr()->bufname()
<
		返回类型: |Number|


wincol()						*wincol()*
		返回窗口光标所在的虚拟列，类型为数值。也就是从窗口左侧算起的屏
		幕列数。最左列为第一列。

		返回类型: |Number|


windowsversion()					*windowsversion()*
		MS-Windows 上，返回当前 OS 版本，类型为字符串。例如，Windows
		10 会返回 "10.0"，Windows 8 会返回 "6.2"，而 Windows XP 会返回
		"5.1"。非 MS-Windows 系统上，返回空串。

		返回类型: |String|


winheight({nr})						*winheight()*
		返回窗口 {nr} 的高度，类型为数值。
		{nr} 可为窗口号或 |window-ID|。
		{nr} 为零时，返回当前窗口的高度。如果窗口 {nr} 不存在，返回
		-1。
		已存在的窗口的高度最小为零。
		窗口工具条行的高度不计算在内。
		示例: >
  :echo "当前窗口有 " .. winheight(0) .. " 行。"

<		也可用作 |method|: >
			GetWinid()->winheight()
<
		返回类型: |Number|


winlayout([{tabnr}])					*winlayout()*
		返回标签页中的窗口布局，类型为嵌套列表。

		{tabnr} 省略时，使用当前标签页，否则使用编号为 {tabnr} 的标签
		页。如果标签页 {tabnr} 不存在，返回空列表。

		对于叶窗口，返回:
			['leaf', {winid}]
		对于水平分割形成的窗口列，返回:
			['col', [{窗口的嵌套列表}]]
		对于垂直分割形成的窗口行，返回:
			['row', [{窗口的嵌套列表}]]

		示例: >
			" 当前标签页中只有一个窗口
			:echo winlayout()
			['leaf', 1000]
			" 当前标签页中有两个水平分割的窗口
			:echo winlayout()
			['col', [['leaf', 1000], ['leaf', 1001]]]
			" 第二个标签页中有三个水平分割的窗口，中间窗口有两个垂
			" 直分割的窗口
			:echo winlayout(2)
			['col', [['leaf', 1002], ['row', [['leaf', 1003],
					    ['leaf', 1001]]], ['leaf', 1000]]]
<
		也可用作 |method|: >
			GetTabnr()->winlayout()
<
		返回类型: list<any>


winline()						*winline()*
		返回当前窗口中，光标所在的屏幕行的行号，类型为数值。亦就是从窗
		口顶部算起的屏幕行数。首行为第 1 行。
		光标移动时，会先更新文件视图，这可能会导致滚动。

		返回类型: |Number|


winnr([{arg}])						*winnr()*
		返回当前窗口的编号，类型为数值。顶部窗口的编号为 1。
		弹出窗口返回零。

		可选参数 {arg} 支持以下值:
			$	返回最后一个窗口的编号 (即窗口的总数)。
			#	返回上次访问窗口的编号 (即 |CTRL-W_p| 转至的窗
				口)。如果没有上次窗口，或者它位于另一个标签页
				中，返回 0。有些情况下，它可能指回当前窗口 (如
				计算 'statusline' 表达式时)。
			{N}j	返回当前窗口之下第 N 个窗口的编号 (即
				|CTRL-W_j| 转至的窗口)。
			{N}k	返回当前窗口之上第 N 个窗口的编号 (即
				|CTRL-W_k| 转至的窗口)。
			{N}h	返回当前窗口之左第 N 个窗口的编号 (即
				|CTRL-W_h| 转至的窗口)。
			{N}l	返回当前窗口之右第 N 个窗口的编号 (即
				|CTRL-W_l| 转至的窗口)。
		窗口编号可用于 |CTRL-W_w| 和 ":wincmd w" |:wincmd|。
		如果 {arg} 非法，报错并返回零。
		另见 |tabpagewinnr()| 和 |win_getid()|。
		示例: >
			let window_count = winnr('$')
			let prev_window = winnr('#')
			let wnum = winnr('3k')

<		也可用作 |method|: >
			GetWinval()->winnr()
<
		返回类型: |Number|


winrestcmd()						*winrestcmd()*
		返回 |:resize| 命令序列，该序列应该能够用来恢复当前窗口的大
		小。只有在没有窗口被打开或关闭过，而且当前窗口和标签页都没有发
		生改变的时候，才能正确工作。
		示例: >
			:let cmd = winrestcmd()
			:call MessWithWindowSizes()
			:exe cmd
<
		返回类型: |String|


winrestview({dict})					*winrestview()*
		使用 |winsaveview()| 返回的 |Dictionary| 来恢复当前窗口的视
		图。
		注意 {dict} 不需要包含 |winsaveview()| 返回的所有的值。某值省
		略时，就不会恢复相应的设置。所以可以用: >
		    :call winrestview({'curswant': 4})
<
		来只设置光标的 curswant 值 (光标垂直移动时会移动到的列) 到第
		5 列 (是的，第 5 列)，而其它设置保持不变。这可用于手动设置光标
		位置。

		如果你手动修改了 |winsaveview()| 的返回值，结果无法预测。如果
		窗口大小发生了改变，结果也不会完全可靠。

		也可用作 |method|: >
			GetView()->winrestview()
<
		返回类型: |Number|


winsaveview()						*winsaveview()*
		返回用来恢复当前窗口视图的信息构成的 |Dictionary|。
		|winrestview()| 可用此信息字典来恢复视图。
		可用于在映射中保存视图，在缓冲区内跳转后，再恢复回原来视图。
		这里不保存折叠的信息。可用 'foldenable' 选项来暂时关闭折叠功
		能，这样移动时就不会打开折叠。这可能有副作用。
		返回值包括:
			lnum		光标行号
			col		光标列号 (注意: 首列为零，和
					|getcurpos()| 不同)
			coladd		'virtualedit' 使用的光标列偏移量
			curswant	垂直移动时会移动到的列 (注意: 首列为零，
					和 |getcurpos()| 不同)。|$| 命令后，设
					为等于 |v:maxcol| 的极大值。
			topline		窗口中显示的首行行号
			topfill		填充行行数，只用于比较模式
			leftcol		窗口中显示的首列列号；只在 'wrap' 关闭
					时使用
			skipcol		窗口顶行开头跳过的列数，只在 'wrap' 开
					启时使用
		注意 这里不保存任何选项值。

		返回类型: dict<number>


winwidth({nr})						*winwidth()*
		返回窗口 {nr} 的宽度，类型为数值。
		{nr} 可为窗口号或 |window-ID|。
		{nr} 为零时，返回当前窗口的宽度。如果窗口 {nr} 不存在，返回
		-1。
		已存在的窗口的宽度最小为零。
		示例: >
  :echo "当前窗口有 " .. winwidth(0) .. " 列。"
  :if winwidth(0) <= 50
  :  50 wincmd |
  :endif
<		要得到终端或屏幕大小，可见 'columns' 选项。

		也可用作 |method|: >
			GetWinid()->winwidth()
<
		返回类型: |Number|


wordcount()						*wordcount()*
		返回当前缓冲区中，字节/字符/单词的统计值构成的字典。和
		|g_CTRL-G| 包含的信息相同。
		返回值包括:
			bytes		缓冲区的字节数
			chars		缓冲区的字符数
			words		缓冲区的单词数
			cursor_bytes    光标前的字节数 (不在可视模式下)
			cursor_chars    光标前的字符数 (不在可视模式下)
			cursor_words    光标前的单词数 (不在可视模式下)
			visual_bytes    可视选择的字节数 (只在可视模式下)
			visual_chars    可视选择的字符数 (只在可视模式下)
			visual_words    可视选择的单词数 (只在可视模式下)

		返回类型: dict<number>


writefile({object}, {fname} [, {flags}])		*writefile()*
		{object} 为 |List| 时，将列表写入文件 {fname}。列表项之间以 NL
		分隔。每个列表项必须是字符串或数值。
		列表项内的所有 NL 字符会转换为 NUL 字符。
		要插入 CR 字符，需要在把 {list} 传递给 writefile() 之前先准备
		好。

		{object} 为 |Blob| 时，其中字节序列会按原样写入文件 {fname}，
		即使不指定二进制模式也是如此。

		{flags} 必须为字符串。识别以下字符 (可组合使用):

		'b'  使用二进制 (Binary) 模式: 最后一个列表项之后不会自动写入
		     NL。如果需要结尾保留换行，可在列表最后追加一个空串项目。

		'a'  使用追加 (Append) 模式，写入的行会附加到现有文件之后: >
			:call writefile(["foo"], "event.log", "a")
			:call writefile(["bar"], "event.log", "a")
<
		'D'  当前函数结束时会自动删除 (Delete) 文件。相当于: >
			:defer delete({fname})
<		     如果不在函数体内使用，会失败。另见 |:defer|。

		's'  写入文件后总会调用 fsync()。尽力确保文件被真正写入磁盘。
		     这会多花些时间，但避免了系统崩溃导致丢失文件内容的风险。

		'S'  写入文件后总不调用 fsync()，忽略 'fsync' 的选项设置。

		     如果 {flags} 既不包含 "S" 也不包含 "s"，仅当置位 'fsync'
		     选项时才会调用 fsync()。

		只要系统允许，会覆盖已有的文件。

		如果写入失败，返回 -1，否则返回 0。如果文件创建或写入失败，会
		报错。

		另见 |readfile()|。
		要按字节复制文件: >
			:let fl = readfile("foo", "b")
			:call writefile(fl, "foocopy", "b")

<		也可用作 |method|: >
			GetText()->writefile("thefile")
<
		返回类型: |Number|


xor({expr}, {expr})					*xor()*
		对两个参数进行按位异或。参数会被转换为数值。参数如果是列表、字
		典或浮点数会报错。
		另见 `and()` 和 `or()`。
		示例: >
			:let bits = xor(bits, 0x80)
<
		也可用作 |method|: >
			:let bits = bits->xor(0x80)
<
		返回类型: |Number|

==============================================================================
3. 特性列表						*feature-list*

有三种类型的特性:
1.  只有在 Vim 编译时加入才会支持的特性 |+feature-list|。例如: >
	:if has("cindent")
<							*gui_running*
2.  只有特定条件满足才会支持的特性。例如: >
	:if has("gui_running")
<							*has-patch*
3.  只有在特定版本之后或在特定版本上并包含了特定补丁才会支持的特性。
    "patch-7.4.248" 特性意味着只有 Vim 7.5 或之后版本，或 7.4 版本并包含补丁
    248 时才会支持。例如: >
	:if has("patch-7.4.248")
<   注意 包含补丁 249 但没有包含补丁 248 是有可能的，只适用于 cherrypick 补丁
    的情况。
    注意 此形式只可用于 7.4.237 补丁或之后版本，在这之前，你需要检查补丁号和
    v:version。例如 (要确定是 version 6.2.148 或更新的版本): >
	:if v:version > 602 || v:version == 602 && has("patch148")

揭示: 要知道 Vim 是否支持文件名中的反斜杠 (MS-Windows)，
可用: `if exists('+shellslash')`


acl			编译时加入了 |ACL| 支持。
all_builtin_terms	编译时打开了所有的内建终端。(总为真)
amiga			Vim 的 Amiga 版本。
arabic			编译时加入了阿拉伯语的支持 |Arabic|。
arp			编译时加入了 ARP 的支持 (Amiga)。
autocmd			编译时加入了自动命令的支持。(总为真)
autochdir		编译时加入了 'autochdir' 的支持。
autoservername		自动打开 |clientserver|。
balloon_eval		编译时加入了 |balloon-eval| 的支持。
balloon_multiline	GUI 支持多行气泡。
beos			Vim 的 BeOS 版本。
browse			编译时加入了 |:browse| 的支持，使 |browse()| 可用。
browsefilter		编译时加入了 |browsefilter| 的支持。
bsd			编译时使用了 BSD 家族的 OS (除了 macOS)。
builtin_terms		编译时打开了若干内建终端的支持。(总为真)
byte_offset		编译时加入了 'statusline' 中对 'o' 的支持。
channel			编译时加入了 |channel| 和 |job| 的支持
cindent			编译时加入了 'cindent' 的支持。(总为真)
clientserver		编译时加入了远程调用的支持 |clientserver|。
clipboard		编译时加入了 'clipboard' 的支持。
clipboard_working	编译时加入了 'clipboard' 的支持且可用。
cmdline_compl		编译时加入了 |cmdline-completion| 的支持。
cmdline_hist		编译时加入了 |cmdline-history| 的支持。
cmdline_info		编译时加入了 'showcmd' 和 'ruler' 的支持。
comments		编译时加入了 'comments' 的支持。
compatible		编译时确保和 Vi 非常兼容。
conpty			|ConPTY| 可用的平台。
cryptv			编译时加入了加密的支持 |encryption|。
cscope			编译时加入了 |cscope| 的支持。
cursorbind		编译时加入了 'cursorbind' 的支持。(总为真)
debug			编译时定义了 "DEBUG"。
dialog_con		编译时加入了控制台对话框的支持。
dialog_con_gui		编译时加入了控制台和 GUI 对话框的支持。
dialog_gui		编译时加入了 GUI 对话框的支持。
diff			编译时加入了 |vimdiff| 和 'diff' 的支持。
digraphs		编译时加入了二合字母的支持。
directx			编译时加入了 DirectX 和 'renderoptions' 的支持。
dnd			编译时加入了 "~ 寄存器的支持 |quote_~|。
drop_file		编译时加入了 |drop_file| 的支持。
ebcdic			在使用 ebcdic 字符集的机器上编译。
emacs_tags		编译时加入了 Emcac 标签的支持。
eval			编译时加入了表达式计算的支持。当然总要打开啦！
ex_extra		|+ex_extra| (总为真)
extra_search		编译时加入了 'incsearch' 和 'hlsearch' 的支持。
farsi			删除了波斯语的支持 |farsi|。
file_in_path		编译时加入了 |gf| 和 |<cfile>| 的支持。(总为真)
filterpipe		'shelltemp' 关闭时，外壳读/写/过滤命令使用管道。
find_in_path		编译时加入了头文件搜索 |+find_in_path| 的支持。
float			编译时加入了 |Float| 的支持。
fname_case		文件名大小写敏感 (在 Amiga 和 Windows 本特性不存在)。
folding			编译时加入了 |folding| 的支持。
footer			编译时加入了 GUI 信息页脚的支持 |gui-footer|。
fork			编译时决定使用 fork()/exec() 而不是 system()。
gettext			编译时加入了信息翻译 |multi-lang|。
gui			编译时加入了 GUI 的支持。
gui_athena		编译时加入了 Athena GUI。(总为假)
gui_gnome		编译时加入了 Gnome 支持 (同时也定义了 gui_gtk)。
gui_gtk			编译时加入了 GTK+ GUI (任何版本)。
gui_gtk2		编译时加入了 GTK+ 2 GUI (同时也定义了 gui_gtk)。
gui_gtk3		编译时加入了 GTK+ 3 GUI (同时也定义了 gui_gtk)。
gui_haiku		编译时加入了 Haiku GUI。
gui_mac			编译时加入了 Macintosh GUI。
gui_motif		编译时加入了 Motif GUI。
gui_photon		编译时加入了 Photon GUI。
gui_running		Vim 在 GUI 上运行，或者 GUI 将很快启动。
gui_win32		编译时加入了 MS-Windows Win32 GUI。
gui_win32s		同上，使用了 Win32s 系统 (Windows 3.1)。
haiku			Vim 的 Haiku 版本。
hangul_input		编译时加入了韩语输入的支持 |hangul|。
hpux			Vim 的 HP-UX 版本。
hurd			Vim 的 GNU/Hurd 版本。
iconv			可以使用 iconv() 进行转换。
insert_expand		编译时加入了插入模式中 CTRL-X 扩展命令的支持。(总为真)
job			编译时加入了 |channel| 和 |job| 的支持。
ipv6			编译时加入了 |channel| 的 IPv6 网络支持。
jumplist		编译时加入了 |jumplist| 的支持。(总为真)
keymap			编译时加入了 'keymap' 的支持。
lambda			编译时加入了 |lambda| 的支持。
langmap			编译时加入了 'langmap' 的支持。
libcall			编译时加入了 |libcall()| 的支持。
linebreak		编译时加入了 'linebreak'、'breakat'、'showbreak' 和
			'breakindent' 的支持。
linux			Vim 的 Linux 版本。
lispindent		编译时加入了 lisp 缩进的支持。(总为真)
listcmds		编译时加入了缓冲区列表 |:files| 和参数列表 |arglist|
			的命令。
localmap		编译时加入了局部映射和缩写 |:map-local|。
lua			编译时加入了 Lua 接口 |Lua|。
mac			Vim 的 Macintosh 版本，参照 osx。
macunix			同 osxdarwin。
menu			编译时加入了 |:menu| 的支持。
mksession		编译时加入了 |:mksession| 的支持。
modify_fname		编译时加入了文件名的修饰符支持 |filename-modifiers|。
			(总为真)
mouse			编译时加入了鼠标的支持。
mouse_dec		编译时加入了 Dec 终端的鼠标支持。
mouse_gpm		编译时加入了 gpm (Linux 控制台鼠标) 的支持。
mouse_gpm_enabled	GPM 鼠标可用。
mouse_netterm		编译时加入了 netterm 的鼠标支持。
mouse_pterm		编译时加入了 qnx 的鼠标支持。
mouse_sysmouse		编译时加入了 sysmouse 支持 (*BSD 控制台鼠标)。
mouse_sgr		编译时加入了 sgr 的鼠标支持。
mouse_urxvt		编译时加入了 urxvt 的鼠标支持。
mouse_xterm		编译时加入了 xterm 的鼠标支持。
mouseshape		编译时加入了 'mouseshape' 的支持。
multi_byte		编译时加入了 'encoding' 的支持。(总为真)
multi_byte_encoding	'encoding' 设为某个多字节的编码。
multi_byte_ime		编译时加入了 IME 输入方法的支持。
multi_lang		编译时加入了多语言的支持。
mzscheme		编译时加入了 MzScheme 接口支持 |mzscheme|。
nanotime		编译时加入了次秒级的时间戳检查。
netbeans_enabled	编译时加入了 |netbeans| 的支持并且已连接上。
netbeans_intg		编译时加入了 |netbeans| 的支持。
num64			编译时加入了 64 位 |Number| 的支持。(总为真)
ole			编译时加入了 Win32 OLE automation 的支持。
osx			为 macOS 编译，参照 mac。
osxdarwin		为 macOS 编译，带有 |mac-darwin-feature|。
packages		编译时加入了 |packages| 的支持。
path_extra		编译时加入了 'path' 和 'tags' 上下搜索的支持。
perl			编译时加入了 Perl 接口。
persistent_undo		编译时加入了持久化撤销历史的支持。
postscript		编译时加入了 PostScript 文件打印的支持。
printer			编译时加入了 |:hardcopy| 的支持。
profile			编译时加入了 |:profile| 的支持。
prof_nsec		剖视结果以纳秒为单位。
python			Python 2.x 接口可用。|has-python|
python_compiled		编译时加入了 Python 2.x 接口。|has-python|
python_dynamic		Python 2.x 接口已动态载入。|has-python|
python3			Python 3.x 接口可用。|has-python|
python3_compiled	编译时加入了 Python 3.x 接口。|has-python|
python3_dynamic		Python 3.x 接口已动态载入。|has-python|
python3_stable		Python 3.x 接口使用 Python 稳定 ABI。|has-python|
pythonx			Python 2.x 和/或 3.x 接口可用。|pythonx|
qnx			Vim 的 QNX 版本。
quickfix		编译时加入了 |quickfix| 的支持。
reltime			编译时加入了 |reltime()| 的支持。
rightleft		编译时加入了 'rightleft' 的支持。
ruby			编译时加入了 Ruby 接口 |ruby|。
scrollbind		编译时加入了 'scrollbind' 的支持。(总为真)
showcmd			编译时加入了 'showcmd' 的支持。
signs			编译时加入了 |:sign| 的支持。
smartindent		编译时加入了 'smartindent' 的支持。(总为真)
socketserver		编译时加入了套接字服务器功能。(只限 Unix)
sodium			编译时加入了 libsodium 以提供更好的加密支持。
sound			编译时加入了声音的支持，例如 `sound_playevent()`。
spell			编译时加入了拼写检查的支持 |spell|。
startuptime		编译时加入了 |--startuptime| 支持。
statusline		编译时加入了 'statusline' 和 'rulerformat' 还有
			'titlestring' 和 'iconstring' 的特殊格式的支持。
sun			Vim 的 SunOS 版本。
sun_workshop		删除了 Sun |workshop| 的支持。
syntax			编译时加入了语法高亮的支持 |syntax|。
syntax_items		当前缓冲区有激活的语法高亮项目。
system			编译时决定使用 system() 而不是 fork()/exec()。
tag_binary		编译时加入了标签文件的二分搜索 |tag-binary-search|。
			(总为真)
tag_old_static		老的静态标签的支持，已删除，见 |tag-old-static|。
tcl			编译时加入了 Tcl 接口。
termguicolors		编译时加入了终端的真彩支持。
terminal		编译时加入 |terminal| 的支持。
terminfo		编译时决定使用 terminfo 而不是 termcap。
termresponse		编译时加入了 |t_RV| 和 |v:termresponse| 的支持。
textobjects		编译时加入了 |text-objects| 的支持。
textprop		编译时加入了 |text-properties| 的支持。
tgetent			编译时加入了 tgetent 的支持，可以使用外部 termcap 或
			terminfo 文件。
timers			编译时加入了 |timer_start()| 支持。
title			编译时加入了窗口标题的支持。'title'。(总为真)
toolbar			编译时加入了 |gui-toolbar| 的支持。
ttyin			输入是终端 (tty)。
ttyout			输出是终端 (tty)。
unix			Vim 的 Unix 版本。 *+unix*
unnamedplus		编译时加入了 'clipboard' 对 "unnamedplus" 的支持。
user_commands		用户定义命令支持。(总为真)
vartabs			编译时加入了可变制表位的支持 'vartabstop'。
vcon			Win32: 有虚拟终端支持，可用 'termguicolors'。另见
			|+vtp|。
vertsplit		编译时加入了垂直分割窗口的支持 |:vsplit|。(总为真)
vim_starting		如果在启动载入脚本的阶段则为真 |startup|。
			*vim_starting*
vim9script		编译时加入 |Vim9| 脚本支持。
viminfo			编译时加入了 viminfo 的支持。
vimscript-1		编译时加入了 Vim 脚本版本 1 的支持。
vimscript-2		编译时加入了 Vim 脚本版本 2 的支持。
vimscript-3		编译时加入了 Vim 脚本版本 3 的支持。
vimscript-4		编译时加入了 Vim 脚本版本 4 的支持。
virtualedit		编译时加入了 'virtualedit' 选项支持。(总为真)
visual			编译时加入了可视模式的支持。(总为真)
visualextra		编译时加入了附加的可视模式命令支持。(总为真)
			|blockwise-operators|。
vms			Vim 的 VMS 版本。
vreplace		编译时加入了 |gR| 和 |gr| 命令支持。(总为真)
vtp			编译时加入了 vcon 支持 |+vtp| (检查 vcon 可知当前控制
			台是否支持)。
wayland			编译时加入了 Wayland 协议支持。
wayland_clipboard	编译时加入了 Wayland 剪贴板支持。
wayland_focus_steal	编译时加入了 Wayland 剪贴板焦点盗取支持。
wildignore		编译时加入了 'wildignore' 选项支持。
wildmenu		编译时加入了 'wildmenu' 选项支持。
win16			旧版本 MS-Windows 3.1。(总为假)
win32			Vim 的 Win32 版本 (MS-Windows 95 及其后的 32 或 64 位
			版本)。
win32unix		Vim 的 Win32 版本，使用 Unix 文件命名 (Cygwin)。
win64			Vim 的 Win64 版本 (MS-Windows 64 位)。
win95			支持 MS-Windows 95/98/ME 的 Win32 版本。(总为假)
winaltkeys		编译时加入了 'winaltkeys' 选项。
windows			编译时加入了多窗口的支持。(总为真)
writebackup		编译时决定缺省打开 'writebackup'。
xattr			编译时加入了扩展属性支持 |xattr| (目前只有 Linux 支
			持)。
xfontset		编译时加入了 X 字体集的支持 |xfontset|。
xim			编译时加入了 X 输入法的支持 |xim|。
xpm			编译时加入了 pixmap 的支持。
xpm_w32			编译时加入了 Win32 的 pixmap 的支持。(只为后向兼容而
			保留，用 "xpm" 代替。)
xsmp			编译时加入了 X 会话管理的支持。
xsmp_interact		编译时加入了交互的 X 会话管理的支持。
xterm_clipboard		编译时加入了 xterm 剪贴板的支持。
xterm_save		编译时加入了保存和恢复 xterm 屏幕的支持。
x11			编译时加入了 X11 的支持。


==============================================================================
4. 字符串里的模式匹配					*string-match*

这是若干函数共同的一类行为。|pattern| 说明的正则表达式通常用于在缓冲区的多行文
本里搜索匹配。当模式用来在字符串里搜索匹配时，绝大多数功能完全相同。唯一的区别
在于，字符串始终被作为单行处理。如果字符串里包含了 "\n" 字符，在模式匹配时，它
并不视为换行，而只是按本义出现的换行符。它可以和模式里的 "\n" 或者 "." 匹配。
示例:
>
	:let a = "aaaa\nxxxx"
	:echo matchstr(a, "..\n..")
	aa
	xx
	:echo matchstr(a, "a.x")
	a
	x

不要忘记 "^" 只会在字符串的首字符处匹配，而 "$" 只会在字符串的末字符处匹配。它
们不会在 "\n" 前后的位置处匹配。

 vim:tw=78:ts=8:noet:ft=help:norl:
