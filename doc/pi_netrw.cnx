*pi_netrw.txt*  For Vim version 8.0.  最近更新: 2017年8月


	    -----------------------------------------------------
		NETRW 参考手册	作者: Charles E. Campbell
	    -----------------------------------------------------
				译者: Willis
				http://vimcdoc.sf.net

Author:  Charles E. Campbell  <NdrOchip@ScampbellPfamily.AbizM>
	  (remove NOSPAM from Campbell's email first)

Copyright: Copyright (C) 2016 Charles E Campbell    *netrw-copyright*
	The VIM LICENSE applies to the files in this package, including
	netrw.vim, pi_netrw.txt, netrwFileHandlers.vim, netrwSettings.vim, and
	syntax/netrw.vim.  Like anything else that's free, netrw.vim and its
	associated files are provided *as is* and comes with no warranty of
	any kind, either expressed or implied.  No guarantees of
	merchantability.  No guarantees of suitability for any purpose.  By
	using this plugin, you agree that in no event will the copyright
	holder be liable for any damages resulting from the use of this
	software. Use at your own risk!

		*netrw*
		*dav*    *ftp*    *netrw-file*  *rcp*    *scp*
		*davs*   *http*   *netrw.vim*   *rsync*  *sftp*
		*fetch*  *network*

==============================================================================
1. 内容							*netrw-contents* {{{1

1.  内容..................................................|netrw-contents|
2.  netrw 初步............................................|netrw-start|
3.  netrw 参考手册........................................|netrw-ref|
      外 部 程 序 及 协 议................................|netrw-externapp|
      读 取...............................................|netrw-read|
      写 入...............................................|netrw-write|
      执 行...............................................|netrw-source|
      目 录 列 表.........................................|netrw-dirlist|
      改 变 用 户 名 和 密 码.............................|netrw-chgup|
      变 量 与 设 置......................................|netrw-variables|
      路 径...............................................|netrw-path|
4.  基于网络的文件传输....................................|netrw-xfer|
      NETRC...............................................|netrw-netrc|
      密 码...............................................|netrw-passwd|
5.  激活..................................................|netrw-activate|
6.  透明远程文件编辑......................................|netrw-transparent|
7.  Ex 命令...............................................|netrw-ex|
8.  变量和选项............................................|netrw-var|
9.  目录浏览..............................................|netrw-browse|
      浏览简介............................................|netrw-intro-browse|
      快速参考: 映射......................................|netrw-browse-maps|
      快速参考: 命令......................................|netrw-browse-cmds|
      显示横幅............................................|netrw-I|
      把目录加入书签......................................|netrw-mb|
      浏览................................................|netrw-cr|
      压缩当前树列表目录..................................|netrw-s-cr|
      水平分割窗口方式浏览................................|netrw-o|
      在新标签页中浏览....................................|netrw-t|
      垂直分割窗口方式浏览................................|netrw-v|
      改变列表方式.(瘦 宽 长 树)..........................|netrw-i|
      切换到收入书签的目录................................|netrw-gb|
      切换到较早访问的目录................................|netrw-u|
      切换到较迟访问的目录................................|netrw-U|
      通过特殊处理程序定制浏览............................|netrw-x|
      删除书签............................................|netrw-mB|
      删除文件或目录......................................|netrw-D|
      目录探索命令........................................|netrw-explore|
      使用星号和模式进行探索..............................|netrw-star|
      显示文件信息........................................|netrw-qf|
      编辑文件或目录隐藏列表..............................|netrw-ctrl-h|
      编辑排序序列........................................|netrw-S|
      强制作为文件或目录对待..............................|netrw-gd| |netrw-gf|
      向上一层............................................|netrw--|
      隐藏文件或目录......................................|netrw-a|
      改进浏览............................................|netrw-ssh-hack|
      列出书签和历史......................................|netrw-qb|
      建立新目录..........................................|netrw-d|
      使浏览目录成为当前目录..............................|netrw-c|
      标记文件............................................|netrw-mf|
      撤销文件标记........................................|netrw-mF|
      用位置列表标记文件..................................|netrw-qL|
      用 QuickFix 列表标记文件............................|netrw-qF|
      用正规表达式标记文件................................|netrw-mr|
      带标记文件: 任意外壳命令............................|netrw-mx|
      带标记文件: 任意外壳命令，整块......................|netrw-mX|
      带标记文件: 任意命令................................|netrw-mv|
      带标记文件: 参数列表................................|netrw-ma| |netrw-mA|
      带标记文件: 压缩及解压缩............................|netrw-mz|
      带标记文件: 复制....................................|netrw-mc|
      带标记文件: 比较....................................|netrw-md|
      带标记文件: 编辑....................................|netrw-me|
      带标记文件: grep....................................|netrw-mg|
      带标记文件: 按后缀隐藏或显示........................|netrw-mh|
      带标记文件: 移动....................................|netrw-mm|
      带标记文件: 打印....................................|netrw-mp|
      带标记文件: 执行....................................|netrw-ms|
      带标记文件: 设置目标目录............................|netrw-mt|
      带标记文件: 建立标签................................|netrw-mT|
      带标记文件: 用书签作为目标目录......................|netrw-Tb|
      带标记文件: 用历史作为目标目录......................|netrw-Th|
      带标记文件: 撤销标记................................|netrw-mu|
      netrw 浏览器变量....................................|netrw-browser-var|
      netrw 浏览和选项不兼容性............................|netrw-incompatible|
      netrw 设置窗口......................................|netrw-settings-window|
      获取文件............................................|netrw-O|
      预览窗口............................................|netrw-p|
      前次窗口............................................|netrw-P|
      刷新列表............................................|netrw-ctrl-l|
      反转排序顺序........................................|netrw-r|
      给文件或目录换名....................................|netrw-R|
      选择排序风格........................................|netrw-s|
      选择编辑窗口........................................|netrw-C|
10. 问题和修正............................................|netrw-problems|
11. 调试 netrw 自身.......................................|netrw-debug|
12. 历史..................................................|netrw-history|
13. TODO .................................................|netrw-todo|
14. 鸣谢..................................................|netrw-credits|

{Vi 没有此项功能}

==============================================================================
2. netrw 初步						*netrw-start* {{{1

netrw 使得读写文件和通过本地或网络进行和浏览变得容易！
首先，确信你打开了插件。这样，你需要至少在 <.vimrc> 里设置: (或者参见
|netrw-activate|) >

	set nocp                    " 不设置 'compatible'
	filetype plugin on          " 允许使用插件
<
(见 |'cp'| 和 |:filetype-plugin-on|)

netrw 支持用 url "透明" 地编辑其它机器上的文件 (见 |netrw-transparent|)。考虑
一个例子，假设你在其它机器上有一个帐号；如果 scp 可用的话，尝试 >

	vim scp://hostname/path/to/file
<
想使 ssh/scp 更容易使用么？察看 |netrw-ssh-hack|！

如果你只有 ftp，没有 ssh/scp 怎么办？也很容易；尝试 >

	vim ftp://hostname/path/to/file
<
想使 ftp 更容易使用么？检查你的 ftp 是不是支持叫 <.netrc> 的文件 -- 通常，它在
你的主目录里，读写权限的设置只限用户自己可读 (也就是，没有组、世界、其它用户等
的权限)，其形式是以下这样的行 >

	machine HOSTNAME login USERID password "PASSWORD"
	machine HOSTNAME login USERID password "PASSWORD"
	...
	default	         login USERID password "PASSWORD"
<
Windows 的 ftp 不支持 .netrc；不过，可以在 .vimrc 里这样做: >

   let g:netrw_ftp_cmd= 'c:\Windows\System32\ftp -s:C:\Users\MyUserName\MACHINE'
<
Netrw 会用 url 的主机名来代替 "MACHINE"，从而，你可以为每个网站分别提供一个文
件: c:\Users\MyUserName\MachineName，来指定 >
	userid
	password

还有浏览 -- 你只想在编辑文件前四处看看。在自己机器上浏览，只要 "编辑" 目录: >

	vim .
	vim /home/userid/path
<
要在远端机器上浏览，也就是 "编辑" 目录 (但要确保目录名后面跟上 "/"): >

	vim scp://hostname/
	vim ftp://hostname/path/to/dir/
<
详情可见 |netrw-browse|！

除了 scp 和 ftp 以外，还支持更多其他的协议！关于如何在 netrw 和 vim 中使用这些
外部应用，见下一节，|netrw-externapp|。

禁 止 载 入 						*netrw-noload*

如果你想使用插件，但由于某种原因不想用 netrw，那你需要禁止调入 netrw 插件本身
和自动调入的部分。为此，在 <.vimrc> 里加入如下两行: >

	:let g:loaded_netrw       = 1
	:let g:loaded_netrwPlugin = 1
<

==============================================================================
3. netrw 参考手册					*netrw-ref* {{{1

   除了 |netrw-start| 提到的 scp 和 ftp 以外，netrw 还支持几个协议。包括 dav、
   fetch、http、...。可以参阅 |netrw-externapp| 的列表。每个协议和一个变量关
   联，该变量指定支持协议的缺省命令。

外 部 程 序 及 协 议					*netrw-externapp* {{{2

	协议      变量	               缺省值
	--------  ----------------     -------------
	   dav:   *g:netrw_dav_cmd*      = "cadaver"    如果 cadaver 可执行
	   dav:   g:netrw_dav_cmd      = "curl -o"    否则，如果 curl 可执行
	 fetch:   *g:netrw_fetch_cmd*    = "fetch -o"   如果 fetch 可用
	   ftp:   *g:netrw_ftp_cmd*      = "ftp"
	  http:   *g:netrw_http_cmd*     = "elinks"     如果 elinks 可用
	  http:   g:netrw_http_cmd     = "links"      否则，如果  links 可用
	  http:   g:netrw_http_cmd     = "curl"       否则，如果  curl  可用
	  http:   g:netrw_http_cmd     = "wget"       否则，如果  wget  可用
	  http:   g:netrw_http_cmd     = "fetch"      否则，如果  fetch 可用
	  http:   *g:netrw_http_put_cmd* = "curl -T"
	   rcp:   *g:netrw_rcp_cmd*      = "rcp"
	 rsync:   *g:netrw_rsync_cmd*    = "rsync -a"
	   scp:   *g:netrw_scp_cmd*      = "scp -q"
	  sftp:   *g:netrw_sftp_cmd*     = "sftp"
	  file:   *g:netrw_file_cmd*     = "elinks" 或 "links"

	*g:netrw_http_xcmd* : http://... 协议的选项字符串由此字符串指定，而且
	可以独立修改。缺省地，http 处理命令的选项参数是

		    elinks : "-source >"
		    links  : "-dump >"
		    curl   : "-o"
		    wget   : "-q -O"
		    fetch  : "-o"

	例如，如果你的系统有 elinks 而你想看渲染后的页面内容 (而不是缺省的显示
	源代码)，可以在 .vimrc 里加上 >
		let g:netrw_http_xcmd= "-dump >"
<
	g:netrw_http_put_cmd: 此选项指定可执行文件和任何必须的选项。此命令在
	url 上执行 PUT 操作。


读 取						*netrw-read* *netrw-nread* {{{2

	一般的，普通的编辑命令都可以使用 url 形式，例如 >

		:e ftp://[user@]machine/path
<
	Netrw 也支持 Nread 命令:

	:Nread ?					给出帮助
	:Nread "machine:file"				使用 rcp
	:Nread "machine file"				使用 ftp 并用 <.netrc>
	:Nread "machine id password file"		使用 ftp
	:Nread "dav://machine[:port]/file"		使用 cadaver
	:Nread "fetch://[user@]machine/file"		使用 fetch
	:Nread "ftp://[user@]machine[[:#]port]/file"	使用 ftp 并用 <.netrc>
	:Nread "http://[user@]machine/file"		使用 http 用 wget 方法
	:Nread "rcp://[user@]machine/file"		使用 rcp
	:Nread "rsync://[user@]machine[:port]/file"	使用 rsync
	:Nread "scp://[user@]machine[[:#]port]/file"	使用 scp
	:Nread "sftp://[user@]machine/file"		使用 sftp

写 入					*netrw-write* *netrw-nwrite* {{{2

	普通的保存命令都可以使用 url 形式，例如 >

		:w ftp://[user@]machine/path
<
	Netrw 也支持 Nwrite 命令:

	:Nwrite ?					给出帮助
	:Nwrite "machine:file"				使用 rcp
	:Nwrite "machine file"				使用 ftp 并用 <.netrc>
	:Nwrite "machine id password file"		使用 ftp
	:Nwrite "dav://machine[:port]/file"		使用 cadaver
	:Nwrite "ftp://[user@]machine[[:#]port]/file"	使用 ftp 并用 <.netrc>
	:Nwrite "rcp://[user@]machine/file"		使用 rcp
	:Nwrite "rsync://[user@]machine[:port]/file"	使用 rsync
	:Nwrite "scp://[user@]machine[[:#]port]/file"	使用 scp
	:Nwrite "sftp://[user@]machine/file"		使用 sftp
	不支持 http: 协议！

执 行 脚 本					*netrw-source* {{{2

	普通的执行脚本命令都可以使用 url 形式，例如 >

		:so ftp://[user@]machine/path
<
	Netrw 也支持 Nsource 命令:

	:Nsource ?					给出帮助
	:Nsource "dav://machine[:port]/path"		使用 cadaver
	:Nsource "fetch://[user@]machine/path"		使用 fetch
	:Nsource "ftp://[user@]machine[[:#]port]/path"	使用 ftp w/ <.netrc>
	:Nsource "http://[user@]machine/path"		使用 http 用 wget 方法
	:Nsource "rcp://[user@]machine/path"		使用 rcp
	:Nsource "rsync://[user@]machine[:port]/path"	使用 rsync
	:Nsource "scp://[user@]machine[[:#]port]/path"	使用 scp
	:Nsource "sftp://[user@]machine/path"		使用 sftp

目 录 列 表			*netrw-trailingslash* *netrw-dirlist* {{{2

	要浏览一个目录以得到文件列表，只需编辑该目录: >

		:e scp://[user]@hostname/path/
		:e ftp://[user]@hostname/path/
<
	对于远程目录列表 (也就是使用 scp 或 ftp 的那些)，结尾的 "/" 是必需的 (
	它告诉 netrw 对该参数使用目录方式浏览而不是去下载文件)。

	Nread 命令也可完成 (再说一次，结尾的斜杠是必需的): >

		:Nread [protocol]://[user]@hostname/path/
<
						*netrw-login* *netrw-password*
改 变 用 户 名 和 密 码			*netrw-chgup* *netrw-userpass* {{{2

	使用 ftp 的尝试会提示你输入用户名字和密码。它们被存在全局变量
	|g:netrw_uid| 和 |s:netrw_passwd| 里。下一次使用 ftp 就会再次使用这两
	个字符串来简化 ftp 将来的应用。不过，如果你要使用别的用户名和/或密码，
	先调用 |NetUserPass()|。为了解决输入密码的问题，检查一下你的 ftp 是否
	支持在你的主目录下的 <.netrc> 文件。另见 |netrw-passwd| (如果你用
	ssh/scp 但希望知道 scp 如何能不输入密码，见 |netrw-ssh-hack|)。

	:NetUserPass [uid [password]]		-- 如果需要，提示
	:call NetUserPass()			-- 提示 uid 和 password
	:call NetUserPass("uid")		-- 提示 password
	:call NetUserPass("uid","password")	-- 设置全局 uid 和 password

(相关主题: |ftp| |netrw-userpass| |netrw-start|)

NETRW 变 量 和 设 置					*netrw-variables* {{{2
    (另见:
    |netrw-browser-var|     : netrw 浏览器选项变量
    |netrw-protocol|        : 文件传输协议选项变量
    |netrw-settings|        : 附加文件传输选项
    |netrw-browser-options| : 这些选项影响如何浏览目录
    )

netrw 提供很多变量，方便你根据自己的喜好定制 netrw。一个查阅这些变量的方法是
:NetrwSettings (见 |netrw-settings|)，它显示你当前的 netrw 设置。大多数设置在
下面描述，还有的在 |netrw-browser-options| 和 |netrw-externapp| 那里:

 *b:netrw_lastfile*	最近一次通过网络读写的文件，该变量局部于缓冲区
			(用于支持无参数的 :Nw )

 *g:netrw_bufsettings*	netrw 缓冲区使用的设置
			(缺省) noma nomod nonu nowrap ro nobl

 *g:netrw_chgwin*	指定后续文件编辑使用的窗口号 (另见 |netrw-C|)
			(缺省) -1

 *g:Netrw_funcref*	指定 netrw 编辑文件时调用的函数。先编辑文件，然后调用
			此函数引用 (|Funcref|)。
			该变量也可包含函数引用的列表。
			(缺省) 无
			(g:Netrw... 中的大写是必需的，因为它保存函函数引用)
>
			    示例: 放入 .vimrc；影响所有文件打开
			    fun! MyFuncRef()
			    endfun
			    let g:Netrw_funcref= function("MyFuncRef")

<
 *g:Netrw_UserMaps*	指定函数或函数的 |List|，可用于设置用户指定的映射和功
			能。
			见 |netrw-usermaps|

 *g:netrw_ftp*		   如果不存在，用缺省的 ftp
			=0 使用缺省的 ftp		       (uid password)
			=1 使用替代的 ftp 方法		  (user uid password)
			   如果你的 ftp 使用有问题，尝试修改此值，看看另一个
			   ftp 方法是否适合你的设置。

 *g:netrw_ftp_options*     缺省使用，这些选项的目的是关闭交互揭示，并且避免初
			始连接时自动重新登录。但是，看来不是所有 ftp 的实现都
			支持 (例如 ncftp)。
		        ="-i -n"

 *g:netrw_ftpextracmd*	缺省: 不存在
			如果此变量存在，那么它包含的任何字符串将被加入到发送给
			ftp 客户的命令中。一个例子:
			  ="passive"

 *g:netrw_ftpmode*	="binary"				       (缺省)
			="ascii"

 *g:netrw_ignorenetrc*	=0 (linux、cygwin 缺省)
			=1 如果你有 <.netrc> 文件但不能工作，设置此变量可以忽
			   略该文件。(Windows + cmd.exe 缺省)

 *g:netrw_menu*		=0 关闭 netrw 菜单
			=1 (缺省) 打开 netrw 菜单

 *g:netrw_nogx*		如果此变量存在，"gx" 映射不可用 (见 |netrw-gx|)

 *g:netrw_uid*		(ftp) 用户名，    可用于同一 vim 会话中
 *s:netrw_passwd*	(ftp) 密码，      可用于同一 vim 会话中

 *g:netrw_preview*	=0 (缺省) 在横向分割的窗口中显示预览窗口
			=1 在纵向分割的窗口中显示预览窗口以相同方式影响 "前次
			   窗口" (见 |netrw-P|)。
			|g:netrw_alto| 变量可用于提供额外的分割控制:
				g:netrw_preview g:netrw_alto 结果
				         0             0     |:aboveleft|
				         0             1     |:belowright|
				         1             0     |:topleft|
				         1             1     |:botright|
			要控制大小，可见 |g:netrw_winsize|

 *g:netrw_scpport*      = "-P" : 设置 scp 端口的选项
 *g:netrw_sshport*      = "-p" : 设置 ssh 端口的选项

 *g:netrw_sepchr*	=\0xff
			=\0x01 如果 enc == euc-jp (也许也适用于其它编码，请让
			   我知道)
			   内部用来分隔文件名和优先码。
			   见 |netrw-p12|。

  *g:netrw_silent*	=0 : 正常方式完成传输
			=1 : 安静方式完成传输

 *g:netrw_use_errorwindow* =1 : netrw 的消息会使用分开的单行窗口。该窗口提供了
 		 		消息的可靠传送。(缺省)
			 =0 : netrw 的消息使用 echoerr；这种方式下不是所有消息
			      都保证能看到，但不需要退出窗口。

 *g:netrw_win95ftp*	=1 如果使用 Win95，删除四个操作系统在传输时 "提供" 的
			   拖尾行
			=0 强制正常的 ftp 行为 (不删除拖尾的行)

 *g:netrw_cygwin*	=1 假设在 windows 上的 scp 是 cygwin 的版本。同时允许
			   用带时间和大小排序的 ls 进行网络浏览 (windows 的缺
			   省值)
			=0 假设在 windows 上的 scp 接受 windows 风格的路径网络
			   浏览使用 dir 而不是 ls
			   如果使用 unix，忽略此选项

 *g:netrw_use_nt_rcp*	=0 不要使用 WinNT、Win2000 和 WinXP 的 rcp
			=1 使用 WinNT 二进制模式的 rcp            (缺省)

路 径							*netrw-path* {{{2

对于多数协议，文件路径通常相对于用户目录。不过，有的协议里路径可以相对于一些相
关的目录。
>
	例如:  vim scp://user@host/somefile
	例如:  vim scp://user@host/subdir1/subdir2/somefile
<
其中 "somefile" 在 "user" 的主目录。如果你想要文件相对于根目录的路径，使用完整
路径: >
	例如:  vim scp://user@host//somefile
	例如:  vim scp://user@host//subdir1/subdir2/somefile
<
==============================================================================
4. 基于网络的文件传输					*netrw-xfer* {{{1

Vim 下基于网络的文件传输是用基于 Vim 脚本的插件技术实现的 (<netrw.vim>)。目
前，它支持基于网络的读写，并支持 rcp、scp、ftp 或者 ftp+<.netrc>、scp、fetch、
dav/cadaver、rsync、 或者 sftp。

目前，http 只支持通过 wget 或者 fetch 读取。

<netrw.vim> 是一个标准插件，它起到 Vim 和若干文件传输程序的粘结剂作用。它使用
自动命令事件 (BufReadCmd、FileReadCmd、BufWriteCmd) 来拦截貌似 url 的文件名的
读写。 >

	例如 vim ftp://hostname/path/to/file
<
冒号前面的字符序列指定所使用的协议；在这个例子里，就是 ftp。
<netrw.vim> 脚本然后构成一个或多个命令 (一般是 ftp)，然后用外部程序去执行
(ftp，scp 等) 来完成实际的文件传输/协议。文件被先读写到一个临时文件里 (在
Unix/Linux 上，/tmp/...)， <netrw.vim> 脚本会清理该文件。

现在，说说 Jan Minář 的 "FTP 用户名和密码披露问题": 首先，ftp 不是安全协议。用
户名和密码在因特网上是明码传输的；任何网络嗅探器都可以截取；这不是 netrw 的问
题，是 ftp 的问题。如果你很介意这点，请使用 scp 或 sftp。

只要远端宿主不变。netrw 会重用同一 vim 会话的用户名和密码。

Jan 也许不很清楚 netrw 对 ftp 的处理方式: 正常情况下，一个 "ftp 会话" 会执行多
个命令，他也许认为用户名/密码信息应该只在单个 ftp 会话中保留。但是，netrw 的每
个 ftp 操作都是在单独的 "ftp 会话" 中进行的: 只在所谓单个 "ftp 会话" 中记住用
户名/密码，就跟完全不记住用户名/密码一样。依我愚见，如果这样去，譬如说，浏览远
程的目录，用户很快就会厌烦的。

不过，很感谢 Jan M. 指出许多 netrw (包括 vim 本身) 处理 "特意构造" 文件名的漏
洞。|shellescape()| 和 |fnameescape()| 函数就是为此由 Bram Moolenaar 实现来处
理这些问题的，netrw 也做了相应的修改，调用了这些函数。不过，我的建议还是，如果
所谓的 "文件名" 看来像 vim 的命令而你不放心，不要打开这些文件。

				*netrw-putty* *netrw-pscp* *netrw-psftp*
你可以通过修改变量修改任何实现协议的外部应用程序 (例如，scp 使用
g:netrw_scp_cmd 变量，缺省是 "scp -q")。 例如，考虑 PuTTY 的使用: >

	let g:netrw_scp_cmd = '"c:\Program Files\PuTTY\pscp.exe" -q -batch'
	let g:netrw_sftp_cmd= '"c:\Program Files\PuTTY\psftp.exe"'
<
(备注: 有报告说 windows 7 的 putty v0.6 的 "-batch" 选项不工作，那个系统最好不
       要那么改)

|netrw-p8| 介绍更多，如 putty、pscp、psftp 等。

ftp，一个古老的协议，看来被很多实现所支持。不幸的是，很多实现都有问题 (例如，
在文件尾部加入垃圾字符)。所以，如果有这样的问题，用户可以自己决定写一个
NetReadFixup() 函数来在从 ftp 读文件后进行清理。有些 Unix 系统 (例如，
FreeBSD) 提供了一个叫 "fetch" 的工具，它使用 ftp 协议，但是没有这样的问题，而
且更方便 <netrw.vim> 的使用。所以，只要 "fetch" 可用 (也就是可以执行)，最好用
它来用来实现 ftp://... 的传输。

对于 rcp、scp、sftp 和 http 协议，你可能希望基于网络的文件传输尽可能透明；例如
>
	vim rcp://[user@]machine/path
	vim scp://[user@]machine/path
<
如果你的 ftp 支持 <.netrc>，那么也可以透明的使用 ftp，因为需要的机器名字，用户
名和密码都定义在这个文件里。你的 ftp 必须自己能理解并使用 <.netrc> 文件。可以
这样，
>
	vim ftp://[user@]machine[[:#]portnumber]/path
<
Windows 提供的 ftp (通常在 c:\Windows\System32\ftp.exe) 接受选项 -s:filename
(filename 应该是也必须是完整路径)，该文件包含 ftp 启动时自动执行的 ftp 命令。
用这个功能，你可以为一个网站输入用户名和密码: >
	userid
	password
<				*netrw-windows-netrc*  *netrw-windows-s*
如果 |g:netrw_ftp_cmd| 包含 -s:[path/]MACHINE，那么 (只适用于 Windows)，netrw
会用当前要 ftp 连接的机器名来替代 MACHINE，这样你就可以有多个 machine.ftp 文
件，包含不同的登录名和密码。例如: >

    let g:netrw_ftp_cmd= 'c:\Windows\System32\ftp -s:C:\Users\Myself\MACHINE'
    vim ftp://myhost.somewhere.net/

会使用文件 >

	C:\Users\Myself\myhost.ftp
<
通常，ftp 需要查询用户需要的用户名和密码。后者通常不会被显示出来；也就是，输入
的密码显示的是星号。netrw 会保留用户名和密码，以便以后从相同机器的读写不需要再
提示输入。

								*netrw-urls*
  +=================================+============================+============+
  |  读                             | 写                         |  使用      |
  +=================================+============================+============+
  | DAV:                            |                            |            |
  |  dav://host/path                |                            | cadaver    |
  |  :Nread dav://host/path         | :Nwrite dav://host/path    | cadaver    |
  +---------------------------------+----------------------------+------------+
  | DAV + SSL:                      |                            |            |
  |  davs://host/path               |                            | cadaver    |
  |  :Nread davs://host/path        | :Nwrite davs://host/path   | cadaver    |
  +---------------------------------+----------------------------+------------+
  | FETCH:                          |                            |            |
  |  fetch://[user@]host/path       |                            |            |
  |  fetch://[user@]host:http/path  |  不可用                    | fetch      |
  |  :Nread fetch://[user@]host/path|                            |            |
  +---------------------------------+----------------------------+------------+
  | FILE:                           |                            |            |
  |  file:///*                      | file:///*                  |            |
  |  file://localhost/*             | file://localhost/*         |            |
  +---------------------------------+----------------------------+------------+
  | FTP:          (*3)              |              (*3)          |            |
  |  ftp://[user@]host/path         | ftp://[user@]host/path     | ftp  (*2)  |
  |  :Nread ftp://host/path         | :Nwrite ftp://host/path    | ftp+.netrc |
  |  :Nread host path               | :Nwrite host path          | ftp+.netrc |
  |  :Nread host uid pass path      | :Nwrite host uid pass path | ftp        |
  +---------------------------------+----------------------------+------------+
  | HTTP: wget is executable: (*4)  |                            |            |
  |  http://[user@]host/path        |   不可用                   | wget       |
  +---------------------------------+----------------------------+------------+
  | HTTP: fetch is executable (*4)  |                            |            |
  |  http://[user@]host/path        |   不可用                   | fetch      |
  +---------------------------------+----------------------------+------------+
  | RCP:                            |                            |            |
  |  rcp://[user@]host/path         | rcp://[user@]host/path     | rcp        |
  +---------------------------------+----------------------------+------------+
  | RSYNC:                          |                            |            |
  |  rsync://[user@]host/path       | rsync://[user@]host/path   | rsync      |
  |  :Nread rsync://host/path       | :Nwrite rsync://host/path  | rsync      |
  |  :Nread rcp://host/path         | :Nwrite rcp://host/path    | rcp        |
  +---------------------------------+----------------------------+------------+
  | SCP:                            |                            |            |
  |  scp://[user@]host/path         | scp://[user@]host/path     | scp        |
  |  :Nread scp://host/path         | :Nwrite scp://host/path    | scp  (*1)  |
  +---------------------------------+----------------------------+------------+
  | SFTP:                           |                            |            |
  |  sftp://[user@]host/path        | sftp://[user@]host/path    | sftp       |
  |  :Nread sftp://host/path        | :Nwrite sftp://host/path   | sftp  (*1) |
  +=================================+============================+============+

	(*1) 要指出绝对路径，用 scp://machine//path。

	(*2) 如果 <.netrc> 存在，假设你的 ftp 客户端会使用之。不然，该脚本提示
	输入用户名和密码。

	(*3) 对于 ftp，"machine" 可以是 machine#port 或者 machine:port，如果需
	要使用不同于标准 ftp 的端口的话。

	(*4) 对于 http:...，如果 wget 可用，就使用之。不然，如果 fetch 可用，
	就使用之。

:Nread 和 :Nwrite 这几个 ex 命令都能接受多个文件名。


NETRC							*netrw-netrc*

<.netrc> 文件通常位于你的主目录，它包含的内容是你想用的和机器名对应的用户名和
密码。

<.netrc> 文件典型的语法如下显示。Unix 上的 ftp 通常支持 <.netrc>；而 Windows
上的 ftp 通常不支持。
>
	machine {full machine name} login {user-id} password "{password}"
	default login {user-id} password "{password}"

你的 ftp 客户端必须自己会使用 <.netrc>，如果 <.netrc> 文件存在，ftp 传输就不会
询问用户名字和密码。

	注意:
	既然这个文件包含密码明码，要确保没人能够读到这个文件！许多程序拒绝使用
	能给别人读取的 .netrc 文件。当然不要忘记，系统管理员总是可以读到这个文
	件的！为此，对 Linux/Unix 而言: chmod 600 .netrc

虽然 Windows  ftp 客户端不支持 .netrc，netrw 有一个解决方法: 见
|netrw-windows-s|。

密 码							*netrw-passwd*

脚本试图用内建的 Vim 函数 |inputsecret()| 不回显地读取 ftp 的密码。参见
|netrw-userpass| 了解如何在设置以后修改密码。

不幸的是，netrw 没有办法自动提供密码给 scp。所以每次通过 scp 传输文件都需要重
新输入密码。不过， |netrw-ssh-hack| 有助于解决这个问题。


==============================================================================
5. 激活							*netrw-activate* {{{1

基于网络的文件传输缺省在 |'nocompatible'| 模式打开时就可用。netrw 的脚本文件在
你系统的 plugin、autoload 和 syntax 目录下，而在启动 vim 时，只自动加载
plugin/netrwPlugin.vim。netrw 的主要脚本定义在 autoload/netrw.vim 中，它只有在
实际使用 netrw 时才会载入。我建议你至少在 <.vimrc> 定制文件里放上: >

	set nocp
	if version >= 600
	  filetype plugin indent on
	endif
<
如果在 .vimrc 文件里也包括以下内容，不带文件名时启动 [g]vim 可以立即激活 netrw
以显示当前目录: >

	" Augroup VimStartup:
	augroup VimStartup
	  au!
	  au VimEnter * if expand("%") == "" | e . | endif
	augroup END
<

==============================================================================
6. 透明远程文件编辑				*netrw-transparent* {{{1

透明文件传输指通过普通的文件读写命令进行的传输 (通过 |:autocmd| 的
|BufReadCmd|、|BufWriteCmd| 或 |SourceCmd| 事件)。这样网络文件的读写或执行就能
和本地文件一样容易。 >

	vim ftp://[user@]machine/path
	...
	:wq

|netrw-activate| 进一步说明如何让你的 vim 更好地使用 netrw 这样的插件。


==============================================================================
7. Ex 命令						*netrw-ex* {{{1

支持普通的读写命令。此外，还有一些额外的命令。通常你不需要使用 Nwrite 或
Nread，就像 |netrw-transparent| 演示的那样 (也就是，用 >
  :e url
  :r url
  :w url
等即可) -- 见 |netrw-urls|。下面的解释中，{netfile} 指代指向远程文件的 URL。

						*:Nwrite*  *:Nw*
:[range]Nw[rite]	把特定的行写到当前由 b:netrw_lastfile 指定的文件里。
		(相关: |netrw-write|)

:[range]Nw[rite] {netfile} [{netfile}]...
		把特定的行写到 {netfile} 所指定的网络文件里。

						*:Nread*   *:Nr*
:Nr[ead]	从 b:netrw_lastfile 指定的文件里读取行到当前的缓冲区。
		(相关: |netrw-read|)

:Nr[ead] {netfile} {netfile}...
		读取 {netfile} 到当前行之后。

						*:Nsource* *:Ns*
:Ns[ource] {netfile}
		执行 {netfile}。
		启动 vim 时如要使用远程的 .vimrc，可以使用如下 (都在同一行上)
		(多谢 Antoine Mechelynck) 的命令 >
		vim -u NORC -N
		 --cmd "runtime plugin/netrwPlugin.vim"
		 --cmd "source scp://HOSTNAME/.vimrc"
<		(相关: |netrw-source|)

:call NetUserPass()				*NetUserPass()*
		如果 g:netrw_uid 和 s:netrw_passwd 不存在，该函数向用户查询。
		(相关: |netrw-userpass|)

:call NetUserPass("userid")
		该调用设置 g:netrw_uid 并且，如果密码不存在的话，向用户查询。
		(相关: |netrw-userpass|)

:call NetUserPass("userid","passwd")
		该调用设置 g:netrw_uid 和 s:netrw_passwd。用户名和密码则被 ftp
		传输使用。要删除用户名和密码，只用使用空字符串 (即 "") 便可。
		(相关: |netrw-userpass|)

:NetrwSettings  |netrw-settings| 里描述此命令 -- 用于显示 netrw 设置和修改
		netrw 行为。


==============================================================================
8. 变量和选项				*netrw-var* *netrw-settings* {{{1

(另见: |netrw-options| |netrw-variables| |netrw-protocol|
       |netrw-browser-settings| |netrw-browser-options| )

<netrw.vim> 脚本提供若干变量，作为控制 <netrw.vim> 行为的选项。这些变量通常在
用户的 <.vimrc> 里设置: (另见: |netrw-settings| |netrw-protocol|)
						*netrw-options*
>
			-------------
			 netrw 选项
			-------------
	选项			含义
	--------------		-----------------------------------------------
<
        b:netrw_col             保存当前的列号 (NetWrite 时)
        g:netrw_cygwin          =1 假设在 windows 上的 scp 是 cygwin 的版本
                                                        (windows 的缺省值)
                                =0 假设在 windows 上的 scp 接受 windows 风格的
                                   路径                 (其他情况的缺省值)
        g:netrw_ftp             =0 使用缺省的 ftp       (uid password)
                                =1 使用替代的 ftp       (user uid password)
                                (见 |netrw-options|)
        g:netrw_ftpmode         ="binary"               (缺省)
                                ="ascii"                (你的选择)
        g:netrw_ignorenetrc     = 1                     (缺省)
                                    如果你有 <.netrc> 文件，但是你不想用它，就
                                    这么设置。它唯一的作用是使得 <.netrc> 被忽
                                    略。
        b:netrw_lastfile        最近一次通过网络读写的方法/机器/路径。
        b:netrw_line            保存当前的行号          (NetWrite 时)
        g:netrw_silent          =0 正常方式的传输
                                =1 安静方式的传输
        g:netrw_uid             保存当前 ftp 的 user-id。
        g:netrw_use_nt_rcp      =0 不要使用 WinNT/2K/XP 的 rcp (缺省)
                                =1 使用 WinNT/2K/XP 二进制模式的 rcp
        g:netrw_win95ftp        =0 使用 unix 风格连接 ftp，即使 win95/98/ME 等
                                =1 使用缺省的方法连接 ftp >
	-----------------------------------------------------------------------
<
						*netrw-internal-variables*
脚本里也可以使用以下的内部变量，尽管应该是暂时的。
>
				--------
				临时变量
				--------
	选项			含义
	--------------		--------------------------------
<
	b:netrw_method		指明 rcp/ftp+.netrc/ftp 等的索引
	w:netrw_method		(同 b:netrw_method)
	g:netrw_machine		保存输入分析结果的机器名
	b:netrw_fname		保存访问的文件名 >
	--------------------------------------------------------
<
							*netrw-protocol*
netrw 支持若干协议。调用这些协议时使用下面的列出的变量，用户可以修改。
>
			   	------------
                                协议控制选项
				------------
    选项	      类型	  设置	  	  意义
    ---------	      --------	  --------------  ---------------------------
<    netrw_ftp         变量        =不存在         userid 由 "user userid" 设置
                                  =0              userid 由 "user userid" 设置
                                  =1              userid 由 "userid" 设置
    NetReadFixup      函数        =不存在         没有改变
                                  =存在           允许用户通过 ftp 自动传输的
                                                  文件通过 NetReadFixUp() 进行
                                                  转换
    g:netrw_dav_cmd      变量  ="cadaver"      如果 cadaver 可执行
    g:netrw_dav_cmd      变量  ="curl -o"      否则如果 curl 可执行
    g:netrw_fetch_cmd    变量  ="fetch -o"     如果 fetch 可以执行
    g:netrw_ftp_cmd      变量  ="ftp"
    g:netrw_http_cmd     变量  ="fetch -o"     如果       fetch 可以执行
    g:netrw_http_cmd     变量  ="wget -O"      不然，如果 wget  可以执行
    g:netrw_http_put_cmd 变量  ="curl -T"
    g:netrw_list_cmd     变量  ="ssh USEPORT HOSTNAME ls -Fa"
    g:netrw_rcp_cmd      变量  ="rcp"
    g:netrw_rsync_cmd    变量  ="rsync -a"
    g:netrw_scp_cmd      变量  ="scp -q"
    g:netrw_sftp_cmd     变量  ="sftp" >
    -------------------------------------------------------------------------
<
								*netrw-ftp*
g:netrw_..._cmd 选项  (|g:netrw_ftp_cmd| 和 |g:netrw_sftp_cmd|) 指定如何处理特
定的协议 (rcp、ftp 等) 的外部程序，也可以包含需要的命令行选项 (如指定 passive
模式的 -p)。例如: >

	let g:netrw_ftp_cmd= "ftp -p"
<
|g:netrw_list_cmd| 提供浏览支持: 其中的 HOSTNAME 子串会被替代为当前请求的机器
名。

两个选项 (|g:netrw_ftp| 和 |netrw-fixup|) 都提供解决特定 ftp 问题的帮助。为了
更好的理解如何在 ftp 有问题的时候使用这些选项，以下是 netrw 如何进行 ftp 读取
的一点讨论。

对于 ftp，netrw 通常用以下几种格式之一构造命令行，并写到临时文件里:
>
  如果 g:netrw_ftp 不存在或者不是 1      如果 g:netrw_ftp 存在且为 1
  ----------------------------------     ------------------------------
<
       open machine [port]                    open machine [port]
       user userid password                   userid password
       [g:netrw_ftpmode]                      password
       [g:netrw_ftpextracmd]                  [g:netrw_ftpmode]
       get filename tempfile                  [g:netrw_extracmd]
                                              get filename tempfile >
  ---------------------------------------------------------------------
<
|g:netrw_ftpmode| 和 |g:netrw_ftpextracmd| 是可选的。

netrw 然后通过过滤命令执行上述命令行:
>
	:%! {g:netrw_ftp_cmd} -i [-n]
<
其中
	g:netrw_ftp_cmd 通常是 "ftp"，
	-i 告诉 ftp 不要交互
	-n 意味着不要用 netrc，它用于方法 #3 (ftp 不用 <.netrc>)

如果 <.netrc> 存在，就不需要想用户查询用户名和密码。传输完毕后，保存文件到临时
文件里。这时，从临时文件里读取的内容被读到被请求的主编辑会话窗口中，并删除临时
文件。

如果你的 ftp 不支持 "user" 命令，而是立即需要输入用户名，那么试试把
"let netrw_ftp=1" 放到你的 <.vimrc> 里。

								*netrw-cadaver*
要解决不受信任的服务器弹出 SSL 认证对话框的问题，你可以下载该认证，并把它放到
/usr/ssl/cert.pem 里。此操作使该服务器被认为是 "可信任的"。

						*netrw-fixup* *netreadfixup*
如果你的 ftp 因某种原因产生不需要的行 (例如 AUTH 消息)，你需要写一个
NetReadFixup() 函数:
>
    function! NetReadFixup(method,line1,line2)
      " a:line1: 当前文件的第一行新行
      " a:line2: 当前文件的最后一行新行
      if     a:method == 1 "rcp
      elseif a:method == 2 "ftp + <.netrc>
      elseif a:method == 3 "ftp + machine,uid,password,filename
      elseif a:method == 4 "scp
      elseif a:method == 5 "http/wget
      elseif a:method == 6 "dav/cadaver
      elseif a:method == 7 "rsync
      elseif a:method == 8 "fetch
      elseif a:method == 9 "sftp
      else                 " 报错
      endif
    endfunction
>
如果 NetReadFixup() 函数存在，它就会被调用，这样你就可以订制自己的读取进程。一
个进一步的例子可以看看 <netrw.vim> 如何处理 Windows 95 ftp 的函数。不知何种原
因，Windows 95 的 ftp 在传输结束以后加了四个空行，所以应该自动把它们删除。这里
是 <netrw.vim> 自己的一些代码: >
>
    if has("win95") && g:netrw_win95ftp
     fun! NetReadFixup(method, line1, line2)
       if method == 3   " ftp (无 <.netrc>)
        let fourblanklines= line2 - 3
        silent fourblanklines.",".line2."g/^\s*/d"
       endif
     endfunction
    endif
>
(相关主题: |ftp| |netrw-userpass| |netrw-start|)

==============================================================================
9. 浏览			*netrw-browsing* *netrw-browse* *netrw-help* {{{1
   			*netrw-browser*  *netrw-dir*    *netrw-list*

浏 览 简 介					*netrw-intro-browse* {{{2
	(快速参考: |netrw-quickmaps| |netrw-quickcoms|)

netrw 支持本地系统和远端机器上的目录浏览；浏览包括列出文件和目录、进入目录、编
辑那里的文件、删除文件/目录、建立新目录和移动 (换名) 文件和目录，复制文件和目
录，等等。还可以对文件进行标记，并对标记的文件执行任何系统命令！netrw 浏览器实
现以前探索器里的映射和命令的更一般的版本以支持远程目录，不过具体细节 (比如使用
的全局变量名) 肯定有所不同。要浏览一个目录，简单地 "编辑" 之便可！ >

	vim /your/directory/
	vim .
	vim c:\your\directory\
<
(相关主题: |netrw-cr|  |netrw-o|  |netrw-p| |netrw-P| |netrw-t|
           |netrw-mf|  |netrw-mx| |netrw-D| |netrw-R| |netrw-v| )


netrw 远程文件和目录浏览器能处理两个协议: ssh 和 ftp。url 如果使用 ftp 协议，
netrw 远程浏览时就同时使用 ftp。相反，如果指定其它协议，该协议将用于文件传输，
而 ssh 协议会被用来进行远程浏览。

要使用 netrw 的远程目录浏览器，只要读入带拖尾斜杠的 "文件" 就可以，它被解释为
列出目录的请求:
>
	vim [protocol]://[user@]hostname/path/
<
其中 [protocol] 一般是 scp 或 ftp。例如: >

	vim ftp://ftp.home.vim.org/pub/vim/
<
对于本地目录，拖尾的斜杠是不必要的。不过因为很容易忘记，这里不厌其烦再重复一
遍: 要浏览远程目录，url 必须以斜杠结尾！

如果要避免 ssh 或 scp 在远程目录列表时反复输入密码的麻烦，见
|netrw-ssh-hack|。要避免 ftp 密码的输入，见 |netrw-netrc| (如果你的 ftp 支持的
话)。

改变浏览器显示文件的方式有以下几个途径:

	* 要改变列表风格，按 "i" 键 (|netrw-i|)。
	  目前支持四种风格: 瘦、长、宽和树状。
	  要使改变永久化，见 |g:netrw_liststyle|。

	* 要隐藏文件 (不想再显示那些 xyz~ 文件？) 见 |netrw-ctrl-h|。

	* 按 s 来对文件按名字、时间或大小排序。

要知道 netrw 可以做的一切事情，见 |netrw-browse-cmds|！

			*netrw-getftype* *netrw-filigree* *netrw-ftype*
在列出本地文件时，|getftype()| 函数被用来加上一个附綴，来表示文件类型:

	directory  : /
	executable : *
	fifo       : |
	links      : @
	sockets    : =

附綴也影响 |g:netrw_sort_sequence|。


快 速 帮 助						*netrw-quickhelp* {{{2
                       (按 ctrl-] 可选择主题)~
	浏览简介........................................|netrw-intro-browse|
	  快速参考: 映射................................|netrw-quickmap|
	  快速参考: 命令................................|netrw-browse-cmds|
	隐藏
	  编辑隐藏列表..................................|netrw-ctrl-h|
	  隐藏文件或目录................................|netrw-a|
	  按后缀隐藏或显示..............................|netrw-mh|
	  隐藏点文件....................................|netrw-gh|
	列表风格
	  选择列表风格 (瘦/长/宽/树状)..................|netrw-i|
	  相关的设置变量................................|g:netrw_liststyle|
	  执行列表的外壳命令............................|g:netrw_list_cmd|
	  快速文件信息..................................|netrw-qf|
	如何排序
	  选择排序风格 (名字/时间/大小).................|netrw-s|
	  编辑排序序列..................................|netrw-S|
	  排序选项......................................|g:netrw_sort_options|
	  相关的设置变量................................|g:netrw_sort_sequence|
	  反转排序顺序..................................|netrw-r|


				*netrw-quickmap* *netrw-quickmaps*
快 速 参 考 : 映 射				*netrw-browse-maps* {{{2
>
	  ----			--------				----
	  映射			简要解释				链接
	  ----			--------				----
<	 <F1>	netrw 给出帮助
	 <cr>	netrw 进入目录或者打开文件                           |netrw-cr|
	 <del>	netrw 试图删除文件/目录                              |netrw-del|
	 <c-h>	编辑文件隐藏列表                                     |netrw-ctrl-h|
	 <c-l>	netrw 刷新目录列表                                   |netrw-ctrl-l|
	 <c-r>	使用 gvim 服务器浏览                                 |netrw-ctrl-r|
	 <c-tab> 收缩/打开 netrw/explore 窗口                        |netrw-c-tab|
	   -	netrw 往上一层目录                                   |netrw--|
	   a	切换普通显示方式、                                   |netrw-a|
		隐藏方式 (不显示匹配 g:netrw_list_hide 的文件) 和
		显示方式 (只显示匹配 g:netrw_list_hide 的文件)
	   c	使浏览中的目录成为当前目录                           |netrw-c|
	   C	设置编辑窗口                                         |netrw-C|
	   d	建立新目录                                           |netrw-d|
	   D	试图删除文件/目录                                    |netrw-D|
	   gb	切换到收入书签的目录                                 |netrw-gb|
	   gd	强制作目录处理                                       |netrw-gd|
	   gf	强制作文件处理                                       |netrw-gf|
	   gh	快速隐藏/显示点文件                                  |netrw-gh|
	   gn	置顶光标下的目录                                     |netrw-gn|
	   i	在瘦、长、宽和树状列表方式循环                       |netrw-i|
	   mb	把当前目录加入书签                                   |netrw-mb|
	   mc	把带标记文件复制到标记目标目录中                     |netrw-mc|
	   md	对带标记文件进行比较 (不超过 3 个)                   |netrw-md|
	   me	把带标记文件放到参数列表中并编辑之                   |netrw-me|
	   mf	标记文件                                             |netrw-mf|
	   mF	撤销文件标记                                         |netrw-mF|
	   mg	给带标记文件应用 vimgrep                             |netrw-mg|
	   mh	切换带标记文件的后缀在隐藏列表中的存在与否           |netrw-mh|
	   mm	把带标记文件移动到标记目标目录中                     |netrw-mm|
	   mp	打印带标记文件                                       |netrw-mp|
	   mr	用外壳风格的 |regexp| 标记文件	                      |netrw-mr|
	   mt	使当前浏览目录成为标记文件的目标目录                 |netrw-mt|
	   mT	对带标记文件应用 ctags                               |netrw-mT|
	   mu	撤销所有带标记文件的标记                             |netrw-mu|
	   mv	对带标记文件应用任意 vim  命令                       |netrw-mv|
	   mx	对带标记文件应用任意 外壳 命令                       |netrw-mx|
	   mx	对带标记文件整块应用任意外壳命令                     |netrw-mX|
	   mz	对带标记文件压缩/解压缩                              |netrw-mz|
	   o	用水平分割在新浏览窗口中进入光标所在的文件/目录      |netrw-o|
	   O	获取光标指定的文件                                   |netrw-O|
	   p	预览文件                                             |netrw-p|
	   P	在前次使用的窗口中浏览                               |netrw-P|
	   qb	列出书签内的目录和历史                               |netrw-qb|
	   qf	显示文件信息                                         |netrw-qf|
	   qF	用 quickfix 列表标记文件                             |netrw-qF|
	   qL	用 |location-list| 标记文件                            |netrw-qL|
	   r	反转排序顺序                                         |netrw-r|
	   R	给指定的文件或目录换名                               |netrw-R|
	   s	选择排序风格: 按名字、时间或文件大小                 |netrw-s|
	   S	指定按名排序时的后缀优先级                           |netrw-S|
	   t	在新标签页里进入光标所在的文件/目录                  |netrw-t|
	   u	切换到较早访问的目录                                 |netrw-u|
	   U	切换到较迟访问的目录                                 |netrw-U|
	   v	用垂直分割在新浏览窗口中进入光标所在的文件/目录      |netrw-v|
	   x	用指定程序阅读文件                                   |netrw-x|
	   X	用 |system()| 执行光标所在的文件                       |netrw-X|

	   %	在 netrw 当前目录打开新文件                          |netrw-%|

	*netrw-mouse* *netrw-leftmouse* *netrw-middlemouse* *netrw-rightmouse*
	<leftmouse>	(仅限于 gvim) 选择鼠标所在的单词，就像按了 <cr> 一样
			(即编辑文件、改变目录)
	<middlemouse>	(仅限于 gvim) 等价于鼠标所在的单词上按 P；见 |netrw-P|
	<rightmouse>	(仅限于 gvim) 删除鼠标所在的文件/目录
	<2-leftmouse>	(仅限于 gvim) 当:
			 * 在 netrw 选择的文件中，_且_
			 * |g:netrw_retmap| == 1    _且_
			 * 用户没有在 netrw 自动载入之前已经定义 <2-leftmouse>
			   映射，
			那么双击鼠标左键返回到 netrw 浏览器窗口。见
			|g:netrw_retmap|。
	<s-leftmouse>	(仅限于 gvim) 等价于 mf，标记文件。拖动按住 shift 的
			鼠标左键可以标记多个文件。(见 |netrw-mf|)

	(浏览时要禁用鼠标键: |g:netrw_mousemaps|)

				*netrw-quickcom* *netrw-quickcoms*
快 速 参 考 : 命 令		*netrw-explore-cmds* *netrw-browse-cmds* {{{2
     :NetrwClean[!]............................................|netrw-clean|
     :NetrwSettings............................................|netrw-settings|
     :Explore[!]  [dir] 探索当前文件所在的目录.................|netrw-explore|
     :Hexplore[!] [dir] 水平分割并探索.........................|netrw-explore|
     :Lexplore[!] [dir] 切换左浏览器...........................|netrw-explore|
     :Nexplore[!] [dir] 垂直分割并探索
                        (译者注: 应为转到下一个匹配的文件).....|netrw-explore|
     :Pexplore[!] [dir] 垂直分割并探索
                        (译者注: 应为转到前一个匹配的文件).....|netrw-explore|
     :Rexplore          返回浏览器.............................|netrw-explore|
     :Sexplore[!] [dir] 分割并探索目录.........................|netrw-explore|
     :Texplore[!] [dir] 建立新标签页并探索.....................|netrw-explore|
     :Vexplore[!] [dir] 垂直分割并探索.........................|netrw-explore|


显 示 横 幅						*netrw-I*

按 "I" 可以切换横幅显示的打开与关闭。

另见: |g:netrw_banner|


把 目 录 加 入 书 签	*netrw-mb* *netrw-bookmark* *netrw-bookmarks* {{{2

用下面的命令可以很方便地把当前浏览目录加入 "书签" >

	mb
<
								*.netrwbook*
书签可以跨会话使用，因为它们被保存在 $HOME/.netrwbook 文件里，并经排序。

如果有带标记的文件和/或目录，mb 会把它们加入书签列表。

*netrw-:NetrwMB*
另外，可用 :NetrwMB 来把文件或目录加入书签。 >

	:NetrwMB[!] [files/directories]

< 没有 !: 把文件/目录加入 netrw 的书签系统

   没有参数并且在 netrw 缓冲区里:
     如果有带标记的文件               : 把带标记的文件加入书答
     否则                             : 把光标下的文件加入书答
   没有参数并且不在 netrw 缓冲区里    : 把当前打开的文件加入书答
   有参数                             : 对每个参数用 |glob()| 展开并加入书签

 带有 !: 从 netrw 的书签系统里删除文件/目录

:NetrwMB 命令可在 netrw 缓冲区之外使用 (一旦在会话中激活了 netrw)。

".netrwbook" 文件用来在 netrw (和 vim) 未激活时记录书签。缺省，它保存在用户
|'runtimepath'| 的第一个目录里。

相关主题:
	|netrw-gb| 如果回到 (go) 书签
	|netrw-mB| 如何删除书签
	|netrw-qb| 如何列出书签
	|g:netrw_home| 控制 .netrwbook 保存的位置


浏 览						*netrw-enter*	*netrw-cr* {{{2


浏览很简单: 移动光标到感兴趣的文件或目录上，按 <cr> (回车键) 就可以选择该文件
或目录。如果还是目录，列出其内容，如果是文件，使用原来读请求中给出的协议来打开
该文件。

  警 告: 有四种列表的形式 (见 |netrw-i|)。netrw 假设两个或更多的空格定界长列表
  和宽列表格式下的文件和目录名。所以如果你的文件或目录名本身内嵌或拖尾两个或更
  多的空格，用 "瘦" 格式来选择文件。

|g:netrw_browse_split| 选项缺省为零。可以修改它，使文件的打开在新窗口或标签页
里进行。如果该选项为一，分割会以水平方式进行，如果为二，分割以垂直方式进行。如
果为三，<cr> 使得文件在新标签页里出现。


如果是用图形界面 (gvim)，可以按 <leftmouse> 选择文件。此外，如果

 * |g:netrw_retmap| == 1    _且_ (其缺省值为 0)
 * 在 netrw 选择的文件中，_且_
 * 用户没有在 netrw 载入之前已经定义 <2-leftmouse> 映射

那么双击鼠标左键返回到 netrw 浏览器窗口。

为了试图加快浏览速度，尤其是可能需要输入密码的远程浏览速度，netrw 会保留和重用
上次得到的目录列表缓冲区。|g:netrw_fastbrowse| 变量控制此行为；可以选择慢速浏
览 (没有目录缓冲区列表重用)，中速浏览 (只对远程目录重用目录缓冲区列表) 和快速
浏览 (尽可能重用目录缓冲区列表)。重用的代价是如果发生了改动 (例如在目录中出现
了新文件)，列表就可能不是最新的。此时，按 ctrl-L 可以刷新目录列表缓冲区 (见
|netrw-ctrl-l|)。

								*netrw-s-cr*
压缩当前树列表目录~

如果打开树列表风格 (见 |netrw-i|) 并且使用 gvim，<s-cr> 映射可用来压缩 (关闭)
光标所在的目录。

否则，可以重新映射用户自己选择的键组合来达到同样的效果: >

    nmap <buffer> <silent> <nowait> YOURKEYCOMBO  <Plug>NetrwTreeSqueeze
<
把此行放在$HOME/ftplugin/netrw/netrw.vim 里；必须只为 netrw 缓冲区而生成。

相关主题:
	|netrw-ctrl-r|	|netrw-o|	|netrw-p|
	|netrw-P|	|netrw-t|	|netrw-v|
相关设置变量:
   |g:netrw_browse_split|	|g:netrw_fastbrowse|
   |g:netrw_ftp_list_cmd|	|g:netrw_ftp_sizelist_cmd|
   |g:netrw_ftp_timelist_cmd|	|g:netrw_ssh_browse_reject|
   |g:netrw_ssh_cmd|		|g:netrw_use_noswf|


水 平 分 割 窗 口 方 式 浏 览			*netrw-o* *netrw-horiz* {{{2

通常用 <cr> 方式进入文件或目录。不过，"o" 映射可以打开新窗口来浏览新目录列表或
文件。这里使用水平分割。(垂直分割可见 |netrw-v|)

通常，o 键水平分割窗口并使新窗口和光标出现在上方。

相关设置变量: |g:netrw_alto| |g:netrw_winsize|

相关主题:
	|netrw-ctrl-r|	|netrw-o|	|netrw-p|
	|netrw-P|	|netrw-t|	|netrw-v|
相关设置变量:
   |g:netrw_alto|    控制上/下分割
   |g:netrw_winsize| 控制初始大小

在 新 标 签 页 里 浏 览				*netrw-t* {{{2

通常你用 <cr> 进入文件或目录。"t" 映射允许你在新标签页里打开新的目录列表或文
件。

如果你希望在背景标签页里显示新列表，用 |gT|。

相关主题:
	|netrw-ctrl-r|	|netrw-o|	|netrw-p|
	|netrw-P|	|netrw-t|	|netrw-v|
相关设置变量:
   |g:netrw_winsize| 控制初始大小

垂 直 分 割 窗 口 方 式 浏 览				*netrw-v* {{{2

通常用 <cr> 方式进入文件或目录。不过，"v" 映射可以打开新窗口来浏览新目录列表或
文件。这里使用垂直分割。(水平分割可见 |netrw-o|)

通常，v 键垂直分割窗口并使新窗口和光标出现在左方。

只能有一个树状列表的缓冲区；因而，在子目录上按 "v" 会分割屏幕，但显示相同的缓
冲区两遍。

相关主题:
	|netrw-ctrl-r|	|netrw-o|	|netrw-p|
	|netrw-P|	|netrw-t|	|netrw-v|
相关设置变量:
   |g:netrw_altv|    控制右/左分割
   |g:netrw_winsize| 控制初始大小


用 GVIM 服 务 器 浏 览				*netrw-ctrl-r* {{{2

可以建立浏览专用的 gvim，和用来编辑的 gvim 区隔。netrw 浏览器上对文件 (不是目
录) 用 <c-r> 映射，会使用 gvim 服务器 (见 |g:netrw_servername|)。后续的 <cr>
(见 |netrw-cr|) 会重用该服务器来编辑文件。

相关主题:
	|netrw-ctrl-r|	|netrw-o|	|netrw-p|
	|netrw-P|	|netrw-t|	|netrw-v|
相关设置变量:
	|g:netrw_servername|   : 设置服务器名
	|g:netrw_browse_split| : 控制 <cr> 如何打开文件


改 变 列 表 方 式 (瘦 长 宽 树)					*netrw-i* {{{2

"i" 映射在瘦、长、宽和树形列表格式之间循环。

瘦列表格式只给出文件和目录名。

对于远程目录，长格式基于通过 ssh 执行的 "ls" 命令结果，对于本地目录，则显示文
件名、文件大小 (字节计) 和最近修改日期和时间。使用长格式时，netrw 不能识别带拖
尾空格的文件名。这样的文件只能用瘦列表格式。

宽列表格式使用两个或多个连续的空格来给文件名定界；使用此格式时，netrw 不能识别
内嵌或拖尾带有两个或多个连续的空格的文件名。不过，瘦格式可以处理这些文件。这种
宽列表方式最为紧凑。

树形列表格式列出顶层目录，然后是文件和目录，它们的前面有一个或多个 "|"，指示目
录深度。可以在目录名上按 <cr> 来打开或关闭目录。

可以设置缺省的列表方式: 见 |g:netrw_liststyle|。例如可在 .vimrc 中加入 >
	let g:netrw_liststyle= 3
树形列表就成为缺省方式了。

一个使用 netrw 树形显示的典型方式是: >

	vim .
	(反复按 i 直到树形显示出现)
	找到一个文件
	v  (垂直分割窗口并编辑文件)
	ctrl-w h  (回到 netrw 列表)
	P (在前次窗口编辑新选文件)
	ctrl-w h  (回到 netrw 列表)
	P (在前次窗口编辑新选文件)
	...等等...
<
相关设置变量: |g:netrw_liststyle| |g:netrw_maxfilenamelen|
              |g:netrw_timefmt|   |g:netrw_list_cmd|


改 变 文 件 权 限						*netrw-gp* {{{2

"gp" 会询问光标所在文件的新权限。目前，只适用于本地文件。

相关设置变量: |g:netrw_chgperm|


切 换 到 收 入 书 签 的 目 录                   	*netrw-gb*  {{{2

要切换回收入书签的目录，用 >

	{cnt}gb

可以使用计数来引用任何书签项目。
注意 |netrw-qb| 同时显示书签和历史；要转到历史的某个位置，见 |netrw-u| 和
|netrw-U|。

相关主题:
	|netrw-mB| 如何删除书签
	|netrw-mb| 如何建立书签
	|netrw-qb| 如何列出书签


切 换 到 较 早 访 问 的 目 录			*netrw-u* *netrw-updir* {{{2

每次你切换到新目录时 (当前会话里新出现)，netrw 会把该目录保存在最近访问过的目
录历史列表里 (除非 |g:netrw_dirhistmax| 为零；缺省该值为 10)。用 "u" 映射可以
切换到较早访问的目录 (前任)。相反的操作见 |netrw-U|。

"u" 映射也接受计数，回到若干个位置前的历史。为你方便起见，qb (见 |netrw-qb|)
列出历史编号，可用于此处的计数。

						*.netrwhist*
参见 |g:netrw_dirhistmax|，说明如何控制保存的历史总数。".netrwhist" 文件在
netrw (和 vim) 未激活时记录历史。它缺省存放在用户 |'runtimepath'| 的第一个目录
里。

相关主题:
	|netrw-U| 切换到较迟访问的目录
	|g:netrw_home| 控制 .netrwhist 何处存放

切 换 到 较 迟 访 问 的 目 录			*netrw-U* *netrw-downdir* {{{2

用 "U" 映射可以切换到较迟访问的目录 (后任)。和 "u" 映射相反。(见 |netrw-u|)
用 qb 映射可以同时列出书签和历史。(见 |netrw-qb|)

"U" 映射也接受计数，回到若干个位置后的历史。

参见 |g:netrw_dirhistmax|，说明如何控制保存的历史总数。


更 改 树 置 顶 目 录			*netrw-ntree*  *:Ntree*  *netrw-gn* {{{2

可以为树列表指定新的树置顶目录 >

	:Ntree [dirname]

如果没有 "dirname"，使用当前行 (跳过开头的深度信息)。
如果有 "dirname"，使用指定的目录名。

"gn" 映射获取光标下的单词并用之改变树列表的置顶。


NETRW 清 理					*netrw-clean* *:NetrwClean* {{{2

使用 NetrwClean 可以很容易地从用户主目录中删除 netrw；更准确的说，从
|'runtimepath'| 的第一个目录中删除之。

使用 NetrwClean! 则会从 |'runtimepath'| 的所有目录中删除。当然，你必须要有正确
的写入/删除权限才能这么做。

不管哪种形式，netrw 都会先确认你是否真的要这么做。如果 netrw 没有权限删除某文
件，它会报错。

						*netrw-gx*
通 过 特 殊 处 理 程 序 定 制 浏 览		*netrw-x* *netrw-handler* {{{2
						(另见 |netrw_filehandler|)

html、gif、jpeg、(word/office) 文档等若干类型的文件最好用特殊处理程序 (也即，
你机器的操作系统上的特定工具程序) 来察看。netrw 允许你调用这些特殊的处理程
序: >

	* 探索时，按 "x" 键
	* 编辑时，在光标所在的特殊文件名上按 gx
<	  (|g:netrw_nogx| 变量存在时后者不可用)

netrw 用下面的方法决定使用哪个特殊处理程序:

  * 如果存在 |g:netrw_browsex_viewer|，尝试用它来察看文件。包含可用设置的示例
    (把它放在 <.vimrc> 里): >

	:let g:netrw_browsex_viewer= "kfmclient exec"
<   或 >
	:let g:netrw_browsex_viewer= "xdg-open"
<
    如果 g:netrw_browsex_viewer == '-'，那么取而代之的是调用
    netrwFileHandlers#Invoke() (见 |netrw_filehandler|)。

  * 对 Windows 32 或 64 来说，使用 url 和 FileProtocolHandler dll。
  * 对 Gnome (带 gnome-open) 来说: 使用 gnome-open。
  * 对 KDE (带 kfmclient) 来说: 使用 kfmclient。
  * 对 Mac OS X 来说: 使用 open。
  * 否则，使用 netrwFileHandler 插件。

这些方法使用文件的后缀名来决定 "处理" 这些文件的合适的应用程序。这样就可以处理
OpenOffice (*.sfx)、可视文件 (*.jpg、*.gif 等) 和 PostScript (*.ps、 *.eps)。

gx 映射延伸到所有缓冲区；在单词上应用 "gx" 使用 netrw 在其上使用特殊处理程序
(就像在 netrw 缓冲区里使用 "x" 一样)。也可用可视模式 (见 |visual-start|) 选择
文本来应用特殊处理程序。通常，gx 使用 expand("<cfile>") 来获取光标下的文本；
通过 |g:netrw_gx| 变量可以改变 |expand()| 使用的参数。此外，也可用可视选择 (见
|visual-block|) 来选择 gx 使用的文本，或改变 |'isfname'| 选项 (全局选项，所以
netrw 不直接修改)。

相关设置变量:
	|g:netrw_gx|	控制 gx 如何获取光标下的文本
	|g:netrw_nogx|	编辑时屏蔽 gx 映射
	|g:netrw_suppress_gx_mesg| 控制 gx 对浏览器消息的抑制

							*netrw_filehandler*

|g:netrw_browsex_viewer| 如果存在且为 "-"，netrw 试图通过 vim 函数来处理特殊文
件。"x" 映射根据文件扩展名来对文件应用一个函数。当然能够调用的前提是该处理函数
本身必须已经存在！
>
 例如 mypgm.html  x -> NFH_html("scp://user@host/some/path/mypgm.html")

<	用户可以编写他们自己的 netrw 文件处理函数来对更多后缀进行特殊处理。参
	见 <autoload/netrwFileHandlers.vim> 的例子来了解如何建立文件处理函数。
	例如: >

	" NFH_suffix(filename)
	fun! NFH_suffix(filename)
	..对文件名进行特殊处理..
	endfun
<
这些函数需要在你的 .vim/plugin (vimfiles\plugin) 目录下的某个文件里定义。Vim
的函数名不能包含标点符号 (除了下划线以外)。要支持包含这类字符的后缀，netrw 会
先按照下表对后缀进行转换: >

    @ -> AT       ! -> EXCLAMATION    % -> PERCENT
    : -> COLON    = -> EQUAL          ? -> QUESTION
    , -> COMMA    - -> MINUS          ; -> SEMICOLON
    $ -> DOLLAR   + -> PLUS           ~ -> TILDE
<
因而，对于下例: >

	file.rcs,v  ->  NFH_rcsCOMMAv()
<
如果你需要更多的转换，请给我发电子邮件: >
		NdrOchip at ScampbellPfamily.AbizM - NOSPAM
提出要求。

相关设置变量: |g:netrw_browsex_viewer|

删 除 书 签						*netrw-mB* {{{2

要删除书签，用 >

	{cnt}mB

如果有带标记的文件，mB 会从书签列表中删除之 。

此外，还可用 :NetrwMB! (见 |netrw-:NetrwMB|)。 >

	:NetrwMB! [文件/目录]

相关主题:
	|netrw-gb| 如何回到 (go) 书签
	|netrw-mb| 如何建立书签
	|netrw-qb| 如何列出书签

删 除 文 件 或 目 录		*netrw-delete* *netrw-D* *netrw-del* {{{2

如果没有用 |netrw-mf| 标记过文件:   (局部标记文件列表)

    文件和目录的删除涉及如下操作: 移动光标到要删除的文件/目录，然后按 "D"。目
    录必须为空才能成功删除。如果所谓的目录是指向目录的软链接。要成功删除该目
    录，netrw 需要发出两个请求。删除前 netrw 会给出确认。用 "V" 命令 (可视选
    择) 然后按 "D" 可以选择行范围。

如果用 |netrw-mf| 标记过文件:   (局部标记文件列表)

    带标记文件 (含空目录) 会被删除；还是一样，在实际操作之前，你会被询问以确认
    删除动作。

进一步，可以删除匹配模式的文件。

    * 用 :MF 模式 (见 |netrw-:MF|)；然后按 "D"。

    * 用 mr (见 |netrw-mr|) 提示你输入模式。使得匹配文件被标记。然后按 "D"。

|g:netrw_rm_cmd|、|g:netrw_rmf_cmd| 和 |g:netrw_rmdir_cmd| 变量用以控制如何删
除远程的文件和目录。g:netrw_rm_cmd 用于文件，缺省值为:

	g:netrw_rm_cmd: ssh HOSTNAME rm

:netrw_rmdir_cmd 变量用于删除目录。缺省值为:

	|g:netrw_rmdir_cmd|: ssh HOSTNAME rmdir

如果用 g:netrw_rmdir_cmd 删除目录失败，netrw 会再尝试一次用 g:netrw_rmf_cmd 变
量进行删除。缺省值为:

	|g:netrw_rmf_cmd|: ssh HOSTNAME rm -f

相关主题: |netrw-d|
相关设置变量: |g:netrw_localrmdir|  |g:netrw_rm_cmd|
              |g:netrw_rmdir_cmd|   |g:netrw_ssh_cmd|


*netrw-explore*  *netrw-hexplore* *netrw-nexplore* *netrw-pexplore*
*netrw-rexplore* *netrw-sexplore* *netrw-texplore* *netrw-vexplore* *netrw-lexplore*
目 录 探 索 命 令  {{{2

     :[N]Explore[!]  [dir]... 探索当前文件所在的目录		     *:Explore*
     :[N]Hexplore[!] [dir]... 水平分割    并探索                     *:Hexplore*
     :[N]Lexplore[!] [dir]... 切换左浏览器                           *:Lexplore*
     :[N]Sexplore[!] [dir]... 分割并探索当前文件所在的目录	     *:Sexplore*
     :[N]Vexplore[!] [dir]... 垂直分割    并探索                     *:Vexplore*
     :Texplore       [dir]... 建立新标签页并探索                     *:Texplore*
     :Rexplore            ... 返回到浏览器                           *:Rexplore*

     用于 :Explore **/模式 : (另见 |netrw-starstar|)
     :Nexplore............. 转到下一个匹配的文件                    *:Nexplore*
     :Pexplore............. 转到前一个匹配的文件                    *:Pexplore*

						*netrw-:Explore*
:Explore  会打开当前文件目录上的本地目录浏览器 (或者如果指定，[dir] 目录)。
	  只有该文件被修改且 |'hidden'| 未置位时才会分割窗口，否则浏览窗口使用
	  该窗口。通常使用水平分割。
:Explore! 类似于 :Explore，但使用垂直分割。

						*netrw-:Hexplore*
:Hexplore  [dir] 执行 :Explore，用 |:belowright| 水平分割。
:Hexplore! [dir] 执行 :Explore，用 |:aboveleft|  水平分割。

						*netrw-:Lexplore*
:[N]Lexplore [dir] 在当前标签页上左侧切换一个全高的浏览器窗口。如果 [dir] 省
	  略，在当前目录上打开 netrw 窗口；不管从哪个窗口执行本命令，:Lexplore
	  [dir] 会在左侧浏览器上显示指定目录。

	  缺省 :Lexplore 会将未初始化的 |g:netrw_chgwin| 值设为 2；从而，编辑
	  会首选在 window#2 进行。

	  [N] 指定 |g:netrw_winsize|，只适用于新建的 :Lexplore 窗口。

	  喜欢此方法的常常也喜欢树风格的显示；见 |g:netrw_liststyle|。

	  另见:	    |netrw-C|           |g:netrw_browse_split|   |g:netrw_wiw|
		    |netrw-p| |netrw-P|   |g:netrw_chgwin|
		    |netrw-c-tab|       |g:netrw_winsize|

:[N]Lexplore! 类似于 :Lexplore，但全高的探索器窗口开在右侧，未初始化的
	 |g:netrw_chgwin| 设为 1。

						*netrw-:Sexplore*
:Sexplore 调用本地目录浏览器前总分割窗口。和 Explore 相同，通常使用水平分割。
:Sexplore! [dir] 类似于 :Sexplore，但使用垂直分割。

						*netrw-:Texplore*
:Texplore  [dir] 在生成浏览窗口前先执行 |:tabnew|

						*netrw-:Vexplore*
:Vexplore  [dir] 执行 :Explore，用 |:leftabove|  垂直分割。
:Vexplore! [dir] 执行 :Explore，用 |:rightbelow| 垂直分割。

可选的参数是:

 [N]: 此参数会代替 |g:netrw_winsize| 来指定新浏览器窗口应有的行数和列数。
      否则，如果用户指定 |g:netrw_winsize| 变量，用来设置新浏览器窗口应有的行
      数和列数。

 [dir]: 缺省这些浏览器命令使用当前文件的目录。不过你可以显式提供使用的目录 (路
        径)。 >

	:Explore /some/path
<
						*netrw-:Rexplore*
:Rexplore  此命令和其它的有所不同，它不一定会打开浏览器窗口。

	   返回浏览器 ~
	   当用在 netrw 浏览器窗口的文件上按 <cr> 等方式编辑文件时，在编辑文件
	   时调用的 :Rexplore 会重新显示上次在此窗口上显示的 netrw 浏览器窗
	   口。

	   从浏览器上返回 ~
	   相反地，编辑目录时调用 :Rexplore 会返回到使用此窗口的上次的文件编辑
	   状态。

	   <2-leftmouse> 映射 (只有在 gvim 和有相应支持的终端才存在) 的行为和
	   :Rexplore 相同。

另见: |g:netrw_alto| |g:netrw_altv| |g:netrw_winsize|

*netrw-star* *netrw-starpat* *netrw-starstar* *netrw-starstarpat* *netrw-grep*
使 用 星 号 和 模 式 进 行 探 索 {{{2

Explore、Sexplore、Hexplore 或 Vexplore 使用以下四种风格的路径时，Explore 生成
本地文件系统生成满足要求的的文件列表。这些探索模式不适用于远程文件浏览。 >

    */filepat	当前目录满足文件模式 filepat 的文件
    **/filepat	当前目录或之下满足文件模式的文件
    *//pattern	当前目录内容包含模式 pattern 的文件 (使用 vimgrep)
    **//pattern	当前目录或之下内容包含模式 pattern 的文件 (使用 vimgrep)
<
光标会被放在列表的第一个文件上。用 |:Nexplore| 可以访问该列表后面的文件，也可
用 |:Pexplore| 访问列表前面的文件。Explore 会更新目录并把光标放在合适的位置。

简单的 >
	:Explore
会清除探索列表。

如果控制台或 GUI 产生的 shift-up 或 shift-down 序列能够被识别，也许你会发现
shift-下箭头 和 shift-上箭头 更方便。netrw 提供它们的映射，如下:

	<s-down>  == Nexplore，而
	<s-up>    == Pexplore。

考虑下例 >

	:Explore */*.c
	:Nexplore
	:Nexplore
	:Pexplore
<
状态行的右侧会显示 "Match 3 of 20" 这样的消息。

相关设置变量:
	|g:netrw_keepdir|          |g:netrw_browse_split|
	|g:netrw_fastbrowse|       |g:netrw_ftp_browse_reject|
	|g:netrw_ftp_list_cmd|     |g:netrw_ftp_sizelist_cmd|
	|g:netrw_ftp_timelist_cmd| |g:netrw_list_cmd|
	|g:netrw_liststyle|


显 示 文 件 信 息					*netrw-qf* {{{2

把光标放在文件名上，按 "qf" 会显示文件的大小和最近的修改时间。目前，此功能只适
用于本地文件。


编 辑 文 件 或 目 录 的 隐 藏 列 表	*netrw-ctrl-h* *netrw-edithide* {{{2

"<ctrl-h>" 映射显示请求以允许用户改变 |g:netrw_list_hide| 包含的文件/目录隐藏
列表。隐藏列表包含一个或多个逗号分隔的模式列表。可以隐藏 (也就是不显示) 或只显
示满足这些模式的文件和/或目录 (见 |netrw-a|)。

"gh" 映射 (见 |netrw-gh|) 在普通的隐藏列表和隐藏 "." 开始的文件或目录间快速切
换。

示例， >
	let g:netrw_list_hide= '\(^\|\s\s\)\zs\.\S\+'
效果上，它使得 |netrw-gh| 命令的结果成为初始的设置。具体来说:

	\(^\|\s\s\)   : 如果下面的模式开始本行，-或-出现在两个连续的空白之后
	\zs           : 开始隐藏匹配
	\.            : 以句号开始
	\S\+          : 后跟一个或多个非空白字符

相关设置变量: |g:netrw_hide| |g:netrw_list_hide|
相关主题: |netrw-a| |netrw-gh| |netrw-mh|


					*netrw-sort-sequence*
编 辑 排 序 序 列			*netrw-S* *netrw-sortsequence* {{{2

如果 "排序风格" 为 name，用此排序序列可决定优先次序 (g:netrw_sort_sequence)。
排序序列里，通常按后缀名安排名字列表的优先级，但其实任何模式都可以用。用逗号定
界模式。缺省的排序序列是 (在一行上):
>
Unix 上: >
	'[\/]$,\<core\%(\.\d\+\)\=,\.[a-np-z]$,\.h$,\.c$,\.cpp$,*,\.o$,\.obj$,
	\.info$,\.swp$,\.bak$,\~$'
<
其它: >
	'[\/]$,\.[a-np-z]$,\.h$,\.c$,\.cpp$,*,\.o$,\.obj$,\.info$,
	\.swp$,\.bak$,\~$'
<
单独的 * 包含其它模式没有覆盖的所有文件名。用 g:netrw_sort_sequence 变量 (手动
或在 <.vimrc> 里设置) 可以修改排序序列，"S" 映射也可以完成。

相关主题:     |netrw-s|               |netrw-S|
相关设置变量: |g:netrw_sort_sequence| |g:netrw_sort_options|


用 SYSTEM() 执 行 光 标 所 在 的 文 件				*netrw-X* {{{2

光标停留在可执行文件上时按 X 时，会用文件名给出提示，要求输入参数。按 [return]
后 netrw 会调用 |system()| 执行该命令和给定参数。结果用 |:echomsg| 显示，
|:messages| 可以重新显示结果。Ansi 转义序列会被去掉。


强 制 作 为 文 件 或 目 录 对 待		*netrw-gd* *netrw-gf* {{{2

远端符号链接 (即通过 ssh 或 ftp 列出的) 有一个问题，不容易知道它们实际链接到文
件还是目录。

强制作为文件: 用 >
	gf
<
强制作为目录: 用 >
	gd
<

向 上 一 层							*netrw--* {{{2

要到上一层的目录，按 "-" 或在列表的 ../ 目录项上按 <cr>。

netrw 用 |g:netrw_list_cmd| 命令执行目录列表操作，其中 HOSTNAME 被用户提供的
url 的宿主名替换。netrw 提供的缺省命令是: >

	ssh HOSTNAME ls -FLa
<
其中的 HOSTNAME 将根据读取操作的请求设为 [user@]hostname。很自然地，用户可以自
行设置以覆盖此命令。NetList 函数实现远程浏览，它期待拖尾斜杠能标记目录名。


隐 藏 文 件 或 目 录			        *netrw-a* *netrw-hiding* {{{2

netrw 的浏览机制提供三种使用隐藏列表的方法: 忽略此列表、隐藏匹配的文件、还有只
显示匹配的文件。

如果没有用 |netrw-mf| 标记过文件:

用户可以用 "a" 映射在这三种方式间切换。

|g:netrw_list_hide| 变量保存逗号分隔的正规表达式列表 (例如 ^.*\.obj$,^\.)，以
指定隐藏列表。(另见 |netrw-ctrl-h|) 要设置隐藏列表，可以用 <c-h> 映射。例如，
要隐藏 "." 开头的文件，可以用 <c-h> 映射来设置隐藏列表为 '^\..*' (你也可以在
<.vimrc> 里设置 g:netrw_list_hide= '^\..*')。然后用 "a" 键就可以显示所有文件、
隐藏匹配文件或只显示匹配文件。

	示例: \.[ch]$
		这个隐藏列表命令会隐藏/显示所有的 *.c 和 *.h 文件。

	示例: \.c$,\.h$
		这个隐藏列表命令也会隐藏/显示所有的 *.c 和 *.h 文件。

不要忘记用 "a" 映射来选择你想要的 (普通/隐藏/显示) 模式！

如果用 |netrw-mf| 标记过文件，那么此命令会:

  如果显示所有文件或非隐藏文件:
   修改 g:netrw_list_hide 列表，加入带标记文件，并只显示非隐藏文件。

  否则，如果只显示隐藏文件:
   修改 g:netrw_list_hide 列表，删除带标记文件，并只显示非隐藏文件。

					*netrw-gh* *netrw-hide*
有一个快捷键，按 >
	gh
可以切换是否隐藏句号 (点) 开始的文件。

相关设置变量: |g:netrw_list_hide|  |g:netrw_hide|
相关主题: |netrw-a| |netrw-ctrl-h| |netrw-mh|

					*netrw-gitignore*
Netrw 提供帮助函数 'netrw_gitignore#Hide()'，和 |g:netrw_list_hide| 一起使用时
自动隐藏 git-ignore 的文件。

'netrw_gitignore#Hide' 搜索下面文件中的模式: >

	'./.gitignore'
	'./.git/info/exclude'
	全局 gitignore 文件: `git config --global core.excludesfile`
	系统 gitignore 文件: `git config --system core.excludesfile`
<
忽略不存在的文件。
从存在的文件中提取 git-ignore 模式，转换为隐藏文件的模式。例如， '.gitignore'
文件中 '*.log' 转换为 '.*\.log'。

要使用此函数，简单地把其输出赋值给 |g:netrw_list_hide| 选项。 >

	例如: let g:netrw_list_hide= netrw_gitignore#Hide()
		在 netrw 里隐藏 git-ignore 文件。

	例如: let g:netrw_list_hide= netrw_gitignore#Hide('my_gitignore_file')
		函数可以接受使用 git-ignore 模式的额外文件。

	例如: g:netrw_list_hide= netrw_gitignore#Hide() . '.*\.swp$'
		混合 'netrw_gitignore#Hide' 和定制的模式。
<

改 进 目 录 浏 览			*netrw-listhack* *netrw-ssh-hack* {{{2

不断要求输入密码很讨厌，远程目录的浏览尤其受这个问题影响。

对 Linux/Unix 系统而言，Rob Flickenger 所著的 "Linux Server Hacks - 100
industrial strength tips & tools" (O'Reilly, ISBN 0-596-00461-3) 一书给出如
何设置无需密码的 ssh 和 scp 的使用方式的提示，也包括相关安全问题的讨论。该书
曾经可从 http://hacks.oreilly.com/pub/h/66 得到，但现在该地址已经被重定向到某
个 "hackzine" 网站。基于该文章和我与 Ben Schmidt 的通信，我试图给一个小结:

	1. 在本地机器 (ssh 客户端) 上生成 公钥/私钥 对: >
		ssh-keygen -t rsa
		(按照提示，把该文件存到 ~/.ssh/id_rsa)
<
	2. 如果不要 passphrase，提示 passphrase 时只要按 <CR> 即可 (两次)。如
	   果需要 passphrase，你要使用 ssh-agent，从而每个会话期间只需输入一次
	   passphrase。如果不用 passphrase，只要简单地登录到你的本地机器上或者
	   用任何方式得到密钥文件就足够可以访问任何使用该密钥提供授权登录的
	   ssh 服务器。

	3. 这会建立两个文件: >
		~/.ssh/id_rsa
		~/.ssh/id_rsa.pub
<
	4. 在目标机器 (ssh 服务器) 上: >
		cd
		mkdir -p .ssh
		chmod 0700 .ssh
<
	5. 在你的本地机器 (ssh 客户端) 上: (在一行上输入) >
		ssh {serverhostname}
		  cat '>>' '~/.ssh/authorized_keys2' < ~/.ssh/id_rsa.pub
<
	   或者，对于 OpenSSH 而言，(在一行上输入) >
		ssh {serverhostname}
		  cat '>>' '~/.ssh/authorized_keys' < ~/.ssh/id_rsa.pub
<
你可以这样测试 >
	ssh {serverhostname}
你应该可以登录到服务器机器而无须任何进一步的输入。

如果你决定使用 passphrase: >
	ssh-agent $SHELL
	ssh-add
	ssh {serverhostname}
ssh-add 时，你会被提示输入密钥 passphrase，但之后 ssh 就无须再输入了。要用于
vim，你可以用 >
	ssh-agent vim
然后在 vim 中，用 >
	:!ssh-add
另一个方案是在要执行 vim 的终端上应用 ssh-agent: >
	ssh-agent xterm &
然后需要的时候执行 ssh-add。

vim 邮件列表上也有人提到 Windows 上的 Pageant 有助于避免不断要求输入密码的麻
烦。

Kingston Fung 写下另一个避免不断要求输入密码的方法:

    要避免每次使用 scp 都输入密码的需要，你在文档里给出了一个设置无密码 ssh 帐
    号的技巧。我有个更好的方法: 我可以使用普通有密码的 ssh 帐号来访问内容，而
    无须每次都输入密码。既安全又方便。我试了 ssh 公钥验证和 ssh-agent，这么做
    就可以用了！这里是具体操作的链接:

    http://www.ibm.com/developerworks/library/l-keyc2/
    http://sial.org/howto/openssh/publickey-auth/


    Ssh 小提示:

	Thomer Gil 提供的加速 netrw+ssh 的提示:
	    http://thomer.com/howtos/netrw_ssh.html

	Alex Young 关于加速ssh 的若干提示:
	    http://usevim.com/2012/03/16/editing-remote-files/


列 出 书 签 和 历 史			*netrw-qb* *netrw-listbookmark* {{{2

按 "qb" (query bookmarks，查询书签) 会列出书签里记录的目录和目录遍历的历史。

相关主题:
	|netrw-gb| 如何回到 (go) 书签
	|netrw-mb| 如何建立书签
	|netrw-mB| 如何删除书签
	|netrw-u|  如何切换到历史堆栈里先前的目录
	|netrw-U|  如何切换到历史堆栈里后来的目录


建 立 新 目 录						*netrw-d* {{{2

用 "d" 映射可以在远端 (取决于全局变量 g:netrw_mkdir_cmd) 或本地 (取决于全局变
量 g:netrw_localmkdir) 建立目录。netrw 会要求新目录的名字。这时单输入 <CR> 可
以中止目录建立过程。试图建立已经存在的本地目录 (可以是文件或目录) 会被检测到并
进行报告，然后忽略。

相关主题: |netrw-D|
相关设置变量:			|g:netrw_localmkdir|   |g:netrw_mkdir_cmd|
				|g:netrw_remote_mkdir| |netrw-%|


使 浏 览 目 录 成 为 当 前 目 录		*netrw-c* *netrw-curdir* {{{2

|g:netrw_keepdir| 缺省为 1。该设置意味着当前目录不会跟踪浏览目录。(这么做是为
于和 v6 版本的文件探索器后向兼容)

设置 g:netrw_keepdir 为 0 告诉 netrw 使 vim 的当前目录跟踪 netrw 的浏览目录。

不过，保持缺省为 1 的 g:netrw_keepdir 设置意味着 netrw 维护它自己的当前目录的
概念。要想使两个目录相同，可用 "c" 映射 (只要按 c 就可以)。该映射会把 Vim 概念
的当前目录设为当前的浏览目录。

相关设置变量: |g:netrw_keepdir|


标 记 文 件					*netrw-:MF*	*netrw-mf* {{{2
	(另见 |netrw-mr|)

netrw 提供了几种标记文件的方式:

	* 把光标移到文件名上按 "mf" 就可以标记文件。

	* gvim 中，更可以用 <s-leftmouse> 来标记文件。(见 |netrw-mouse|)

	* :MF 命令接受文件列表 (针对本地目录，列表可能包含通配符 -- 见
	  |glob()|) >

		:MF *.c
<
	  (备注 :MF 用 |<f-args>| 以便在空白内断开行)

	* 用 |argument-list| 标记文件 (|netrw-mA|)

	* 基于 |location-list| 标记文件 (|netrw-qL|)

	* 基于 quickfix (|netrw-qF|)
	  (|quickfix-error-lists|)

下面的 netrw 映射使用带标记文件:

    |netrw-a|	隐藏标记文件/目录
    |netrw-D|	删除标记文件/目录
    |netrw-ma|	移动标记文件名到 |arglist|
    |netrw-mA|	移动 |arglist| 文件名到标记文件列表
    |netrw-mb|	附加标记文件到书签
    |netrw-mB|	从书签中删除标记文件
    |netrw-mc|	复制标记文件到目标
    |netrw-md|	给标记文件应用 vimdiff
    |netrw-me|	编辑标记文件
    |netrw-mF|	撤销文件标记
    |netrw-mg|	在标记文件上应用 vimgrep
    |netrw-mm|	移动标记文件到目标
    |netrw-mp|	打印标记文件
    |netrw-mt|	为 |netrw-mm| 和 |netrw-mc| 设定目标
    |netrw-mT|	用标记文件生成标签
    |netrw-mv|	在标记文件上应用 vim 命令
    |netrw-mx|	在标记文件上应用外壳命令
    |netrw-mX|	在标记文件上整块应用外壳命令
    |netrw-mz|	压缩/解压标记文件
    |netrw-O|	获取标记文件
    |netrw-R|	为标记文件换名

用标记文件相同的方式可以撤销文件的标记，也就是，把光标移到带标记的文件上按
"mf"。这也适用于 gvim 的 <s-leftmouse>。按 "mu" 可以一次撤销所有标记 (见
|netrw-mu|)。

标记的文件使用 "netrwMarkFile" 高亮组高亮，该组缺省链接到 "Identifier" (见
|group-name| 下的 Identifier)。可以把以下代码 >

	highlight clear netrwMarkFile
	hi link netrwMarkFile ..随便什么..
<
加入 $HOME/.vim/after/syntax/netrw.vim 来改变高亮组设置。

如果鼠标功能打开且在 Vim 里可用，可用 <s-leftmouse> 来标记一个或多个文件。多个
文件的标记可通过按住 shift 拖动鼠标左键实现。(见 |netrw-mouse|)

			*markfilelist* *global_markfilelist* *local_markfilelist*
所有的标记文件都进入全局标记文件列表；只有唯一的这样的列表。此外，每个 netrw
缓冲区都有自己缓冲区局部的标记文件列表；因为 netrw 缓冲区和特定的目录相关联，
这意味着每个目录都有自己的局部标记文件列表。操作标记文件的命令分别使用两个标记
文件列表中的一个。

已知问题: 如果使用树模式 (|g:netrw_liststyle|) 而多个目录上有相同的文件名，标
记其中一个文件会高亮所有这样的文件，就像它们都被标记了一样。不过，
|markfilelist| 只包含你实际选择的文件。这个问题不太可能得到修正。

撤 销 文 件 标 记						*netrw-mF* {{{2
	(另见 |netrw-mf|、|netrw-mu|)

"mF" 命令撤销当前缓冲区所有文件的标记。也可用 mf (|netrw-mf|) 来撤销特定的己标
记文件的标记。

用 位 置 列 表 标 记 文 件 					*netrw-qL* {{{2
	(另见 |netrw-mf|)

"qL" 可以把 |location-list| 转换为标记文件的列表。然后用 me (|netrw-me|) 这样
的命令就可以编辑它们。


用 QUICKFIX 列 表 标 记 文 件					*netrw-qF* {{{2
	(另见 |netrw-mf|)

"qF" 可以把 |quickfix-error-lists| 转换为标记文件的列表。然后用 me
(|netrw-me|) 这样的命令就可以编辑它们。例如，可以调用 |:vimgrep| 来生成
Quickfix 错误列表。


用 正 规 表 达 式 标 记 文 件				*netrw-mr* {{{2
	(另见 |netrw-mf|)

也可以用 "mr" 来标记文件；netrw 会给出提示，"Enter regexp: "。此时，你可以输入
一个外壳风格的正规表达式，比如 *.c$ (见 |glob()|)。glob() 不能用于远程文件，所
以 netrw 把 "*" 转换成 ".*" (见 |regexp|) 并依此匹配文件。将来，我可能会考虑提
供选项来使用 |regexp| 而不是 glob()-风格的表达式 (另一个选项)。


带 标 记 文 件，任 意 VIM 命 令					*netrw-mv* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用局部标记文件列表)

"mv" 映射会使 netrw 在本地标记文件列表的每个文件上分别执行任意的 vim 命令:

	* 1split
	* sil! keepalt e file
	* 执行 vim 命令
	* sil! keepalt wq!

给出提示 "Enter vim command: " 让用户给出要使用的 vim 命令。


带 标 记 文 件，任 意 外 壳 命 令				*netrw-mx* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用局部标记文件列表)

激活 "mx" 映射后，netrw 会询问用户应用于所有带标记文件的 (外部) 命令。命令中所
有的 "%" 被带标记文件的每个名字依次替代。如果命令中没有 "%"，那么命令后附加一
个空格和一个带标记文件名。

示例:
	(标记文件)
	mx
	Enter command: cat

	结果是一系列外壳命令:
	cat 'file1'
	cat 'file2'
	...


带 标 记 文 件，任 意 外 壳 命 令，整 块			*netrw-mX* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用全局标记文件列表)

激活 'mX' 映射后，netrw 会请用户给出某个 (外部) 命令，应用在全局标记文件列表上
的所有带标记文件。"整块" 的意思是一个命令一次执行在所有文件上: >

	command files

此方法可用于，例如，选择所有文件打个 tarball 包: >

	(标记文件)
	mX
	Enter command: tar cf mynewtarball.tar
<
此例中会执行的命令是:

	tar cf mynewtarball.tar 'file1' 'file2' ...


带 标 记 文 件 : 参 数 列 表				*netrw-ma* *netrw-mA*
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用全局标记文件列表)

ma 可以从标记文件列表移动文件名到参数列表。
mA 可以从参数列表移动文件名到标记文件列表。

另见: |netrw-qF| |argument-list| |:args|


带 标 记 文 件 : 压 缩 与 解 压 缩			*netrw-mz* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用局部标记文件列表)

对任何压缩过的带标记文件，"mz" 会对它们解压。
对任何被解压的带标记文件，"mz" 会用 |g:netrw_compress| 指定的命令对它们进行压
缩。缺省，使用 "gzip"。

对于解压，netrw 使用一个后缀到相应解压工具的 |Dictionary|；见
|g:netrw_decompress|。

记住可以用正规表达式来标记多个文件 (见 |netrw-mr|)；这对压缩与解压缩大量文件特
别有用。

相关设置变量: |g:netrw_compress| |g:netrw_decompress|

带 标 记 文 件 : 复 制					*netrw-mc* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用全局标记文件列表)

用 mt 选择目标目录 (|netrw-mt|)。然后改变目录，选择文件 (见 |netrw-mf|)，然后
按 "mc"。从当前窗口 (执行 mf 的地方) 复制到目标。

如果没有用 |netrw-mt| 设置目标目录，netrw 会让你输入要复制到的目录。

也可以复制目录及其内容 (只限本地) 来目标目录。

相关设置变量:
	|g:netrw_localcopycmd|
	|g:netrw_localcopydircmd|
	|g:netrw_ssh_cmd|

带 标 记 文 件 : 比 较					*netrw-md* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用全局标记文件列表)

用 |vimdiff| 来显示选择文件的差异 (为此，可以选择两到三个文件)。

带 标 记 文 件 : 编 辑					*netrw-me* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用全局标记文件列表)

"me" 命令把带标记文件放在 |arglist| 上，然后开始编辑它们。用 |:Rexplore| 可以
回到浏览器窗口。
(|:n| 和 |:p| 可以编辑 arglist 的下一个和上一个文件)

带 标 记 文 件: GREP						*netrw-mg* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用全局标记文件列表)

"mg" 命令在带标记文件上应用 |:vimgrep|。
该命令会询问需要的模式；你可以输入: >
	/pattern/[g][j]
	! /pattern/[g][j]
	pattern
<
用 /pattern/，从 vimgrep 产生的 |quickfix| 列表 (见  |:copen|、|:cnext|、
|:cprevious|、|:cclose|) 的首个项目开始编辑。使用的是 |:vimgrep| ，因而不带
'g' 时每行只加到 quickfix 列表上一次，带 'g' 时加入每个匹配。

用 /pattern/j，"mg" 可以缩减当前的标记文件列表，只包含给定模式的那些标记文件。
因此可以用 >
	mr ...文件模式...
	mg /内容模式/j
<
来得到同时满足文件名匹配文件模式且内容限定在指定内容模式的标记文件列表。


带 标 记 文 件 : 按 后 缀 隐 藏 或 显 示		*netrw-mh* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用局部标记文件列表)

"mh" 命令提取带标记文件的后缀，然后在隐藏列表中切换它们的存在与否。请 注意 据
此，带有相同后缀的文件多次出现会使得每个文件都切换一次此后缀的存在与否 (所以偶
数个相同后缀的带标记文件和不选任何文件的作用是一样的)。

相关主题: |netrw-a| |g:netrw_list_hide|

带 标 记 文 件 : 移 动					*netrw-mm* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用全局标记文件列表)

	警 告: 移动文件比复制文件要危险。被移动的文件先被复制然后被删除；如果
	复制操作失败但删除操作成功，该文件就丢失了。你要么用不太重要的文件先试
	试，要么用 mc 和 D 先进行复制然后再删除。请自行负责！

用 mt 选择目标目录 (|netrw-mt|)。然后改变目录，选择文件 (见 |netrw-mf|)，然后
按 "mm"。从当前窗口 (执行 mf 的地方) 移动到目标。

相关设置变量: |g:netrw_localmovecmd| |g:netrw_ssh_cmd|

带 标 记 文 件 : 打 印					*netrw-mp* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用局部标记文件列表)

"mp" 命令使 netrw 对带标记文件应用 |:hardcopy| 命令。具体地，它在一个单行的窗
口上打开每个文件，执行 hardcopy，然后关闭这个单行窗口。


带 标 记 文 件 : 执 行					*netrw-ms* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用局部标记文件列表)

"ms" 命令使 netrw 执行带标记文件 (使用 vim 的 |:source| 命令)


带 标 记 文 件 : 设 置 目 标 目 录			*netrw-mt* {{{2
     (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)

设置带标记文件复制/移动的目标 (见 |netrw-mc| 和 |netrw-mm|):

  * 如果光标在文件名上，使用 netrw 窗口当前显示的目录作为复制/移动目标。

  * 同样，如果光标在横幅处，使用 netrw 窗口当前显示的目录作为复制/移动目标。
    除非目标已经是当前目录，此时，键入 "mf" 撤销该目标。

  * 但如果光标在一个目录名上，使用该目录作为复制/移动目标。

  * 可用 :MT [directory] 命令来设置目标			*netrw-:MT*
    此命令使用 |<q-args>|，所以接受里带空格的目录名，不需转义。

  * 在打开鼠标的 vim 或 gvim 里，可用 <c-leftmouse> 选择目标

每个 vim 会话只有一个复制/移动目标；也就是说，该目标是一个脚本变量 (见
|s:var|)，并且由所有 (同一 vim 实例中的) netrw 窗口共享。

使用菜单和 gvim 时，netrw 提供 "Targets" 菜单项，可用来从书签和历史的选项中选
取目标。

相关主题:
      标记文件...........................................|netrw-mf|
      用正规表达式标记文件...............................|netrw-mr|
      带标记文件: 用书签作为目标目录.....................|netrw-Tb|
      带标记文件: 用历史作为目标目录.....................|netrw-Th|


带 标 记 文 件 : 建 立 标 签				*netrw-mT* {{{2
	    (关于如何标记文件，见 |netrw-mf| 和 |netrw-mr|)
		      (使用全局标记文件列表)

"mT" 映射为带标记文件应用 |g:netrw_ctags| 定义的命令 (缺省是 "ctags")。对于远
程浏览，为了建立一个标签文件，netrw 会使用 ssh (见 |g:netrw_ssh_cmd|)，所以要
能在远程系统使用此命令，ssh 必须存在。对于本地系统，见 |ctags| 说明如何得到可
用的版本。我自己用 hdrtags，目前可从
http://www.drchip.org/astronaut/src/index.html 获得，并在我的 <.vimrc> 中
有 >

	let g:netrw_ctags= "hdrtag"
<
如果为一组远程的文件建立了标签，产生的 tags 文件被 "获取"；也即，一个备份被传
输到本地系统的目录。然后这个本地的 tags 文件被修改，使得它可以在网上使用。具体
地，tags 里的文件名被修改，每个路径前面加上了用于获取的 netrw 兼容的 url。如果
用户随后用某个转到标签的动作 (|tags|)，netrw 就可以用该 url 来编辑想要的文件，
并转到对应的标签上。

相关设置变量: |g:netrw_ctags| |g:netrw_ssh_cmd|


带 标 记 文 件: 用 书 签 作 为 目 标 目 录		*netrw-Tb* {{{2

设置带标记文件复制/移动的目标。

|netrw-qb| 映射给出书签 (和历史) 的列表。可以用 [count]Tb (缺省计数: 1) 从中选
取一个书签作为标记文件的目标。

相关主题:
      复制文件到目标.....................................|netrw-mc|
      列出书签和历史.....................................|netrw-qb|
      带标记文件: 设置目标目录...........................|netrw-mt|
      带标记文件: 用历史作为目标目录.....................|netrw-Th|
      标记文件...........................................|netrw-mf|
      用正规表达式标记文件...............................|netrw-mr|
      移动文件到目标.....................................|netrw-mm|


带 标 记 文 件: 用 历 史 作 为 目 标 目 录			*netrw-Th* {{{2

设置带标记文件复制/移动的目标。

|netrw-qb| 映射给出历史 (和书签) 的列表。可以用 [count]Th (缺省计数: 0，即当前
目录) 从中选取一个历史项作为标记文件的目标。

相关主题:
      复制文件到目标.....................................|netrw-mc|
      列出书签和历史.....................................|netrw-qb|
      带标记文件: 设置目标目录...........................|netrw-mt|
      带标记文件: 用书签作为目标目录.....................|netrw-Tb|
      标记文件...........................................|netrw-mf|
      用正规表达式标记文件...............................|netrw-mr|
      移动文件到目标.....................................|netrw-mm|


带 标 记 文 件 : 撤 销 标 记				*netrw-mu* {{{2
     (见 |netrw-mf| 、|netrw-mF|)

"mu" 映射撤销当前所有带标记文件的标记。此命令和 "mF" 不同之处在于后者只撤销当
当前目录下的文件，而 "mu" 撤销全局和所有缓冲区局部的标记文件的标记。
(见 |netrw-mF|)


				*netrw-browser-settings*
NETRW 浏 览 器 变 量		*netrw-browser-options* *netrw-browser-var* {{{2

(如果你对 netrw 文件传输设置感兴趣，见 |netrw-options| 和 |netrw-protocol|)

<netrw.vim> 浏览器提供你可以修改的以变量形式出现的设置。把这些设置放在
<.vimrc> 里，你就可以定制浏览的偏好。(另见: |netrw-settings|)
>
   ----				----
   变量				解释
   ----				----
<  *g:netrw_altfile*		有些人喜欢 |CTRL-^| 返回最返的编辑文件。要选择
				此行为，设置此参数为 1。
				其他的人喜欢 |CTRL-^| 返回 netrw 浏览缓冲区。
				要选择此行为，设置此参数为 0。
				 缺省: =0

  *g:netrw_alto*		置位此变量后，分割后的新窗口出现在下方而不是
				上方 (见 |netrw-o|)
				 缺省: =&sb           (见 |'sb'|)

  *g:netrw_altv*		置位此变量后，分割后的新窗口出现在右方而不是
  				左方  (见 |netrw-v|)
				 缺省: =&spr          (见 |'spr'|)

  *g:netrw_banner*		显示/关闭横幅
				=0: 关闭横幅
				=1: 显示横幅1 (缺省)
				注意: 关闭横幅是新功能，可能会引起问题。

  *g:netrw_bannerbackslash*	如果此变量存在且非零，横幅显示时使用反斜杠而不
  				是斜杠。

  *g:netrw_browse_split*	浏览时，<cr> 这样打开文件:
				=0: 重用同一个窗口 (缺省)
				=1: 先水平分割窗口
				=2: 先垂直分割窗口
				=3: 在新标签页中打开文件
				=4: 等同于 "P" (即打开前次窗口)
				    注意 可用 |g:netrw_preview| 来进行垂直分割
				    而不是水平分割。
				=[servername,标签页号,窗口号]
				    给出 |List| 就像这样，用名为 "servername"
				    的远程服务器进行编辑。使用给定的标签页号和
				    窗口号来执行编辑
				    (见 |clientserver|、|netrw-ctrl-r|)
				此选项不影响 |:Lexplore| 窗口。

				相关主题:
				    |g:netrw_alto|	|g:netrw_altv|
				    |netrw-C|		|netrw-cr|
				    |netrw-ctrl-r|

  *g:netrw_browsex_viewer*	指定查阅器的用户偏好: >
					"kfmclient exec"
					"gnome-open"
<				如果使用了 >
					"-"
<				那么 netrwFileHandler() 将寻找处理该扩展名的脚
				本/函数 (见 |netrw_filehandler|)。

  *g:netrw_chgperm*		Unix/Linux: "chmod PERM FILENAME"
				Windows:    "cacls FILENAME /e /p PERM"
				用以改变文件的访问权限。

  *g:netrw_compress*		="gzip"
				    用此命令压缩带标记文件

  *g:Netrw_corehandler*		可用来指定 netrw 浏览器的 "x" 命令处理
				<core> 文件的额外处理。如果定义，
				g:Netrw_corehandler 指定一个或多个函数引用 (见
				|Funcref|)。
				(g:Netrw... 中的大写是必需的，因为它保存函函数
				引用)


  *g:netrw_ctags*		="ctags"
				建立标签使用的缺省外部程序

  *g:netrw_cursor*		= 2 (缺省)
				本选项控制 netrw 使用的 |'cursorline'| (cul)
				和 |'cursorcolumn'| (cuc) 设置:

				 值        瘦-长-树            宽
				 =0      u-cul u-cuc      u-cul u-cuc
				 =1      u-cul u-cuc        cul u-cuc
				 =2        cul u-cuc        cul u-cuc
				 =3        cul u-cuc        cul   cuc
				 =4        cul   cuc        cul   cuc

				其中
				  u-cul : 用户使用的 |'cursorline'|
				  u-cuc : 用户使用的 |'cursorcolumn'|
				  cul   : 局部设置的 |'cursorline'|
				  cuc   : 局部设置的 |'cursorcolumn'|

  *g:netrw_decompress*		= { ".gz"  : "gunzip" ,
				    ".bz2" : "bunzip2" ,
				    ".zip" : "unzip" ,
				    ".tar" : "tar -xf"}
				  映射后缀到解压程序的字典。

  *g:netrw_dirhistmax*            =10: 控制过去历史最大数量。零关闭之。
				     (相关: |netrw-qb| |netrw-u| |netrw-U|)

  *g:netrw_dynamic_maxfilenamelen* =32: 支持动态决定
				    |g:netrw_maxfilenamelen| 的值，它影响本地
				    文件的长列表。

  *g:netrw_errorlvl*		=0: 最低显示的错误级别
				    0: 备注
				    1: 警告
				    2: 错误

  *g:netrw_fastbrowse*		=0: 慢速浏览；
				    不会重用目录列表；
				    总是重新获取目录列表。
				=1: 中速浏览；
				    只有远程浏览才重用目录列表。
				    (缺省值)
				=2: 快速目录浏览；
				    只获取没有浏览过的目录列表
				    (或在用 |netrw-ctrl-l| 时)。
				快速浏览意味着保留旧目录列表的缓冲区，这样就不
				需要重新获取了。该特性对远程浏览特别有意义。不
				过，如果加入或者删除文件，旧的目录列表就不再是
				最新的。此时可用 |netrw-ctrl-l| 刷新目录列表。
				本选项提供用户机会来选择准确性 (即最新的列表)
				和速度的权衡。

  *g:netrw_ffkeep*		(缺省: 不存在)
				如果此变量存在且为零，netrw 不会保存和恢复
				|'fileformat'|。

  *g:netrw_fname_escape*	=' ?&;%'
  				远程读取/写入前用于文件名。

  *g:netrw_ftp_browse_reject*	ftp 可能会生成一些错误和警告信息，它们会作为
  				"目录" 和 "文件" 出现在列表里。使用本模式来删
				除这些内嵌的消息。缺省值为:
				 '^total\s\+\d\+$\|
				 ^Trying\s\+\d\+.*$\|
				 ^KERBEROS_V\d rejected\|
				 ^Security extensions not\|
				 No such file\|
				 : connect to address [0-9a-fA-F:]*
				 : No route to host$'

  *g:netrw_ftp_list_cmd*	传递给 ftp 用于列出目录的选项。缺省为:
				 unix 或置位 g:netrw_cygwin 时:	"ls -lF"
                                 否则                           "dir"


  *g:netrw_ftp_sizelist_cmd*	传递给 ftp 用于列出目录并按文件大小排序的选
				项。
				缺省:
				 unix 或置位 g:netrw_cygwin 时: "ls -slF"
				 否则                           "dir"

  *g:netrw_ftp_timelist_cmd*	传递给 ftp 用于列出目录并按文件最后修改时间
  				排序的选项。
				缺省:
				 unix 或置位 g:netrw_cygwin 时: "ls -tlF"
				 否则                           "dir"

  *g:netrw_glob_escape*		='[]*?`{~$'  (unix)
				='[]*?`{$'  (windows
  				应用 glob() 前，目录名中的这些字符被转义

  *g:netrw_gx*			="<cfile>"
				此选项控制 gx (|netrw-gx|) 如果选择光标下的文
				本。可用值见 |expand()|。

  *g:netrw_hide*		受 "a" 映射控制 (见 |netrw-a|)
				=0 : 显示全部
				=1 : 显示非隐藏文件
				=2 : 只显示隐藏文件
				 缺省: =0

  *g:netrw_home*		书签和历史保存的主目录 (分别存为 .netrwbook
  				和 .netrwhist)。
				 缺省: |'runtimepath'| 的第一个目录

  *g:netrw_keepdir*		=1 (缺省) 浏览目录时不影响当前目录。
				=0 浏览目录时设置当前目录为该目录。
				当前的浏览目录保存在 b:netrw_curdir 里 (另见
				|netrw-c|)

  *g:netrw_keepj*		="keepj" (缺省) netrw 试图使 |:jumps| 表不受影
					 响。
				=""      netrw 不用 |:keepjumps|，但位置的保
					 存/恢复是例外。

  *g:netrw_list_cmd*		列出远程目录的命令
				 缺省: (如果 ssh 可执行)
                                       "ssh USEPORT HOSTNAME ls -FLa"

 *g:netrw_list_cmd_options*	如果此变量存在，其内容被附加到
				g:netrw_list_cmd 里。例如，
				"2>/dev/null" 在 unix 系统上可用来去掉横幅。


  *g:netrw_liststyle*		设置缺省的列表风格:
                                = 0: 瘦列表 (每个文件一行)
                                = 1: 长列表 (每个文件一行，带有时间信息和文件
                                     长度)
				= 2: 宽列表 (多个文件，分列显示)
				= 3: 树型风格列表
  *g:netrw_list_hide*		逗号分隔的隐藏文件的模式列表
				模式是正规表达式 (见 |regexp|)
				对 git-ignore 文件有特殊支持: 可加入帮助函数
				'netrw_gitignore#Hide()'  的输出来自动隐藏所有
				的 git-ignore 文件。
				更多详情可见 |netrw-gitignore|。

				示例:
				 let g:netrw_list_hide= '.*\.swp$'
				 let g:netrw_list_hide= netrw_gitignore#Hide().'.*\.swp$'
				缺省: ""

  *g:netrw_localcopycmd*	="cp" Linux/Unix/MacOS/Cygwin
  				="copy" Windows
				把带标记文件 (|netrw-mf|) 复制到目标目录
				(|netrw-mt|、|netrw-mc|)

 *g:netrw_localcopydircmd*	="cp -R"	Linux/Unix/MacOS/Cygwin
				="xcopy /e /c /h/ /i /k"	Windows
				复制目录到目标目录。
				(|netrw-mc|、|netrw-mt|)

  *g:netrw_localmkdir*		建立本地目录的命令
				 缺省: "mkdir"

  *g:netrw_localmovecmd*	="mv" Linux/Unix/MacOS/Cygwin
  				="move" Windows
				把带标记文件 (|netrw-mf|) 移动到目标目录
				(|netrw-mt|、|netrw-mm|)

  *g:netrw_localrmdir*		删除目录的命令 (rmdir)
				 缺省: "rmdir"

  *g:netrw_maxfilenamelen*	=32 缺省之所以选为该值，使为了使长列表能在
				80 列内显示。如果你的屏幕更宽或者文件或目录名
				可能长于 32 个字节，可以设置此选项使列表按列排
				列

  *g:netrw_mkdir_cmd*		用 ssh 建立远程目录的命令 (另见
				|g:netrw_remote_mkdir|)
				 缺省: "ssh USEPORT HOSTNAME mkdir"

  *g:netrw_mousemaps*		  =1 (缺省) 打开鼠标按钮的功能
				   浏览时:
				     leftmouse       : 打开文件/目录
				     shift-leftmouse : 标记文件
				     middlemouse     : 同 P
				     rightmouse      : 删除文件/目录
				=0: 关闭鼠标映射

  *g:netrw_nobeval*		不存在 (缺省)
				如果此变量存在，不进行气泡计算
				(见 |'ballooneval'|)

 *g:netrw_sizestyle*		未定义: 实际字节 (缺省)
				="b" : 实际字节       (缺省)
				="h" : 人类可读 (例如 5k, 4m, 3g)
				       以 1000 为底
				="H" : 人类可读 (例如 5K, 4M, 3G)
				       以 1024 为底
				长列表 (|netrw-i|) 和查询文件的映射
				(|netrw-qf|) 会使用指定风格显示文件大小。

  *g:netrw_usetab*		如果此变量存在且非零，<tab> 映射支持 Lexplore
				的缩/放或打开 netrw 窗口。
				(见 |netrw-c-tab|)

  *g:netrw_remote_mkdir*	用 ftp 建立本地目录的命令 (另见
				|g:netrw_mkdir_cmd|)
				 缺省: "mkdir"

  *g:netrw_retmap*		如果存在且为一，那么:
  				 * 如果在 netrw 选择的文件中，_且_
				 * 没有定义过普通模式的 <2-leftmouse> 映射，
				那么 <2-leftmouse> 会被映射以方便地回到 netrw
				浏览器窗口。
				 示例: 点击一次，选择并打开文件，双击返回

				备注: 你也可以选择这么做:
				 * let g:netrw_retmap= 1 (译者注: 0？)，_且_
				 * nmap <silent> 你的选择 <Plug>NetrwReturn
				来让其它的映射，而不是 <2-leftmouse> 执行返回
				的任务。

				也可以用 |:Rexplore| 命令完成同样的功能。

				  缺省: =0

  *g:netrw_rm_cmd*		删除远程文件的命令
				 缺省: "ssh USEPORT HOSTNAME rm"

  *g:netrw_rmdir_cmd*		删除远程目录的命令
				 缺省: "ssh USEPORT HOSTNAME rmdir"

  *g:netrw_rmf_cmd*		删除远程软链接的命令
				 缺省: "ssh USEPORT HOSTNAME rm -f"

  *g:netrw_servername*		此变量提供 |netrw-ctrl-r| 所用的服务器名。
				 缺省: "NETRWSERVER"

  *g:netrw_sort_by*		按 "name" (名字)、"time" (时间)、"size" (大小)
				或 "exten" (扩展名) 排序。
				 缺省: "name"

  *g:netrw_sort_direction*	排序方向: "normal" (普通) 或 "reverse" (反
  				转) 缺省: "normal"

  *g:netrw_sort_options*	排序是通过 |:sort| 命令进行的；此变量的值会附
				加到排序命令之后。例如，在 .vimrc 里加上以下内
				容就可以忽略大小写: >
					let g:netrw_sort_options="i"
<				 缺省: ""

  *g:netrw_sort_sequence*	按名字排序时，先按逗号分隔的此模式序列排序。
				注意 模式须考虑表示文件类型的任何附綴。
				 缺省: '[\/]$,*,\.bak$,\.o$,\.h$,
                                        \.info$,\.swp$,\.obj$'

  *g:netrw_special_syntax*	如果为真，特定文件会以特殊语法出现在浏览器
  				中:

					netrwBak     : *.bak
					netrwCompress: *.gz *.bz2 *.Z *.zip
					netrwData    : *.dat
					netrwHdr     : *.h
					netrwLib     : *.a *.so *.lib *.dll
					netrwMakefile: [mM]akefile *.mak
					netrwObj     : *.o *.obj
					netrwTags    : tags ANmenu ANtags
					netrwTilde   : *
					netrwTmp     : tmp* *tmp

				这些语法高亮组缺省被链接到 Folded 或
				DiffChange (见 |hl-Folded| 和
				|hl-DiffChange|)，但你可以在 <.vimrc> 放上这样
				的行 >
					hi link netrwCompress Visual
<				来定义自己的偏好。此外，还可以把设定存放在
				.vim/after/syntax/netrw.vim。

				例如，我自己使用深色背景的色彩方案，在
				.vim/after/syntax/netrw.vim 里有以下设置: >

 hi netrwCompress term=NONE cterm=NONE gui=NONE ctermfg=10 guifg=green  ctermbg=0 guibg=black
 hi netrwData	  term=NONE cterm=NONE gui=NONE ctermfg=9 guifg=blue ctermbg=0 guibg=black
 hi netrwHdr	  term=NONE cterm=NONE,italic gui=NONE guifg=SeaGreen1
 hi netrwLex	  term=NONE cterm=NONE,italic gui=NONE guifg=SeaGreen1
 hi netrwYacc	  term=NONE cterm=NONE,italic gui=NONE guifg=SeaGreen1
 hi netrwLib	  term=NONE cterm=NONE gui=NONE ctermfg=14 guifg=yellow
 hi netrwObj	  term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
 hi netrwTilde	  term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
 hi netrwTmp	  term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
 hi netrwTags	  term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
 hi netrwDoc	  term=NONE cterm=NONE gui=NONE ctermfg=220 ctermbg=27 guifg=yellow2 guibg=Blue3
 hi netrwSymLink  term=NONE cterm=NONE gui=NONE ctermfg=220 ctermbg=27 guifg=grey60
<
  *g:netrw_ssh_browse_reject*	ssh 有时产生你不想要的行、消息、标题和任何你
  				不希望看作是 "目录" 和 "文件" 的内容。
				此模式可用于删除这些内嵌的信息。缺省值为:
					 '^total\s\+\d\+$'

  *g:netrw_ssh_cmd*		可以用此值代替 ssh，用于执行列表，删除文件等
  				这些远程动作的可执行命令。
				 缺省: ssh

 *g:netrw_suppress_gx_mesg*	=1 : 浏览器有时生成通常不需要的消息，混杂在页
				面之中。
				不过，比如使用 links 时，这些消息正是浏览器产
				生的。如果设置此选项为 0，netrw 不会抑制浏览器
				消息。

  *g:netrw_tmpfile_escape*	=' &;'
  				对所有的临时文件使用 escape() 来转义这些字符。

  *g:netrw_timefmt*		指定代替 %c 的 strftime() 的格式字符串
				缺省值 "%c"，根据我的 strftime() 项目的 man 页
				面，是 "建议使用的本地 locale 日期时间的表现方
				式"；不过，不是所有人都满意。一些选择:
				 "%a %d %b %Y %T"、
				 " %a %Y-%m-%d  %I-%M-%S %p"
				 缺省: "%c"

  *g:netrw_use_noswf*		netrw 通常避免给浏览器缓冲区写入交换文件。不
				过，在有些系统上，看来这么做引起讨厌的 ml_get
				错误；如果你看到 ml_get 错误，尝试在 .vimrc 中
				放入
				  let g:netrw_use_noswf= 0
				  缺省: 1

  *g:netrw_winsize*		指定 "o" (见 |netrw-o|)、"v" (见 |netrw-v|)、
				|:Hexplore| 或 |:Vexplore| 建立的新窗口的初始
				大小。g:netrw_winsize 是整数，指定当前 netrw
				缓冲区窗口大小的百分比，来设定新窗口的大小。
				 如果 g:netrw_winsize 小于零，其绝对值用来指定
				新窗口的绝对行数和列数。
				 如果 g:netrw_winsize 为零，使用正常分割方式
				(如 |'equalalways'| 生效，等等)。
				 缺省: "50" (代表 50%)

  *g:netrw_wiw*			=1 指定收缩 netw/Lexplore 窗口使用的最小窗口宽
				度
				(见 |netrw-c-tab|)。

  *g:netrw_xstrlen*		控制 netrw 如何计算包含多字节字符的字符串的长
  				度 (来自 N Weibull、T Mechelynck)
				=0: 使用 Vim 的内建 strlen()
				=1: 代码点的个数 (Latin a + 组合用 circumflex
				    是两个代码点)  (缺省)
				=2: 占空间的代码点个数 (Latin + 组合用
				    circumflex 是一个占空间的代码点；硬制表符
				    是一个；宽和窄的 CJK 都是一个；等等)
				=3: 虚拟长度 (制表符在 1 到 |'tabstop'| 之间，
				    宽 CJK 是 2 而不是 1，阿拉伯 alif 在 lam
				    之前是零，否则为 1，等等)

  *g:NetrwTopLvlMenu*		指定顶层子菜单名；缺省为 "Netrw."。
				如果你想改变，在 .vimrc 里进行。

NETRW 浏 览 和 选 项 不 兼 容 性		*netrw-incompatible* {{{2

netrw 的设计中，对用户选项的处理是先保存它们，设置和 netrw 需要兼容的选项值，
然后恢复原有的值。但 autochdir 选项: >
	:set acd
是有问题的。autochdir 设置当前目录为编辑文件所在的目录；这显然也适用于目录。换
而言之，autochdir 设置当前目录为包含该 "文件" 的目录 (即使该 "文件" 本身也是目
录)。

NETRW 设 置 窗 口				*netrw-settings-window* {{{2

使用 NetrwSettings.vim 插件， >
	:NetrwSettings
会弹出一个窗口来显示用作 netrw 设置的许多变量。你可以修改这里列出的所有值；保
存文件时，设置的值就会被应用。在任何行上按 "?" 就可以得到每个变量功能的帮助。

(另见: |netrw-browser-var| |netrw-protocol| |netrw-variables|)


获 取 文 件						*netrw-obtain* *netrw-O* {{{2

如果没有带标记文件:

    浏览远程目录时，用户可用 O 键获取光标所在的文件 (即在本地机器上保存备份，
    但不编辑)。

如果有带标记文件:

    获取带标记文件 (即传输一个备份到本地机器，但不用来编辑)。

此操作只支持 ftp 和 scp (既然只有它们能用作浏览，这应该不是问题)。这时
状态行的右侧会显示 "Obtaining filename" 这样的消息。传输完成后，状态行复原。

netrw 也可以用本地浏览器 "获得" 文件。netrw 显示的目录不一定和 Vim 的 "当前目
录" 一致，除非用户的 <.vimrc> 里把 |g:netrw_keepdir| 设为 0。在本地浏览器里选
择文件 (光标移动到该文件名上) 然后按 "O" 就可以 "获得" 该文件；也就是把它复制
到 Vim 的当前目录。

相关主题:
 * 察看当前目录可用 |:pwd|
 * 使得当前浏览目录成为当前目录可见 |netrw-c|
 * 要自动使得当前浏览目录总成为当前目录可见 |g:netrw_keepdir|。

					*netrw-newfile* *netrw-createfile*
在 NETRW 当 前 目 录 打 开 新 文 件		*netrw-%* {{{2

要在 netrw 当前目录打开一个新文件，按 "%"。此映射询问用户新的文件名；然后在
netrw 当前目录 (即 b:netrw_curdir) 就会建立以此命名的的空文件。

相关主题:               |netrw-d|


预 览 窗 口				*netrw-p* *netrw-preview* {{{2

用 "p" 键可以使用预览窗口来预览光标所在的文件名。屏幕会被分割以同时显示浏览器
(光标还在那里) 和文件 (见 |:pedit|)。缺省，进行水平分割；如果先设置好
|g:netrw_preview| 就可以进行垂直分割。

一组有意思的 netrw 设置是: >

	let g:netrw_preview   = 1
	let g:netrw_liststyle = 3
	let g:netrw_winsize   = 30

它们会:

	1. 使垂直分割成为缺省的文件预览方式
	2. 使 "树形" 成为缺省的列表方式
	3. 打开垂直预览窗口时，目录列表只用 30% 列；窗口其余部分用于预览窗口。

	相关: 如果你喜欢这个想法，你可能对 :Lexplore (|netrw-:Lexplore|) 或
	      |g:netrw_chgwin| 也会感兴趣

另见: |g:netrw_chgwin| |netrw-P| |'previewwindow'| |CTRL-W_z| |:pclose|


前 次 窗 口					*netrw-P* *netrw-prvwin* {{{2

要使用上次使用 (最近访问) 的窗口编辑光标下的文件或目录 (见 :he |CTRL-W_P|)，按
"P"。如果只有一个窗口，该窗口被水平分割 (缺省)。

如果多于一个窗口，重用上次使用的窗口以显示选择的文件/目录。如果前次窗口相关联
的缓冲区被修改而且该缓冲区只有这个窗口，用户会被询问是否要先保存该缓冲区 (yes
(是)、no (否) 或 cancel (取消))。

相关动作 |netrw-cr| |netrw-o| |netrw-t| |netrw-v|
相关设置变量:
   |g:netrw_alto|    控制上/下分割
   |g:netrw_altv|    控制右/左分割
   |g:netrw_preview| 控制水平/垂直分割
   |g:netrw_winsize| 控制初始大小

另见: |g:netrw_chgwin| |netrw-p|


刷 新 列 表			*netrw-refresh* *netrw-ctrl-l* *netrw-ctrl_l* {{{2

要刷新本地或远程目录列表，按 ctrl-l (<c-l>) 或在列表的 ./ 目录项上按 <cr>。用
":e ." 也可以刷新本地目录。


反 转 排 序 顺 序			*netrw-r* *netrw-reverse* {{{2

用 "r" 键可以在正常和反转两种排序顺序之间切换。

相关主题:     |netrw-s|
相关设置变量: |g:netrw_sort_direction|


给 文 件 或 目 录 换 名		*netrw-move* *netrw-rename* *netrw-R* {{{2

如果没有用 |netrw-mf| 标记过文件:

    换名文件和目录涉及以下操作: 移动光标到要移动 (换名) 的文件/目录，然后
    按 "R"。你会被询问要把文件/目录换什么名字。用 "V" 命令 (可视选择) 可以选择
    行范围，然后按 "R" ；每个文件会依次询问要换成什么名字。

如果用 |netrw-mf| 标记过文件:

    带标记文件会被移动 (换名)；和上面一样，你会被询问文件/目录要移动到的位置。

    如果你对换名询问的回答是 "s/frompattern/topattern/"，则会对标记文件列表的
    每个后续文件通过取得名字，执行替换，把替换结果作为要换的名字来进行换名。
    作为一个例子: >

	mr  [query: reply with *.c]
	R   [query: reply with s/^\(.*\)\.c$/\1.cpp/]
<
    此例会标记所有的 *.c 文件便执行换名为 *.cpp 文件。

    ctrl-X 字符对文件换名有特殊意义: >

	<c-x>      : 单个 ctrl-x 告知 netrw 忽略响应在最后的 '/' 和 ctrl-x 之
		     间的部分。

	<c-x><c-x> : 一对连续 ctrl-x 告知 netrw 忽略字符串在两个 ctrl-x 之前的
		     所有部分。
<
    警 告:~

    注意 移动文件是一个危险的操作；复制更安全。因为远程文件的 "移动" 实际上是
    复制 + 删除 -- 如果复制失败但删除成功，该文件就会丢失。
    后果自负。

g:netrw_rename_cmd 变量实现远程换名。缺省值为:

	ssh HOSTNAME mv

使用瘦风格时，用 V (|linewise-visual|) 可以给若干文件和目录同时换名。


选 择 排 序 风 格			*netrw-s* *netrw-sort* {{{2

可以选择排序风格，使之按 name (名字)、time (时间) 或 size (文件大小) 排序。
"s" 映射允许你在这三个选择之间循环；目录列表会自动更新以反映选择的风格。

相关主题:     |netrw-r| |netrw-S|
相关设置变量: |g:netrw_sort_by| |g:netrw_sort_sequence|


设 置 编 辑 窗 口		*netrw-editwindow* *netrw-C* *netrw-:NetrwC* {{{2

用 "C" 映射选择一个 netrw 窗口用以编辑，此映射使用 :NetrwC [win#] 命令，也可以
设置 |g:netrw_chgwin| 为要选择的窗口号。此后，选择文件以进行编辑 (|netrw-cr|)
时都用该窗口。

	* C : 单独使用，选择当前 netrw 缓冲区所在的窗口用于 |netrw-cr| 的编
	  辑。C 映射只可用于 netrw 缓冲区。

	* [count]C : 计数用作窗口号，用于后继的 |netrw-cr| 的编辑。

	* :NetrwC 设置 |g:netrw_chgwin| 为当前窗口

	* :NetrwC win#  设置 |g:netrw_chgwin| 为指定窗口号

用 >
	let g:netrw_chgwin= -1
可以恢复缺省的编辑行为 (即使用当前窗口进行编辑)。

相关主题:			|netrw-cr| |g:netrw_browse_split|
相关设置变量:			|g:netrw_chgwin|


缩 放 NETRW 或 LEXPLORE 窗 口				*netrw-c-tab* {{{2

<c-tab> 键切换 netrw 或 |:Lexplore| 窗口的宽度，但仅当 |:netrw_usetab| 存在且
非零时才有效 (当然，它还需要终端支持能区别 <c-tab> 和普通的 <tab>)。

  * 如果当前窗口是 netrw 窗口，切换宽度 (在 |g:netrw_wiw| 和它的原始宽度之间)

  * 否则如果当前标签页有 |:Lexplore| 窗口，切换其宽度

  * 否则打开新 |:Lexplore| 窗口

如果 |g:netrw_usetab| 存在且为零，或已有 <c-tab> 映射存在，不重新映射
<c-tab>。也可以使用 <c-tab> 以外的映射: (但 g:netrw_usetab 还必须设置) >

	nmap <unique> (随便什么)	<Plug>NetrwShrink
<
相关主题:			|:Lexplore|
相关设置变量:			|g:netrw_usetab|


用 户 定 义 映 射 					*netrw-usermaps* {{{1

可以自定义用户映射。指定变量，|g:Netrw_UserMaps|，来保存键映射字符串和函数名的
列表的 |List|: >

	[["键映射序列","示例用户映射函数"],...]
<
netrw 为 netrw 缓冲区设置映射时，如果 |g:Netrw_UserMaps| 存在，调用内部函数
netrw#UserMaps(islocal)。此函数遍历 |g:Netrw_UserMaps| 列表的所有项目:

	* 设置映射: >
		nno <buffer> <silent> 键映射序列
		:call s:UserMaps(islocal,"示例用户映射函数")
<	* 如果函数调用返回字符串 "refresh"，刷新
	* 如果返回的字符串不是 ""，执行该字符串 (:exe 返回结果)
	* 如果返回的是列表，对返回列表里的每个字符串执行上述两项

用户函数接受一个参数；就像这样 >

	fun! ExampleUserMapFunc(islocal)
<
其中，如果是本地目录的系统调用，a:islocal 为 1，如果是远程目录的系统调用，为
0。

用 netrw#Expose("varname")           来访问 netrw 内部 (局部于脚本) 变量。
用 netrw#Modify("varname",newvalue)  来改变 netrw 内部变量。
用 netrw#Call("funcname"[,args])     来调用 netrw 内部函数和指定所需参数。

示例: 得到 netrw 标记文件列表的备份: >

	let netrwmarkfilelist= netrw#Expose("netrwmarkfilelist")
<
示例: 修改 netrw 标记文件列表的值: >

	call netrw#Modify("netrwmarkfilelist",[])
<
示例: 通过映射 gu 来清除 netrw 标记文件列表 >
    " ExampleUserMap: {{{2
    fun! ExampleUserMap(islocal)
      call netrw#Modify("netrwmarkfilelist",[])
      call netrw#Modify('netrwmarkfilemtch_{bufnr("%")}',"")
      let retval= ["refresh"]
      return retval
    endfun
    let g:Netrw_UserMaps= [["gu","ExampleUserMap"]]
<
==============================================================================
10. 问题和修正						*netrw-problems* {{{1

	(本节可能会不断增长，视乎我得到的反馈而定)
	(另见 |netrw-debug|)
								*netrw-p1*
	P1. 我用 windows 95，我的 ftp 每次读取之后多了额外的四个空行。

		见 |netrw-fixup|，在 <.vimrc> 文件里加入下行:

			let g:netrw_win95ftp= 1

								*netrw-p2*
	P2. 我用 windows，用 ftp 进行网络浏览不能按时间或大小排序 -或- 远程系
	    统是 Windows 服务器；为什么我不能按时间或大小排序？

		Windows 的 ftp 只有基本的 ls 的支持 (即，不支持排序的选项)。它
		也不支持 -F 以给出类型字符 (ABC/ 代表 "ABC 是目录")。
		netrw 使用 dir 得到的瘦长两种列表。如果你认为自己的 ftp 支持完
		整功能的 ls，在 <.vimrc> 加入下行: >

			let g:netrw_ftp_list_cmd= "ls -lF"
			let g:netrw_ftp_timelist_cmd= "ls -tlF"
			let g:netrw_ftp_sizelist_cmd= "ls -slF"
<
		还有一个办法，如果你在 Windows 上安装了 cygwin，在 <.vimrc> 加
		入下行: >

			let g:netrw_cygwin= 1
<
		如果远端系统使用 Windows，这个问题也会出现。在此情形下，
		g:netrw_ftp_[time|size]list_cmds 诸命令如上所示，但远端系统不
		会因而正确地修改它的列表方式。


								*netrw-p3*
	P3. 我尝试 rcp://user@host/ (或任何不是 ftp 的协议) 但 netrw 使用
	     ssh！我不要这样...

		netrw 有两个方法进行远程目录浏览: ssh 和 ftp。除非你指定 ftp，
		使用的只能是 ssh。
		如果你需要下载文件 (不是目录列表)，netrw 会使用你要求的任何协
		议。

								*netrw-p4*
	P4. 我喜欢缺省使用长格式的列表。

	    在 |.vimrc| 里放入: >
			let g:netrw_liststyle=1
<
		|netrw-browser-var| 说明你可以改变的更多设置。

								*netrw-p5*
	P5. 本地浏览时，时间显示不正常

		你系统的 strftime() 是否接受 "%c" 以产生类似于下面的格式:
		"Sun Apr 27 11:49:23 1997"？如果不是，执行 "man strftime" 寻找
		什么选项可以完成类似的功能。然后在 |.vimrc| 里放入: >
			let g:netrw_timefmt= "%X"  (其中 X 是找到的选项)
<
								*netrw-p6*
	P6. 我想让当前目录和我的浏览同步。如何进行？

	    在 |.vimrc| 里放入:
>
		let g:netrw_keepdir= 0
<
								*netrw-p7*
        P7. 我在文件名中使用中文 (或其它非 ascii) 字符，netrw (Explore、
            Sexplore、Hexplore 等) 却不能显示这些文件名！

		(取自 Wu Yongwei 在 Vim 邮件列表上的回答)
                我现在明白你的问题了。你的代码页不是 936，对么？Vim 看来只能打
                开在当前代码页中合法的文件名，这和许多其它不使用 Unicode 版本
                的 Windows API 的应用程序一样。这是操作系统上的问题。如果系统
                locale 使用 UTF-8 就不应该有这个问题，例如现代的 Linux 的各种
                发布就是如此。

		(...又多一个理由鼓励大家使用 utf-8！)

								*netrw-p8*
	P8. 我看到错误 "你的系统无法执行 ssh" -- 我该怎么办？

		(Dudley Fox) 我知道的多数人在 windows 上 用 putty 的 ssh。这是
		一个免费的 ssh/telnet 应用。更多的情况可见:

		http://www.chiark.greenend.org.uk/~sgtatham/putty/ 还有:

		(Marlin Unruh) 我也用这个程序。它是一个单独的可执行文件，所以
		可以复制到 Windows\System32 文件夹并建立一个快捷方式。

		(Dudley Fox) 你也可以考虑 plink，听起来它和你要找的很接近。
		plink 是 putty 程序包中的一个应用。

           http://the.earth.li/~sgtatham/putty/0.58/htmldoc/Chapter7.html#plink

	   	(Vissale Neang) 你可以试试 OpenSSH 的 windows 版本，可以在这里
		得到:

		http://sshwindows.sourceforge.net/

		它并不需要 Cygwin 包。

		(Antoine Mechelynck) 对于单独需要在直接的 Windows 环境工作的
		Unix 风格的程序，我推荐从 sourceforge 的 GnuWin32 项目获取，如
		果有的话:

		    http://gnuwin32.sourceforge.net/

		和 Cygwin 不同，后者建立一个在 Windows 之上的 Unix 风格的模拟
		机，而 GnuWin32 使用 Windows 系统调用来重写 Unix 工具，它的程
		序也能在 cmd.exe "Dos 窗口" 中正常运行。

		(dave) 下载 WinSCP并用它连到服务器上。Preferences > Editors 选
		项里设置 gvim 为你的编辑器:

			- 点击 "Add..."
			- 设置外部编辑器 (如果需要，调整实际的路径并加上引号和
			  最后的 !.!):
			    "c:\Program Files\Vim\vim70\gvim.exe" !.!
			- 确认下面框中的文件类型为 {asterisk}.{asterisk} (即所
			  有文件)，或任何你期望的类型 (cec: 把 {asterisk} 换成
			  * ；我这么写是因为不然的话，helptags 系统认为它是一
			  个标签)
			- 确认它在列表框的顶端 (如若不然，点击它再点击 "Up")
		如果使用 Norton Commander 风格，你只要按 <F4> 来使用本地的
		gvim 来编辑文件。

		(Vit Gottwald) 如何生成公钥/私钥并把公钥存在服务器上: >
  http://www.chiark.greenend.org.uk/~sgtatham/putty/0.60/htmldoc/Chapter8.html#pubkey-gettingready
			(8.3 Getting ready for public key authentication)
<
		'pscp' 如何使用私钥: >

  http://www.chiark.greenend.org.uk/~sgtatham/putty/0.60/htmldoc/Chapter5.html
			(5.2.4 Using public key authentication with PSCP)
<
		(Ben Schmidt) 我发现 cwRsync 所带的 ssh 太好了，现在我在自己用
		的大多数 Windows 系统上都安装了 cwRsync 或 cwRsyncServer。对只
		需要在 Windows 上 ssh 的人来说，我推测同一作者提供的 COPSSH 可
		能更好，而且它还带有 cwRsync 没有的 sftp 等等工具。虽然它可能
		... (译者注: 下文缺)

		(cec) 要正确地使用的以上的建议，你需要在 .vimrc 中修改以下用户
		可设的变量:

		|g:netrw_ssh_cmd| |g:netrw_list_cmd|  |g:netrw_mkdir_cmd|
		|g:netrw_rm_cmd|  |g:netrw_rmdir_cmd| |g:netrw_rmf_cmd|

		第一个 (|g:netrw_ssh_cmd|) 是最重要的；多数其它的变量在缺省情
		况下使用和 g:netrw_ssh_cmd 相同的值。

						*netrw-p9* *netrw-ml_get*
	P9. 我在浏览，切换目录，哦！出现了 ml_get 错误，我不得不杀掉 vim。有什
	    么解决方法？

		netrw 通常避免给临时目录缓冲区写入交换文件。不过，在有些系统
		上，看来这么做引起 ml_get 错误；尝试在 <.vimrc> 中设置
		|g:netrw_use_noswf| 为零: >
			let g:netrw_use_noswf= 0
<
								*netrw-p10*
	P10. "[something] is a directory" 和
	     "Press ENTER or type command to continue" 这些提示烦死我了...

		"[something] is a directory" 提示是 Vim 发出的，不是 netrw，看
		来没有办法绕过它。再加上缺省的 cmdHeight 为 1，此消息导致了
		"Press ENTER..." 提示。所以:  阅读 |hit-enter|；
		我也建议你在 <.vimrc> 文件里设置 |'cmdheight'| 为 2 (或更高)。

								*netrw-p11*
	P11. 我想要有两个窗口；一个瘦的在左边，我的编辑窗口在右边。应该怎么
	     做？

	     你可能想在一个边窗运行 netrw。如果这样，":[N]Lexplore" 可能就是你
	     所想要的。可选的 "[N]" 可以让你指定想要的 |:Lexplore| 开始的列数
	     (关于此参数如何工作，见 |g:netrw_winsize|)。

	     之前的方法:

		* 在 <.vimrc> 放入:
			let g:netrw_altv = 1
		* 编辑当前目录:  :e .
		* 选择某个文件，按 v
		* 按照自己需要调整窗口大小 (见 |CTRL-W_<| 和 |CTRL-W_>|)。如果
		  使用 gvim，可用鼠标拖动分割栏。
		* 想编辑新文件时，用 ctrl-w h 回到 netrw 浏览器，选择文件，然
		  后按 P (见 |CTRL-W_h| 和 |netrw-P|)。如果使用 gvim，在浏览器
		  窗口按 <leftmouse> 然后用 <middlemouse> 来选择文件。


								*netrw-p12*
	P12. 我的目录排序不对，或者有不想要的字符出现在列出的文件名里，或者宽
	     列表中名字的对齐有问题...

	     这可能是编码的问题，我自己通常使用 utf-8，但其实只用 ascii (也就
	     是 32-126 的字符)。多字节编码每个字符使用两个 (或更多) 字节。你可
	     能需要改变 |g:netrw_sepchr| 和/或 |g:netrw_xstrlen|。

								*netrw-p13*
	P13. 我是 Windows + putty + ssh 的用户，每次我试图浏览时，目录没有结尾
	     的 "/"，所以 netrw 当成文件传输而不试图当成子目录浏览。怎么办？

	     (mikeyao) 如果你在 Windows 上用 ssh 和 putty 访问 vim，尝试
	     pscp/psftp 加上 plink 的组合。pscp/psftp 用于连接，而 plink 用于
	     执行服务器端的命令。例如: 列出文件和 'ls' 目录。

	     以下是我使用的设置:
>
	    " 列出文件。这是关键设置。如果没有设置好，只能得到空白缓冲区。
	    let g:netrw_list_cmd = "plink HOSTNAME ls -Fa"
	    " 如果没有把 putty 目录加到系统目录中，必须指定 scp/sftp 命令的位
	    " 置。例如:
	    "let g:netrw_sftp_cmd = "d:\\dev\\putty\\PSFTP.exe"
	    "let g:netrw_scp_cmd = "d:\\dev\\putty\\PSCP.exe"
<
								*netrw-p14*
	P14. 我想加快 Nwrite 和 scp/ssh 风格连接的写操作。怎么做？(Thomer M.
	     Gil)

	     ssh 的 ControlMaster 和 ControlPath (见 ssh_config man 帮助页) 可
	     用来使多个 ssh 连接共享同一个网络连接。这可减少每个文件写入的加密
	     握手协议，有时这可提升速度一个数量级以上。
	     (见  http://thomer.com/howtos/netrw_ssh.html)
	     (此段文字得到许可)

	     在你的 ~/.ssh/config 中加入: >

		 # 可把 "*" 改为你关心的终端名
		 Host *
		   ControlMaster auto
		   ControlPath /tmp/%r@%h:%p

<	     然后建立一个到此终端的 ssh 连接，并保持之: >

		 ssh -N host.domain.com

<	     现在用 Vim 的 Netrw 远程打开文件，享受极速吧: >

		vim scp://host.domain.com//home/user/.bashrc
<
								*netrw-p15*
	P15. 如何用双击而不是 netrw 通常的单击来打开文件或目录？(Ben Fritz)

	     首先，关闭 netrw 的映射 >
		    let g:netrw_mousemaps= 0
<	     然后在 $HOME/.vim/after/ftplugin/netrw.vim 中创建只适用 netrw 缓
	     冲区的映射: >
		    nmap <buffer> <2-leftmouse> <CR>
<	     注意 设置 g:netrw_mousemaps 为零关闭所有 netrw 的鼠标映射，不只是
	     <leftmouse> 的。
	     (见 |g:netrw_mousemaps|)

								*netrw-p16*
	P16. Windows 里编辑远程文件 (如 :e ftp://hostname/path/file) 时，得到
	     |E303| 信息，抱怨不能打开交换文件。
	     to open a swap file.

	     (romainl) 看来你从一个受保护的目录下启动 Vim。从你的 $HOME 或其它
	     可写的目录下启动 netrw。

								*netrw-p17*
	P17. Netrw 自己关闭了缓冲区。
	     如何重现此问题？
		1. :Explore，访问目录，打开文件
		2. :Explore，打开其它文件
		3. 第一步打开的缓冲区被关闭。
	    期待结果是什么？实际看到了什么？
		我期待两个缓冲区同时存在，但实际只看见了最后那个。

	   (Lance) 问题出在 .vimrc 里的 "set autochdir"。
	   (drchip) 置位 |'acd'| 时我能重现此问题。不过，缓冲区不是真的关闭；
	            ":ls!" 还能显示它们 (但 ":ls" 不会)。

								*netrw-P18*
	P18. 如何本地编辑只能通过 ssh 访问的其它服务器上的文件？
	     见 http://stackoverflow.com/questions/12469645/
	     "Using Vim to Remotely Edit A File on ServerB Only
	      Accessible From ServerA"

								*netrw-P19*
	P19. 目录列表中如何得到行号？
		通过 |g:netrw_bufsettings| 可以控制 netrw 缓冲区设置；试试在
		.vimrc 里放上 >
		  let g:netrw_bufsettings="noma nomod nu nobl nowrap ro nornu"
<		如果喜欢相对行号，试试 >
		  let g:netrw_bufsettings="noma nomod nonu nobl nowrap ro rnu"
<
								*netrw-P20*
	P20. 如何使 gvim 启动时显示目录列表？
		在 .vimrc 里放上以下代码片断: >
		    augroup VimStartup
		      au!
		      au VimEnter * if expand("%") == "" && argc() == 0 &&
		      \ (v:servername =~ 'GVIM\d*' || v:servername == "")
		      \ | e . | endif
		    augroup END
<		如果你特别想要，可以用 Lexplore 来代替 "e"。
		此代码片断假定你打开客户-服务器功能 (即 "huge" vim 版本)。

								*netrw-P21*
	P21. 我建立的目录 (或文件) 使用了带重音的字符，但 netrw 不让我进入该目
		录/读取文件:

		可能是外壳或操作系统使用了和 vim (netrw) 不同的编码。将来 vim
		支持 "systemencoding" 的补丁也许可以解决这个问题；现在，只要让
		netrw 使用合适的编码就可以了。例如: >

			au FileType netrw set enc=latin1
<
								*netrw-P22*
	P22. 试图复制或移动文件时出错:

		**error** (netrw) tried using g:netrw_localcopycmd<cp>; it doesn't work!

	     怎么回事？

	     Netrw 使用若干系统级的命令来完成任务 (见

		 |g:netrw_localcopycmd|, |g:netrw_localmovecmd|,
		 |g:netrw_localrmdir|, |g:netrw_mkdir_cmd|)。

	    可能需要在 .vimrc 里适当地调整部分这些命令。另一个困难源于这些命令
	    使用了 vim 的本地目录，但它和 netrw 显示的浏览目录可能有所不同 (见
	    |g:netrw_keepdir|)。


==============================================================================
11. 调试 netrw 自身					*netrw-debug* {{{1

第一步: 确定你遇到的问题是否所以通过获取最新的 (通常是开发版本) netrw 得到解
决，最新版本在:

	http://www.drchip.org/astronaut/vim/index.html#NETRW

<netrw.vim> 脚本通常安装的系统位置是:
>
 	/usr/local/share/vim/vim7x/plugin/netrwPlugin.vim
	/usr/local/share/vim/vim7x/autoload/netrw.vim
		(见 :echo &rtp 的输出)
<
在启动时自动被加载 (假设 :set nocp)。如果你案头了新版本的 netrw，它位于 >

	$HOME/.vim/plugin/netrwPlugin.vim
	$HOME/.vim/autoload/netrw.vim
<
第二步: 假定你安装了最新版本的 netrw，确定你的问题是否真的由 netrw 引起。新建
一个叫 netrw.vimrc 的文件，包含以下内容: >

	set nocp
	so $HOME/.vim/plugin/netrwPlugin.vim
<
然后这样执行 netrw: >

	vim -u netrw.vimrc --noplugins -i NONE [some path here]
<
执行任何你想要的 netrw 命令，然后检查问题是否存在。此过程回避了由于个人 .vimrc
设置，.viminfo 文件和其它插件引起的问题。如果问题不再出现，你需要自己找到什么
.vimrc 设置引起了和 netrw 或其它相关插件的冲突。

第三步: 如果问题仍然存在，这样获取 netrw 的调试跟踪:

	1. 先从这里取得 <Decho.vim> 脚本:

	     http://www.drchip.org/astronaut/vim/index.html#DECHO
	   或者
	     http://vim.sourceforge.net/scripts/script.php?script_id=120

	  Decho.vim 以 "vimball" 形式出现；见 |vimball-intro|。

	2. 修改 <netrw.vim> 文件如下: >

		vim netrw.vim
		:DechoOn
		:wq
<
	   要恢复到正常的非调试行为，修改 <netrw.vim> 如下: >

		vim netrw.vim
		:DechoOff
		:wq
<
	   此命令由 <Decho.vim> 提供，它会注释掉所有 Decho 调试语句 (Dfunc()、
	   Dret()、Decho()、Dredir())。

	3. 然后启动 vim 进行文件传输或者进行浏览以重现错误。一系列消息应该在一
	   个单独的标签页或服务器 vim 窗口出现，提示 <netrw.vim> 进行网络文件
	   读写的一系列步骤。

           要保存文件，用 >
		:tabnext
		:set bt=
		:w! DBG

<	   进一步，最好你能键入 >
		:Dsep <command>
<	   其中的 <command> 是你将要键入的命令，这样就容易把调试跟踪的哪部分和
	   哪条命令对应赶来。

	   请把该信息发送到 <netrw.vim> 的维护者，还请包括使用的操作系统和 vim
	   版本 (见 |:version|) >
		NdrOchip at ScampbellPfamily.AbizM - NOSPAM
<
==============================================================================
12. 历史 (英文)						*netrw-history* {{{1

	v156:	Feb 18, 2016	* Changed =~ to =~# where appropriate
		Feb 23, 2016	* s:ComposePath(base,subdir) now uses
				  fnameescape() on the base portion
		Mar 01, 2016	* (gt_macki) reported where :Explore would
				  make file unlisted. Fixed (tst943)
		Apr 04, 2016	* (reported by John Little) netrw normally
				  suppresses browser messages, but sometimes
				  those "messages" are what is wanted.
				  See |g:netrw_suppress_gx_mesg|
		Apr 06, 2016	* (reported by Carlos Pita) deleting a remote
				  file was giving an error message.  Fixed.
		Apr 08, 2016	* (Charles Cooper) had a problem with an
				  undefined b:netrw_curdir.  He also provided
				  a fix.
		Apr 20, 2016	* Changed s:NetrwGetBuffer(); now uses
				  dictionaries.  Also fixed the "No Name"
				  buffer problem.
	v155:	Oct 29, 2015	* (Timur Fayzrakhmanov) reported that netrw's
				  mapping of ctrl-l was not allowing refresh of
				  other windows when it was done in a netrw
				  window.
		Nov 05, 2015	* Improved s:TreeSqueezeDir() to use search()
				  instead of a loop
				* NetrwBrowse() will return line to
				  w:netrw_bannercnt if cursor ended up in
				  banner
		Nov 16, 2015	* Added a <Plug>NetrwTreeSqueeze (|netrw-s-cr|)
		Nov 17, 2015	* Commented out imaps -- perhaps someone can
				  tell me how they're useful and should be
				  retained?
		Nov 20, 2015	* Added |netrw-ma| and |netrw-mA| support
		Nov 20, 2015	* gx (|netrw-gx|) on an url downloaded the
				  file in addition to simply bringing up the
				  url in a browser.  Fixed.
		Nov 23, 2015	* Added |g:netrw_sizestyle| support
		Nov 27, 2015	* Inserted a lot of <c-u>s into various netrw
				  maps.
		Jan 05, 2016	* |netrw-qL| implemented to mark files based
				  upon |location-list|s; similar to |netrw-qF|.
		Jan 19, 2016	* using - call delete(directoryname,"d") -
				  instead of using g:netrw_localrmdir if
				  v7.4 + patch#1107 is available
		Jan 28, 2016	* changed to using |winsaveview()| and
				  |winrestview()|
		Jan 28, 2016	* s:NetrwTreePath() now does a save and
				  restore of view
		Feb 08, 2016	* Fixed a tree-listing problem with remote
				  directories
	v154:	Feb 26, 2015	* (Yuri Kanivetsky) reported a situation where
				  a file was not treated properly as a file
				  due to g:netrw_keepdir == 1
		Mar 25, 2015	* (requested by Ben Friz) one may now sort by
				  extension
		Mar 28, 2015	* (requested by Matt Brooks) netrw has a lot
				  of buffer-local mappings; however, some
				  plugins (such as vim-surround) set up
				  conflicting mappings that cause vim to wait.
				  The "<nowait>" modifier has been included
				  with most of netrw's mappings to avoid that
				  delay.
		Jun 26, 2015	* |netrw-gn| mapping implemted
				* :Ntree NotADir resulted in having
				  the tree listing expand in the error messages
				  window.  Fixed.
		Jun 29, 2015	* Attempting to delete a file remotely caused
				  an error with "keepsol" mentioned; fixed.
		Jul 08, 2015	* Several changes to keep the |:jumps| table
				  correct when working with
				  |g:netrw_fastbrowse| set to 2
				* wide listing with accented characters fixed
				  (using %-S instead of %-s with a |printf()|
		Jul 13, 2015	* (Daniel Hahler) CheckIfKde() could be true
				  but kfmclient not installed.  Changed order
				  in netrw#BrowseX(): checks if kde and
				  kfmclient, then will use xdg-open on a unix
				  system (if xdg-open is executable)
		Aug 11, 2015	* (McDonnell) tree listing mode wouldn't
				  select a file in a open subdirectory.
				* (McDonnell) when multiple subdirectories
				  were concurrently open in tree listing
				  mode, a ctrl-L wouldn't refresh properly.
				* The netrw:target menu showed duplicate
				  entries
		Oct 13, 2015	* (mattn) provided an exception to handle
				  windows with shellslash set but no shell
		Oct 23, 2015	* if g:netrw_usetab and <c-tab> now used
				  to control whether NetrwShrink is used
				  (see |netrw-c-tab|)
	v153:	May 13, 2014	* added another |g:netrw_ffkeep| usage {{{2
		May 14, 2014	* changed s:PerformListing() so that it
				  always sets ft=netrw for netrw buffers
				  (ie. even when syntax highlighting is
				  off, not available, etc)
		May 16, 2014	* introduced the |netrw-ctrl-r| functionality
		May 17, 2014	* introduced the |netrw-:NetrwMB| functionality
				* mb and mB (|netrw-mb|, |netrw-mB|) will
				  add/remove marked files from bookmark list
		May 20, 2014	* (Enno Nagel) reported that :Lex <dirname>
				  wasn't working.  Fixed.
		May 26, 2014	* restored test to prevent leftmouse window
				  resizing from causing refresh.
				  (see s:NetrwLeftmouse())
				* fixed problem where a refresh caused cursor
				  to go just under the banner instead of
				  staying put
		May 28, 2014	* (László Bimba) provided a patch for opening
				  the |:Lexplore| window 100% high, optionally
				  on the right, and will work with remote
				  files.
		May 29, 2014	* implemented :NetrwC  (see |netrw-:NetrwC|)
		Jun 01, 2014	* Removed some "silent"s from commands used
				  to implemented scp://... and pscp://...
				  directory listing.  Permits request for
				  password to appear.
		Jun 05, 2014	* (Enno Nagel) reported that user maps "/"
				  caused problems with "b" and "w", which
				  are mapped (for wide listings only) to
				  skip over files rather than just words.
		Jun 10, 2014	* |g:netrw_gx| introduced to allow users to
				  override default "<cfile>" with the gx
				  (|netrw-gx|) map
		Jun 11, 2014	* gx (|netrw-gx|), with |'autowrite'| set,
				  will write modified files.  s:NetrwBrowseX()
				  will now save, turn off, and restore the
				  |'autowrite'| setting.
		Jun 13, 2014	* added visual map for gx use
		Jun 15, 2014	* (Enno Nagel) reported that with having hls
				  set and wide listing style in use, that the
				  b and w maps caused unwanted highlighting.
		Jul 05, 2014	* |netrw-mv| and |netrw-mX| commands included
		Jul 09, 2014	* |g:netrw_keepj| included, allowing optional
				  keepj
		Jul 09, 2014	* fixing bugs due to previous update
		Jul 21, 2014	* (Bruno Sutic) provided an updated
				  netrw_gitignore.vim
		Jul 30, 2014	* (Yavuz Yetim) reported that editing two
				  remote files of the same name caused the
				  second instance to have a "temporary"
				  name.  Fixed: now they use the same buffer.
		Sep 18, 2014	* (Yasuhiro Matsumoto) provided a patch which
				  allows scp and windows local paths to work.
		Oct 07, 2014	* gx (see |netrw-gx|) when atop a directory,
				  will now do |gf| instead
		Nov 06, 2014	* For cygwin: cygstart will be available for
				  netrw#BrowseX() to use if its executable.
		Nov 07, 2014	* Began support for file://... urls.  Will use
				  |g:netrw_file_cmd| (typically elinks or links)
		Dec 02, 2014	* began work on having mc (|netrw-mc|) copy
				  directories.  Works for linux machines,
				  cygwin+vim, but not for windows+gvim.
		Dec 02, 2014	* in tree mode, netrw was not opening
				  directories via symbolic links.
		Dec 02, 2014	* added resolved link information to
				  thin and tree modes
		Dec 30, 2014	* (issue#231) |:ls| was not showing
				  remote-file buffers reliably.  Fixed.
	v152:	Apr 08, 2014	* uses the |'noswapfile'| option (requires {{{2
				  vim 7.4 with patch 213)
				* (Enno Nagel) turn |'rnu'| off in netrw
				  buffers.
				* (Quinn Strahl) suggested that netrw
				  allow regular window splitting to occur,
				  thereby allowing |'equalalways'| to take
				  effect.
				* (qingtian zhao) normally, netrw will
				  save and restore the |'fileformat'|;
				  however, sometimes that isn't wanted
		Apr 14, 2014	* whenever netrw marks a buffer as ro,
				  it will also mark it as nomod.
		Apr 16, 2014	* sftp protocol now supported by
				  netrw#Obtain(); this means that one
				  may use "mc" to copy a remote file
				  to a local file using sftp, and that
				  the |netrw-O| command can obtain remote
				  files via sftp.
				* added [count]C support (see |netrw-C|)
		Apr 18, 2014	* when |g:netrw_chgwin| is one more than
				  the last window, then vertically split
				  the last window and use it as the
				  chgwin window.
		May 09, 2014	* SavePosn was "saving filename under cursor"
				  from a non-netrw window when using :Rex.
	v151:	Jan 22, 2014	* extended :Rexplore to return to buffer {{{2
				  prior to Explore or editing a directory
				* (Ken Takata) netrw gave error when
				  clipboard was disabled.  Sol'n: Placed
				  several if has("clipboard") tests in.
				* Fixed ftp://X@Y@Z// problem; X@Y now
				  part of user id, and only Z is part of
				  hostname.
				* (A Loumiotis) reported that completion
				  using a directory name containing spaces
				  did not work.  Fixed with a retry in
				  netrw#Explore() which removes the
				  backslashes vim inserted.
		Feb 26, 2014	* :Rexplore now records the current file
				   using w:netrw_rexfile when returning via
				  |:Rexplore|
		Mar 08, 2014	* (David Kotchan) provided some patches
				  allowing netrw to work properly with
				  windows shares.
				* Multiple one-liner help messages available
				  by pressing <cr> while atop the "Quick
				  Help" line
				* worked on ShellCmdPost, FocusGained event
				  handling.
				* |:Lexplore| path: will be used to update
				  a left-side netrw browsing directory.
		Mar 12, 2014	* |netrw-s-cr|: use <s-cr>  to close
				  tree directory implemented
		Mar 13, 2014	* (Tony Mechylynck) reported that using
				  the browser with ftp on a directory,
				  and selecting a gzipped txt file, that
				  an E19 occurred (which was issued by
				  gzip.vim).  Fixed.
		Mar 14, 2014	* Implemented :MF and :MT (see |netrw-:MF|
				  and |netrw-:MT|, respectively)
		Mar 17, 2014	* |:Ntree| [dir] wasn't working properly; fixed
		Mar 18, 2014	* Changed all uses of set to setl
		Mar 18, 2014	* Commented the netrw_btkeep line in
				  s:NetrwOptionSave(); the effect is that
				  netrw buffers will remain as |'bt'|=nofile.
				  This should prevent swapfiles being created
				  for netrw buffers.
		Mar 20, 2014	* Changed all uses of lcd to use s:NetrwLcd()
				  instead.  Consistent error handling results
				  and it also handles Window's shares
				* Fixed |netrw-d| command when applied with ftp
				* https: support included for netrw#NetRead()
	v150:	Jul 12, 2013	* removed a "keepalt" to allow ":e #" to {{{2
				  return to the netrw directory listing
		Jul 13, 2013	* (Jonas Diemer) suggested changing
				  a <cWORD> to <cfile>.
		Jul 21, 2013	* (Yuri Kanivetsky) reported that netrw's
				  use of mkdir did not produce directories
				  following the user's umask.
		Aug 27, 2013	* introduced |g:netrw_altfile| option
		Sep 05, 2013	* s:Strlen() now uses |strdisplaywidth()|
				  when available, by default
		Sep 12, 2013	* (Selyano Baldo) reported that netrw wasn't
				  opening some directories properly from the
				  command line.
		Nov 09, 2013	* |:Lexplore| introduced
				* (Ondrej Platek) reported an issue with
				  netrw's trees (P15).  Fixed.
				* (Jorge Solis) reported that "t" in
				  tree mode caused netrw to forget its
				  line position.
		Dec 05, 2013	* Added <s-leftmouse> file marking
				  (see |netrw-mf|)
		Dec 05, 2013	* (Yasuhiro Matsumoto) Explore should use
				  strlen() instead s:Strlen() when handling
				  multibyte chars with strpart()
				  (ie. strpart() is byte oriented, not
				  display-width oriented).
		Dec 09, 2013	* (Ken Takata) Provided a patch; File sizes
				  and a portion of timestamps were wrongly
				  highlighted with the directory color when
				  setting `:let g:netrw_liststyle=1` on Windows.
				* (Paul Domaskis) noted that sometimes
				  cursorline was activating in non-netrw
				  windows.  All but one setting of cursorline
				  was done via setl; there was one that was
				  overlooked.  Fixed.
		Dec 24, 2013	* (esquifit) asked that netrw allow the
				  /cygdrive prefix be a user-alterable
				  parameter.
		Jan 02, 2014	* Fixed a problem with netrw-based ballon
				  evaluation (ie. netrw#NetrwBaloonHelp()
				  not having been loaded error messages)
		Jan 03, 2014	* Fixed a problem with tree listings
				* New command installed: |:Ntree|
		Jan 06, 2014	* (Ivan Brennan) reported a problem with
				  |netrw-P|.  Fixed.
		Jan 06, 2014	* Fixed a problem with |netrw-P| when the
				  modified file was to be abandoned.
		Jan 15, 2014	* (Matteo Cavalleri) reported that when the
				  banner is suppressed and tree listing is
				  used, a blank line was left at the top of
				  the display.  Fixed.
		Jan 20, 2014	* (Gideon Go) reported that, in tree listing
				  style, with a previous window open, that
				  the wrong directory was being used to open
				  a file.  Fixed. (P21)
	v149:	Apr 18, 2013	* in wide listing format, now have maps for {{{2
				  w and b to move to next/previous file
		Apr 26, 2013	* one may now copy files in the same
				  directory; netrw will issue requests for
				  what names the files should be copied under
		Apr 29, 2013	* Trying Benzinger's problem again.  Seems
				  that commenting out the BufEnter and
				  installing VimEnter (only) works.  Weird
				  problem!  (tree listing, vim -O Dir1 Dir2)
		May 01, 2013	* :Explore ftp://... wasn't working.  Fixed.
		May 02, 2013	* introduced |g:netrw_bannerbackslash| as
				  requested by Paul Domaskis.
		Jul 03, 2013	* Explore now avoids splitting when a buffer
				  will be hidden.
	v148:	Apr 16, 2013	* changed Netrw's Style menu to allow direct {{{2
				  choice of listing style, hiding style, and
				  sorting style

==============================================================================
13. Todo (英文)						*netrw-todo* {{{1

07/29/09 : banner	:|g:netrw_banner| can be used to suppress the
	   suppression	  banner.  This feature is new and experimental,
			  so its in the process of being debugged.
09/04/09 : "gp"		: See if it can be made to work for remote systems.
			: See if it can be made to work with marked files.

==============================================================================
14. 鸣谢						*netrw-credits* {{{1

	Vim editor	by Bram Moolenaar (谢了，Bram!)
	dav		提供支持: C Campbell
	fetch		提供支持: Bram Moolenaar 和 C Campbell
	ftp		提供支持: C Campbell <NdrOchip@ScampbellPfamily.AbizM>
	http		提供支持: Bram Moolenaar <bram@moolenaar.net>
	rcp
	rsync		提供支持: C Campbell (Erik Warendorph 提供建议)
	scp		提供支持: raf <raf@comdyn.com.au>
	sftp		提供支持: C Campbell

	inputsecret()、BufReadCmd、BufWriteCmd 由 C Campbell 提供

	Jérôme Augé		-- 也使用新的缓冲区方法操作 ftp+.netrc
	Bram Moolenaar		-- 显然写了 vim 本身，还有 :e 和 v:cmdarg 的使
                                   用， fetch 等
	Yasuhiro Matsumoto	-- 指出 undo+0r 的问题和解决方法
	Erik Warendorph		-- 提供若干建议 (g:netrw_..._cmd 变量，rsync
                                   等)
	Doug Claar		-- 提供能成功通过 ftp 操作的测试的修改

==============================================================================
模式行: {{{1
 vim:tw=78:ts=8:ft=help:norl:fdm=marker
