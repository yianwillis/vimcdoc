<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<![endif]-->
<title>VIM 中文帮助: 删除和替换文本</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css" />
<link rel="canonical" href="https://yianwillis.github.io/vimcdoc/doc/change.html" />
<script type="text/javascript" src="vimcdoc.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
<nav id=banner>
<form action=tags.html target="tag_iframe">
  <input type="text" name="tag" id="tag" placeholder="标签搜索">
</form>
<iframe name="tag_iframe" src=""></iframe>
<a href="help.html">帮助总览</a> &middot;
<hr/>
<a href="quickref.html">快速参考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="eval.html#functions">函数列表</a> &middot;
<a href="quickref.html#option-list">选项列表</a> &middot;
<hr/>
<a href="usr_toc.html">用户手册</a> &middot;
<a href="help.html#reference_toc">参考手册</a> &middot;
</nav>

<header>
<h2>change</h2>
</header>
<article id=outer>
<section class=inner>
<b class="vimtag"> <a name="change.txt">change.txt</a> </b>    适用于 Vim 9.1 版本。   最近更新: 2025年9月


                  <code class="vim">VIM 参考手册    by Bram Moolenaar</code>
                                <code class="vim">译者</code>: Willis


本文档描述删除和修改文本的命令。在本文中，修改文本意味着用单个命令删除部分文本
并将其替换成其他文本。所有本文描述的命令都可以被撤销。其中非命令行 (Ex) 的命令
可以用 "." 命令重复。

1. 删除文本                      <a href="change.html#deleting">deleting</a> 
2. 删除并插入                    <a href="change.html#delete-insert">delete-insert</a> 
3. 简单修改                      <a href="change.html#simple-change">simple-change</a>          <b class="vimtag"> <a name="changing">changing</a> </b>
4. 复杂修改                      <a href="change.html#complex-change">complex-change</a> 
   4.1 过滤命令                     <a href="change.html#filter">filter</a> 
   4.2 替代                         <a href="change.html#:substitute">:substitute</a> 
   4.3 搜索与替代                   <a href="change.html#search-replace">search-replace</a> 
   4.4 调整制表                     <a href="change.html#change-tabs">change-tabs</a> 
5. 复制并移动文本                <a href="change.html#copy-move">copy-move</a> 
6. 文本排版                      <a href="change.html#formatting">formatting</a> 
7. 文本排序                      <a href="change.html#sorting">sorting</a> 
8. 文本去重                      <a href="change.html#deduplicating">deduplicating</a> 

关于插入文本部分，参阅  <a href="insert.html#insert.txt">insert.txt</a> 。

</section><hr class="doubleline" /><section class=inner>
<h4>1. 删除文本                                             <b class="vimtag"> <a name="deleting">deleting</a> </b> <b class="vimtag"> <a name="E470">E470</a> </b></h4>
["x]<code class="special">&lt;Del&gt;</code>       或                                      <b class="vimtag"> <a name="%3CDel%3E">&lt;Del&gt;</a> </b> <b class="vimtag"> <a name="x">x</a> </b> <b class="vimtag"> <a name="dl">dl</a> </b>
["x]x                   删除 <code class="special">[count]</code> 个光标之下和之后的字符 [到寄存器 x 里]
                        (非  <a href="motion.html#linewise">linewise</a>  行动作)。和 "dl" 相同。
                        <code class="special">&lt;Del&gt;</code> 键不使用 <code class="special">[count]</code> 计数。相反，如果有计数，它删
                        除该计数的最后一位。
                        如果 <code class="special">&lt;Del&gt;</code> 键的操作与你预期的不符，参见  <a href="options.html#:fixdel">:fixdel</a> 。关
                        于如何删除换行符 (连接行)，参见 <a href="options.html#'whichwrap'">'whichwrap'</a>。

                                                        <b class="vimtag"> <a name="X">X</a> </b> <b class="vimtag"> <a name="dh">dh</a> </b>
["x]X                   删除 <code class="special">[count]</code> 个光标之前的字符 [到寄存器 x 里] (非
                         <a href="motion.html#linewise">linewise</a>  行动作)。和 "dh" 相同。另见 <a href="options.html#'whichwrap'">'whichwrap'</a>。

                                                        <b class="vimtag"> <a name="d">d</a> </b>
["x]d<code class="special">{motion}</code>           删除 <code class="special">{motion}</code> 动作跨越的文本 [到寄存器 x 里]。例外见
                        下。

                                                        <b class="vimtag"> <a name="dd">dd</a> </b>
["x]dd                  删除 <code class="special">[count]</code> 行 [到寄存器 x 里]， <a href="motion.html#linewise">linewise</a>  行动作。

                                                        <b class="vimtag"> <a name="D">D</a> </b>
["x]D                   删除光标所在的字符到行尾及其后的 <code class="special">[count]</code>-1 行 [到寄
                        存器 x 里] (非  <a href="motion.html#linewise">linewise</a>  行动作)。和 "d$" 同义。
                        如果 <a href="options.html#'cpoptions'">'cpoptions'</a> 里有 '#' 标志位，忽略计数。

<code class="special">{Visual}</code>["x]x   或                                      <b class="vimtag"> <a name="v_x">v_x</a> </b> <b class="vimtag"> <a name="v_d">v_d</a> </b> <b class="vimtag"> <a name="v_%3CDel%3E">v_&lt;Del&gt;</a> </b>
<code class="special">{Visual}</code>["x]d   或
<code class="special">{Visual}</code>["x]<code class="special">&lt;Del&gt;</code>       删除高亮文本 [到寄存器 x 里] (关于 <code class="special">{Visual}</code> 见
                         <a href="visual.html#Visual-mode">Visual-mode</a> )。

<code class="special">{Visual}</code>["x]<code class="keystroke">CTRL-H</code>   或                                 <b class="vimtag"> <a name="v_CTRL-H">v_CTRL-H</a> </b> <b class="vimtag"> <a name="v_%3CBS%3E">v_&lt;BS&gt;</a> </b>
<code class="special">{Visual}</code>["x]<code class="special">&lt;BS&gt;</code>        在选择模式时，删除高亮文本 [到寄存器 x 里]。

<code class="special">{Visual}</code>["x]X   或                                      <b class="vimtag"> <a name="v_X">v_X</a> </b> <b class="vimtag"> <a name="v_D">v_D</a> </b> <b class="vimtag"> <a name="v_b_D">v_b_D</a> </b>
<code class="special">{Visual}</code>["x]D           删除高亮行 [到寄存器 x 里] (关于 <code class="special">{Visual}</code> 见
                         <a href="visual.html#Visual-mode">Visual-mode</a> )。在可视列块模式里，"D" 删除高亮的文本直
                        到行尾。

                                        <b class="vimtag"> <a name=":d">:d</a> </b> <b class="vimtag"> <a name=":de">:de</a> </b> <b class="vimtag"> <a name=":del">:del</a> </b> <b class="vimtag"> <a name=":delete">:delete</a> </b> <b class="vimtag"> <a name=":dl">:dl</a> </b> <b class="vimtag"> <a name=":dp">:dp</a> </b>
:<code class="special">[range]</code>d[elete] <code class="special">[x]</code>    删除 <code class="special">[range]</code> 范围的行 (缺省: 当前行) [到寄存器 x 里]。
                        <code class="note">注意</code> 这些奇异的缩写:
                           :dl          删除并列出 (list)
                           :dell        同上
                           :delel       同上
                           :deletl      同上
                           :deletel     同上
                           :dp          删除并显示 (print)
                           :dep         同上
                           :delp        同上
                           :delep       同上
                           :deletp      同上
                           :deletep     同上

:<code class="special">[range]</code>d[elete] <code class="special">[x]</code> <code class="special">{count}</code>
                        从 <code class="special">[range]</code> 指定的范围开始，删除 <code class="special">{count}</code> 行 (缺省: 当前
                        行  <a href="cmdline.html#cmdline-ranges">cmdline-ranges</a> ) [到寄存器 x 里]。

这些命令删除文本。你可以用  <a href="repeat.html#.">.</a>  命令重复它们 (除了  <a href="change.html#:d">:d</a> )，也可以撤销它们。用可
视模式可以删除文本列块。关于寄存器的解释，参见  <a href="change.html#registers">registers</a> 。
                                                        <b class="vimtag"> <a name="d-special">d-special</a> </b>
d<code class="special">{motion}</code> 命令的一个特例: 如果动作不面向行，动作的开始和结束处不在同一行，开始
位置之前只有空白，并且结束位置之后没有非空白的话，该删除会转为行动作。这意味着
删除命令可能删除你还想保留的空白行。 <a href="motion.html#o_v">o_v</a>  操作符强制该动作面向字符，也可从
<a href="options.html#'cpoptions'">'cpoptions'</a> 里删除 "z" 标志位 (见  <a href="options.html#cpo-z">cpo-z</a> ) 来关闭此怪异行为。

如果 <a href="options.html#'cpoptions'">'cpoptions'</a> 包括 'E' 标志位，删除文本里的空区域 (例如，在首列上 "d0") 会
报错。

                                                        <b class="vimtag"> <a name="J">J</a> </b>
J                       连接 <code class="special">[count]</code> 行，但至少包含两行。删除缩进，插入不多于
                        两个的空格 (见下)。在缓冲区末行此操作会失败。<code class="special">[count]</code>
                        如果过多，会自行缩减至余下可用的行。

                                                        <b class="vimtag"> <a name="v_J">v_J</a> </b>
<code class="special">{Visual}</code>J               连接高亮行，但至少包含两行。删除缩进，插入不多于两个的
                        空格 (见下)。

                                                        <b class="vimtag"> <a name="gJ">gJ</a> </b>
gJ                      连接 <code class="special">[count]</code> 行，但至少包含两行。不插入或删除任何空
                        格。

                                                        <b class="vimtag"> <a name="v_gJ">v_gJ</a> </b>
<code class="special">{Visual}</code>gJ              连接高亮行，但至少包含两行。不插入或删除任何空格。

                                                        <b class="vimtag"> <a name=":j">:j</a> </b> <b class="vimtag"> <a name=":join">:join</a> </b>
<code class="special">[range]</code>j[oin][!] <code class="special">[flags]</code>
                        连接 <code class="special">[range]</code> 范围的行。和 "J" 相同，但如有 [!] 时，连
                        接不插入或删除任何空格。如果 <code class="special">[range]</code> 包括相同的开始和
                        结束行，该命令不做任何事。缺省行为是连接当前行与下一
                        行。
                        <code class="special">[flags]</code> 部分可参见  <a href="cmdline.html#ex-flags">ex-flags</a> 。

:<code class="special">[range]</code>j[oin][!] <code class="special">{count}</code> <code class="special">[flags]</code>
                        连接 <code class="special">[range]</code> 开始的 <code class="special">{count}</code> 行 (缺省: 当前行
                         <a href="cmdline.html#cmdline-ranges">cmdline-ranges</a> )。和 "J" 相同，但如有 [!] 时，连接不
                        插入或删除任何空格。
                        <code class="special">[flags]</code> 部分可参见  <a href="cmdline.html#ex-flags">ex-flags</a> 。

这些命令删除行间的 <code class="special">&lt;EOL&gt;</code>，即换行符，从而实际上使多行连接成一行。除了  <a href="change.html#:j">:j</a>  之
外，你可以重复这些命令或者撤销之。

这些命令，除了 "gJ" 以外，插入一个空格以代替 <code class="special">&lt;EOL&gt;</code>，除非当前行的结尾已经有空白
或者下一行以 ')' 开始。这些命令，除了 "gJ" 之外，也删除下一行所有开头的空白。
如果 <a href="options.html#'joinspaces'">'joinspaces'</a> 选项打开，这些命令在 '.'、'!' 或者 '?' 之后插入两个空格 (但
如果 <a href="options.html#'cpoptions'">'cpoptions'</a> 包括 'j' 标志位，只有在 '.' 之后插入两个空格)。
<a href="options.html#'formatoptions'">'formatoptions'</a> 里的 'B' 和 'M' 标志位改变在多字节字符之前或者之后插入空格的行
为  <a href="change.html#fo-table">fo-table</a> 。

 <a href="motion.html#'[">'[</a>  标记指向被连接的首行之原行尾处， <a href="motion.html#']">']</a>  则指向合并后的行尾。


</section><hr class="doubleline" /><section class=inner>
<h4>2. 删除并插入                                   <b class="vimtag"> <a name="delete-insert">delete-insert</a> </b> <b class="vimtag"> <a name="replacing">replacing</a> </b></h4>
                                                        <b class="vimtag"> <a name="R">R</a> </b>
R                       进入替换模式: 每个输入的字符替代一个现有的字符，从光标
                        所在的位置开始。重复输入的文本 <code class="special">[count]</code> - 1 次。参见
                         <a href="insert.html#Replace-mode">Replace-mode</a>  以了解相关详情。

                                                        <b class="vimtag"> <a name="gR">gR</a> </b>
gR                      进入虚拟替换模式: 每个输入的字符替代屏幕位置一个现有的
                        字符。因而，一个 <code class="special">&lt;Tab&gt;</code> 可以一次替换若干个字符。重复输
                        入的文本 <code class="special">[count]</code>-1 次。参见  <a href="insert.html#Virtual-Replace-mode">Virtual-Replace-mode</a>  以
                        了解相关详情。

                                                        <b class="vimtag"> <a name="c">c</a> </b>
["x]c<code class="special">{motion}</code>           将 <code class="special">{motion}</code> 跨过的文本删除 [到寄存器 x 里] 并开始插
                        入。如果 <a href="options.html#'cpoptions'">'cpoptions'</a> 包括 'E' 标志位并且没有任何文本实
                        际需要删除时 (例如，"cTx" 而光标刚在 'x' 之后的时候)，
                        报错并拒绝开始插入模式 (这与 Vi 兼容)。如果
                        <a href="options.html#'cpoptions'">'cpoptions'</a> 没有 'E'，"c" 命令总是启动插入模式，即使没
                        有文本要删除也是如此。

                                                        <b class="vimtag"> <a name="cc">cc</a> </b>
["x]cc                  删除 <code class="special">[count]</code> 行 [到寄存器 x 里] 并开始插入。
                         <a href="motion.html#linewise">linewise</a>  行动作。如果置位 <a href="options.html#'autoindent'">'autoindent'</a>，保留首行的缩
                        进。

                                                        <b class="vimtag"> <a name="C">C</a> </b>
["x]C                   从当前光标位置删除到行尾，再删除 <code class="special">[count]</code>-1 行 [到寄存
                        器 x 里]，并开始插入。和 c$ 等价 (非  <a href="motion.html#linewise">linewise</a>  行动
                        作)。

                                                        <b class="vimtag"> <a name="s">s</a> </b>
["x]s                   删除 <code class="special">[count]</code> 个字符 [到寄存器 x 里]，并开始插入。(s 代
                        表替代 (Substitute))。和 "cl" 等价 (非  <a href="motion.html#linewise">linewise</a>  行动
                        作)。

                                                        <b class="vimtag"> <a name="S">S</a> </b>
["x]S                   删除 <code class="special">[count]</code> 行 [到寄存器 x 里] 并开始插入。和 "cc" 等
                        价  <a href="motion.html#linewise">linewise</a>  行动作。

<code class="special">{Visual}</code>["x]c   or                                      <b class="vimtag"> <a name="v_c">v_c</a> </b> <b class="vimtag"> <a name="v_s">v_s</a> </b>
<code class="special">{Visual}</code>["x]s           删除高亮文本 [到寄存器 x 里]，并开始插入 (关于
                        <code class="special">{Visual}</code> 参见  <a href="visual.html#Visual-mode">Visual-mode</a> )。

                                                        <b class="vimtag"> <a name="v_r">v_r</a> </b>
<code class="special">{Visual}</code>r<code class="special">{char}</code>         把所有高亮的字符替换成 <code class="special">{char}</code>。
                        <code class="keystroke">CTRL-C</code> 按本义插入。

                                                        <b class="vimtag"> <a name="v_C">v_C</a> </b>
<code class="special">{Visual}</code>["x]C           删除高亮行 [到寄存器 x 里] 并开始插入。在可视列块模式
                        下有所不同  <a href="visual.html#v_b_C">v_b_C</a> 。
                                                        <b class="vimtag"> <a name="v_S">v_S</a> </b>
<code class="special">{Visual}</code>["x]S           删除高亮行 [到寄存器 x 里] 并开始插入 (关于 <code class="special">{Visual}</code>
                        参见  <a href="visual.html#Visual-mode">Visual-mode</a> )。
                                                        <b class="vimtag"> <a name="v_R">v_R</a> </b>
<code class="special">{Visual}</code>["x]R           现在和 <code class="special">{Visual}</code>["x]S 相同。以后的版本可能会有所改变。

<code class="note">注意</code>:
- 你可以用 <code class="special">&lt;Esc&gt;</code> 退出插入和替换模式。
- 参见 "插入和替换模式" 一节  <a href="insert.html#mode-ins-repl">mode-ins-repl</a>  以了解其他这些模式下的特殊字符。
- <code class="special">[count]</code> 的效果只有在 Vim 退出插入或替换模式时才会体现。
- 当 <a href="options.html#'cpoptions'">'cpoptions'</a> 选项包含 '$' 并且所做的修改在一行之内，Vim 继续显示被删除的文
  本，并在最后一个被删除的字符之后加上一个 '$'。

关于寄存器的解释，参见  <a href="change.html#registers">registers</a> 。

替换模式和插入模式类似，除了每输入一个字符同时删除一个字符以外。如果到达行尾，
Vim 把其后的字符插入在行尾 (和插入模式相同)。在替换模式下，退格键恢复原来的文
本 (如果有的话)。(参见 "插入和替换模式" 一节  <a href="insert.html#mode-ins-repl">mode-ins-repl</a> )。

                                                <b class="vimtag"> <a name="cw">cw</a> </b> <b class="vimtag"> <a name="cW">cW</a> </b>
特殊情况: 如果光标在单词内部，"cw" 和 "cW" 不包含单词后的空白而只修改到词尾。
这是因为 Vim 把 "cw" 解释为 修改-单词，而单词并不包括其后的空白。
{Vi: 在其后还有空白的空白字符上 "cw" 只修改第一个空白；这也许是一个漏洞，因为
"dw" 删除所有空白；用 <a href="options.html#'cpoptions'">'cpoptions'</a> 里的 'w' 标志位来设置类似于 Vi 的工作方式}

如果你希望 "cw" 包括单词之后的空格，使用如下的映射: 
<code class="example">        :map cw dwi</code>
替代方案可用 "caw" (另见  <a href="motion.html#aw">aw</a>  和  <a href="options.html#cpo-z">cpo-z</a> )。

                                                        <b class="vimtag"> <a name=":c">:c</a> </b> <b class="vimtag"> <a name=":ch">:ch</a> </b> <b class="vimtag"> <a name=":change">:change</a> </b>
:<code class="special">{range}</code>c[hange][!]     用另外的文本替换若干文本行。输入只包含 "." 的行结束替
                        换。如果没有 <code class="special">{range}</code>，该命令只置换当前行。
                        加上 [!] 后，在本命令的执行期间切换 <a href="options.html#'autoindent'">'autoindent'</a>。
                        此命令在  <a href="vim9.html#Vim9">Vim9</a>  脚本里不支持，因为它太容易和变量名混淆
                        了。

</section><hr class="doubleline" /><section class=inner>
<h4>3. 简单修改                                             <b class="vimtag"> <a name="simple-change">simple-change</a> </b></h4>
                                                        <b class="vimtag"> <a name="r">r</a> </b>
r<code class="special">{char}</code>                 把光标下的字符换成 <code class="special">{char}</code>。如果 <code class="special">{char}</code> 是 <code class="special">&lt;CR&gt;</code> 或者
                        <code class="special">&lt;NL&gt;</code>，则把该字符变成换行符。要换成一个真正的 <code class="special">&lt;CR&gt;</code>，使
                        用 <code class="keystroke">CTRL-V</code> <code class="special">&lt;CR&gt;</code>。<code class="keystroke">CTRL-V</code> <code class="special">&lt;NL&gt;</code> 则换成 <code class="special">&lt;Nul&gt;</code>。

                        若 <code class="special">{char}</code> 为 <code class="keystroke">CTRL-E</code> 或 <code class="keystroke">CTRL-Y</code>，使用下一行或上一行的
                        字符来代替，就像  <a href="insert.html#i_CTRL-E">i_CTRL-E</a>  和  <a href="insert.html#i_CTRL-Y">i_CTRL-Y</a>  一样。这里
                        计数也适用，所以  <code class="badlink">10r<code class="special">&lt;C-E&gt;</code></code>  从下一行复制 10 个字符。

                        如果你给出 <code class="special">[count]</code>，Vim 替换 <code class="special">[count]</code> 个字符为 <code class="special">[count]</code>
                        个 <code class="special">{char}</code>。不过如果 <code class="special">{char}</code> 为 <code class="special">&lt;CR&gt;</code> 或者 <code class="special">&lt;NL&gt;</code>，Vim 只插
                        入一个换行符: "5r<code class="special">&lt;CR&gt;</code>" 替换五个字符为一个换行符。

                        当 <code class="special">{char}</code> 为 <code class="special">&lt;CR&gt;</code> 或者 <code class="special">&lt;NL&gt;</code>，Vim 会自动缩进。这和先执
                        行删除要替换的字符再执行 "i<code class="special">&lt;CR&gt;</code><code class="special">&lt;Esc&gt;</code>" 类似。

                        <code class="special">{char}</code> 可以输入二合字母  <a href="change.html#digraph-arg">digraph-arg</a> 。

                         <a href="map.html#:lmap">:lmap</a>  映射会应用在 <code class="special">{char}</code> 上。插入模式下的 <code class="keystroke">CTRL-^</code> 命
                        令可以切换这一功能  <a href="insert.html#i_CTRL-^">i_CTRL-^</a> 。

                        参见  <a href="mbyte.html#utf-8-char-arg">utf-8-char-arg</a>  以了解在 <a href="options.html#'encoding'">'encoding'</a> 为 Unicode
                        编码时如果使用组合字符。

                                                        <b class="vimtag"> <a name="gr">gr</a> </b>
gr<code class="special">{char}</code>                替换光标下的虚拟字符。替换发生在屏幕位置而不是文件位置
                        上。参见  <a href="change.html#gR">gR</a>  和  <a href="insert.html#Virtual-Replace-mode">Virtual-Replace-mode</a>  以了解相关详
                        情。和  <a href="change.html#r">r</a>  一样，可以使用计数。<code class="special">{char}</code> 输入的方式也相
                        同，但不可使用插入模式下有特殊含义的字符，如大多数的
                        <code class="keystroke">CTRL-键</code>。

                                                <b class="vimtag"> <a name="digraph-arg">digraph-arg</a> </b>
普通模式下的命令，像  <a href="change.html#r">r</a>  和  <a href="motion.html#t">t</a> ，需要一个单字符的参数。如果 <a href="options.html#'cpo'">'cpo'</a> 不包含 'D'
标志位，该字符可以用  <a href="digraph.html#digraphs">digraphs</a>  那样的方式输入: 先键入 <code class="keystroke">CTRL-K</code> 然后输入二合字母
的两个字符 <code class="notvi">{仅当编译时加入  <a href="various.html#+digraphs">+digraphs</a>  特性有效}</code>。

                                                <b class="vimtag"> <a name="case">case</a> </b>
下面的命令根据当前的  <a href="mbyte.html#locale">locale</a>  改变字母的大小写。参见  <a href="mlang.html#:language">:language</a> 。这里会用到
LC_CTYPE 的值。

                                                        <b class="vimtag"> <a name="%7E">~</a> </b>
~                       <a href="options.html#'notildeop'">'notildeop'</a> 选项: 切换光标下字符的大小写，并把光标向右
                        移。如果给出 <code class="special">[count]</code>，应用在那么多数目的字符上。

~<code class="special">{motion}</code>               <a href="options.html#'tildeop'">'tildeop'</a> 选项: 切换 <code class="special">{motion}</code> 跨越的文本的大小写。

                                                        <b class="vimtag"> <a name="g%7E">g~</a> </b>
g~<code class="special">{motion}</code>              切换 <code class="special">{motion}</code> 跨越的文本的大小写。

g~g~                                                    <b class="vimtag"> <a name="g%7Eg%7E">g~g~</a> </b> <b class="vimtag"> <a name="g%7E%7E">g~~</a> </b>
g~~                     切换当前行的大小写。

                                                        <b class="vimtag"> <a name="v_%7E">v_~</a> </b>
<code class="special">{Visual}</code>~               切换高亮文本的大小写 (关于 <code class="special">{Visual}</code> 见
                         <a href="visual.html#Visual-mode">Visual-mode</a> )。

                                                        <b class="vimtag"> <a name="v_U">v_U</a> </b>
<code class="special">{Visual}</code>U               使高亮文本成为大写 (关于 <code class="special">{Visual}</code> 见  <a href="visual.html#Visual-mode">Visual-mode</a> )。

                                                        <b class="vimtag"> <a name="gU">gU</a> </b> <b class="vimtag"> <a name="uppercase">uppercase</a> </b>
gU<code class="special">{motion}</code>              使 <code class="special">{motion}</code> 跨越的文本成为大写。
                        例如: 
<code class="example">                                :map! &lt;C-F&gt; &lt;Esc&gt;gUiw`]a</code>
                        可以用在插入模式下: 按 <code class="keystroke">CTRL-F</code> 使光标之前的单词成为大
                        写。这使得输入大写单词很方便，只要输入小写单词再一次转
                        换就行了。


gUgU                                                    <b class="vimtag"> <a name="gUgU">gUgU</a> </b> <b class="vimtag"> <a name="gUU">gUU</a> </b>
gUU                     使得当前行成为大写。

                                                        <b class="vimtag"> <a name="v_u">v_u</a> </b>
<code class="special">{Visual}</code>u               使高亮文本成为小写 (关于 <code class="special">{Visual}</code> 见  <a href="visual.html#Visual-mode">Visual-mode</a> )。

                                                        <b class="vimtag"> <a name="gu">gu</a> </b> <b class="vimtag"> <a name="lowercase">lowercase</a> </b>
gu<code class="special">{motion}</code>              使 <code class="special">{motion}</code> 跨越的文本成为小写。

gugu                                                    <b class="vimtag"> <a name="gugu">gugu</a> </b> <b class="vimtag"> <a name="guu">guu</a> </b>
guu                     使得当前行成为小写。

                                                        <b class="vimtag"> <a name="g?">g?</a> </b> <b class="vimtag"> <a name="rot13">rot13</a> </b>
g?<code class="special">{motion}</code>              用 Rot13 对 <code class="special">{motion}</code> 跨越的文本进行编码。

                                                        <b class="vimtag"> <a name="v_g?">v_g?</a> </b>
<code class="special">{Visual}</code>g?              用 Rot13 对高亮文本进行编码 (关于 <code class="special">{Visual}</code> 见
                         <a href="visual.html#Visual-mode">Visual-mode</a> )。

g?g?                                                    <b class="vimtag"> <a name="g?g?">g?g?</a> </b> <b class="vimtag"> <a name="g??">g??</a> </b>
g??                     用 Rot13 对当前行进行编码。

要以标题大写 (title cap) 方式改写一行，亦即使每个单词的首字母大写: 
<code class="example">        :s/\v&lt;(.)(\w*)/\u\1\L\2/g</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">递 增 与 递 减 </code>
                                                        <b class="vimtag"> <a name="CTRL-A">CTRL-A</a> </b>
<code class="keystroke">CTRL-A</code>                  把当前光标之上或之后的数值或者字母加上 <code class="special">[count]</code>。

                                                        <b class="vimtag"> <a name="v_CTRL-A">v_CTRL-A</a> </b>
<code class="special">{Visual}</code><code class="keystroke">CTRL-A</code>          给高亮文本内的数值或者字母加上 <code class="special">[count]</code>。

                                                        <b class="vimtag"> <a name="v_g_CTRL-A">v_g_CTRL-A</a> </b>
<code class="special">{Visual}</code>g <code class="keystroke">CTRL-A</code>        给高亮文本内的数值或者字母加上 <code class="special">[count]</code>。如果高亮超过一
                        行，每行会加上额外的 <code class="special">[count]</code> (即生成 <code class="special">[count]</code> 为增量的
                        递增数列)。
                        例如，假定有如下数字的列表:
<code class="section">                                1. </code>
<code class="section">                                1. </code>
<code class="section">                                1. </code>
<code class="section">                                1. </code>
                        移动至第二个 "1."，可视地选择后三行，按 g <code class="keystroke">CTRL-A</code> 会生
                        生成:
<code class="section">                                1. </code>
<code class="section">                                2. </code>
<code class="section">                                3. </code>
<code class="section">                                4. </code>

                                                        <b class="vimtag"> <a name="CTRL-X">CTRL-X</a> </b>
<code class="keystroke">CTRL-X</code>                  把当前光标之上或之后的数值或者字母减去 <code class="special">[count]</code>。

                                                        <b class="vimtag"> <a name="v_CTRL-X">v_CTRL-X</a> </b>
<code class="special">{Visual}</code><code class="keystroke">CTRL-X</code>          给高亮文本内的数值或者字母减去 <code class="special">[count]</code>。

                        MS-Windows 上，此键被映射到剪切可视文本
                         <a href="os_dos.html#dos-standard-mappings">dos-standard-mappings</a> 。要屏蔽该映射，可用: 
<code class="example">                                silent! vunmap &lt;C-X&gt;</code>

                                                        <b class="vimtag"> <a name="v_g_CTRL-X">v_g_CTRL-X</a> </b>
<code class="special">{Visual}</code>g <code class="keystroke">CTRL-X</code>        给高亮文本内的数值或者字母减去 <code class="special">[count]</code>。如果高亮超过一
                        行，每行会减去额外的 <code class="special">[count]</code> (即生成 <code class="special">[count]</code> 为增量的
                        递减数列)。

<code class="keystroke">CTRL-A</code> 和 <code class="keystroke">CTRL-X</code> 命令可用于:
- 带符号或无符号十进制数
- 无符号二进制、八进制和十六进制数
- 字母

这取决于 <a href="options.html#'nrformats'">'nrformats'</a> 选项:
- 当 <a href="options.html#'nrformats'">'nrformats'</a> 包括 "bin" 时，Vim 假设 '0b' 或 '0B' 开始的数值为二进制。
- 当 <a href="options.html#'nrformats'">'nrformats'</a> 包括 "octal" 时，Vim 假设 '0' 开始的数值为八进制，除非该数值
  里包含 '8' 或 '9'。其他的数值为十进制，并可以在开始带一个可选的负号。
  如果光标已经在数值上，命令应用于该数值；否则，应用于光标右侧的数值。
- 当 <a href="options.html#'nrformats'">'nrformats'</a> 包括 "alpha" 时，Vim 会改变光标之上或之后的字母。这可用于构造
  字母编号的列表。
- 当 <a href="options.html#'nrformats'">'nrformats'</a> 包括 "hex" 时，Vim 假设 '0x' 或者 '0X' 开始的数值为十六进制。
  这个数值最右端的字母决定所产生十六进制数值的大小写。如果当前数值没有字母，
  Vim 使用上一次检测到的大小写。

增减操作会考虑十进制开始的负号。二进制、八进制和十六进制值则不会。要忽略正负
号，可视地选择数值本身。然后再应用 <code class="keystroke">CTRL-A</code> 或 <code class="keystroke">CTRL-X</code>。

对零开头的数值 (包括八进制和十六进制的)，Vim 尽可能保留相同数量的字符。<code class="keystroke">CTRL-A</code>
在 "0077" 上产生 "0100"，<code class="keystroke">CTRL-X</code> 在 "0x100" 上产生 "0x0ff"。
有一个例外: 在发现某数值以零开始但不是八进制 (包含 '8' 或 '9')，而 <a href="options.html#'nrformats'">'nrformats'</a>
却包含 "octal" 的时候，引导的零会被删除，以免结果被误认为八进制。

<code class="note">注意</code> 如果 <a href="options.html#'nrformats'">'nrformats'</a> 包括 "octal"，开头有零的十进制数会产生错误，因为会和八进
制数产生混淆。

同样类似的要 <code class="note">注意</code>，如果 <a href="options.html#'nrformats'">'nrformats'</a> 同是包括 "bin" 和 "hex"，开头有 '0x' 或
'0X' 的二进制数被认作十六进制，因为 '0b' 是合法的十六进制数字。"0x0b11" 上按
<code class="keystroke">CTRL-A</code> 会返回 "0x0b12" 而不是 "0x0b100"。
而 <a href="options.html#'nrformats'">'nrformats'</a> 包括 "bin" 但没有 "hex" 时，在 "0x0b11" 的 "0b11" 上按 <code class="keystroke">CTRL-A</code>
会返回 "0x0b100"。

如果光标下的数值大到超过 32 或 64 位 (取决于 Vim 是如何编译的) 能表示的范围，
取整到最接近的可表示的数值，且忽略增减操作。例如 64 位支持下在
18446744073709551616 上按 <code class="keystroke">CTRL-X</code> 会返回 18446744073709551615。对更大的数值如
18446744073709551618 上的操作返回结果相同。

<code class="keystroke">CTRL-A</code> 命令在宏命令里很有用。例如: 使用以下的步骤构造一个数字编号的列表。

1. 建立第一个列表项。确保它以数字开始。
2. qa        - 用寄存器 'a' 开始记录
3. Y         - 抽出这个列表项
4. p         - 把该项的一个副本放置在下一行上
5. <code class="keystroke">CTRL-A</code>    - 增加计数
6. q         - 停止记录
7. <code class="special">&lt;count&gt;</code>@a - 重复抽出、放置和增加计数操作 <code class="special">&lt;count&gt;</code> 次


将 文 本 左 移 或 右 移                                 <b class="vimtag"> <a name="shift-left-right">shift-left-right</a> </b>

                                                        <b class="vimtag"> <a name="%3C">&lt;</a> </b>
&lt;<code class="special">{motion}</code>               将 <code class="special">{motion}</code> 跨越的多行左移 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列。

                        如果打开 <a href="options.html#'vartabstop'">'vartabstop'</a> 特性且 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 选项设为零，
                        缩进量在行中首个非空白字符处计算。
                                                        <b class="vimtag"> <a name="%3C%3C">&lt;&lt;</a> </b>
&lt;&lt;                      将 <code class="special">[count]</code> 行左移 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列。

                                                        <b class="vimtag"> <a name="v_%3C">v_&lt;</a> </b>
<code class="special">{Visual}</code><code class="special">[count]</code>&lt;        将高亮行左移 <code class="special">[count]</code> 个 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列 (关于 <code class="special">{Visual}</code>
                        见  <a href="visual.html#Visual-mode">Visual-mode</a> )。

                                                        <b class="vimtag"> <a name="%3E">&gt;</a> </b>
 &gt;<code class="special">{motion}</code>              将 <code class="special">{motion}</code> 跨越的多行右移 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列。

                        如果打开 <a href="options.html#'vartabstop'">'vartabstop'</a> 特性且 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 选项设为零，
                        缩进量在行中首个非空白字符处计算。
                                                        <b class="vimtag"> <a name="%3E%3E">&gt;&gt;</a> </b>
 &gt;&gt;                     将 <code class="special">[count]</code> 行右移 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列。

                                                        <b class="vimtag"> <a name="v_%3E">v_&gt;</a> </b>
<code class="special">{Visual}</code><code class="special">[count]</code>&gt;        将高亮行右移 <code class="special">[count]</code> 个 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列 (关于 <code class="special">{Visual}</code>
                        见  <a href="visual.html#Visual-mode">Visual-mode</a> )。

                                                        <b class="vimtag"> <a name=":%3C">:&lt;</a> </b>
:<code class="special">[range]</code>&lt;               将 <code class="special">[range]</code> 指定的多行左移 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列。多个 '&lt;' 左
                        移多个 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列。

:<code class="special">[range]</code>&lt; <code class="special">{count}</code>       左移 <code class="special">[range]</code> 开始的 <code class="special">{count}</code> 行 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列 (缺省从
                        当前行  <a href="cmdline.html#cmdline-ranges">cmdline-ranges</a> )。多个 '&lt;' 左移多个
                        <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列。

:<code class="special">[range]</code>le[ft] <code class="special">[indent]</code> 左对齐 <code class="special">[range]</code> 指定的多行。设置缩进距离为 <code class="special">[indent]</code> (缺
                        省为 0)。

                                                        <b class="vimtag"> <a name=":%3E">:&gt;</a> </b>
:<code class="special">[range]</code>&gt; <code class="special">[flags]</code>       将 <code class="special">[range]</code> 指定的多行右移 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列。多个 '&gt;' 右
                        移多个 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列。
                        <code class="special">[flags]</code> 部分可参见  <a href="cmdline.html#ex-flags">ex-flags</a> 。

:<code class="special">[range]</code>&gt; <code class="special">{count}</code> <code class="special">[flags]</code>
                        右移 <code class="special">[range]</code> 开始的 <code class="special">{count}</code> 行 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列 (缺省从
                        当前行  <a href="cmdline.html#cmdline-ranges">cmdline-ranges</a>  开始)。多个 '&gt;' 右移多个
                        <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列。
                        <code class="special">[flags]</code> 部分可参见  <a href="cmdline.html#ex-flags">ex-flags</a> 。

"&gt;" 和 "&lt;" 命令可以用来方便地调整程序的缩进。使用 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 选项设置这些命
令增加或者减少的空白的数量。通常，<a href="options.html#'shiftwidth'">'shiftwidth'</a> 选项是 8，但你也可以设置为，比
如说，3，使得缩进更小些。如果已经没有缩进，左移命令会停止。另一方面，右移命令
则不会影响空白行。

如果打开 <a href="options.html#'shiftround'">'shiftround'</a> 选项，缩进距离被取整到 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 的倍数。

如果打开 <a href="options.html#'smartindent'">'smartindent'</a> 选项，或者打开 <a href="options.html#'cindent'">'cindent'</a> 并且 <a href="options.html#'cinkeys'">'cinkeys'</a> 包含带零值的
'#'，右移不影响 '#' 开始的行 (这些应该是 C 预处理行，它们应该保持在第一列)。
用 <a href="options.html#'cino'">'cino'</a> 选项可改变此行为，参见  <a href="indent.html#cino-%23">cino-#</a> 。

如果 <a href="options.html#'expandtab'">'expandtab'</a> 选项关闭 (这是缺省值)， Vim 尽可能使用 <code class="special">&lt;Tab&gt;</code> 来构成缩进。你可
以用 "&gt;&gt;&lt;&lt;" 来把缩进尽可能从空格替换成同样缩进距离的 <code class="special">&lt;Tab&gt;</code> (如有需要，还有少量
的空格)。如果 <a href="options.html#'expandtab'">'expandtab'</a> 选项打开，Vim 只使用空格。这样你可以使用 "&gt;&gt;&lt;&lt;" 把
<code class="special">&lt;Tab&gt;</code> 替换成空格 (或者可以用  <a href="change.html#:retab!">:retab!</a> )。

要移动一行多个 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 列，使用可视模式或者  <a href="cmdline.html#:">:</a>  命令。例如: 
<code class="example">        Vjj4&gt;           右移三行四个缩进位</code>
<code class="example">        :&lt;&lt;&lt;            左移当前行三个缩进位</code>
<code class="example">        :&gt;&gt; 5           右移五行两个缩进位</code>
<code class="example">        :5&gt;&gt;            右移第五行两个缩进位</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>4. 复杂修改                                             <b class="vimtag"> <a name="complex-change">complex-change</a> </b></h4>
4.1 过滤命令                                            <b class="vimtag"> <a name="filter">filter</a> </b>

过滤程序是一个接受文本作为标准输入，作某些修改，并把结果放到标准输出的程序。你
可以用下面的命令把若干文本发送给过滤程序，然后用过滤的输出结果替换。一个过滤程
序的例子是 "sort"，按字母顺序给行排序；还有 "indent"，排版 C 程序文件 (你需要
一个能以过滤程序方式工作的版本，并非所有的版本都可以)。<a href="options.html#'shell'">'shell'</a> 选项指定 Vim 使
用的外壳程序，用以执行过滤程序 (另见 <a href="options.html#'shelltype'">'shelltype'</a> 选项)。你可以用 "." 重复过滤
命令。Vim 不会识别  <a href="various.html#:!">:!</a>  命令之后的注释 (用 '"' 开始)。

                                                        <b class="vimtag"> <a name="!">!</a> </b>
!<code class="special">{motion}</code><code class="special">{filter}</code>       用外部程序 <code class="special">{filter}</code> 过滤 <code class="special">{motion}</code> 跨越的多行。

                                                        <b class="vimtag"> <a name="!!">!!</a> </b>
!!<code class="special">{filter}</code>              用外部程序 <code class="special">{filter}</code> 过滤 <code class="special">[count]</code> 行。

                                                        <b class="vimtag"> <a name="v_!">v_!</a> </b>
<code class="special">{Visual}</code>!<code class="special">{filter}</code>       用外部程序 <code class="special">{filter}</code> 过滤高亮行。(关于 <code class="special">{Visual}</code> 见
                         <a href="visual.html#Visual-mode">Visual-mode</a> )。

:<code class="special">{range}</code>![!]<code class="special">{filter}</code> [!]<code class="special">[arg]</code>                           <b class="vimtag"> <a name=":range!">:range!</a> </b>
                        要执行外部命令，可见  <a href="various.html#:!">:!</a> 

                        用外部程序 <code class="special">{filter}</code> 过滤 <code class="special">{range}</code> 指定的多行。Vim 把可
                        选的感叹号替换成最后一次使用的命令，并附加上可选的参数
                        <code class="special">[arg]</code>。Vim 把过滤命令的输出保存到临时文件，并把文件内
                        容读到一个缓冲区里  <a href="change.html#tempfile">tempfile</a> 。Vim 使用 <a href="options.html#'shellredir'">'shellredir'</a>
                        选项把过滤程序的结果重定向到临时文件。
                        不过，如果关闭了 <a href="options.html#'shelltemp'">'shelltemp'</a> 选项且可以的话，使用管道
                        机制 (Unix 上)。
                        如果 <a href="options.html#'cpoptions'">'cpoptions'</a> 包含 'R' 标志位，过滤行里的位置标记被
                        删除，除非使用了  <a href="motion.html#:keepmarks">:keepmarks</a>  命令。例如: 
<code class="example">                                :keepmarks '&lt;,'&gt;!sort</code>
                        如果过滤后的行数变少，删去的行里的位置标记无论如何不会
                        保存。

                                                        <b class="vimtag"> <a name="%20">=</a> </b>
=<code class="special">{motion}</code>               用 <a href="options.html#'equalprg'">'equalprg'</a> 选项指定的外部程序过滤 <code class="special">{motion}</code> 跨越的多
                        行。如果 <a href="options.html#'equalprg'">'equalprg'</a> 选项为空 (缺省)，使用内部的排版机
                        制  <a href="indent.html#C-indenting">C-indenting</a>  和 <a href="options.html#'lisp'">'lisp'</a>，除非 <a href="options.html#'indentexpr'">'indentexpr'</a> 非空，此
                        时使用  <a href="indent.html#indent-expression">indent-expression</a>  机制来代替。反之，如果 Vim
                        编译时没有包含内部排版机制，最后手段是使用外部的
                        "indent" 程序。

                                                        <b class="vimtag"> <a name="%20%20">==</a> </b>
==                      和 =<code class="special">{motion}</code> 类似，过滤 <code class="special">[count]</code> 行。

                                                        <b class="vimtag"> <a name="v_%20">v_=</a> </b>
<code class="special">{Visual}</code>=               和 =<code class="special">{motion}</code> 类似，过滤高亮行。


                                                <b class="vimtag"> <a name="tempfile">tempfile</a> </b> <b class="vimtag"> <a name="setuid">setuid</a> </b>
Vim 使用临时文件来处理过滤、执行比较和用于 tempname()。Unix 上，该文件会放在一
个私人的目录里 (只能被当前用户访问)，以防堵安全上的漏洞 (例如，符号链接攻击或
文件被其他用户读取等)。Vim 退出时，自动删除该目录及之下的所有文件 (仅对 Unix
有效，其它系统上需要自行清理)。如果 Vim 本身设置了 setuid 位，这样或许会有问
题。临时文件由 setuid 用户拥有，但过滤程序以原来用户的权限执行。
在以下目录首个可用者建立存放临时文件的目录:
        Unix:    $TMPDIR、/tmp、当前目录、$HOME。
        Windows: $TMP、$TEMP、c:\TMP、c:\TEMP
MS-Windows 上，使用 GetTempFileName() 系统函数。
其它系统上使用 tmpnam() 库函数。


4.2 替代                                                <b class="vimtag"> <a name=":substitute">:substitute</a> </b>
                                                        <b class="vimtag"> <a name=":s">:s</a> </b> <b class="vimtag"> <a name=":su">:su</a> </b>
:<code class="special">[range]</code>s[ubstitute]/<code class="special">{pattern}</code>/<code class="special">{string}</code>/[flags] <code class="special">[count]</code>
                        对 <code class="special">[range]</code> 指定的行把 <code class="special">{pattern}</code> 的匹配替代成
                        <code class="special">{string}</code>。
                        关于 <code class="special">{pattern}</code>，参见  <a href="pattern.html#pattern">pattern</a> 。
                        <code class="special">{string}</code> 可以是按本义出现的字符串，也可包含特殊字符。
                        参见  <a href="change.html#sub-replace-special">sub-replace-special</a> 。
                        如果不指定 <code class="special">[range]</code> 和 <code class="special">[count]</code>，仅在当前行进行替代。
                        如果指定 <code class="special">[count]</code>，在 <code class="special">[range]</code> 最后一行开始的 <code class="special">[count]</code>
                        行进行替代。如果不指定 <code class="special">[range]</code>，则从当前行开始。
                                                        <b class="vimtag"> <a name="E939">E939</a> </b> <b class="vimtag"> <a name="E1510">E1510</a> </b>
                        <code class="special">[count]</code> 必须为正数 (最大值 2147483647)。
                        另见  <a href="cmdline.html#cmdline-ranges">cmdline-ranges</a> 。

                        关于 <code class="special">[flags]</code>，参见  <a href="change.html#:s_flags">:s_flags</a> 。
                        定界符不必非是 / 不可，请见  <a href="change.html#pattern-delimiter">pattern-delimiter</a> 。

:<code class="special">[range]</code>s[ubstitute] <code class="special">[flags]</code> <code class="special">[count]</code>
:<code class="special">[range]</code>&amp;[&amp;][flags] <code class="special">[count]</code>                                     <b class="vimtag"> <a name=":&">:&amp;</a> </b>
                        使用最后一次 :substitute 相同的模式和替代字符串，但不
                        包括相同的标志位。你可以另加 <code class="special">[flags]</code> (见  <a href="change.html#:s_flags">:s_flags</a> )。
                        <code class="note">注意</code> 在  <a href="change.html#:substitute">:substitute</a>  之后，不能使用 '&amp;' 和 '#' 标志
                        位。它们被识别为模式分隔符。
                         <a href="change.html#:substitute">:substitute</a>  和 'c'、'g'、'i'、'I' 和 'r' 标志位之间
                        的空格不是必需的，但在脚本里为了避免混淆起见，最好保留
                        它。
                        另见下面所述的两字母和三字母的重复 :substitute 的命令
                         <a href="change.html#:substitute-repeat">:substitute-repeat</a> 。

:<code class="special">[range]</code>~[&amp;][flags] <code class="special">[count]</code>                                     <b class="vimtag"> <a name=":%7E">:~</a> </b>
                        使用最后一次 :substitute 相同的替代字符串，但使用最近
                        使用的搜索模式作为匹配模式。这类似于  <code class="badlink">:&amp;r</code> 。
                        关于 <code class="special">[flags]</code>，参见  <a href="change.html#:s_flags">:s_flags</a> 。

                                                                <b class="vimtag"> <a name="&">&amp;</a> </b>
&amp;                       同  <a href="change.html#:s">:s</a>  (重复上次的 substitute)。<code class="note">注意</code> 这里不记住标志
                        位，所以实际工作方式可能不尽相同。你可以用  <code class="badlink">:&amp;&amp;</code>  来保
                        持相同的标志位。

                                                                <b class="vimtag"> <a name="g&">g&amp;</a> </b>
g&amp;                      同  <code class="badlink">:%s//~/&amp;</code>  (在所有行上重复上次的 substitute 并使用
                        相同的标志位，但使用前次的匹配模式)。
                        例如，如果先用了替代  <code class="badlink">:s/pattern/repl/flags</code>  然后
                         <code class="badlink">/search</code>  搜索了其他模式， <code class="badlink">g&amp;</code>   会执行
                         <code class="badlink">:%s/search/repl/flags</code> 。
                        助记: 全局 (global) 替代 (substitute)。

                                                <b class="vimtag"> <a name=":snomagic">:snomagic</a> </b> <b class="vimtag"> <a name=":sno">:sno</a> </b>
:<code class="special">[range]</code>sno[magic] ...  同  <a href="change.html#:substitute">:substitute</a> ，但总使用 <a href="options.html#'nomagic'">'nomagic'</a>。

                                                <b class="vimtag"> <a name=":smagic">:smagic</a> </b> <b class="vimtag"> <a name=":sm">:sm</a> </b>
:<code class="special">[range]</code>sm[agic] ...    同  <a href="change.html#:substitute">:substitute</a> ，但总使用 <a href="options.html#'magic'">'magic'</a>。

                                                        <b class="vimtag"> <a name=":s_flags">:s_flags</a> </b>
你可以在 substitute 命令里使用以下标志位:

                                                        <b class="vimtag"> <a name=":&&">:&amp;&amp;</a> </b>
[&amp;]     必须是首个使用的标志位: 保留和前次 substitute 相同的标志位。例如: 
<code class="example">                :&amp;&amp;</code>
<code class="example">                :s/this/that/&amp;</code>
        <code class="note">注意</code>  <a href="change.html#:s">:s</a>  和  <code class="badlink">:&amp;</code>  不保留标志位。

[c]     确认每个替代。Vim 高亮匹配的字符串 (如果使用了  <a href="syntax.html#hl-IncSearch">hl-IncSearch</a> )。你可以
        输入:                                           <b class="vimtag"> <a name=":s_c">:s_c</a> </b>
            'y'     来替代这次匹配
            'l'     来替代这次匹配并退出 (助记: "last"，最后)
            'n'     来跳过这次匹配
            <code class="special">&lt;Esc&gt;</code>   来退出替代过程
            'a'     来替代这次和以后所有的匹配
            'q'     来退出替代过程
            <code class="keystroke">CTRL-E</code>  来上卷屏幕
            <code class="keystroke">CTRL-Y</code>  来下卷屏幕
        如果 <a href="options.html#'edcompatible'">'edcompatible'</a> 选项打开，Vim 记住 <code class="special">[c]</code> 标志位并在每次使用它时切换
        是否确认，但在给出一个新的匹配模式时复位。

                                                        <b class="vimtag"> <a name=":s_e">:s_e</a> </b>
[e]     如果模式搜索不成功，不给出错误信息。因为没产生错误，映射的过程得以继
        续。这主要用来防止在映射执行过程的无匹配 ("No match") 错误中断映射。
        不过，Vim 不会抑制以下的错误信息:
                Regular expressions can't be delimited by letters (正则表达式
                        不能以字母分隔)
                \ should be followed by /, ? or &amp; (\ 必须后面跟 /、? 或者 &amp;)
                No previous substitute regular expression (没有上次的替代正则
                        表达式)
                Trailing characters (结尾有多余的字符)
                Interrupted (中断)

                                                        <b class="vimtag"> <a name=":s_g">:s_g</a> </b>
[g]     对行内所有的匹配进行替代。如果没有这个参数，替代只对每行的首个匹配进
        行。如果 <a href="options.html#'edcompatible'">'edcompatible'</a> 选项打开，Vim 记住这个标志并在你每次使用该标志
        时切换，但在给出一个新的匹配模式时复位。如果 <a href="options.html#'gdefault'">'gdefault'</a> 选项打开，这个
        标志缺省打开，而 <code class="special">[g]</code> 参数关闭之。

                                                        <b class="vimtag"> <a name=":s_i">:s_i</a> </b>
[i]     忽略模式的大小写。不使用 <a href="options.html#'ignorecase'">'ignorecase'</a> 和 <a href="options.html#'smartcase'">'smartcase'</a> 选项。

                                                        <b class="vimtag"> <a name=":s_I">:s_I</a> </b>
[I]     不忽略模式的大小写。不使用 <a href="options.html#'ignorecase'">'ignorecase'</a> 和 <a href="options.html#'smartcase'">'smartcase'</a> 选项。

                                                        <b class="vimtag"> <a name=":s_n">:s_n</a> </b>
[n]     报告匹配的次数，并不实际进行替代。忽略 <code class="special">[c]</code> 标志位。匹配报告的发生就像
        <a href="options.html#'report'">'report'</a> 总是为零那样。可用于  <a href="tips.html#count-items">count-items</a> 。
        如果使用 \=  <a href="change.html#sub-replace-expression">sub-replace-expression</a> ，该表达式对每一个匹配的执行都在
         <a href="eval.html#sandbox">sandbox</a>  里进行。

[p]     显示包含最后一次替代的行。 <b class="vimtag"> <a name=":s_p">:s_p</a> </b>

[#]     类似 <code class="special">[p]</code>，且在前面加上行号。 <b class="vimtag"> <a name=":s_%23">:s_#</a> </b>

[l]     类似 <code class="special">[p]</code>，但显示的方式类似于  <a href="various.html#:list">:list</a> 。 <b class="vimtag"> <a name=":s_l">:s_l</a> </b>

                                                        <b class="vimtag"> <a name=":s_r">:s_r</a> </b>
[r]     仅对于不带参数的  <code class="badlink">:&amp;</code>  和  <a href="change.html#:s">:s</a>  有用。 <code class="badlink">:&amp;r</code>  和  <a href="change.html#:%7E">:~</a>  工作的方式相同: 如果
        匹配模式为空，使用上一次使用的搜索模式，而不是上一次的 substitute 或者
         <a href="repeat.html#:global">:global</a>  所使用的模式。如果最近一次使用搜索的命令就是 substitute 或者
         <a href="repeat.html#:global">:global</a> ，那就没有区别了。如果最近的命令的是 "/" 那样的搜索命令，使用
        那个命令的搜索模式。
        带参数的  <a href="change.html#:s">:s</a> ，则不论如何，总是如此: 
<code class="example">                :s/blue/red/</code>
<code class="example">                /green</code>
<code class="example">                :s//red/   或  :~   或  :&amp;r</code>
        最后的命令把 "green" 替代成 "red"。 
<code class="example">                :s/blue/red/</code>
<code class="example">                /green</code>
<code class="example">                :&amp;</code>
        最后的命令把 "blue" 替代成 "red"。

<code class="note">注意</code>这里没有标志位可以改变模式的 "魔术性" (magicness)。你可以用别的命令或
 <a href="pattern.html#%2F\v">/\v</a>  之类。原因是标志位只能在跳过模式之后才能找到，而要跳过模式，必须先知道模
式的 "魔术性"。第二十二条军规！

如果 substitute 命令所用的 <code class="special">{pattern}</code> 为空，该命令使用上次的 substitute 或者
 <a href="repeat.html#:global">:global</a>  命令用过的模式。如果不存在，但有上次搜索模式，使用之。如果有 <code class="special">[r]</code> 标
志位，该命令使用上次 substitute、 <a href="repeat.html#:global">:global</a>  或者搜索命令使用的模式。

如果 <code class="special">{string}</code> 省略，替代命令假定它为空。这样就把匹配文本删除了。这时，
<code class="special">{pattern}</code> 之后的分隔符也可省略。例如: 
<code class="example">        :%s/TESTING</code>
删除所有行上的 "TESTING"，但每行只删一个。
                                                                <b class="vimtag"> <a name="E1270">E1270</a> </b>
为了和 Vi 的兼容性，老式脚本有两个例外:
"\/<code class="special">{string}</code>/" 和 "\?<code class="special">{string}</code>?" 等同于 "//<code class="special">{string}</code>/r"。
"\&amp;<code class="special">{string}</code>&amp;" 等同于 "//<code class="special">{string}</code>/"。
                                <b class="vimtag"> <a name="pattern-delimiter">pattern-delimiter</a> </b> <b class="vimtag"> <a name="E146">E146</a> </b> <b class="vimtag"> <a name="E1241">E1241</a> </b> <b class="vimtag"> <a name="E1242">E1242</a> </b>
除了用 '/' 来包围模式和替代字符串之外，你可以使用其它的单字节字符，用于 '/' 是
搜索模式或替代字符串一部分的场合。例如: 
<code class="example">        :s+/+//+</code>
<code class="example"></code>
除了字母、数字、'\'、'"' 或 '|' 之外，可用大部分的字符。Vim9 脚本里也不能用
'#'，因为它被识别为注释的开始。

关于模式的定义，参见  <a href="pattern.html#pattern">pattern</a> 。在可视列块模式下，如果模式中使用了  <a href="pattern.html#%2F\%V">/\%V</a> ，那
么替代只在列块内进行，否则它作用于整行。

                                        <b class="vimtag"> <a name="sub-replace-special">sub-replace-special</a> </b> <b class="vimtag"> <a name=":s\%20">:s\=</a> </b>
<code class="special">{string}</code> 以 "\=" 开始时，它被作为表达式来执行，参见  <a href="change.html#sub-replace-expression">sub-replace-expression</a> 。
你可以用此功能实现复杂替换，也可用来使用特殊字符。

替代最多可以递归 4 层。 <b class="vimtag"> <a name="E1290">E1290</a> </b>

否则，<code class="special">{string}</code> 字符串里的字符有如下的特殊含义:
                                                                <b class="vimtag"> <a name=":s%">:s%</a> </b>
如果 <code class="special">{string}</code> 等于 "%"，且 <a href="options.html#'cpoptions'">'cpoptions'</a> 选项包含 '/'，重复使用上次替代命令的
<code class="special">{string}</code>，见  <a href="options.html#cpo-%2F">cpo-/</a> 

<code class="section">magic   nomagic   动作    </code>
  &amp;       \&amp;      替代为完整的匹配                                   <b class="vimtag"> <a name="s%2F\&">s/\&amp;</a> </b>
 \&amp;        &amp;      替代为 &amp;
      \0          替代为完整的匹配                                 <b class="vimtag"> <a name="\0">\0</a> </b> <b class="vimtag"> <a name="s%2F\0">s/\0</a> </b>
      \1          替代为匹配的第一个 () 里面的内容                   <b class="vimtag"> <a name="s%2F\1">s/\1</a> </b>
      \2          替代为匹配的第二个 () 里面的内容                   <b class="vimtag"> <a name="s%2F\2">s/\2</a> </b>
      ..          ..                                                 <b class="vimtag"> <a name="s%2F\3">s/\3</a> </b>
      \9          替代为匹配的第九个 () 里面的内容                   <b class="vimtag"> <a name="s%2F\9">s/\9</a> </b>
  ~       \~      替代为前一个 substitute 的替代字符串               <b class="vimtag"> <a name="s%7E">s~</a> </b>
 \~        ~      替代为 ~                                           <b class="vimtag"> <a name="s%2F\%7E">s/\~</a> </b>
      \u          下一个字符成为大写                                 <b class="vimtag"> <a name="s%2F\u">s/\u</a> </b>
      \U          其后字符成为大写，直到 \E 出现                     <b class="vimtag"> <a name="s%2F\U">s/\U</a> </b>
      \l          下一个字符成为小写                                 <b class="vimtag"> <a name="s%2F\l">s/\l</a> </b>
      \L          其后字符成为小写，直到 \E 出现                     <b class="vimtag"> <a name="s%2F\L">s/\L</a> </b>
      \e          结束 \u、\U、\l 和 \L (<code class="note">注意</code>: 不是 <code class="special">&lt;Esc&gt;</code>!)          <b class="vimtag"> <a name="s%2F\e">s/\e</a> </b>
      \E          结束 \u、\U、\l 和 \L                              <b class="vimtag"> <a name="s%2F\E">s/\E</a> </b>
      <code class="special">&lt;CR&gt;</code>        把该行在此位置一分为二
                  (<code class="special">&lt;CR&gt;</code> 以 <code class="keystroke">CTRL-V</code> <code class="special">&lt;Enter&gt;</code> 方式输入)                  <b class="vimtag"> <a name="s%3CCR%3E">s&lt;CR&gt;</a> </b>
      \r          同上                                               <b class="vimtag"> <a name="s%2F\r">s/\r</a> </b>
      \<code class="special">&lt;CR&gt;</code>       插入一个回车 (<code class="keystroke">CTRL-M</code>)
                  (<code class="special">&lt;CR&gt;</code> 以 <code class="keystroke">CTRL-V</code> <code class="special">&lt;Enter&gt;</code> 方式输入)                  <b class="vimtag"> <a name="s%2F\%3CCR%3E">s/\&lt;CR&gt;</a> </b>
      \n          插入一个 <code class="special">&lt;NL&gt;</code> (文件里的 <code class="special">&lt;NUL&gt;</code>)
                  (此处并不是换行)                                   <b class="vimtag"> <a name="s%2F\n">s/\n</a> </b>
      \b          插入一个 <code class="special">&lt;BS&gt;</code>                                      <b class="vimtag"> <a name="s%2F\b">s/\b</a> </b>
      \t          插入一个 <code class="special">&lt;Tab&gt;</code>                                     <b class="vimtag"> <a name="s%2F\t">s/\t</a> </b>
      \\          插入单个反斜杠                                     <b class="vimtag"> <a name="s%2F\\">s/\\</a> </b>
      \x          其中 x 是上面没提到的任何一个字符:
                  保留作将来的扩展

这里的特殊含义也用于  <a href="builtin.html#substitute()">substitute()</a>  函数的第三个参数 <code class="special">{sub}</code>，除了若干例外:
  - % 总是插入百分号，与 <a href="options.html#'cpoptions'">'cpoptions'</a> 无关。
  - 总是假定有魔术性，与 <a href="options.html#'magic'">'magic'</a> 无关。
  - ~ 总是插入波浪符。
  - <code class="special">&lt;CR&gt;</code> 和 \r 插入回车 (<code class="keystroke">CTRL-M</code>)。
  - \<code class="special">&lt;CR&gt;</code> 没有特殊意义，只是 \x 之一。

示例: 
<code class="example">  :s/a\|b/xxx\0xxx/g             修改 "a b"      为 "xxxaxxx xxxbxxx"</code>
<code class="example">  :s/\([abc]\)\([efg]\)/\2\1/g   修改 "af fa bg" 为 "fa fa gb"</code>
<code class="example">  :s/abcde/abc^Mde/              修改 "abcde"    为 "abc"、"de" (两行)</code>
<code class="example">  :s/$/\^M/                      修改 "abcde"    为 "abcde^M"</code>
<code class="example">  :s/\w\+/\u\0/g                 修改 "bla bla"  为 "Bla Bla"</code>
<code class="example">  :s/\w\+/\L\u\0/g               修改 "BLA bla"  为 "Bla Bla"</code>
<code class="example"></code>
<code class="note">注意</code>: "\L\u" 可用于使单词的首个字母变大写。此行为和 Vi 以及旧版 Vim 不兼容，那
里 "\u" 会抵消 "\L"。"\U\l" 亦然。

<code class="note">注意</code>: 在以前的版本里，<code class="keystroke">CTRL-V</code> 以特殊的方式处理。因为和 Vi 不兼容，该功能已经被
去掉了，现在用反斜杠来替代。

<code class="section">命令            文本    结果 </code>
:s/aa/a^Ma/     aa      a<code class="special">&lt;line-break&gt;</code>a
:s/aa/a\^Ma/    aa      a^Ma
:s/aa/a\\^Ma/   aa      a\<code class="special">&lt;line-break&gt;</code>a

(你需要输入 <code class="keystroke">CTRL-V</code> <code class="special">&lt;CR&gt;</code> 来得到这里的 ^M)

"\1"，"\2" 等里的数字是基于模式里 "\(" 出现的顺序 (从左到右)。如果一个括号组匹
配多次，最后一次的匹配被使用在 "\1"，"2" 等里。例如: 
<code class="example">  :s/\(\(a[a-d] \)*\)/\2/      修改 "aa ab x" 为 "ab x"</code>
"\2" 对应 "\(a[a-d] \)"。第一次匹配 "aa "，第二次匹配 "ab "。

如果括号和 '|' 组合使用，如 \([ab]\)\|\([cd]\)，两者有一个会不匹配，所以 \1 或
者 \2 会为空。例如: 
<code class="example">  :s/\([ab]\)\|\([cd]\)/\1x/g   修改 "a b c d" 为 "ax bx x x"</code>
<code class="example"></code>

                <b class="vimtag"> <a name=":sc">:sc</a> </b> <b class="vimtag"> <a name=":sce">:sce</a> </b> <b class="vimtag"> <a name=":scg">:scg</a> </b> <b class="vimtag"> <a name=":sci">:sci</a> </b> <b class="vimtag"> <a name=":scI">:scI</a> </b> <b class="vimtag"> <a name=":scl">:scl</a> </b> <b class="vimtag"> <a name=":scp">:scp</a> </b> <b class="vimtag"> <a name=":sg">:sg</a> </b> <b class="vimtag"> <a name=":sgc">:sgc</a> </b>
                <b class="vimtag"> <a name=":sge">:sge</a> </b> <b class="vimtag"> <a name=":sgi">:sgi</a> </b> <b class="vimtag"> <a name=":sgI">:sgI</a> </b> <b class="vimtag"> <a name=":sgl">:sgl</a> </b> <b class="vimtag"> <a name=":sgn">:sgn</a> </b> <b class="vimtag"> <a name=":sgp">:sgp</a> </b> <b class="vimtag"> <a name=":sgr">:sgr</a> </b> <b class="vimtag"> <a name=":sI">:sI</a> </b> <b class="vimtag"> <a name=":si">:si</a> </b>
                <b class="vimtag"> <a name=":sic">:sic</a> </b> <b class="vimtag"> <a name=":sIc">:sIc</a> </b> <b class="vimtag"> <a name=":sie">:sie</a> </b> <b class="vimtag"> <a name=":sIe">:sIe</a> </b> <b class="vimtag"> <a name=":sIg">:sIg</a> </b> <b class="vimtag"> <a name=":sIl">:sIl</a> </b> <b class="vimtag"> <a name=":sin">:sin</a> </b> <b class="vimtag"> <a name=":sIn">:sIn</a> </b> <b class="vimtag"> <a name=":sIp">:sIp</a> </b>
                <b class="vimtag"> <a name=":sip">:sip</a> </b> <b class="vimtag"> <a name=":sIr">:sIr</a> </b> <b class="vimtag"> <a name=":sir">:sir</a> </b> <b class="vimtag"> <a name=":sr">:sr</a> </b> <b class="vimtag"> <a name=":src">:src</a> </b> <b class="vimtag"> <a name=":srg">:srg</a> </b> <b class="vimtag"> <a name=":sri">:sri</a> </b> <b class="vimtag"> <a name=":srI">:srI</a> </b> <b class="vimtag"> <a name=":srl">:srl</a> </b>
                <b class="vimtag"> <a name=":srn">:srn</a> </b> <b class="vimtag"> <a name=":srp">:srp</a> </b> <b class="vimtag"> <a name=":substitute-repeat">:substitute-repeat</a> </b>
<code class="section">2-字母和 3-字母的 :substitute 命令 </code>

这些命令重复之前的  <a href="change.html#:substitute">:substitute</a>  命令，但带上指定标志位。首个字母总是 "s"，后
跟一个或两个可能的标志位字符。例如， <a href="change.html#:sce">:sce</a>  相当于  <code class="badlink">:s///ce</code> 。此表列出所有可能
的组合，不是所有的标志位组合都可以，因为有些命令是其它命令的缩写。

     :substitute 命令列表
     |      c    e    g    i    I    n    p    l    r
     | c  :sc  :sce :scg :sci :scI :scn :scp :scl
     | e
     | g  :sgc :sge :sg  :sgi :sgI :sgn :sgp :sgl :sgr
     | i  :sic :sie      :si  :siI :sin :sip      :sir
     | I  :sIc :sIe :sIg :sIi :sI  :sIn :sIp :sIl :sIr
     | n
     | p
     | l
     | r  :src      :srg :sri :srI :srn :srp :srl :sr

例外:
     :scr  是   <a href="repeat.html#:scriptnames">:scriptnames</a> 
     :se   是   <a href="options.html#:set">:set</a> 
     :sig  是   <a href="sign.html#:sign">:sign</a> 
     :sil  是   <a href="various.html#:silent">:silent</a> 
     :sn   是   <a href="windows.html#:snext">:snext</a> 
     :sp   是   <a href="windows.html#:split">:split</a> 
     :sl   是   <a href="various.html#:sleep">:sleep</a> 
     :sre  是   <a href="windows.html#:srewind">:srewind</a> 


以表达式方式替代                                <b class="vimtag"> <a name="sub-replace-expression">sub-replace-expression</a> </b>
                                                <b class="vimtag"> <a name="sub-replace-\%20">sub-replace-\=</a> </b> <b class="vimtag"> <a name="s%2F\%20">s/\=</a> </b>
当替代字符串以 "\=" 开始时，其余部分被解释为一个表达式。

除了 "<code class="special">&lt;CR&gt;</code>" 以外， <a href="change.html#sub-replace-special">sub-replace-special</a>  提到的字符的特殊含义这里不适用。<code class="special">&lt;NL&gt;</code>
字符被用作换行符，双引号字符串 "\n" 也可以。在 <code class="special">&lt;NL&gt;</code> 之前加上反斜杠得到一个真正
的 <code class="special">&lt;NL&gt;</code> 字符 (在文件里成为 NUL)。

"\=" 记法也可用于  <a href="builtin.html#substitute()">substitute()</a>  函数的第三个参数 <code class="special">{sub}</code> 之内，这时，
 <a href="change.html#sub-replace-special">sub-replace-special</a>  指出的特殊含义完全不适用。具体说，<code class="special">&lt;CR&gt;</code> 和 <code class="special">&lt;NL&gt;</code> 不用作换
行，而分别是回车和新行。

如果结果是  <a href="eval.html#List">List</a> ，连接其中的项目并以换行符分隔。这样，每个项目单独成为一行，
当然本身就包含换行符的除外。

 <a href="builtin.html#submatch()">submatch()</a>  函数可用来获取匹配文本。完整的匹配可以用 "submatch(0)" 得到。首个
括号里的匹配可以用 "submatch(1)"，余者类似。

小心: 分隔符不能出现在表达式里！可以考虑使用 "@" 或者 ":" 那样的字符。执行结果
里出现分隔符不成问题。

例如: 
<code class="example">        :s@\n@\="\r" .. expand("$HOME") .. "\r"@</code>
把换行符替代为包含 $HOME 值的一个新行。 
<code class="example"></code>
<code class="example">        s/E/\="\&lt;Char-0x20ac&gt;"/g</code>
把所有的 'E' 字符替代为欧元符号。详见  <a href="map.html#%3CChar-%3E">&lt;Char-&gt;</a> 。


4.3 搜索与替代                                          <b class="vimtag"> <a name="search-replace">search-replace</a> </b>

                                                        <b class="vimtag"> <a name=":pro">:pro</a> </b> <b class="vimtag"> <a name=":promptfind">:promptfind</a> </b>
:promptf[ind] <code class="special">[string]</code>
                        弹出搜索对话框。如果给出 <code class="special">[string]</code>，它被用作初始的搜索
                        字符串。
                        <code class="notvi">{仅适用于 Win32、Motif 和 GTK GUI 环境}</code>

                                                <b class="vimtag"> <a name=":promptr">:promptr</a> </b> <b class="vimtag"> <a name=":promptrepl">:promptrepl</a> </b>
:promptr[epl] <code class="special">[string]</code>
                        弹出搜索/替代对话框。如果给出 <code class="special">[string]</code>，它被用作初始的
                        搜索字符串。
                        <code class="notvi">{仅适用于 Win32、Motif 和 GTK GUI 环境}</code>

4.4 改变制表                                            <b class="vimtag"> <a name="change-tabs">change-tabs</a> </b>
                                                        <b class="vimtag"> <a name=":ret">:ret</a> </b> <b class="vimtag"> <a name=":retab">:retab</a> </b> <b class="vimtag"> <a name=":retab!">:retab!</a> </b>
:<code class="special">[range]</code>ret[ab][!] [-indentonly] [<code class="special">{new-tabstop}</code>]
                        把所有包含 <code class="special">&lt;Tab&gt;</code> 的空白序列替代成由 <code class="special">{new-tabstop}</code> 确定
                        的空白序列。如果你不指定 <code class="special">{new-tabstop}</code> 或者它为 0，Vim
                        使用原来的制表位 <a href="options.html#'tabstop'">'tabstop'</a>。
                        已有的制表宽度总是用 <a href="options.html#'tabstop'">'tabstop'</a> 的当前值来计算。
                        如果有 !，Vim 也在合适的时候，把只包含正常空格的字符串
                        换成制表。
                        如果置位了 <a href="options.html#'expandtab'">'expandtab'</a>，Vim 把所有的制表换成相当的空
                        格。
                        该命令把 <a href="options.html#'tabstop'">'tabstop'</a> 设为 <code class="special">{new-tabstop}</code>。如果按照缺省的
                        情况，在全文件上进行处理，视觉上应该不会有任何改变。

                        如果给出了 [-indentonly]，只替换引导的空白。不改变其他
                        的连续空白序列。

                        小心: 该命令修改 C 程序中的字符串里的任何 <code class="special">&lt;Tab&gt;</code> 字符。
                        要避免这一点，用 "\t" (无论如何，应该养成这个好的习
                        惯)。
                         <a href="change.html#:retab!">:retab!</a>  也把空格序列换成 <code class="special">&lt;Tab&gt;</code>，这可能会使 printf()
                        引起混淆。
                        如果打开  <a href="various.html#+vartabs">+vartabs</a>  特性，可用以逗号分隔的制表宽度的列
                        表来代替单个制表位。列表的每个值代表一个制表位的宽度。
                        末值除外，该值适用于其后所有的制表位。

                                                        <b class="vimtag"> <a name="retab-example">retab-example</a> </b>
下面的例子使用自动命令和 ":retab" 来编辑使用制表位为 8 的文件，但在编辑时制表
位设置为 4。<code class="note">警告</code>: 字符串里的空格会被改变。另见 <a href="options.html#'softtabstop'">'softtabstop'</a> 选项。 
<code class="example"></code>
<code class="example">  :auto BufReadPost     *.xx    retab! 4</code>
<code class="example">  :auto BufWritePre     *.xx    retab! 8</code>
<code class="example">  :auto BufWritePost    *.xx    retab! 4</code>
<code class="example">  :auto BufNewFile      *.xx    set ts=4</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>5. 复制并移动文本                                       <b class="vimtag"> <a name="copy-move">copy-move</a> </b></h4>
                                                        <b class="vimtag"> <a name="quote">quote</a> </b>
"{a-zA-Z0-9.%#:-"}      指定下次的删除、抽出和放置命令使用的寄存器
                        {a-zA-Z0-9.%#:-"} (大写字符使得删除和抽出命令附加到该
                        寄存器) (<code class="special">{.%#:}</code> 只能用于放置命令)。
"<code class="special">{register}</code>             指定下次的删除、抽出和放置命令使用的寄存器
                        <code class="special">{register}</code>。大写字符使得删除和抽出命令附加到该寄存器。
                        寄存器 "."、"%"、"#" 和 ":" 只能用于放置命令。

                                                        <b class="vimtag"> <a name=":reg">:reg</a> </b> <b class="vimtag"> <a name=":registers">:registers</a> </b>
:reg[isters]            显示所有编号和命名寄存器的类型和内容。但不列出用于
                         <a href="various.html#:redir">:redir</a>  目的地的寄存器。
                        类型可以是以下之一:
                        "c"     用于  <a href="motion.html#characterwise">characterwise</a>  文本
                        "l"     用于  <a href="motion.html#linewise">linewise</a>  文本
                        "b"     用于  <a href="visual.html#blockwise-visual">blockwise-visual</a>  文本

:reg[isters] <code class="special">{arg}</code>      显示 <code class="special">{arg}</code> 里提到的编号和命名寄存器的内容。例如: 
<code class="example">                                :reg 1a</code>
                        显示寄存器 '1' 和 'a'。<code class="special">{arg}</code> 里可以用空格。

                                                        <b class="vimtag"> <a name=":di">:di</a> </b> <b class="vimtag"> <a name=":dis">:dis</a> </b> <b class="vimtag"> <a name=":display">:display</a> </b>
:di[splay] <code class="special">[arg]</code>        和 :registers 相同。

                                                        <b class="vimtag"> <a name="y">y</a> </b> <b class="vimtag"> <a name="yank">yank</a> </b>
["x]y<code class="special">{motion}</code>           抽出 <code class="special">{motion}</code> 跨越的文本 [到寄存器 x]。如果没有字符被
                        抽出 (例如，在第一列执行 "y0") 并且 <a href="options.html#'cpoptions'">'cpoptions'</a> 里包括
                        'E' 标志位，这是一个错误。

                                                        <b class="vimtag"> <a name="yy">yy</a> </b>
["x]yy                  抽出 <code class="special">[count]</code> 行 [到寄存器 x]  <a href="motion.html#linewise">linewise</a>  行动作。

                                                        <b class="vimtag"> <a name="Y">Y</a> </b>
["x]Y                   抽出 <code class="special">[count]</code> 行 [到寄存器 x] (同 yy， <a href="motion.html#linewise">linewise</a>  行动
                        作)。如果你想要 "Y" 执行从光标到行尾的操作 (更合乎逻
                        辑，但是与 Vi 不兼容)，用 ":map Y y$"。

                                                        <b class="vimtag"> <a name="zy">zy</a> </b>
["x]zy<code class="special">{motion}</code>          抽出 <code class="special">{motion}</code> 跨越的文本 [到寄存器 x]。 和  <a href="change.html#y">y</a>  的仅有
                        不同是在选择文本列块时，见  <a href="change.html#v_zy">v_zy</a> 。

                                                        <b class="vimtag"> <a name="v_y">v_y</a> </b>
<code class="special">{Visual}</code>["x]y           抽出高亮文本 [到寄存器 x] (关于 <code class="special">{Visual}</code> 见
                         <a href="visual.html#Visual-mode">Visual-mode</a> )。

                                                        <b class="vimtag"> <a name="v_Y">v_Y</a> </b>
<code class="special">{Visual}</code>["x]Y           抽出高亮行 [到寄存器 x] (关于 <code class="special">{Visual}</code> 见
                         <a href="visual.html#Visual-mode">Visual-mode</a> )。

                                                        <b class="vimtag"> <a name="v_zy">v_zy</a> </b>
<code class="special">{Visual}</code>["x]zy          抽出高亮文本 [到寄存器 x]。不会抽出选中的列块的每行尾
                        部拖尾的空白。和  <a href="change.html#zp">zp</a>  的组合特别有用。(关于 <code class="special">{Visual}</code>
                        见  <a href="visual.html#Visual-mode">Visual-mode</a> )

                                                        <b class="vimtag"> <a name=":y">:y</a> </b> <b class="vimtag"> <a name=":yank">:yank</a> </b> <b class="vimtag"> <a name="E850">E850</a> </b>
:<code class="special">[range]</code>y[ank] <code class="special">[x]</code>      抽出 <code class="special">[range]</code> 所指定的行 [到寄存器 x]。仅当包含
                         <a href="various.html#+clipboard">+clipboard</a>  特性时才可以抽出到 "* 或 "+ 寄存器。

:<code class="special">[range]</code>y[ank] <code class="special">[x]</code> <code class="special">{count}</code>
                        从 <code class="special">[range]</code> 的最后一行开始 (缺省: 当前行
                         <a href="cmdline.html#cmdline-ranges">cmdline-ranges</a> ) 抽出 <code class="special">{count}</code> 行 [到寄存器 x]。

                                                <b class="vimtag"> <a name="p">p</a> </b> <b class="vimtag"> <a name="put">put</a> </b> <b class="vimtag"> <a name="E353">E353</a> </b> <b class="vimtag"> <a name="E1240">E1240</a> </b>
["x]p                   放置文本 [从寄存器 x] 在光标之后 <code class="special">[count]</code> 次。

                                                        <b class="vimtag"> <a name="P">P</a> </b>
["x]P                   放置文本 [从寄存器 x] 在光标之前 <code class="special">[count]</code> 次。

                                                        <b class="vimtag"> <a name="%3CMiddleMouse%3E">&lt;MiddleMouse&gt;</a> </b>
["x]<code class="special">&lt;MiddleMouse&gt;</code>       从一个寄存器放置文本在光标之前 <code class="special">[count]</code> 次。除非另外指
                        定，否则用 "* 寄存器。
                        光标停留在新文本的尾部。
                        只有在 <a href="options.html#'mouse'">'mouse'</a> 包含 'n' 或者 'a' 时鼠标才会工作。
                        如果你有滚轮鼠标而且经常不小心粘贴了文本，你可以使用以
                        下映射来关闭鼠标中键粘贴的功能: 
<code class="example">                                :map &lt;MiddleMouse&gt; &lt;Nop&gt;</code>
<code class="example">                                :imap &lt;MiddleMouse&gt; &lt;Nop&gt;</code>
                        你也许还想要关闭多键击的功能。参见  <a href="term.html#double-click">double-click</a> 。

                                                        <b class="vimtag"> <a name="gp">gp</a> </b>
["x]gp                  如同 "p"，但光标停留在新文本之后。

                                                        <b class="vimtag"> <a name="gP">gP</a> </b>
["x]gP                  如同 "P"，但光标停留在新文本之后。

                                                        <b class="vimtag"> <a name=":pu">:pu</a> </b> <b class="vimtag"> <a name=":put">:put</a> </b>
:<code class="special">[line]</code>pu[t] <code class="special">[x]</code>        放置文本 [从寄存器 x] 在行号 <code class="special">[line]</code> (缺省为当前行) 之
                        后。总是  <a href="motion.html#linewise">linewise</a>  行动作，此命令因而可用来把抽出的块
                        作为新行放置。
                        如果未指定寄存器，则取决于 <a href="options.html#'cb'">'cb'</a> 选项: 如果 <a href="options.html#'cb'">'cb'</a> 包含
                        "unnamedplus"，从 + 寄存器  <a href="gui_x11.html#quoteplus">quoteplus</a>  取出，否则如果
                        <a href="options.html#'cb'">'cb'</a> 包含 "unnamed"，从 * 寄存器  <a href="gui.html#quotestar">quotestar</a>  取出，否
                        则，从无名寄存器  <a href="change.html#quote_quote">quote_quote</a>  取出。
                        寄存器也可以是 '='，跟随一个可选的表达式。表达式继续到
                        该命令结束为止。需在 '|' 和 '"' 字符前加上反斜杠不让它
                        们终止你的命令行。例如: 
<code class="example">                                :put ='path' .. \",/test\"</code>
                        '=' 之后如果没有表达式，Vim 会使用前一个表达式。用
                        ":dis =" 可以察看。

:<code class="special">[line]</code>pu[t]! <code class="special">[x]</code>       放置文本 [从寄存器 x] 在行号 <code class="special">[line]</code> (缺省为当前行) 之
                        前。

                                                        <b class="vimtag"> <a name=":ip">:ip</a> </b> <b class="vimtag"> <a name=":iput">:iput</a> </b>
:<code class="special">[line]</code>ip[ut] <code class="special">[x]</code>       类似  <a href="change.html#:put">:put</a> ，但调整缩进和当前行一致

:<code class="special">[line]</code>ip[ut]! <code class="special">[x]</code>      类似  <a href="change.html#:put">:put</a> !，但调整缩进和当前行一致

["x]]p              或                                  <b class="vimtag"> <a name="]p">]p</a> </b> <b class="vimtag"> <a name="]%3CMiddleMouse%3E">]&lt;MiddleMouse&gt;</a> </b>
["x]]<code class="special">&lt;MiddleMouse&gt;</code>      类似 "p"，但调整当前行的缩进。只有在 <a href="options.html#'mouse'">'mouse'</a> 包含 'n'
                        或者 'a' 时鼠标才会工作。

["x][P              或                                  <b class="vimtag"> <a name="[P">[P</a> </b>
["x]]P              或                                  <b class="vimtag"> <a name="]P">]P</a> </b>
["x][p              或                                  <b class="vimtag"> <a name="[p">[p</a> </b> <b class="vimtag"> <a name="[%3CMiddleMouse%3E">[&lt;MiddleMouse&gt;</a> </b>
["x][<code class="special">&lt;MiddleMouse&gt;</code>      类似 "P"，但调整当前行的缩进。只有在 <a href="options.html#'mouse'">'mouse'</a> 包含 'n'
                        或者 'a' 时鼠标才会工作。

["x]zp              或                                  <b class="vimtag"> <a name="zp">zp</a> </b> <b class="vimtag"> <a name="zP">zP</a> </b>
["x]zP                  类似 "p" 和 "P"，但粘贴列块时不附加拖尾空白。这样插入
                        的文本就不总是矩阵。和  <a href="change.html#v_zy">v_zy</a>  的组合特别有用。

你可以用这些命令把文本从一个地方复制到另一个地方。首先，把文本用抽出、删除或者
修改命令取到一个寄存器里，然后用放置命令把寄存器的内容插入。你可以用这些命令把
文本从一个文件移动到另一个文件，因为 Vim 在切换缓冲区时保留所有的寄存器
(<code class="keystroke">CTRL-^</code> 命令可用来快捷地切换文件)。

                                <b class="vimtag"> <a name="linewise-register">linewise-register</a> </b> <b class="vimtag"> <a name="characterwise-register">characterwise-register</a> </b>
可用 "." 重复放置命令 (:put 除外)，也可以撤销它们。如果保存到寄存器文本的命令
是  <a href="motion.html#linewise">linewise</a>  行动作，Vim 把文本插入在光标所在的行之下 ("p") 或之上 ("P")。不
然，Vim 把文本插入在光标之后 ("p") 或之前 ("P")。":put" 命令使得 Vim 总是把文
本放在下一行。可用命令序列 "xp" 来交换两个字母。用 "ddp" 命令序列来交换两行。
还可用 "deep" 命令交换两个单词 (光标在首个单词之前的空白上)。更可在放置命令之
后用  <a href="motion.html#']">']</a>  或者  <a href="motion.html#`]">`]</a>  命令把光标移动到插入文本之后，或者用  <a href="motion.html#'[">'[</a>  或  <a href="motion.html#`[">`[</a>  把光标移
动到文本的开始处。

                                                <b class="vimtag"> <a name="put-Visual-mode">put-Visual-mode</a> </b> <b class="vimtag"> <a name="v_p">v_p</a> </b> <b class="vimtag"> <a name="v_P">v_P</a> </b>
在可视模式下使用如  <a href="change.html#p">p</a>  或者  <a href="change.html#P">P</a>  之类的放置命令时，Vim 试图把选择的文本替换成寄
存器的内容。这是否如你所愿取决于选择的类型和寄存器里文本的类型。对于列块选择而
言，也取决于列块的大小和头尾是否在已存在的字符上。(实现细节: 实际上先在选择区
之后放置寄存器的内容，然后再删除选择区的内容。)
用  <a href="change.html#p">p</a>  时前次选择的文本被放在无名寄存器 (可能同时也在选择和/或剪贴板) 中。可用
于把该文本放置到他处。但不能重复相同操作。
用  <a href="change.html#P">P</a>  时无名寄存器不改变 (同样选择或剪贴板也不会改变)，可以重复相同的改变，但
删除的文本不能再用。如果需要，可以用  <a href="change.html#p">p</a>  并选用其它寄存器。例如，先抽出要复制
的文本，再可视化选择要替换的文本，然后使用 "0p。重复任意多次均可，而每次无名寄
存器都会被改变。
                                                        <b class="vimtag"> <a name="blockwise-put">blockwise-put</a> </b>
寄存器如果包含单行文本 (面向字符)，使用面向列块的可视选择时，放置该寄存器时会
把该文本复制到选择的每一行上，也即，把选择的列块区域替代为寄存器文本的多个备
份。例如:
        - 用  <code class="badlink">yw</code>  抽出单词 "TEXT" 到某寄存器
        - 选择可视列块，如下面文本里的 "v" 的部分:
            aaavvaaa
            bbbvvbbb
            cccvvccc
        - 按  <a href="change.html#p">p</a> ，结果是:
            aaaTEXTaaa
            bbbTEXTbbb
            cccTEXTccc

                                                        <b class="vimtag"> <a name="blockwise-register">blockwise-register</a> </b>
如果你使用面向列块的可视模式命令把文本存到寄存器里，文本列块会被插入在当前和其
后的行的当前列之前 ("P") 或之后 ("p")。Vim 使得整个文本列块从同一列开始。这
样，插入的文本看上去和抽出或删除时看起来一样。为了使之可能，Vim 可能需要把一些
<code class="special">&lt;Tab&gt;</code> 字符替换成空格。不过，如果列块的宽度不是 <code class="special">&lt;Tab&gt;</code> 宽度的整数倍并且插入列块
之后文本里包含 <code class="special">&lt;Tab&gt;</code> 的时候，那些文本可能就不会那么整齐。

用  <a href="change.html#zP">zP</a> / <a href="change.html#zp">zp</a>  来粘贴已抽出的面向列块的寄存器，而不附加拖尾的空白。

<code class="note">注意</code> 在一个面向字符的抽出命令之后，Vim 把光标停留在最接近缓冲区开头的首个被抽
出的字符之上。这意味着 "yl" 不会移动光标，但是 "yh" 把光标向左移一格。
逻辑:           在 Vi 里 "y" 命令跟一个反向的动作有时不会把光标移动到首个被抽
                出的字符之上，因为屏幕没有刷新。Vim 符合 Posix 的规范，总是把
                光标移动到首个字符之上。
在一个面向行的抽出命令之后，光标放置在首行上，但是列保持不变，所以不必然在第一
个抽出的字符上。

共有十种类型的寄存器:                           <b class="vimtag"> <a name="registers">registers</a> </b> <b class="vimtag"> <a name="{register}">{register}</a> </b> <b class="vimtag"> <a name="E354">E354</a> </b>
1. 无名寄存器 ""
2. 10 个编号寄存器 "0 到 "9 (<code class="vim">译者注</code>: 最近抽出、最近及更早跨行删除)
3. 行内删除寄存器 "-
4. 26 个命名的寄存器 "a 到 "z 或者 "A 到 "Z
5. 三个只读寄存器 ":、". 和 "% (<code class="vim">译者注</code>: 最近命令行、最近插入文本、当前文件名)
6. 轮换缓冲区寄存器 "#
7. 表达式寄存器 "=
8. 选择和拖放寄存器 "*、"+ 和 "~  (<code class="vim">译者注</code>: 主选择、剪切、拖放)
9. 黑洞寄存器 "_
10. 最近搜索模式寄存器 "/

1. 无名寄存器 ""                                <b class="vimtag"> <a name="quote_quote">quote_quote</a> </b> <b class="vimtag"> <a name="quotequote">quotequote</a> </b>
用 "d"、"c"、"s"、"x" 等命令删除或者用 "y" 等抽出命令复制的文本都被 Vim 用来填
充该寄存器，不管是否用到别的专门寄存器 (例如 "xdd)。这就好像无名寄存器是指向最
近使用的那个寄存器的指针一样。使用大写寄存器进行添加时，无名寄存器包含和命名寄
存器相同的文本。'_' 寄存器是一个特例。"_dd 不把删除的文本存在任何寄存器里。
不指定寄存器的放置命令 (p 或 P) 使用无名寄存器的内容。你也可以用 '"' 作为名字
来访问该寄存器。这意味着要输入两个连续的双引号。写入 "" 寄存器将实际写到寄存器
"0 上。
<code class="notvi">{Vi: 寄存器内容在更换文件时丢失，没有 '"'}</code>

2. 编号寄存器 "0 到 "9                  <b class="vimtag"> <a name="quote_number">quote_number</a> </b> <b class="vimtag"> <a name="quote0">quote0</a> </b> <b class="vimtag"> <a name="quote1">quote1</a> </b>
                                        <b class="vimtag"> <a name="quote2">quote2</a> </b> <b class="vimtag"> <a name="quote3">quote3</a> </b> <b class="vimtag"> <a name="quote4">quote4</a> </b> <b class="vimtag"> <a name="quote9">quote9</a> </b>
Vim 把抽出和删除命令的文本保存在这些寄存器里。
   编号寄存器 0 包含最近抽出的文本，除非该命令用 ["x] 指定了别的寄存器。
   编号寄存器 1 包含了最近删除或者修改的文本 (即使该命令指定了别的寄存器)，除
非该文本小于一行 (该情况下使用行内删除寄存器)。以下移动命令在应用删除操作符时
例外:  <a href="motion.html#%">%</a> 、 <a href="motion.html#(">(</a> 、 <a href="motion.html#)">)</a> 、 <a href="motion.html#`">`</a> 、 <a href="pattern.html#%2F">/</a> 、 <a href="pattern.html#?">?</a> 、 <a href="pattern.html#n">n</a> 、 <a href="pattern.html#N">N</a> 、 <a href="motion.html#{">{</a>  和  <a href="motion.html#}">}</a> 。它们总是使用寄存器
"1 (这是 Vi 兼容行为)。如果文本小于一行，同时使用 "- 寄存器。<code class="note">注意</code> 这些字符可能
会被映射。例如，matchit 插件会映射 % 字符。
   每来一次新的删除和修改，Vim 把前一次的寄存器 1 的内容复制到寄存器 2，2 到
3，依此类推。而寄存器 9 的内容就丢失了。
<code class="notvi">{Vi: 寄存器 0 不存在}</code>

3. 行内删除寄存器 "-                                    <b class="vimtag"> <a name="quote_-">quote_-</a> </b> <b class="vimtag"> <a name="quote-">quote-</a> </b>
该寄存器保存删除不到一行内容的命令的文本，除非该命令用 ["x] 指定了寄存器。

4. 命名寄存器 "a 到 "z 或者 "A 到 "Z                    <b class="vimtag"> <a name="quote_alpha">quote_alpha</a> </b> <b class="vimtag"> <a name="quotea">quotea</a> </b>
Vim 只有在你指定的时候才使用这些寄存器。指定为小写字母时替换原来的内容，指定为
大写字母时附加到原来的内容。如果 <a href="options.html#'cpoptions'">'cpoptions'</a> 里有 '&gt;' 标志位，在附加文本前插入
一个换行符。

5. 只读寄存器 ":、". 和 "%
它们是 '%'、':' 和 '.'。你只能在 "p"、"P"、":put" 命令和 <code class="keystroke">CTRL-R</code> 的时候使用它
们。
                                                <b class="vimtag"> <a name="quote_.">quote_.</a> </b> <b class="vimtag"> <a name="quote.">quote.</a> </b> <b class="vimtag"> <a name="E29">E29</a> </b>
        ".      包含最近插入的文本 (和插入模式命令 <code class="keystroke">CTRL-A</code> 和 <code class="keystroke">CTRL-@</code> 插入的一
                样)。<code class="note">注意</code>: 它不适用于命令行上的 <code class="keystroke">CTRL-R</code>。后者的工作方式稍有不
                同，例如，文本是被插入而不是放置的 (<a href="options.html#'textwidth'">'textwidth'</a> 和其它选项
                影响插入的内容)。
                                                        <b class="vimtag"> <a name="quote_%">quote_%</a> </b> <b class="vimtag"> <a name="quote%">quote%</a> </b>
        "%      包含当前文件名。
                                                <b class="vimtag"> <a name="quote_:">quote_:</a> </b> <b class="vimtag"> <a name="quote:">quote:</a> </b> <b class="vimtag"> <a name="E30">E30</a> </b>
        ":      包含最近执行过的命令行。例如: 用 "@:" 重复上次执行过的命令行命
                令。只有当一个命令行中至少一个字符是键入的，该寄存器才会保存命
                令行的内容。所以，如果命令行完全来自映射，该寄存器保持不变。
                <code class="notvi">{仅当编译时加入  <a href="various.html#+cmdline_hist">+cmdline_hist</a>  特性才有效}</code>
                                                        <b class="vimtag"> <a name="quote_%23">quote_#</a> </b> <b class="vimtag"> <a name="quote%23">quote#</a> </b>
6. 轮换文件寄存器 "#
包含当前窗口轮换文件的名字。它影响 <code class="keystroke">CTRL-^</code> 的命令的工作方式。
该寄存器是可写的，主要用来帮助插件在改变其值后恢复原值。接受缓冲区号: 
<code class="example">    let altbuf = bufnr(@#)</code>
<code class="example">    ...</code>
<code class="example">    let @# = altbuf</code>
如果传递了不存在的缓冲区号，会报错  <a href="windows.html#E86">E86</a> 。
也可接受现有缓冲区名的匹配: 
<code class="example">    let @# = 'buffer_name'</code>
如果有多于一个缓冲区匹配该名，报错  <a href="windows.html#E93">E93</a> ，如果没有缓冲区匹配该名，也会报错
 <a href="windows.html#E94">E94</a> 。

7. 表达式寄存器 "=                              <b class="vimtag"> <a name="quote_%20">quote_=</a> </b> <b class="vimtag"> <a name="quote%20">quote=</a> </b> <b class="vimtag"> <a name="@%20">@=</a> </b>
其实并没有这么一个寄存器可以储存文本，但是这是用来在使用寄存器的命令中使用表达
式的一个方式。表达式寄存器是可读写的。

" 或 <code class="keystroke">CTRL-R</code> 之后输入 '=' 时，光标移到命令行上，这时你可以输入任何的表达式 (见
 <a href="eval.html#expression">expression</a> )。可以使用所有正常的命令行编辑命令，还有一个表达式专门的历史表。
当你按回车结束命令行时，Vim 计算表达式的结果。如果你用 <code class="special">&lt;Esc&gt;</code> 结束，Vim 中止表
达式。如果你不输入表达式，Vim 使用最近的表达式 (和 "/" 命令的处理相似)。

表达式的计算结果必须是一个字符串。数值结果会自动转化为字符串。对 "p" 和 ":put"
命令而言，浮点数结果也会被转化为字符串。如果结果为列表，每个成员被转成字符串，
然后被单独放在一行上。字典被转换为字符串。函数引用类型的结果则产生错误信息 (通
过 string() 转化)。

如果 "= 寄存器被 "p" 命令使用，该字符串会在 <code class="special">&lt;NL&gt;</code> 字符处断开。如果该字符串以
<code class="special">&lt;NL&gt;</code> 结尾，则它被视为一个面向行的寄存器。

8. 选择和拖放寄存器 "*、"+ 和 "~ 
用这些寄存器来保存和取得 GUI 界面选择的文本。参见  <a href="gui.html#quotestar">quotestar</a>  和  <a href="gui_x11.html#quoteplus">quoteplus</a> 。
如果剪贴板不存在或者不工作，使用无名寄存器。Unix 上，仅当  <a href="various.html#+xterm_clipboard">+xterm_clipboard</a> 
特性存在时才可用剪贴板。

<code class="note">注意</code> "* 和 "+ 在 X11 系统上有分别。关于该差别的解释，参见  <a href="gui_x11.html#x11-selection">x11-selection</a> 。在
MS-Windows 上，"* 和 "+ 的使用实际上是等价的，可见  <a href="gui_w32.html#gui-clipboard">gui-clipboard</a> 。

                                                <b class="vimtag"> <a name="quote_%7E">quote_~</a> </b> <b class="vimtag"> <a name="quote%7E">quote~</a> </b> <b class="vimtag"> <a name="%3CDrop%3E">&lt;Drop&gt;</a> </b>
只读的 "~ 寄存器保存最近一次拖放操作放下的文本。如果有什么东西被放到 Vim 上，
"~ 寄存器被填充，<code class="special">&lt;Drop&gt;</code> 虚拟键被激活。如果你需要，你可以重定义该键的映射；缺省
的动作 (适用于所有模式) 是把 "~ 寄存器的内容插入到当前光标位置。
<code class="notvi">{仅当编译时加入  <a href="various.html#+dnd">+dnd</a>  特性才有效，当前只适用于 GTK GUI 版本}</code>

<code class="note">注意</code>: "~ 寄存器仅用于在 Vim 上拖放普通文本。URI 列表的拖放在内部处理。

9. 黑洞寄存器 "_                                <b class="vimtag"> <a name="quote_">quote_</a> </b>
当写到这个寄存器时，什么都不会发生。这可以用来删除文本，而不影响任何正常的寄存
器。从该寄存器读时，什么都不会返回。

10. 最近搜索模式寄存器  "/                      <b class="vimtag"> <a name="quote_%2F">quote_/</a> </b> <b class="vimtag"> <a name="quote%2F">quote/</a> </b>
含有最近搜索的模式。它被 "n" 和 <a href="options.html#'hlsearch'">'hlsearch'</a> 使用。可以用  <a href="eval.html#:let">:let</a>  来修改。你可以
改变它使得 <a href="options.html#'hlsearch'">'hlsearch'</a> 不经过实际的搜索直接高亮某些匹配。你不能把抽出或者删除命
令的内容放到该寄存器上。搜索方向则可从  <a href="eval.html#v:searchforward">v:searchforward</a>  得到。
<code class="note">注意</code> 从函数返回时该值被复原  <a href="userfunc.html#function-search-undo">function-search-undo</a> 。

                                                        <b class="vimtag"> <a name="@%2F">@/</a> </b>
你可以用  <a href="eval.html#:let">:let</a>  命令写到一个寄存器  <a href="eval.html#:let-@">:let-@</a> 。例如: 
<code class="example">        :let @/ = "the"</code>
<code class="example"></code>
如果你用放置命令而不指定寄存器，Vim 使用上次填充的寄存器 (这也是无名寄存器的内
容)。如果你弄糊涂了，用  <a href="change.html#:dis">:dis</a>  命令看看 Vim 会放置什么内容 (该命令显示所有的有
名和无名的寄存器；无名寄存器被标为 '"')。

下面三个命令总是针对整行工作。

:<code class="special">[range]</code>co[py] <code class="special">{address}</code>                                <b class="vimtag"> <a name=":co">:co</a> </b> <b class="vimtag"> <a name=":copy">:copy</a> </b>
                        把 <code class="special">[range]</code> 指定的行复制到 <code class="special">{address}</code> 给出的行之下。

                                                        <b class="vimtag"> <a name=":t">:t</a> </b>
:t                      和 :copy 等价。
                        此命令在  <a href="vim9.html#Vim9">Vim9</a>  脚本里不支持，因为它太容易和变量名混淆
                        了。

:<code class="special">[range]</code>m[ove] <code class="special">{address}</code>                        <b class="vimtag"> <a name=":m">:m</a> </b> <b class="vimtag"> <a name=":mo">:mo</a> </b> <b class="vimtag"> <a name=":move">:move</a> </b> <b class="vimtag"> <a name="E134">E134</a> </b>
                        把 <code class="special">[range]</code> 指定的行移动到 <code class="special">{address}</code> 给出的行之下。
                        清除 <code class="special">[range]</code> 里的所有文本属性。见
                         <a href="textprop.html#text-prop-cleared">text-prop-cleared</a> 。

</section><hr class="doubleline" /><section class=inner>
<h4>6. 文本排版                                             <b class="vimtag"> <a name="formatting">formatting</a> </b></h4>
:<code class="special">[range]</code>ce[nter] <code class="special">[width]</code>                                <b class="vimtag"> <a name=":ce">:ce</a> </b> <b class="vimtag"> <a name=":center">:center</a> </b>
                        在 <code class="special">[range]</code> 指定范围的行和 <code class="special">[width]</code> 限定的列 (缺省为
                        <a href="options.html#'textwidth'">'textwidth'</a>，如其为 0，则取 80) 范围内的文本居中对齐。

:<code class="special">[range]</code>ri[ght] <code class="special">[width]</code>                                 <b class="vimtag"> <a name=":ri">:ri</a> </b> <b class="vimtag"> <a name=":right">:right</a> </b>
                        在 <code class="special">[range]</code> 指定范围的行和 <code class="special">[width]</code> 限定的列 (缺省为
                        <a href="options.html#'textwidth'">'textwidth'</a>，如其为 0，则取 80) 范围内的文本靠右对齐。

                                                        <b class="vimtag"> <a name=":le">:le</a> </b> <b class="vimtag"> <a name=":left">:left</a> </b>
:<code class="special">[range]</code>le[ft] <code class="special">[indent]</code>
                        在 <code class="special">[range]</code> 指定范围的行的文本靠左对齐。其缩进的距离可
                        由 <code class="special">[indent]</code> 设置 (缺省为 0)。

                                                        <b class="vimtag"> <a name="gq">gq</a> </b>
gq<code class="special">{motion}</code>              对 <code class="special">{motion}</code> 动作跨越的行进行排版。
                        排版使用如下三种方式之一:
                        1. 如果 <a href="options.html#'formatexpr'">'formatexpr'</a> 不为空，计算该表达式。每个缓冲区
                           的值可以不同。
                        2. 如果 <a href="options.html#'formatprg'">'formatprg'</a> 不为空，使用外部程序。
                        3. 否则，使用内部排版机制。

                        第三种方式使用 <a href="options.html#'textwidth'">'textwidth'</a> 选项控制所有待排版行的行宽
                        (见下)。
                        如果 <a href="options.html#'textwidth'">'textwidth'</a> 选项为 0，则排版行宽设为屏幕的宽度
                        (但最大宽度不超过 79)。
                        <a href="options.html#'formatoptions'">'formatoptions'</a> 选项控制排版的方式  <a href="change.html#fo-table">fo-table</a> 。
                        光标停留在排版行末行的首个非空白处。
                        <code class="note">注意</code>: "Q" 命令以前执行此项功能。如果你还想继续用 "Q"
                        来排版，执行如下映射命令: 
<code class="example">                                :nnoremap Q gq</code>
<code class="example"></code>
gqgq                                                    <b class="vimtag"> <a name="gqgq">gqgq</a> </b> <b class="vimtag"> <a name="gqq">gqq</a> </b>
gqq                     排版当前行。如带计数排版相应多行。

                                                        <b class="vimtag"> <a name="v_gq">v_gq</a> </b>
<code class="special">{Visual}</code>gq              排版高亮文本 (<code class="special">{Visual}</code> 的部分参见  <a href="visual.html#Visual-mode">Visual-mode</a> )。

                                                        <b class="vimtag"> <a name="gw">gw</a> </b>
gw<code class="special">{motion}</code>              对 <code class="special">{motion}</code> 动作跨越的行进行排版。和  <a href="change.html#gq">gq</a>  类似，但排版
                        后光标恢复原位。而且不使用 <a href="options.html#'formatprg'">'formatprg'</a> 和 <a href="options.html#'formatexpr'">'formatexpr'</a>
                        选项。

gwgw                                                    <b class="vimtag"> <a name="gwgw">gwgw</a> </b> <b class="vimtag"> <a name="gww">gww</a> </b>
gww                     对当前行排版，其它和 "gw" 类同。

                                                        <b class="vimtag"> <a name="v_gw">v_gw</a> </b>
<code class="special">{Visual}</code>gw              排版高亮文本，其它和 "gw" 类同。(<code class="special">{Visual}</code> 可见
                         <a href="visual.html#Visual-mode">Visual-mode</a> )。

例如: 要排版当前段落，可用:                                     <b class="vimtag"> <a name="gqap">gqap</a> </b>  
<code class="example">        gqap</code>
<code class="example"></code>
"gq" 命令后，光标随着指定的移动命令移动。这使得用 "." 进行连续排版成为可能。例
如，"gqj" (对当前行和下一行排版) 和 "gq}" (排版到段落尾) 便可如此。<code class="note">注意</code>: 如果
设置了 <a href="options.html#'formatprg'">'formatprg'</a>，"gq" 把光标留在排版后的首行 (如同过滤命令那般)。

如果你想对当前段落排版后留在原来的位置，可用: 
<code class="example">        gwap</code>
如果你想使段落自动排版，可以在 <a href="options.html#'formatoptions'">'formatoptions'</a> 里加入 'a' 标志位。参见
 <a href="change.html#auto-format">auto-format</a> 。

如果 <a href="options.html#'autoindent'">'autoindent'</a> 选项打开，Vim 用首行的缩进距离排版其后的所有行。

排版不会改变空行 (但会改变只有空白字符的行！)。

如果有连接行的操作，应用 <a href="options.html#'joinspaces'">'joinspaces'</a> 选项。

你可以设置 <a href="options.html#'formatexpr'">'formatexpr'</a> 选项为某表达式或设置 <a href="options.html#'formatprg'">'formatprg'</a> 选项为外部程序名，Vim
会用之进行文本排版。<a href="options.html#'textwidth'">'textwidth'</a> 等选项对外部程序的排版不起作用。

                                                        <b class="vimtag"> <a name="format-formatexpr">format-formatexpr</a> </b>
<a href="options.html#'formatexpr'">'formatexpr'</a> 选项可设为对缓冲区重新排版的 Vim 脚本函数。此功能常用于
 <a href="usr_51.html#ftplugin">ftplugin</a> ，因为排版方式高度依赖于文件类型。这里，建议使用  <a href="userfunc.html#autoload">autoload</a>  脚本，这
样只有在有需要时才会载入对应的脚本，而该脚本应命名为 <code class="special">&lt;filetype&gt;</code>format.vim。

例如，随 Vim 发布的在 $VIMRUNTIME/ftplugin 目录里的 XML 文件类型插件把
<a href="options.html#'formatexpr'">'formatexpr'</a> 选项设为: 
<code class="example"></code>
<code class="example">   setlocal formatexpr=xmlformat#Format()</code>
<code class="example"></code>
这意味着，在以下文件你会找到相应的脚本，其中定义了 xmlformat#Format() 函数:
 <code class="badlink">$VIMRUNTIME/autoload/xmlformat.vim</code> 

下例脚本删除选定文本的拖尾空白。把它放在你的 autoload 目录，如
~/.vim/autoload/format.vim 里:
&gt;vim
  func! format#Format()
    " 只在显式的 gq 命令时重新排版
    if mode() != 'n'
      " 缺省使用 Vim 内部的重新排版方式
      return 1
    endif
    let lines = getline(v:lnum, v:lnum + v:count - 1)
    call map(lines, {key, val -&gt; substitute(val, '\s\+$', '', 'g')})
    call setline('.', lines)

    " 不使用内部的排版方式！
    return 0
  endfunc

然后，如此打开此种排版方式: 
<code class="example">  setlocal formatexpr=format#Format()</code>

<code class="note">注意</code>: 此函数在插入模式下 (一般这意味着文本的插入超出了 <a href="options.html#'textwidth'">'textwidth'</a> 限制) 显式
返回非零。这样，Vim 会使用缺省的内部排版方法。

反之，该  <a href="change.html#gq">gq</a>  命令会用于重新排版文本，此时，函数获取所选的行，删除这些行拖尾的
空白，并在原地放置。如果你需要把单行分割为多行，小心不要覆盖额外的部分。

如果在插入或替换模式下希望重排文本，分外小心，因为此时函数可能会被递归调用。调
试可用 <a href="options.html#'debug'">'debug'</a> 选项。

                                                        <b class="vimtag"> <a name="right-justify">right-justify</a> </b>
Vim 没有靠右控制对齐 (right justify) 文本的命令。你可以用 "par" 这样的外部命令
来实现 (例如， <code class="badlink">:.,}!par</code>  对到段落尾的文本排版)，或者设置 <a href="options.html#'formatprg'">'formatprg'</a> 为
"par"。

                                                        <b class="vimtag"> <a name="format-comments">format-comments</a> </b>
用户手册的  <a href="usr_30.html#30.6">30.6</a>  一节给出注释排版的总览。

Vim 可以自动对注释的插入和排版进行特殊处理。Vim 把以特定字符串开头 (忽略空白)
的行识别为注释。以下是三种不同类型的注释:

- 在每行的开头都出现的注释字符串。例如，外壳脚本使用的注释行都以 "#" 开头。
- 只在首行出现的注释字符串。使用连字符 "-" 的本列表就是这样的一个例子，
- 由三部分组成的注释，包括起始字符串，结尾字符串，和两者之间可选的行的起始字符
  串。三种字符串可分别指定。如下 C 风格的注释就是如此:
        /*
         * this is a C comment
         */

<a href="options.html#'comments'">'comments'</a> 选项是一个由逗号分隔的列表。每个部分定义一种类型的注释字符串。每个
部分的组成方式是:
        <code class="special">{flags}</code>:<code class="special">{string}</code>

<code class="special">{string}</code> 是必须出现的字符串 (不作转义)。

<code class="special">{flags}</code>:
  n     可嵌套的注释: 允许多个部分间的嵌套。例如，<a href="options.html#'comments'">'comments'</a> 为 "n:),n:&gt;"。则
        以 "&gt; ) &gt;" 开始的行视为注释。

  b     在 <code class="special">{string}</code> 之后必须有空白字符 (<code class="special">&lt;Space&gt;</code>、<code class="special">&lt;Tab&gt;</code> 或 <code class="special">&lt;EOL&gt;</code>)。

  f     该注释字符串只在首行出现。下一行不重复注释，但保留相同的缩进 (例如，带
        符号的列表 (bullet-list))。

  s     三段式注释的起始字符串

  m     三段式注释的中间字符串

  e     三段式注释的结尾字符串

  l     左对齐。和 's' 或 'e' 一起使用。起始或结尾字符串的最左字符和中间字符串
        的最左字符对齐。
        这是缺省值，可以省略。详情见下。

  r     右对齐。同上，不过不是最左字符而是最右字符。详情见下。

  O     "O" 命令不把它当作注释。

  x     允许三段式注释用以下方式结束: 在中间字符串自动提供的情况下，在新行第一
        个动作是输入结尾字符串的最后一个字符。详情见下。

  <code class="special">{digits}</code>
        在和 's' 或 'e' 一起使用时: 对自动插入的中间或结尾字符串增加 <code class="special">{digit}</code>
        单位的位移。该位移以左对齐的位置为基准。详情见下。

  -<code class="special">{digits}</code>
        和 <code class="special">{digits}</code> 类似，但减少缩进。这只对开始或结尾部分至少有相当数量的缩进
        时才有效。

如果一个字符串没有 'f'、's'、'm' 或 'e' 任何一个标志位，Vim 假设注释字符串在每
行都重复出现。<code class="special">{flags}</code> 字段可以为空。

在 <code class="special">{string}</code> 之前或之后的任何空白都是 <code class="special">{string}</code> 的一部分，所以不要随便留出开头或
结尾的空白，除非空白的确是注释字符串的一部分。

如果某个注释字符串是另一个字符串的一部分，先指定完整的，再指定部分的。例如，要
包含 "-" 和 "-&gt;"，用 
<code class="example">        :set comments=f:-&gt;,f:-</code>
<code class="example"></code>
三段式注释必须以开始、中间和结尾三部分给出，而且不能间杂其它的部分。一个三段式
C 注释的例子是 
<code class="example">        sr:/*,mb:*,ex:*/</code>
为了避免形如 "*ptr" 的内容被识别为注释，这里的中间字符串包含了 'b' 标志位。对
三段式注释而言，Vim 从开始和中间字符串之后查找结尾字符串。如果找到，注释就不会
再从下一行继续。三段式注释必须要有一个中间字符串，不然 Vim 无法识别中间的那些
行。

<code class="note">注意</code> 上述三段式注释定义里的 "x" 标志位。当你在一个 C-注释里按回车时，Vim 会自
动在新行后插入中间字符串: " * "。要结束注释，你只需要在新行里首先键入 "/"。这
样就把中间字符串替换成结尾字符串并应用指定的对齐方式，成为了 " */"。从而省却了
先按退格键的麻烦。

如果同时匹配中间部分和结尾部分但结尾部分更长，使用结尾部分。这样 C 风格注释就
不需要中间部分后加空格了。

这里是一个关于用于对齐的标志位的例子，使得注释看起来很突出 (也很像一个 1 字)。
考虑注释字符串: 
<code class="example">        :set comments=sr:/***,m:**,ex-2:******/</code>

<code class="section">                                   /*** </code>
<code class="section">                                     **&lt;--右对齐，来自 "r" 标志位 </code>
<code class="section">                                     ** </code>
<code class="section">  2 个单位的位移，来自 "2" 标志位---&gt;** </code>
<code class="section">                                   ******/ </code>
该例中，第一行注释是键入的，然后按回车四次，最后按 "/" 以结束注释。

这里是三部分注释的一些细节。有三个时间点应用对齐和位移标志位: 输入起始字符串后
开启新行、在结尾字符串前开启新行、三部分注释的自动结束。而结尾部分的对齐标志位
要反过来看；这样，相同的对齐标志位在分别用于 "s" 和 "e" 时才会使起始和结尾部分
有相同的缩进。每个注释部分只应用一种对齐方式，但位移优先于 "r" 和 "l" 标志位。

打开 <a href="options.html#'cindent'">'cindent'</a> 在很多情况下会覆盖对齐标志位。使用其它方法，如  <a href="change.html#gq">gq</a>  或  <a href="change.html#%20">=</a>  来重
新缩进也不会参考对齐标志位。这些其它的排版选择可以定义类似的行为。一个担心是
<a href="options.html#'cindent'">'cindent'</a> 虽然有众多附加的选项来对注释进行基于上下文的缩进，但不能再现三部分注
释的缩进对齐。但 <a href="options.html#'indentexpr'">'indentexpr'</a> 应该有能力很好地处理三部分注释。

其它示例: 
<code class="example">   "b:*"        包含 "*" 开头的行，但 "*" 后面不是空白的除外。这样避免指针取值</code>
<code class="example">                操作 "*str" 被识别为注释。</code>
<code class="example">   "n:&gt;"        包含形如 "&gt;"、"&gt;&gt;"、"&gt;&gt;&gt;" 等开头的行。</code>
<code class="example">   "fb:-"       包含 "- " 开头的列表，可用来自动排版。</code>
<code class="example"></code>
该选项的缺省值是 "b:#"。这意味着 "#include" 开头的行不会被认为是注释，但
"# define" 是。这是个不得不然的妥协。

                                                        <b class="vimtag"> <a name="fo-table">fo-table</a> </b>
你可以使用 <a href="options.html#'formatoptions'">'formatoptions'</a> 选项来控制 Vim 如何对文本进行排版。<a href="options.html#'formatoptions'">'formatoptions'</a>
是一个字符串，它可以包含下列字符。缺省设置是 "tcq"。为了提高可读性，你可以用逗
号分隔选项字符。

<code class="section">字符     在 <a href="options.html#'formatoptions'">'formatoptions'</a> 里代表的含义   </code>
                                                        <b class="vimtag"> <a name="fo-t">fo-t</a> </b>
t       使用 <a href="options.html#'textwidth'">'textwidth'</a> 自动回绕文本
                                                        <b class="vimtag"> <a name="fo-c">fo-c</a> </b>
c       使用 <a href="options.html#'textwidth'">'textwidth'</a> 自动回绕注释，自动插入当前注释前导符。
                                                        <b class="vimtag"> <a name="fo-r">fo-r</a> </b>
r       在插入模式按回车时，自动插入当前注释前导符。
                                                        <b class="vimtag"> <a name="fo-o">fo-o</a> </b>
o       在普通模式按 'o' 或者 'O' 时，自动插入当前注释前导符。如果特定处不想要
        注释，可以用 <code class="keystroke">CTRL-U</code> 快速删除之。  <a href="insert.html#i_CTRL-U">i_CTRL-U</a> 
                                                        <b class="vimtag"> <a name="fo-%2F">fo-/</a> </b>
/       包含 'o' 时: 不为语句后的 // 注释插入注释前导符，除非 // 在行首出现。
                                                        <b class="vimtag"> <a name="fo-q">fo-q</a> </b>
q       允许 "gq" 排版时排版注释。
        <code class="note">注意</code> 排版不会影响空行或者只有注释前导符的行。这样的行开启一个新段落，
        注释前导符的改变也是如此。
                                                        <b class="vimtag"> <a name="fo-w">fo-w</a> </b>
w       拖尾的空格指示下一行继续同一个段落。而以非空白字符结束的行结束一个段
        落。
                                                        <b class="vimtag"> <a name="fo-a">fo-a</a> </b>
a       自动排版段落。每当文本被插入或者删除时，段落都会自动进行排版。参见
         <a href="change.html#auto-format">auto-format</a> 。
        如果 'c' 标志位存在，该设置只对识别的注释有效。
                                                        <b class="vimtag"> <a name="fo-n">fo-n</a> </b>
n       在对文本排版时，识别编号的列表。实际上，这里使用了 <a href="options.html#'formatlistpat'">'formatlistpat'</a> 选
        项，所以可以使用任何类型的列表。出现在数字之后的文本缩进距离被应用到后
        面的行。数字之后可以有可选的 '.'、':'、')'、']' 或者 '}'。
        <code class="note">注意</code> <a href="options.html#'autoindent'">'autoindent'</a> 也必须置位。不要和 "2" 一起使用，效果不好。
        示例: 
<code class="example">                1. 第一项</code>
<code class="example">                   回绕文字</code>
<code class="example">                2. 第二项</code>
                                                        <b class="vimtag"> <a name="fo-2">fo-2</a> </b>
2       在对文本排版时，将段落第二行而非第一行的缩进距离应用到其后的行上。这适
        用于第一行有特殊缩进需要的段落。<code class="note">注意</code> <a href="options.html#'autoindent'">'autoindent'</a> 也必须置位。
        示例: 
<code class="example">                        first line of a paragraph</code>
<code class="example">                second line of the same paragraph</code>
<code class="example">                third line.</code>
        也适用于注释内部，并忽略注释前导符。
                                                        <b class="vimtag"> <a name="fo-v">fo-v</a> </b>
v       Vi-兼容的插入模式自动回绕: 只有在当前输入命令键入的空白上才会分行。
        (<code class="note">注意</code>: 这并不能 100% Vi 兼容。Vi 在这方面有些 "意想不到的特性"，换而言
        之，漏洞。它使用屏幕列而非实际的列。)
                                                        <b class="vimtag"> <a name="fo-b">fo-b</a> </b>
b       和 'v' 类似，但只有在键入空白时还没抵达或者刚到回绕边界的时候才会自动
        回绕。如果一行在开始插入之前已经超过 <a href="options.html#'textwidth'">'textwidth'</a> 指定的长度，或者在到
        达 <a href="options.html#'textwidth'">'textwidth'</a> 之时没有输入过空白，Vim 不会自动回绕。
                                                        <b class="vimtag"> <a name="fo-l">fo-l</a> </b>
l       插入模式不分行: 当一行已经超过 <a href="options.html#'textwidth'">'textwidth'</a> 时，插入命令不会自动排版。
                                                        <b class="vimtag"> <a name="fo-m">fo-m</a> </b>
m       可以在任何值高于 255 的多字节字符上分行。这对亚洲文本尤其有用，因为每
        个字符都是单独的单位。
                                                        <b class="vimtag"> <a name="fo-M">fo-M</a> </b>
M       在连接行时，不要在多字节字符之前或之后插入空格。优先于 'B' 标志位。
                                                        <b class="vimtag"> <a name="fo-B">fo-B</a> </b>
B       在连接行时，不要在两个多字节字符之间插入空格。有 'M' 标志位时无效。
                                                        <b class="vimtag"> <a name="fo-1">fo-1</a> </b>
1       不要在单字母单词后分行。如有可能，在它之前分行。
                                                        <b class="vimtag"> <a name="fo-]">fo-]</a> </b>
]       严格遵循 <a href="options.html#'textwidth'">'textwidth'</a> 选项。置位此标志位时，除非断行禁则
        (line-break-prohibition rules) 使得行长不可能保留在限定的文本宽度以
        内，行长不允许超出限定的文本宽度。此标志位主要用于 CJK 文本，并且仅在
        <a href="options.html#'encoding'">'encoding'</a> 是 "utf-8" 时才生效。
                                                        <b class="vimtag"> <a name="fo-j">fo-j</a> </b>
j       在合适的场合，连接行时删除注释前导符。例如，连接:
<code class="section">                int i;   // the index </code>
<code class="section">                         // in the list </code>
        结果是:
<code class="section">                int i;   // the index in the list </code>
                                                        <b class="vimtag"> <a name="fo-p">fo-p</a> </b>
p       不在句号后的单个空白上断行。它的目的是和 <a href="options.html#'joinspaces'">'joinspaces'</a> 和  <a href="options.html#cpo-J">cpo-J</a>  相补
        充，用于两个空格分隔的日常语句。例如，如果 <a href="options.html#'textwidth'">'textwidth'</a> 设为 28: 
<code class="example">                Surely you're joking, Mr. Feynman!</code>
        结果是: 
<code class="example">                Surely you're joking,</code>
<code class="example">                Mr. Feynman!</code>
        而不是: 
<code class="example">                Surely you're joking, Mr.</code>
<code class="example">                Feynman!</code>
<code class="example"></code>
<code class="example"></code>
't' 和 'c' 不同组合方式决定 Vim 何时进行自动回绕:
<code class="section">值      行为    </code>
""      没有自动排版 (你可以用 "gq" 进行手工排版)
"t"     自动排版文本，不包括注释
"c"     自动排版注释，不包括文本 (对 C 程序适用)
"tc"    自动排版文本和注释

<code class="note">注意</code> 如果 <a href="options.html#'textwidth'">'textwidth'</a> 为 0，Vim 不会做任何自动排版 (但是会根据 <a href="options.html#'comments'">'comments'</a> 选项
自动插入注释前导符)。但 'a' 标志位存在时有例外。 <a href="change.html#auto-format">auto-format</a> 

<code class="note">注意</code> 如果 <a href="options.html#'paste'">'paste'</a> 打开，Vim 也不会做任何排版。

<code class="note">注意</code> 即使 Vim 不做自动回绕，仍然可以把 <a href="options.html#'textwidth'">'textwidth'</a> 设为非零。<a href="options.html#'textwidth'">'textwidth'</a> 对
"gq" 的排版依然有用。

如果 <a href="options.html#'comments'">'comments'</a> 选项包含 "/*"、"*" 和/或 "*/"，Vim 有一套处理这些注释更加聪明
的内嵌方法。在 "/*" 或 "*/" 之前或之后开始一个新行 (在 <a href="options.html#'formatoptions'">'formatoptions'</a> 里有
'r' 或者 'o' 的情况下)，会自动给出正确的开始部分。排版或者自动回绕也会有相同的
处理。在以 "/*" 或者 "*" 开始并包含 "*/" 的行之后开启新行，就不会插入注释前导
符，而且新行的缩进由注释起始行决定。
例如: 
<code class="example">    /* ~</code>
<code class="example">     * 你的任何注释。</code>
<code class="example">     */ ~</code>
<code class="example">    该行的缩进和以上注释的起始行相同。</code>
<code class="example"></code>
上述这些应该已经十分够用了，尤其在与新的 :autocmd 命令协同使用时，可以为不同文
件类型提供不同的设置。

一些例子:
  适用于 C 代码 (只对注释排版): 
<code class="example">        :set fo=croq</code>
  适用于邮件/新闻 (排版所有文本，"o" 命令不开始注释): 
<code class="example">        :set fo=tcrq</code>


自动排版                                        <b class="vimtag"> <a name="auto-format">auto-format</a> </b> <b class="vimtag"> <a name="autoformat">autoformat</a> </b>

如果 <a href="options.html#'formatoptions'">'formatoptions'</a> 里包含 'a' 标志位，在插入或者删除文本时会自动进行排版。这
对编辑文本段落很好用。以下对如何使用这一功能提供一些提示:

- 你需要正确定义何谓段落。最简单的方式是以空行分隔的为段落。如果没有分隔的空
  行，考虑用 'w' 标志位并在段落中除了最后一行以外，每行结尾加上一个空格。

- 你可以根据文件类型  <a href="filetype.html#filetype">filetype</a> ， 或者用  <a href="options.html#modeline">modeline</a>  指定特定文件的方式，设置不
  同的 <a href="options.html#'formatoptions'">'formatoptions'</a>。

- 将 <a href="options.html#'formatoptions'">'formatoptions'</a> 设为 "aw2tq" 使得文本以如下方式缩进:

            bla bla foobar bla 
        bla foobar bla foobar bla
            bla bla foobar bla 
        bla foobar bla bla foobar

- 如果只想自动排版注释，加上 'c' 标志位。可用于源代码。

- 设置 <a href="options.html#'textwidth'">'textwidth'</a> 为你希望的宽度。如果为零，使用 79 或屏幕宽度中较小的那个。

还有一些<code class="note">警告</code>:

- 如果段落没有正确分隔，任何改变都会使得所有相连的文本自动排版。考虑 
<code class="example"></code>
<code class="example">        :set fo-=a</code>
<code class="example"></code>
- 如果用 'w' 标志位 (行尾的空格意味着段落的继续) 并且用  <a href="change.html#dd">dd</a>  删除了段落的末
  行，这段落自动和下一个段落合并为一个段落。

- 改变的文本被保存以备可能的撤销之用。排版也是改变的一种。所以每次排版都会为撤
  销保存文本。这会有相当的内存开销。

- 排版一个很长的段落和/或复杂的缩进也许会相当慢。

</section><hr class="doubleline" /><section class=inner>
<h4>7. 文本排序                                             <b class="vimtag"> <a name="sorting">sorting</a> </b></h4>
Vim 有排序函数和排序命令。排序函数可见:  <a href="builtin.html#sort()">sort()</a> ， <a href="builtin.html#uniq()">uniq()</a> 。
另见  <a href="change.html#:uniq">:uniq</a> 。

                                                        <b class="vimtag"> <a name=":sor">:sor</a> </b> <b class="vimtag"> <a name=":sort">:sort</a> </b>
:<code class="special">[range]</code>sor[t][!] <code class="special">[b]</code>[f][i][l][n][o][r][u][x] [/<code class="special">{pattern}</code>/]
                        给 <code class="special">[range]</code> 里的行排序。如果没有给出行范围，给所有行排
                        序。

                        带 [!] 则反向排序。

                        带 <code class="special">[i]</code> 则忽略大小写。
                                                        <b class="vimtag"> <a name=":sort-l">:sort-l</a> </b>
                        带 <code class="special">[l]</code> 时排序使用当前排序规则 locale。
                        实现细节: 用 strcoll() 来进行字符串比较。关于如何查看
                        或设置排序规则 locale，参见  <a href="mlang.html#:language">:language</a> 。例如: 
<code class="example">                                :language collate en_US.UTF-8</code>
<code class="example">                                :%sort l</code>
                         <a href="eval.html#v:collate">v:collate</a>  也可用于检查当前 locale。
                        按 locale 的排序通常忽略大小写。
                        Mac 上此功能不能正常工作。

                        选项 <code class="special">[n]</code>[f][x][o][b] 互斥。

                        带 <code class="special">[n]</code> 则排序基于每行的首个十进制数 (在 <code class="special">{pattern}</code> 匹配
                        之后或之内)。
                        数值包含前导的 '-'。

                        带 <code class="special">[f]</code> 则排序基于每行内的浮点数。浮点值相当于在文本
                        (<code class="special">{pattern}</code> 匹配的之后或之内) 上调用 str2float() 函数的
                        结果。仅当 Vim 编译时加入浮点数支持时该标志位才有效。

                        带 <code class="special">[x]</code> 则排序基于每行的首个十六进制数 (在 <code class="special">{pattern}</code> 匹
                        配之后或之内)。忽略引导的 "0x" 或 "0X"。
                        数值包含前导的 '-'。

                        带 <code class="special">[o]</code> 则排序基于每行的首个八进制数 (在 <code class="special">{pattern}</code> 匹配
                        之后或之内)。

                        带 <code class="special">[b]</code> 则排序基于每行的首个二进制数 (在 <code class="special">{pattern}</code> 匹配
                        之后或之内)。
                                                        <b class="vimtag"> <a name=":sort-u">:sort-u</a> </b> <b class="vimtag"> <a name=":sort-uniq">:sort-uniq</a> </b>
                        带 <code class="special">[u]</code> (u 代表 unique 唯一) 则只保留完全相同的行的第一
                        行 (如果带 <code class="special">[i]</code>，忽略大小写的区别)。
                        没有这个标志位，完全相同的行的序列会按照它们原来的顺序
                        被保留下来。
                        <code class="note">注意</code> 引导和拖尾的空白差异会导致不相同的行。
                        如果只想去除重复，可用  <a href="change.html#:uniq">:uniq</a> 。

                        如果指定 /<code class="special">{pattern}</code>/ 并且没有 <code class="special">[r]</code> 标志位，跳过匹配
                        <code class="special">{pattern}</code> 的文本，使得排序在匹配之后的内容上进行。
                        模式适用 <a href="options.html#'ignorecase'">'ignorecase'</a>，但不使用 <a href="options.html#'smartcase'">'smartcase'</a>。
                        除了斜杠，任何非字母的字符也都可以。
                        例如，要按第二个逗号分隔的字段排序: 
<code class="example">                                :sort /[^,]*,/</code>
                        按虚拟第 10 列的文本排序 (从而忽略制表和空格的区别): 
<code class="example">                                :sort /.*\%10v/</code>
                        按每行的首个数值排序，不管它前面有什么: 
<code class="example">                                :sort /.\{-}\ze\d/</code>
                        (说明: ".\<code class="special">{-}</code>" 匹配任何文本，"\ze" 设置匹配结束位置，
                        \d 匹配单个数位。)
                        带 <code class="special">[r]</code> 则排序在匹配 <code class="special">{pattern}</code> 的文本上进行，而不是如上
                        所述的用它之后的文本。
                        例如，要按每行的前三个字母排序且只看这三个字母: 
<code class="example">                                :sort /\a\a\a/ r</code>
<code class="example"></code>
                        如果使用 <code class="special">{pattern}</code>，不匹配 <code class="special">{pattern}</code> 的行按照它们原来
                        的顺序被保留，但和匹配 <code class="special">{pattern}</code> 的行分开。如果反向排
                        序，它们会以反向顺序出现，并在排序好的行之后。否则它们
                        会以原有顺序出现，在排序好的行之前。

                        如果 <code class="special">{pattern}</code> 为空 (例如指定 //)，则使用最近使用的搜
                        索模式。这样你可以先试好模式，然后在执行。

<code class="note">注意</code>  <a href="change.html#:sort">:sort</a>  和  <a href="repeat.html#:global">:global</a>  一起使用并不能对匹配的行进行排序，这样做没有意义。

除非使用 l 标志位， <a href="change.html#:sort">:sort</a>  不使用当前 locale。Vim 保证 "稳定" 排序。

排序可以被中断，但在整个过程里如果中断得太晚，最后可能会出现重复的行。这取决于
使用的系统库函数。

</section><hr class="doubleline" /><section class=inner>
<h4>8. 文本去重                                     <b class="vimtag"> <a name="deduplicating">deduplicating</a> </b> <b class="vimtag"> <a name="unique">unique</a> </b></h4>
Vim 有去重函数和去重命令。去重函数可见:  <a href="builtin.html#uniq()">uniq()</a> 。
另见  <a href="change.html#:sort-uniq">:sort-uniq</a> 。

                                                        <b class="vimtag"> <a name=":uni">:uni</a> </b> <b class="vimtag"> <a name=":uniq">:uniq</a> </b>
:<code class="special">[range]</code>uni[q][!] <code class="special">[i]</code>[l][r][u] [/<code class="special">{pattern}</code>/]
                        删除 <code class="special">[range]</code> 里相邻的重复行。未指定范围则处理所有行。

                        带 <code class="special">[i]</code> 则忽略大小写。

                        带 <code class="special">[l]</code> 时比较使用当前排序规则 locale。
                        详见  <a href="change.html#:sort-l">:sort-l</a> 。

                        带 <code class="special">[r]</code> 则比较在匹配 <code class="special">{pattern}</code> 的文本上进行，而不是整
                        行。

                        带 <code class="special">[u]</code> 则只保留不重复的行 (即不立即紧跟相同行的那些
                        行)。

                        带 [!] 则只保留立即紧跟重复行的那些行。

                        同时给出 [!] 和 <code class="special">[u]</code> 时，忽略 <code class="special">[u]</code>，只有 [!] 生效。

                        如果指定 /<code class="special">{pattern}</code>/ 并且没有 <code class="special">[r]</code> 标志位，跳过匹配
                        <code class="special">{pattern}</code> 的文本，使得比较在匹配之后的内容上进行。
                        模式适用 <a href="options.html#'ignorecase'">'ignorecase'</a>，但不使用 <a href="options.html#'smartcase'">'smartcase'</a>。
                        除了斜杠，任何非字母的字符也都可以。

                        例如，要按第二个逗号分隔的字段去重: 
<code class="example">                                :uniq /[^,]*,/</code>
                        要只保留忽略前 5 个字符的不重复行: 
<code class="example">                                :uniq u /.\{5}/</code>
                        如果 <code class="special">{pattern}</code> 为空 (例如指定 //)，则使用最近使用的搜
                        索模式。

                        <code class="note">注意</code> 引导和拖尾的空白差异会导致不相同的行。
                        要删除任何位置的重复内容，可用  <a href="change.html#:sort-u">:sort-u</a>  或外部工具。

 vim:tw=78:ts=8:noet:ft=help:norl:
</section>
</article>
<footer>
Generated by vim2html
</footer>
</body>
</html>
