<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<![endif]-->
<title>VIM 中文帮助: 当事件发生时自动执行命令</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css" />
<link rel="canonical" href="https://yianwillis.github.io/vimcdoc/doc/autocmd.html" />
<script type="text/javascript" src="vimcdoc.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
<nav id=banner>
<form action=tags.html target="tag_iframe">
  <input type="text" name="tag" id="tag" placeholder="标签搜索">
</form>
<iframe name="tag_iframe" src=""></iframe>
<a href="help.html">帮助总览</a> &middot;
<hr/>
<a href="quickref.html">快速参考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="eval.html#functions">函数列表</a> &middot;
<a href="quickref.html#option-list">选项列表</a> &middot;
<hr/>
<a href="usr_toc.html">用户手册</a> &middot;
<a href="help.html#reference_toc">参考手册</a> &middot;
</nav>

<header>
<h2>autocmd</h2>
</header>
<article id=outer>
<section class=inner>
<b class="vimtag"> <a name="autocmd.txt">autocmd.txt</a> </b>   适用于 Vim 9.1 版本。   最近更新: 2025年9月


                  <code class="vim">VIM 参考手册    by Bram Moolenaar</code>
                                <code class="vim">译者</code>: Willis


自动命令                                        <b class="vimtag"> <a name="autocommand">autocommand</a> </b> <b class="vimtag"> <a name="autocommands">autocommands</a> </b>

一个基本的介绍可以在用户手册的  <a href="usr_40.html#40.3">40.3</a>  章节找到。

1.  简介                         <a href="autocmd.html#autocmd-intro">autocmd-intro</a> 
2.  定义自动命令                 <a href="autocmd.html#autocmd-define">autocmd-define</a> 
3.  删除自动命令                 <a href="autocmd.html#autocmd-remove">autocmd-remove</a> 
4.  列出自动命令                 <a href="autocmd.html#autocmd-list">autocmd-list</a> 
5.  事件                         <a href="autocmd.html#autocmd-events">autocmd-events</a> 
6.  模式                         <a href="autocmd.html#autocmd-patterns">autocmd-patterns</a> 
7.  局部于缓冲区的自动命令       <a href="autocmd.html#autocmd-buflocal">autocmd-buflocal</a> 
8.  组                           <a href="autocmd.html#autocmd-groups">autocmd-groups</a> 
9.  执行自动命令                 <a href="autocmd.html#autocmd-execute">autocmd-execute</a> 
10. 自动命令的使用               <a href="autocmd.html#autocmd-use">autocmd-use</a> 
11. 屏蔽自动命令                 <a href="autocmd.html#autocmd-disable">autocmd-disable</a> 


</section><hr class="doubleline" /><section class=inner>
<h4>1. 简介                                                 <b class="vimtag"> <a name="autocmd-intro">autocmd-intro</a> </b></h4>
在文件读写，缓冲区或窗口进出，甚至 Vim 退出等时刻，你都可以指定要自动执行的命
令。例如，你可以创建一个自动命令，对匹配 *.c 的文件自动置位 <a href="options.html#'cindent'">'cindent'</a> 选项。你
还可以用自动命令来实现诸如编辑压缩文件 (见  <a href="autocmd.html#gzip-example">gzip-example</a> ) 等的高级特性。一般
来说，自动命令在 .vimrc 或 .exrc 文件里设置。

                                <b class="vimtag"> <a name="E203">E203</a> </b> <b class="vimtag"> <a name="E204">E204</a> </b> <b class="vimtag"> <a name="E143">E143</a> </b> <b class="vimtag"> <a name="E855">E855</a> </b> <b class="vimtag"> <a name="E937">E937</a> </b> <b class="vimtag"> <a name="E952">E952</a> </b>
<code class="note">警告</code>: 自动命令功能强大，甚至会导致意想不到的副作用。小心你的文本不要遭到破坏。
- 最好能先在一个能够牺牲的副本上进行测试。
  例如: 如果你使用自动命令在文件开始编辑时进行解压，应确保写回时能正确执行压缩
  的自动命令。
- 准备好中途出现的错误 (例如，磁盘没有空间)。Vim 通常能够撤销缓冲区里的改动，
  但文件的其他方面改动需要你手动清理 (例如，压缩被解压的文件)。
- 如果 BufRead* 等事件允许你编辑一个压缩文件，FileRead* 等事件应该完成同样的操
  作 (这使得在一些特殊情况下内容可以恢复)。如果可能，尽量用相同的自动命令处理
  File* 和 Buf* 事件。

建议用法:
- 总是使用自动命令组，方便需要时自动命令的删除。
- 保持命令本身简短，繁重工作可用函数完成。
- 确保定义所在的脚本被重复执行时，自动命令不会被重复。

Vim9 脚本示例: 
<code class="example">   autocmd_add([{replace: true,</code>
<code class="example">                group:   'DemoGroup',</code>
<code class="example">                event:   'BufEnter',</code>
<code class="example">                pattern: '*.txt',</code>
<code class="example">                cmd:     'call DemoBufEnter()'</code>
<code class="example">                }])</code>
<code class="example"></code>
老式脚本示例: 
<code class="example">   call autocmd_add([#{replace: v:true,</code>
<code class="example">                    \ group: 'DemoGroup',</code>
<code class="example">                    \ event: 'BufEnter',</code>
<code class="example">                    \ pattern: '*.txt',</code>
<code class="example">                    \ cmd: 'call DemoBufEnter()'</code>
<code class="example">                    \ }])</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>2. 定义自动命令                                         <b class="vimtag"> <a name="autocmd-define">autocmd-define</a> </b></h4>
                                                        <b class="vimtag"> <a name=":au">:au</a> </b> <b class="vimtag"> <a name=":autocmd">:autocmd</a> </b>
:au[tocmd] <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">{aupat}</code> [++once] [++nested] <code class="special">{cmd}</code>
                        把 <code class="special">{cmd}</code> 加到 Vim 匹配 <code class="special">{aupat}</code> 模式的文件执行 <code class="special">{event}</code>
                        事件时自动执行的命令列表。见  <a href="autocmd.html#autocmd-patterns">autocmd-patterns</a> 。
                        这里的 <code class="special">{event}</code> 不能是 "*"。  <b class="vimtag"> <a name="E1155">E1155</a> </b>
                        <code class="note">注意</code>: 引号视为 :autocmd 的参数而非注释的引导。
                        Vim 总把 <code class="special">{cmd}</code> 加到已有的自动命令之后，这样保证自动命
                        令的执行顺序与其定义的顺序相同。
                        关于 [++nested]，参见  <a href="autocmd.html#autocmd-nested">autocmd-nested</a> 。为了后向兼容，
                        也可用 "nested" (没有 ++)，但  <a href="vim9.html#Vim9">Vim9</a>  脚本里不可以。
                        <b class="vimtag"> <a name="E1078">E1078</a> </b>
                                                        <b class="vimtag"> <a name="autocmd-once">autocmd-once</a> </b>
                        如果给出 [++once]，命令执行一次，然后删除 ("一次性")。

特殊模式 <code class="special">&lt;buffer&gt;</code> 或 &lt;buffer=N&gt; 定义局部于缓冲区的自动命令。见
 <a href="autocmd.html#autocmd-buflocal">autocmd-buflocal</a> 。

如果  <a href="autocmd.html#:autocmd">:autocmd</a>  出现在 Vim9 脚本中 ( <a href="repeat.html#:vim9script">:vim9script</a>  开始的脚本并在  <a href="vim9.html#:def">:def</a>  函数里
定义)，那么 <code class="special">{cmd}</code> 会在 Vim9 脚本环境下运行。此处取决于 autocmd 定义所在的位置
而不是其触发的位置。
                                                        <b class="vimtag"> <a name=":autocmd-block">:autocmd-block</a> </b>
类似于  <a href="map.html#:command">:command</a> ，<code class="special">{cmd}</code> 可为命令块，参见  <a href="map.html#:command-repl">:command-repl</a> 。示例: 
<code class="example">        au BufReadPost *.xml {</code>
<code class="example">                  setlocal matchpairs+=&lt;:&gt;</code>
<code class="example">                  /&lt;start</code>
<code class="example">                }</code>
<code class="example"></code>
在 Vim 脚本里可用  <a href="builtin.html#autocmd_add()">autocmd_add()</a>  函数来新增一组自动命令和自动命令组。需要在
 <a href="autocmd.html#:autocmd">:autocmd</a>  里使用  <a href="eval.html#:execute">:execute</a>  时，这个方法更好。

<code class="note">注意</code>: 要在 ":autocmd" 命令之后紧跟其他命令，'|' 必须在期待模式出现的地方出现。
可以这样: 
<code class="example">        :augroup mine | au! BufRead | augroup END</code>
但下列命令会把 "augroup" 视为所定义命令的一部分: 
<code class="example">        :augroup mine | au! BufRead * | augroup END</code>
<code class="example">        :augroup mine | au BufRead * set tw=70 | augroup END</code>
正确的方法应把组名放在命令里: 
<code class="example">        :au! mine BufRead *</code>
<code class="example">        :au mine BufRead * set tw=70</code>
或者用  <a href="eval.html#:execute">:execute</a> : 
<code class="example">        :augroup mine | exe "au! BufRead *" | augroup END</code>
<code class="example">        :augroup mine | exe "au BufRead * set tw=70" | augroup END</code>
<code class="example"></code>
                                                        <b class="vimtag"> <a name="autocmd-expand">autocmd-expand</a> </b>
<code class="note">注意</code> ":autocmd" 的参数里的特殊字符 (例如，"%"、"<code class="special">&lt;cword&gt;</code>") 在定义时不会被扩展，
而是在事件发生并执行 <code class="special">{cmd}</code> 的时候才进行。唯一的例外是 "<code class="special">&lt;sfile&gt;</code>" 在定义时扩展。
例如:

<code class="example">        :au BufNewFile,BufRead *.html so &lt;sfile&gt;:h/html.vim</code>
<code class="example"></code>
这里 Vim 把 <code class="special">&lt;sfile&gt;</code> 扩展为该行所在的文件名。不过，<code class="special">&lt;sfile&gt;</code> 在函数里的用法不同，
为此，最好用  <a href="eval.html#:execute">:execute</a>  带 <code class="special">&lt;script&gt;</code> 来达到相同的效果:

<code class="example">        :exe $'au BufNewFile,BufRead *.html so {expand("&lt;script&gt;:h")}/html.vim'</code>
<code class="example"></code>
即使已经执行过，:autocmd 仍会把同一命令加入自动命令列表。如果你的 .vimrc 被执
行两次，自动命令就会出现两次。要避免这个问题，在一个组里定义自动命令，这样方便
清除之前的命令: 
<code class="example"></code>
<code class="example">        augroup vimrc</code>
<code class="example">          " 清除 vimcrc 组全部的的自动命令</code>
<code class="example">          autocmd!</code>
<code class="example">          au BufNewFile,BufRead *.html so &lt;sfile&gt;:h/html.vim</code>
<code class="example">        augroup END</code>
<code class="example"></code>
如果你不想删除所有的自动命令，可以用变量来确保 Vim 只定义自动命令一次: 
<code class="example"></code>
<code class="example">        :if !exists("autocommands_loaded")</code>
<code class="example">        :  let autocommands_loaded = 1</code>
<code class="example">        :  au ...</code>
<code class="example">        :endif</code>
<code class="example"></code>
如果没有给定 <code class="special">{group}</code> 参数，Vim 使用当前组 (由 ":augroup" 定义)；不然，Vim 使用
<code class="special">{group}</code> 定义的组。<code class="note">注意</code> 该 <code class="special">[group]</code> 必须事先定义。定义新组不能用 ":au group ..."
而应该用 ":augroup"。

测试自动命令时，你也许会发现 <a href="options.html#'verbose'">'verbose'</a> 选项很有用: 
<code class="example">        :set verbose=9</code>
这个设置使得 Vim 在执行自动命令时回显之。

在脚本里定义自动命令时，可以调用局部于脚本的函数或者使用局部于脚本的映射。在事
件触发并执行相应命令时，该命令在定义脚本的上下文内执行。如果命令里用到
 <a href="map.html#%3CSID%3E">&lt;SID&gt;</a> ，这一点很重要。

执行命令时，某个命令的消息覆盖前一个的。这和手动执行命令不同。通常，屏幕不会滚
动，所以也不会有按-回车的提示。但当一个命令输出两条消息时，这仍会发生。

</section><hr class="doubleline" /><section class=inner>
<h4>3. 删除自动命令                                         <b class="vimtag"> <a name="autocmd-remove">autocmd-remove</a> </b></h4>
除了以下命令以外，Vim 脚本里也可用  <a href="builtin.html#autocmd_delete()">autocmd_delete()</a>  函数来删除一组自动命令和
自动命令组。

:au[tocmd]! <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">{aupat}</code> [++once] [++nested] <code class="special">{cmd}</code>
                        删除所有和 <code class="special">{event}</code> 事件和 <code class="special">{aupat}</code> 模式相关联的自动命
                        令，然后加入命令 <code class="special">{cmd}</code>。
                        关于 [++once]，参见  <a href="autocmd.html#autocmd-once">autocmd-once</a> 。
                        关于 [++nested]，参见  <a href="autocmd.html#autocmd-nested">autocmd-nested</a> 。

:au[tocmd]! <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">{aupat}</code>
                        删除所有和 <code class="special">{event}</code> 事件和 <code class="special">{aupat}</code> 模式相关联的自动命
                        令。

:au[tocmd]! <code class="special">[group]</code> * <code class="special">{aupat}</code>
                        删除所有和 <code class="special">{aupat}</code> 模式相关联的自动命令。

:au[tocmd]! <code class="special">[group]</code> <code class="special">{event}</code>
                        删除所有和 <code class="special">{event}</code> 事件相关联的自动命令。
                        <code class="note">警告</code>: 没有给出组时，不要轻易用本命令对 BufRead 和其它
                        常用事件进行操作，可能会对插件、语法高亮等产生破坏。

:au[tocmd]! <code class="special">[group]</code>     删除所有的自动命令。
                        <code class="note">注意</code>: 引号视为 :autocmd 的参数而非注释的引导。
                        <code class="note">警告</code>: 没有给出组时，不要轻易用本命令，会对插件、语法高
                        亮等产生破坏。

如果没有给出 <code class="special">{group}</code> 参数，Vim 使用当前组 (由 ":augroup" 定义)；不然，Vim 使用
<code class="special">{group}</code> 定义的组。

</section><hr class="doubleline" /><section class=inner>
<h4>4. 列出自动命令                                         <b class="vimtag"> <a name="autocmd-list">autocmd-list</a> </b></h4>
:au[tocmd] <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">{aupat}</code>
                        显示所有和 <code class="special">{event}</code> 事件和 <code class="special">{aupat}</code> 模式相关联的自动命
                        令。

:au[tocmd] <code class="special">[group]</code> * <code class="special">{aupat}</code>
                        显示所有和 <code class="special">{aupat}</code> 模式相关联的自动命令。

:au[tocmd] <code class="special">[group]</code> <code class="special">{event}</code>
                        显示所有和 <code class="special">{event}</code> 事件相关联的自动命令。

:au[tocmd] <code class="special">[group]</code>      显示所有自动命令。

如果给出 <code class="special">{group}</code> 参数，Vim 只列出 <code class="special">[group]</code> 里的自动命令；不然，Vim 列出 <code class="emphasis">所有</code> 组
里的自动命令。<code class="note">注意</code> 此处该参数的行为和定义与删除自动命令时的不同。

要列出局部于缓冲区的自动命令，使用如下形式的模式 <code class="special">&lt;buffer&gt;</code> 或 &lt;buffer=N&gt;。见
 <a href="autocmd.html#autocmd-buflocal">autocmd-buflocal</a> 。

Vim 脚本里可用  <a href="builtin.html#autocmd_get()">autocmd_get()</a>  函数来获取自动函数列表。

                                                        <b class="vimtag"> <a name=":autocmd-verbose">:autocmd-verbose</a> </b>
如果 <a href="options.html#'verbose'">'verbose'</a> 非空，列出自动命令同时显示该自动命令最近修改的位置。例如: 
<code class="example"></code>
<code class="example">    :verbose autocmd BufEnter</code>
<code class="example">    FileExplorer  BufEnter</code>
<code class="example">        *         call s:LocalBrowse(expand("&lt;amatch&gt;"))</code>
<code class="example">            Last set from /usr/share/vim/vim-7.0/plugin/NetrwPlugin.vim</code>

详见  <a href="various.html#:verbose-cmd">:verbose-cmd</a> 。

</section><hr class="doubleline" /><section class=inner>
<h4>5. 事件                                         <b class="vimtag"> <a name="autocmd-events">autocmd-events</a> </b> <b class="vimtag"> <a name="E215">E215</a> </b> <b class="vimtag"> <a name="E216">E216</a> </b></h4>
你可以指定逗号分隔的事件名列表。此列表中不能有空格。该命令应用于列表里的所有事
件。

 <code class="emphasis">文件读入</code> 时，有四类可能的事件:
        BufNewFile                      开始编辑一个还不存在的文件
        BufReadPre      BufReadPost     开始编辑一个已经存在的文件
        FilterReadPre   FilterReadPost  读取过滤程序输出的暂存文件
        FileReadPre     FileReadPost    任何别的文件读入
Vim 读入文件时，只用这四类中的一类。"Pre" 和 "Post" 事件被双双触发，分别在文件
读取的前后。

<code class="note">注意</code> *ReadPre 和所有的过滤事件的自动命令不能更换当前缓冲区 (如果你这么做，会得
到错误信息)。可用来防止文件被读入错误的缓冲区。

<code class="note">注意</code> 执行完 BufReadPost 和 BufNewFile 自动命令 <code class="emphasis">之后</code> 复位 <a href="options.html#'modified'">'modified'</a> 标志位，但
如果自动命令已经置位了 <a href="options.html#'modified'">'modified'</a> 选项除外。

你可以使用 <a href="options.html#'eventignore'">'eventignore'</a> 选项来忽略若干甚至全部事件。
                                        <b class="vimtag"> <a name="autocommand-events">autocommand-events</a> </b> <b class="vimtag"> <a name="{event}">{event}</a> </b>
Vim 识别以下事件，事件名的大小写被忽略 (例如，你可以使用 "BUFread" 或者
"bufread" 来取代 "BufRead")。

这里首先提供功能的总览并提供简短说明。然后，按字母顺序列出它们的详细解释
 <a href="autocmd.html#autocmd-events-abc">autocmd-events-abc</a> 。

<code class="section">名字                    触发条件 </code>

        读入
 <a href="autocmd.html#BufNewFile">BufNewFile</a>             开始编辑尚不存在的文件
 <a href="autocmd.html#BufReadPre">BufReadPre</a>             开始编辑新缓冲区，读入文件前
 <a href="autocmd.html#BufRead">BufRead</a>                开始编辑新缓冲区，读入文件后
 <a href="autocmd.html#BufReadPost">BufReadPost</a>            开始编辑新缓冲区，读入文件后
 <a href="autocmd.html#BufReadCmd">BufReadCmd</a>             开始编辑新缓冲区前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#FileReadPre">FileReadPre</a>            用 ":read" 命令读入文件前
 <a href="autocmd.html#FileReadPost">FileReadPost</a>           用 ":read" 命令读入文件后
 <a href="autocmd.html#FileReadCmd">FileReadCmd</a>            用 ":read" 命令读入文件前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#FilterReadPre">FilterReadPre</a>          用过滤命令读入文件前
 <a href="autocmd.html#FilterReadPost">FilterReadPost</a>         用过滤命令读入文件后

 <a href="autocmd.html#StdinReadPre">StdinReadPre</a>           从标准输入读入缓冲区前
 <a href="autocmd.html#StdinReadPost">StdinReadPost</a>          从标准输入读入缓冲区后

        写回
 <a href="autocmd.html#BufWrite">BufWrite</a>               开始把整个缓冲区写回到文件
 <a href="autocmd.html#BufWritePre">BufWritePre</a>            开始把整个缓冲区写回到文件
 <a href="autocmd.html#BufWritePost">BufWritePost</a>           把整个缓冲区写回到文件后
 <a href="autocmd.html#BufWriteCmd">BufWriteCmd</a>            把整个缓冲区写回到文件前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#FileWritePre">FileWritePre</a>           开始把缓冲区部分内容写回到文件
 <a href="autocmd.html#FileWritePost">FileWritePost</a>          把缓冲区部分内容写回到文件后
 <a href="autocmd.html#FileWriteCmd">FileWriteCmd</a>           把缓冲区部分内容写回到文件前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#FileAppendPre">FileAppendPre</a>          开始附加到文件
 <a href="autocmd.html#FileAppendPost">FileAppendPost</a>         附加到文件后
 <a href="autocmd.html#FileAppendCmd">FileAppendCmd</a>          附加到文件前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#FilterWritePre">FilterWritePre</a>         开始为过滤命令或 diff 写到文件
 <a href="autocmd.html#FilterWritePost">FilterWritePost</a>        为过滤命令或 diff 写到文件后

        缓冲区
 <a href="autocmd.html#BufAdd">BufAdd</a>                 刚把缓冲区附加到缓冲区列表后
 <a href="autocmd.html#BufCreate">BufCreate</a>              刚把缓冲区附加到缓冲区列表后
 <a href="autocmd.html#BufDelete">BufDelete</a>              从缓冲区列表删除缓冲区前
 <a href="autocmd.html#BufWipeout">BufWipeout</a>             从缓冲区列表完全删除缓冲区前

 <a href="autocmd.html#BufFilePre">BufFilePre</a>             改变当前缓冲区名字前
 <a href="autocmd.html#BufFilePost">BufFilePost</a>            改变当前缓冲区名字后

 <a href="autocmd.html#BufEnter">BufEnter</a>               进入缓冲区后
 <a href="autocmd.html#BufLeave">BufLeave</a>               转到其它缓冲区前
 <a href="autocmd.html#BufWinEnter">BufWinEnter</a>            在窗口显示缓冲区前
 <a href="autocmd.html#BufWinLeave">BufWinLeave</a>            从窗口删除缓冲区前

 <a href="autocmd.html#BufUnload">BufUnload</a>              卸载缓冲区前
 <a href="autocmd.html#BufHidden">BufHidden</a>              刚把缓冲区变为隐藏前
 <a href="autocmd.html#BufNew">BufNew</a>                 刚建立新缓冲区后

 <a href="autocmd.html#SwapExists">SwapExists</a>             检测到交换文件已经存在

        选项
 <a href="autocmd.html#FileType">FileType</a>               设置 <a href="options.html#'filetype'">'filetype'</a> 选项时
 <a href="autocmd.html#Syntax">Syntax</a>                 设置 <a href="options.html#'syntax'">'syntax'</a> 选项时
 <a href="autocmd.html#EncodingChanged">EncodingChanged</a>        <a href="options.html#'encoding'">'encoding'</a> 选项改变后
 <a href="autocmd.html#TermChanged">TermChanged</a>            <a href="options.html#'term'">'term'</a> 的值改变后
 <a href="autocmd.html#OptionSet">OptionSet</a>              设置任何选项后

        启动和退出
 <a href="autocmd.html#VimEnter">VimEnter</a>               完成所有的初始化步骤后
 <a href="autocmd.html#GUIEnter">GUIEnter</a>               成功启动 GUI 后
 <a href="autocmd.html#GUIFailed">GUIFailed</a>              启动 GUI 失败之后
 <a href="autocmd.html#TermResponse">TermResponse</a>           收到  <a href="term.html#t_RV">t_RV</a>  的终端应答后
 <a href="autocmd.html#TermResponseAll">TermResponseAll</a>        收到  <a href="term.html#t_RV">t_RV</a>  及其他的终端应答后

 <a href="autocmd.html#QuitPre">QuitPre</a>                用  <a href="editing.html#:quit">:quit</a>  时，决定是否退出之前
 <a href="autocmd.html#ExitPre">ExitPre</a>                用可使 Vim 退出的命令时
 <a href="autocmd.html#VimLeavePre">VimLeavePre</a>            退出 Vim 前，在写入 viminfo 文件之前
 <a href="autocmd.html#VimLeave">VimLeave</a>               退出 Vim 前，在写入 viminfo 文件之后

 <a href="autocmd.html#VimSuspend">VimSuspend</a>             暂停 Vim 时
 <a href="autocmd.html#VimResume">VimResume</a>              Vim 在暂停后恢复运行时

        终端
 <a href="autocmd.html#TerminalOpen">TerminalOpen</a>           建立终端缓冲区后
 <a href="autocmd.html#TerminalWinOpen">TerminalWinOpen</a>        在新窗口建立终端缓冲区后

        杂项
 <a href="autocmd.html#FileChangedShell">FileChangedShell</a>       Vim <code class="note">注意</code>到文件在编辑开始后被改变
 <a href="autocmd.html#FileChangedShellPost">FileChangedShellPost</a>   对在编辑开始后被改变的文件的处理完成后
 <a href="autocmd.html#FileChangedRO">FileChangedRO</a>          对只读文件进行第一次修改前

 <a href="autocmd.html#DiffUpdated">DiffUpdated</a>            刷新比较结果后
 <a href="autocmd.html#DirChangedPre">DirChangedPre</a>          工作目录改变前
 <a href="autocmd.html#DirChanged">DirChanged</a>             工作目录改变后

 <a href="autocmd.html#ShellCmdPost">ShellCmdPost</a>           执行外壳命令后
 <a href="autocmd.html#ShellFilterPost">ShellFilterPost</a>        用外壳命令执行完过滤后

 <a href="autocmd.html#CmdUndefined">CmdUndefined</a>           调用没有定义的用户命令
 <a href="autocmd.html#FuncUndefined">FuncUndefined</a>          调用没有定义的用户函数
 <a href="autocmd.html#SpellFileMissing">SpellFileMissing</a>       使用不存在的拼写文件
 <a href="autocmd.html#SourcePre">SourcePre</a>              执行 Vim 脚本之前
 <a href="autocmd.html#SourcePost">SourcePost</a>             执行 Vim 脚本之后
 <a href="autocmd.html#SourceCmd">SourceCmd</a>              执行 Vim 脚本之前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#VimResized">VimResized</a>             Vim 窗口大小改变后
 <a href="autocmd.html#FocusGained">FocusGained</a>            Vim 得到输入焦点
 <a href="autocmd.html#FocusLost">FocusLost</a>              Vim 失去输入焦点
 <a href="autocmd.html#CursorHold">CursorHold</a>             用户有一段时间没有按键
 <a href="autocmd.html#CursorHoldI">CursorHoldI</a>            在插入模式下，用户有一段时间没有按键
 <a href="autocmd.html#CursorMoved">CursorMoved</a>            普通模式下移动了光标
 <a href="autocmd.html#CursorMovedC">CursorMovedC</a>            <a href="cmdline.html#Command-line">Command-line</a>  下移动了光标
 <a href="autocmd.html#CursorMovedI">CursorMovedI</a>           插入模式下移动了光标

 <a href="autocmd.html#WinNewPre">WinNewPre</a>              创建新窗口前
 <a href="autocmd.html#WinNew">WinNew</a>                 创建新窗口后
 <a href="autocmd.html#TabNew">TabNew</a>                 创建新标签页后
 <a href="autocmd.html#WinClosed">WinClosed</a>              关闭窗口后
 <a href="autocmd.html#TabClosed">TabClosed</a>              关闭标签页后
 <a href="autocmd.html#TabClosedPre">TabClosedPre</a>           关闭标签页前
 <a href="autocmd.html#WinEnter">WinEnter</a>               进入其它窗口后
 <a href="autocmd.html#WinLeave">WinLeave</a>               离开窗口前
 <a href="autocmd.html#TabEnter">TabEnter</a>               进入其它标签页后
 <a href="autocmd.html#TabLeave">TabLeave</a>               离开标签页前
 <a href="autocmd.html#CmdwinEnter">CmdwinEnter</a>            进入命令行窗口后
 <a href="autocmd.html#CmdwinLeave">CmdwinLeave</a>            离开命令行窗口前

 <a href="autocmd.html#CmdlineChanged">CmdlineChanged</a>         命令行文本发生改变后
 <a href="autocmd.html#CmdlineEnter">CmdlineEnter</a>           光标移到命令行后
 <a href="autocmd.html#CmdlineLeave">CmdlineLeave</a>           光标离开命令行前
 <a href="autocmd.html#CmdlineLeavePre">CmdlineLeavePre</a>        准备离开命令行前

 <a href="autocmd.html#InsertEnter">InsertEnter</a>            开始插入模式前
 <a href="autocmd.html#InsertChange">InsertChange</a>           在插入或替换模式下输入 <code class="special">&lt;Insert&gt;</code> 时
 <a href="autocmd.html#InsertLeave">InsertLeave</a>            离开插入模式时
 <a href="autocmd.html#InsertLeavePre">InsertLeavePre</a>         离开插入模式前
 <a href="autocmd.html#InsertCharPre">InsertCharPre</a>          插入模式输入每个字符前

 <a href="autocmd.html#ModeChanged">ModeChanged</a>            改变模式后

 <a href="autocmd.html#TextChanged">TextChanged</a>            普通模式中对文本进行改变后
 <a href="autocmd.html#TextChangedI">TextChangedI</a>           弹出菜单不可见时，插入模式中对文本进行改变后
 <a href="autocmd.html#TextChangedP">TextChangedP</a>           弹出菜单可见时，插入模式中对文本进行改变后
 <a href="autocmd.html#TextChangedT">TextChangedT</a>           终端模式中对文本进行改变后
 <a href="autocmd.html#TextYankPost">TextYankPost</a>           文本抽出或删除后

 <a href="autocmd.html#SafeState">SafeState</a>              没有任何待定字符，等待用户键入字符
 <a href="autocmd.html#SafeStateAgain">SafeStateAgain</a>         重复出现 的 SafeState

 <a href="autocmd.html#ColorSchemePre">ColorSchemePre</a>         载入色彩方案前
 <a href="autocmd.html#ColorScheme">ColorScheme</a>            载入色彩方案后

 <a href="autocmd.html#RemoteReply">RemoteReply</a>            得到了 Vim 服务器的应答

 <a href="autocmd.html#QuickFixCmdPre">QuickFixCmdPre</a>         执行快速修复命令前
 <a href="autocmd.html#QuickFixCmdPost">QuickFixCmdPost</a>        执行快速修复命令后

 <a href="autocmd.html#SessionLoadPost">SessionLoadPost</a>        载入会话文件后

 <a href="autocmd.html#SessionWritePost">SessionWritePost</a>       用  <a href="starting.html#:mksession">:mksession</a>  命令写入会话文件后

 <a href="autocmd.html#MenuPopup">MenuPopup</a>              刚要显示弹出菜单前
 <a href="autocmd.html#CompleteChanged">CompleteChanged</a>        插入模式补全菜单被改变后
 <a href="autocmd.html#CompleteDonePre">CompleteDonePre</a>        插入模式补全结束之后，清理 info 之前
 <a href="autocmd.html#CompleteDone">CompleteDone</a>           插入模式补全结束之后，清理 info 之后

 <a href="autocmd.html#KeyInputPre">KeyInputPre</a>            要处理按键之前

 <a href="autocmd.html#User">User</a>                   和 ":doautocmd" 一起使用
 <a href="autocmd.html#SigUSR1">SigUSR1</a>                检测到 SIGUSR1 信号后

 <a href="autocmd.html#WinScrolled">WinScrolled</a>            滚动窗口或改变窗口大小后


自动命令事件按字母顺序排列的列表                        <b class="vimtag"> <a name="autocmd-events-abc">autocmd-events-abc</a> </b>

                                                        <b class="vimtag"> <a name="BufCreate">BufCreate</a> </b> <b class="vimtag"> <a name="BufAdd">BufAdd</a> </b>
BufAdd 或 BufCreate             缓冲区列表加入缓冲区后。可以是刚建立的新缓冲区
                                或者是已有的缓冲区。
                                也在缓冲区列表的某个缓冲区换名之后发生。
                                启动时初始缓冲区的建立不触发。
                                BufCreate 的名称有其历史原因。
                                <code class="note">注意</code>: 执行此自动命令时，当前缓冲区 "%" 可能会
                                和被建立的缓冲区 "<code class="special">&lt;afile&gt;</code>" 不同。
                                                        <b class="vimtag"> <a name="BufDelete">BufDelete</a> </b>
BufDelete                       缓冲区列表删除缓冲区前。可能先调用 BufUnload
                                事件 (如果该缓冲区已经载入的话)。
                                也在缓冲区列表的某个缓冲区换名之前发生。
                                <code class="note">注意</code>: 执行此自动命令时，当前缓冲区 "%" 可能会
                                和被删除的缓冲区 "<code class="special">&lt;afile&gt;</code>" 及 "<code class="special">&lt;afile&gt;</code>" 不同。
                                此处不可切换到其它缓冲区，否则会引起问题。
                                                        <b class="vimtag"> <a name="BufEnter">BufEnter</a> </b>
BufEnter                        进入缓冲区后。可用来设定有关文件类型的选项。也
                                在开始编辑缓冲区时执行，它发生在 BufReadPost
                                自动命令之后。
                                                        <b class="vimtag"> <a name="BufFilePost">BufFilePost</a> </b>
BufFilePost                     ":file" 或 ":saveas" 命令改变当前缓冲区的名字
                                后。
                                                        <b class="vimtag"> <a name="BufFilePre">BufFilePre</a> </b>
BufFilePre                      ":file" 或 ":saveas" 命令改变当前缓冲区的名字
                                前。
                                                        <b class="vimtag"> <a name="BufHidden">BufHidden</a> </b>
BufHidden                       缓冲区刚被隐藏前。也就是说，没有窗口显示该缓冲
                                区，但是它没有被卸载或者删除。":qa" 或者 ":q"
                                退出 Vim 时不会触发该事件。
                                <code class="note">注意</code>: 执行此自动命令时，当前缓冲区 "%" 可能会
                                和被隐藏的缓冲区 "<code class="special">&lt;afile&gt;</code>" 不同。
                                                        <b class="vimtag"> <a name="BufLeave">BufLeave</a> </b>
BufLeave                        转到别的缓冲区前、或离开/关闭当前窗口并且新的
                                当前窗口编辑的不是相同的缓冲区前，
                                ":qa" 或 ":q" 退出 Vim 时不会触发此事件。
                                                        <b class="vimtag"> <a name="BufNew">BufNew</a> </b>
BufNew                          刚建立新缓冲区或给缓冲区换名后。缓冲区被加到缓
                                冲区列表时，同时会触发 BufAdd 事件。
                                <code class="note">注意</code>: 执行此自动命令时，当前缓冲区 "%" 可能会
                                和被建立的缓冲区 "<code class="special">&lt;afile&gt;</code>" 不同。
                                                        <b class="vimtag"> <a name="BufNewFile">BufNewFile</a> </b>
BufNewFile                      开始编辑尚未存在的文件时。可用来读入骨架文件。
                                                <b class="vimtag"> <a name="BufRead">BufRead</a> </b> <b class="vimtag"> <a name="BufReadPost">BufReadPost</a> </b>
BufRead 或 BufReadPost          开始编辑新的缓冲区并把文件读入缓冲区后，执行模
                                式行之前。模式行之后的事件，见  <a href="autocmd.html#BufWinEnter">BufWinEnter</a> 。
                                以下情况也会触发:
                                - 写回未命名缓冲区时以使缓冲区取得名字
                                - 成功恢复文件后
                                - 执行 ":filetype detect" 时，用于
                                  filetypedetect 自动命令组
                                 <code class="emphasis">不</code> 触发:
                                - ":r file" 命令
                                - 文件还不存在时
                                                        <b class="vimtag"> <a name="BufReadCmd">BufReadCmd</a> </b>
BufReadCmd                      开始编辑新的缓冲区前。应执行把文件读入缓冲区的
                                操作。 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                <b class="vimtag"> <a name="BufReadPre">BufReadPre</a> </b> <b class="vimtag"> <a name="E200">E200</a> </b> <b class="vimtag"> <a name="E201">E201</a> </b>
BufReadPre                      开始编辑新的缓冲区并把文件读入缓冲区前。如果文
                                件还不存在，不会有此事件。
                                                        <b class="vimtag"> <a name="BufUnload">BufUnload</a> </b>
BufUnload                       缓冲区卸载前。此时，缓冲区里的文本将要被释放。
                                可在 BufWritePost 后和 BufDelete 前发生。 Vim
                                即将退出时，每个载入的缓冲区也会收到该事件。
                                <code class="note">注意</code>: 执行此自动命令时，当前缓冲区 "%" 可能会
                                和被卸载的缓冲区 "<code class="special">&lt;afile&gt;</code>" 不同。
                                                                <b class="vimtag"> <a name="E1546">E1546</a> </b>
                                此处不可切换到其它缓冲区或窗口，否则会引起问
                                题。
                                退出时如果 v:dying 至少为 2，不触发此事件。
                                                        <b class="vimtag"> <a name="BufWinEnter">BufWinEnter</a> </b>
BufWinEnter                     窗口显示缓冲区后。可以是新缓冲区载入 (处理完模
                                式行之后) 或者隐藏缓冲区在窗口开始显示 (从而不
                                再隐藏)。
                                不带参数的  <a href="windows.html#:split">:split</a>  不触发此事件，因为你继续编
                                辑的是同一个缓冲区，":split" 已在某窗口打开的
                                文件也是如此，同样因为它重用已有的缓冲区。但用
                                当前缓冲区名来 ":split" 却会触发本事件，因为此
                                时该缓冲区被重新载入。
                                终端窗口不适用，因为以终端-作业模式启动时，普
                                通模式不可用。可用  <a href="autocmd.html#TerminalOpen">TerminalOpen</a>  代替。
                                                        <b class="vimtag"> <a name="BufWinLeave">BufWinLeave</a> </b>
BufWinLeave                     窗口删除缓冲区前。除非它在别的窗口仍然可见。
                                系统退出时也会触发。在 BufUnload 或 BufHidden
                                之前触发。
                                <code class="note">注意</code>: 当此自动命令被执行时，当前缓冲区 "%" 可
                                能会和被卸载的缓冲区 "<code class="special">&lt;afile&gt;</code>" 不同。
                                退出时如果 v:dying 至少为 2，不触发此事件。
                                                        <b class="vimtag"> <a name="BufWipeout">BufWipeout</a> </b>
BufWipeout                      完全删除缓冲区前。可能先调用 BufUnload 和
                                BufDelete 事件 (如果缓冲区已经载入并且在缓冲区
                                列表之中的话)。
                                也在不在缓冲区列表的某个缓冲区换名之前发生。
                                <code class="note">注意</code>: 执行此自动命令时，当前缓冲区 "%" 可能会
                                和被删除的缓冲区 "<code class="special">&lt;afile&gt;</code>" 不同。
                                此处不可切换到其它缓冲区，否则会引起问题。
                                                <b class="vimtag"> <a name="BufWrite">BufWrite</a> </b> <b class="vimtag"> <a name="BufWritePre">BufWritePre</a> </b>
BufWrite 或 BufWritePre         把整个缓冲区写回到文件前。
                                                        <b class="vimtag"> <a name="BufWriteCmd">BufWriteCmd</a> </b>
BufWriteCmd                     把整个缓冲区写回到文件前。应执行把文件写回的操
                                作并在成功后复位 <a href="options.html#'modified'">'modified'</a> 标志，除非 <a href="options.html#'cpo'">'cpo'</a>
                                里包含了 '+' 并且写到另一个文件里  <a href="options.html#cpo-+">cpo-+</a> 。它
                                不应改动缓冲区的内容。
                                此操作复位 <a href="options.html#'modified'">'modified'</a> 时，调整撤销信息，把之前
                                的撤销状态标记为 <a href="options.html#'modified'">'modified'</a>，这和  <a href="editing.html#:write">:write</a>  的
                                行为一致。 <a href="motion.html#'[">'[</a>  和  <a href="motion.html#']">']</a>  位置标记可用于定位行范
                                围。
                                 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                        <b class="vimtag"> <a name="BufWritePost">BufWritePost</a> </b>
BufWritePost                    把整个缓冲区写回到文件后 (应该撤销 BufWritePre
                                的相关命令)。
                                                        <b class="vimtag"> <a name="CmdUndefined">CmdUndefined</a> </b>
CmdUndefined                    调用未定义的用户命令时。可以用来实现在实际调用
                                时才提供动态定义的命令。模式匹配的是命令的名
                                字。<code class="special">&lt;amatch&gt;</code> 和 <code class="special">&lt;afile&gt;</code> 都被设为该命令的名字。
                                即使是没有  <a href="autocmd.html#autocmd-nested">autocmd-nested</a>  的自动命令定义里也
                                会触发。
                                <code class="note">注意</code>: 在命令未定义前，自动补全不能工作。一个替
                                代方法是总是定义好用户命令，使之调用自动载入函
                                数。见  <a href="userfunc.html#autoload">autoload</a> 。
                                                        <b class="vimtag"> <a name="CmdlineChanged">CmdlineChanged</a> </b>
CmdlineChanged                  命令行文本发生改变后。小心不要改动命令行本身，
                                不然可能会使 Vim 死锁。
                                <code class="special">&lt;afile&gt;</code> 设为单个字符，指示命令行的类型。
                                 <a href="cmdline.html#cmdwin-char">cmdwin-char</a> 
                                                        <b class="vimtag"> <a name="CmdlineEnter">CmdlineEnter</a> </b>
CmdlineEnter                    光标移到命令行后，此时用户可输入命令或搜索字符
                                串；这里包括映射中非交互式使用 ":" 的情形，但
                                不包括使用  <a href="map.html#%3CCmd%3E">&lt;Cmd&gt;</a>  时。
                                模式匹配的是代表命令行类型的字符。
                                 <a href="cmdline.html#cmdwin-char">cmdwin-char</a> 
                                <code class="special">&lt;afile&gt;</code> 设为单个字符，指示命令行的类型。
                                 <a href="cmdline.html#cmdwin-char">cmdwin-char</a> 
                                                        <b class="vimtag"> <a name="CmdlineLeave">CmdlineLeave</a> </b>
CmdlineLeave                    离开命令行前。也用于按 <code class="keystroke">CTRL-C</code> 或 <code class="special">&lt;Esc&gt;</code> 之后放
                                弃命令行时；这里包括映射中非交互式使用 ":" 的
                                情形，但不包括使用  <a href="map.html#%3CCmd%3E">&lt;Cmd&gt;</a>  时。
                                此处命令出错时，命令行本身依旧执行。
                                <code class="special">&lt;afile&gt;</code> 设为单个字符，指示命令行的类型。
                                 <a href="cmdline.html#cmdwin-char">cmdwin-char</a> 
                                 <a href="eval.html#v:char">v:char</a>  设为使命令行退出的键值 (如 <code class="special">&lt;CR&gt;</code>、
                                &lt;<code class="keystroke">CTRL-C</code>&gt;、<code class="special">&lt;Esc&gt;</code>)。
                                                        <b class="vimtag"> <a name="CmdlineLeavePre">CmdlineLeavePre</a> </b>
CmdlineLeavePre                 刚要离开命令行前，在  <a href="autocmd.html#CmdlineLeave">CmdlineLeave</a>  之前。可用
                                于通过  <a href="builtin.html#cmdcomplete_info()">cmdcomplete_info()</a>  捕捉补全信息，因为
                                此信息在  <a href="autocmd.html#CmdlineLeave">CmdlineLeave</a>  触发前已清除。这里包括
                                映射中非交互式使用 ":" 的情形，但不包括使用
                                 <a href="map.html#%3CCmd%3E">&lt;Cmd&gt;</a>  时。按 <code class="keystroke">CTRL-C</code> 或 <code class="special">&lt;Esc&gt;</code> 之后放弃命令行
                                时也会触发。<code class="special">&lt;afile&gt;</code> 设为单个字符，指示命令行的
                                类型。详见  <a href="cmdline.html#cmdwin-char">cmdwin-char</a> 。
                                 <a href="eval.html#v:char">v:char</a>  的设置值同  <a href="autocmd.html#CmdlineLeave">CmdlineLeave</a> 。
                                                        <b class="vimtag"> <a name="CmdwinEnter">CmdwinEnter</a> </b>
CmdwinEnter                     进入命令行窗口后。可用来对此特殊类型的窗口进行
                                设置。
                                <code class="special">&lt;afile&gt;</code> 设为单个字符，指示命令行的类型。
                                 <a href="cmdline.html#cmdwin-char">cmdwin-char</a> 
                                                        <b class="vimtag"> <a name="CmdwinLeave">CmdwinLeave</a> </b>
CmdwinLeave                     退出命令行窗口前。可用来清除任何 CmdwinEnter
                                所做的全局设置。
                                <code class="special">&lt;afile&gt;</code> 设为单个字符，指示命令行的类型。
                                 <a href="cmdline.html#cmdwin-char">cmdwin-char</a> 
                                                        <b class="vimtag"> <a name="ColorScheme">ColorScheme</a> </b>
ColorScheme                     载入色彩方案后。 <a href="syntax.html#:colorscheme">:colorscheme</a> 
                                找不到对应色彩方案时不触发。
                                模式匹配的是色彩方案名。<code class="special">&lt;afile&gt;</code> 可获得设置该选
                                项时的实际文件名。<code class="special">&lt;amatch&gt;</code> 为新色彩方案名。

                                                        <b class="vimtag"> <a name="ColorSchemePre">ColorSchemePre</a> </b>
ColorSchemePre                  载入色彩方案前。 <a href="syntax.html#:colorscheme">:colorscheme</a> 
                                可用于在下个色彩方案载入之前，删除前一个色彩方
                                案的若干设置，
CompleteChanged                                         <b class="vimtag"> <a name="CompleteChanged">CompleteChanged</a> </b>
                                每次插入模式补全菜单被改动后。不为弹出式菜单的
                                隐藏触发，为此可用  <a href="autocmd.html#CompleteDonePre">CompleteDonePre</a>  或
                                 <a href="autocmd.html#CompleteDone">CompleteDone</a> 。绝不会递归触发。

                                设置以下这些  <a href="eval.html#v:event">v:event</a>  键:
                                    completed_item      见  <a href="insert.html#complete-items">complete-items</a> 。
                                    height              可见项目数目
                                    width               屏幕单元格数
                                    row                 屏幕顶行号
                                    col                 屏幕最左列号
                                    size                项目总数
                                    scrollbar           如果可见则为 TRUE

                                不能改变文本  <a href="eval.html#textlock">textlock</a> 。

                                也可通过  <a href="builtin.html#pum_getpos()">pum_getpos()</a>  得到弹出式菜单的大小和
                                位置。

                                                        <b class="vimtag"> <a name="CompleteDonePre">CompleteDonePre</a> </b>
CompleteDonePre                 插入模式补全结束之后。不管补会是否成功完成或是
                                被放弃都会触发本事件。 <a href="insert.html#ins-completion">ins-completion</a> 
                                可用  <a href="builtin.html#complete_info()">complete_info()</a> ，CompleteDonePre 触发后
                                此信息被清空。
                                 <a href="eval.html#v:completed_item">v:completed_item</a>  变量包含补全项目的信息。

                                                        <b class="vimtag"> <a name="CompleteDone">CompleteDone</a> </b>
CompleteDone                    插入模式补全结束之后。不管补会是否成功完成或是
                                被放弃都会触发本事件。 <a href="insert.html#ins-completion">ins-completion</a> 
                                不能用  <a href="builtin.html#complete_info()">complete_info()</a> ，CompleteDone 触发之
                                前此信息已被清空。如有需要可用 CompleteDonePre
                                事件。
                                 <a href="eval.html#v:completed_item">v:completed_item</a>  变量包含补全项目的信息。

                                设置以下  <a href="eval.html#v:event">v:event</a>  键值:
                                    complete_word       选中的单词，如果放弃补
                                                        全则为空。
                                    complete_type        <a href="builtin.html#complete_info_mode">complete_info_mode</a> 

                                                        <b class="vimtag"> <a name="CursorHold">CursorHold</a> </b>
CursorHold                      用户在 <a href="options.html#'updatetime'">'updatetime'</a> 指定的时间里没有按键时。直
                                到用户按键时该事件才会触发 (就是说，如果你离开
                                Vim 去煮杯咖啡，该事件不会每 <a href="options.html#'updatetime'">'updatetime'</a> 毫秒
                                就发生一次。:)
                                 <a href="windows.html#CursorHold-example">CursorHold-example</a>  提供了预览标签的范例。
                                该事件只有在普通模式才会触发。等待输入命令参数
                                或操作符之后的动作命令时，该事件不会发生。
                                记录时，不触发 CursorHold 事件。 <a href="repeat.html#q">q</a> 
                                                        <b class="vimtag"> <a name="%3CCursorHold%3E">&lt;CursorHold&gt;</a> </b>
                                在内部实现里，<code class="special">&lt;CursorHold&gt;</code> 键用来触发此自动命
                                令。此字符在  <a href="builtin.html#getchar()">getchar()</a>  表达式映射中可见。

                                <code class="note">注意</code>: 该事件的处理不能使用交互的命令，不会有
                                按 - 回车 (hit-enter) 的提示。
                                <code class="note">注意</code>: 将来设定时间可能有别的选项。
                                提示: 要强制更新状态行，用: 
<code class="example">                                        :let &amp;ro = &amp;ro</code>
                                {仅在 Amiga、Unix、Win32 和所有的 GUI 版本上有
                                效}
                                                        <b class="vimtag"> <a name="CursorHoldI">CursorHoldI</a> </b>
CursorHoldI                     类似于 CursorHold，但用于插入模式。
                                等待其它键时不触发。譬如在 <code class="keystroke">CTRL-V</code> 之后。也不适
                                用于 <code class="keystroke">CTRL-X</code> 模式  <a href="insert.html#insert_expand">insert_expand</a> 。

                                                        <b class="vimtag"> <a name="CursorMoved">CursorMoved</a> </b>
CursorMoved                     在普通或可视模式下移动光标后。也用于光标行的文
                                本被改变时，例如，使用 "x"、"rx" 或 "p"。
                                如果有预输入、在脚本文件中执行命令、在等待操作
                                符中、或移动到其他窗口但光标位置恰好不变的时
                                候，不总能触发此事件。
                                示例可见  <a href="tips.html#match-parens">match-parens</a> 。
                                <code class="note">备注</code>:  <a href="autocmd.html#:noautocmd">:noautocmd</a>  不会跳过此事件。
                                小心: 本事件发生非常频繁，不要做任何用户意想不
                                到或需时很久的事情。
                                                        <b class="vimtag"> <a name="CursorMovedC">CursorMovedC</a> </b>
CursorMovedC                    在命令行下移动光标后。小心不要破坏命令行，不然
                                可能会导致 Vim 死锁。
                                <code class="special">&lt;afile&gt;</code> 设为单个字符，指示命令行的类型。
                                 <a href="cmdline.html#cmdwin-char">cmdwin-char</a> 
                                                        <b class="vimtag"> <a name="CursorMovedI">CursorMovedI</a> </b>
CursorMovedI                    在插入模式下移动光标后。但有弹出菜单时不触发。
                                其余细节和 CursorMoved 相同。
                                                        <b class="vimtag"> <a name="DiffUpdated">DiffUpdated</a> </b>
DiffUpdated                     刷新比较结果后。取决于使用什么类型的比较 (内部
                                或外部)，触发可能在每次改动时，也可能在
                                 <a href="diff.html#:diffupdate">:diffupdate</a>  后。
                                                        <b class="vimtag"> <a name="DirChangedPre">DirChangedPre</a> </b>
DirChangedPre                   因  <a href="autocmd.html#DirChanged">DirChanged</a>  列出原因引起的工作目录即将改
                                变前。模式见  <a href="autocmd.html#DirChanged">DirChanged</a> 。新目录可见于
                                v:event.directory。
                                                        <b class="vimtag"> <a name="DirChanged">DirChanged</a> </b>
DirChanged                      因  <a href="editing.html#:cd">:cd</a> 、 <a href="editing.html#:tcd">:tcd</a>  或  <a href="editing.html#:lcd">:lcd</a>  命令，或
                                <a href="options.html#'autochdir'">'autochdir'</a> 选项而引起的工作目录改变时。
                                模式可以是:
                                        "window"  由  <a href="editing.html#:lcd">:lcd</a>  触发
                                        "tabpage" 由  <a href="editing.html#:tcd">:tcd</a>  触发
                                        "global"  由  <a href="editing.html#:cd">:cd</a>  触发
                                        "auto"    由 <a href="options.html#'autochdir'">'autochdir'</a> 触发。
                                        "drop"    由文件编辑触发
                                <code class="special">&lt;afile&gt;</code> 设为新目录名。
                                                        <b class="vimtag"> <a name="EncodingChanged">EncodingChanged</a> </b>
EncodingChanged                 改变 <a href="options.html#'encoding'">'encoding'</a> 选项后触发。可用于设定字体。
                                                        <b class="vimtag"> <a name="ExitPre">ExitPre</a> </b>
ExitPre                         用  <a href="editing.html#:quit">:quit</a> 、 <a href="editing.html#:wq">:wq</a>  等命令如使得 Vim 退出，或用
                                 <a href="editing.html#:qall">:qall</a>  时，此事件紧跟在  <a href="autocmd.html#QuitPre">QuitPre</a>  之后。可用
                                于关闭非紧要的窗口。如果有已修改的缓冲区且未自
                                动保存的话，退出行为仍然可被终止。真正退出可用
                                 <a href="autocmd.html#VimLeavePre">VimLeavePre</a> 。
                                                        <b class="vimtag"> <a name="FileAppendCmd">FileAppendCmd</a> </b>
FileAppendCmd                   附加到文件前。应执行附加到文件的操作。用 '[ 和
                                '] 位置标记来定位行范围。 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                        <b class="vimtag"> <a name="FileAppendPost">FileAppendPost</a> </b>
FileAppendPost                  附加到文件后。
                                                        <b class="vimtag"> <a name="FileAppendPre">FileAppendPre</a> </b>
FileAppendPre                   附加到文件前。用 '[ 和 '] 位置标记来定位行范
                                围。
                                                        <b class="vimtag"> <a name="FileChangedRO">FileChangedRO</a> </b>
FileChangedRO                   刚开始修改只读文件前。可以用来从源文件控制系统
                                里更新文件。但如果该修改由自动命令产生，该事件
                                不会发生。
                                该事件在缓冲区的第一次修改或者 <a href="options.html#'readonly'">'readonly'</a> 置位
                                后的第一次修改时触发，就在文本刚刚要被修改前发
                                生。
                                <code class="note">警告</code>: 如果在自动命令里移动了光标，此修改的效果
                                无法预测。
                                                        <b class="vimtag"> <a name="E788">E788</a> </b>
                                这里不能切换到别的缓冲区。你可以重新载入本缓冲
                                区，但不能用来编辑别的文件。
                                                        <b class="vimtag"> <a name="E881">E881</a> </b>
                                如果行数改变，撤销的保存可能会失败，相关改动也
                                会被放弃。
                                                        <b class="vimtag"> <a name="FileChangedShell">FileChangedShell</a> </b>
FileChangedShell                Vim <code class="note">注意</code>到文件的修改时间不同于编辑开始的时间或
                                者文件属性或文件大小发生改变时。 <a href="editing.html#timestamp">timestamp</a> 
                                该事件最有可能在执行外壳命令后发生，也可以在执
                                行  <a href="editing.html#:checktime">:checktime</a>  命令或 gvim 重新获得输入焦点后
                                发生。
                                该自动命令对每个发生改变的文件进行，但不包括置
                                位了 <a href="options.html#'autoread'">'autoread'</a> 且 (<code class="vim">译者注</code>: 似乎应为或) 没发生
                                改变而的缓冲区。如果指定了 FileChangedShell 自
                                动命令，不会给出相应的<code class="note">警告</code>消息和提示。
                                 <a href="eval.html#v:fcs_reason">v:fcs_reason</a>  变量被设置，以指示发生了什么
                                事，而  <a href="eval.html#v:fcs_choice">v:fcs_choice</a>  则可用来告知 Vim 下一步
                                该做什么。
                                <code class="note">注意</code>: 当此自动命令执行时，当前缓冲区 "%" 可能
                                和 "<code class="special">&lt;afile&gt;</code>" 指定的被改变的缓冲区不同。
                                <code class="note">注意</code>: 执行的命令必须不能修改当前缓冲区，跳转到
                                别的缓冲区，或者删除任何一个缓冲区。
                                <b class="vimtag"> <a name="E246">E246</a> </b> <b class="vimtag"> <a name="E811">E811</a> </b>
                                <code class="note">注意</code>: 该事件不会嵌套而引起无限循环。这意味着，
                                FileChangedShell 事件所执行的命令不会引起别的
                                FileChangedShell 事件。
                                                        <b class="vimtag"> <a name="FileChangedShellPost">FileChangedShellPost</a> </b>
FileChangedShellPost            对外部改变的文件的处理完成后。可用于更新状态
                                行。
                                                        <b class="vimtag"> <a name="FileEncoding">FileEncoding</a> </b>
FileEncoding                    已废弃。仍可用并等价于  <a href="autocmd.html#EncodingChanged">EncodingChanged</a> 。
                                                        <b class="vimtag"> <a name="FileReadCmd">FileReadCmd</a> </b>
FileReadCmd                     ":read" 命令读入文件前。应执行把文件读入缓冲区
                                的操作。 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                        <b class="vimtag"> <a name="FileReadPost">FileReadPost</a> </b>
FileReadPost                    ":read" 命令读入文件后。
                                <code class="note">注意</code> Vim 设置 '[' 和 ']' 位置标记为读入的首行
                                和末行。它们可以用来操作刚读入的行范围。
                                                        <b class="vimtag"> <a name="FileReadPre">FileReadPre</a> </b>
FileReadPre                     ":read" 命令读入文件前。
                                                        <b class="vimtag"> <a name="FileType">FileType</a> </b>
FileType                        设置 <a href="options.html#'filetype'">'filetype'</a> 选项时。模式匹配的是文件类型。
                                <code class="special">&lt;afile&gt;</code> 可以用来取得设置该选项的文件名，而
                                <code class="special">&lt;amatch&gt;</code> 则是 <a href="options.html#'filetype'">'filetype'</a> 的新值。不允许切换到
                                其它窗口或缓冲区。
                                参见  <a href="filetype.html#filetypes">filetypes</a> 。
                                                        <b class="vimtag"> <a name="FileWriteCmd">FileWriteCmd</a> </b>
FileWriteCmd                    写入文件前，但不包括写入整个缓冲区。应执行写入
                                文件的操作。不应改动缓冲区的内容。 <a href="motion.html#'[">'[</a>  和  <a href="motion.html#']">']</a> 
                                位置标记可用于定位行范围。
                                 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                        <b class="vimtag"> <a name="FileWritePost">FileWritePost</a> </b>
FileWritePost                   写入文件后，但不包括写入整个缓冲区。
                                                        <b class="vimtag"> <a name="FileWritePre">FileWritePre</a> </b>
FileWritePre                    写入文件前，但不包括写入整个缓冲区。 <a href="motion.html#'[">'[</a>  和
                                 <a href="motion.html#']">']</a>  位置标记可用于定位行范围。
                                                        <b class="vimtag"> <a name="FilterReadPost">FilterReadPost</a> </b>
FilterReadPost                  过滤命令读入文件后。Vim 用当前缓冲区的名字来匹
                                配模式，正如 FilterReadPre 那样。
                                如果 <a href="options.html#'shelltemp'">'shelltemp'</a> 关闭，不触发此事件。
                                                        <b class="vimtag"> <a name="FilterReadPre">FilterReadPre</a> </b> <b class="vimtag"> <a name="E135">E135</a> </b>
FilterReadPre                   过滤命令读入文件前。Vim 用当前缓冲区的名字来匹
                                配模式，而不是过滤命令输出的临时文件名字。
                                如果 <a href="options.html#'shelltemp'">'shelltemp'</a> 关闭，不触发此事件。
                                                        <b class="vimtag"> <a name="FilterWritePost">FilterWritePost</a> </b>
FilterWritePost                 过滤命令写入文件或用外部 diff 产生 diff 文件后
                                (内部 diff 可见  <a href="autocmd.html#DiffUpdated">DiffUpdated</a> )。Vim 用当前缓冲
                                区的名字来匹配模式，正如 FilterWritePre 那样。
                                如果 <a href="options.html#'shelltemp'">'shelltemp'</a> 关闭，不触发此事件。
                                                        <b class="vimtag"> <a name="FilterWritePre">FilterWritePre</a> </b>
FilterWritePre                  过滤程序写入文件或用外部 diff 产生 diff 文件
                                前。Vim 用当前缓冲区的名字来匹配模式，而不是过
                                滤命令输出的临时文件名字。
                                如果 <a href="options.html#'shelltemp'">'shelltemp'</a> 关闭，不触发此事件。
                                                        <b class="vimtag"> <a name="FocusGained">FocusGained</a> </b>
FocusGained                     Vim 取得输入焦点时。只有 GUI 和少数几个控制台
                                版本能检测该事件。  <a href="term.html#xterm-focus-event">xterm-focus-event</a> 
                                                        <b class="vimtag"> <a name="FocusLost">FocusLost</a> </b>
FocusLost                       Vim 失去输入焦点时。只有 GUI 和少数几个控制台
                                版本能检测该事件。  <a href="term.html#xterm-focus-event">xterm-focus-event</a> 
                                也有可能在弹出对话框时发生。
                                                        <b class="vimtag"> <a name="FuncUndefined">FuncUndefined</a> </b>
FuncUndefined                   调用未定义的用户函数时。可以用来实现在实际调用
                                时才提供动态定义的函数。模式匹配的是函数的名
                                字。<code class="special">&lt;amatch&gt;</code> 和 <code class="special">&lt;afile&gt;</code> 都被设为该函数的名字。
                                即使是没有  <a href="autocmd.html#autocmd-nested">autocmd-nested</a>  的自动命令定义里也
                                会触发，但  <a href="vim9.html#Vim9">Vim9</a>  函数编译时不触发。
                                <code class="note">注意</code>: 写 Vim 脚本时，最好采用自动调入函数。
                                见  <a href="userfunc.html#autoload-functions">autoload-functions</a> 。
                                                        <b class="vimtag"> <a name="GUIEnter">GUIEnter</a> </b>
GUIEnter                        成功启动 GUI 并打开窗口后。用 gvim 的时候，
                                它在 VimEnter 之前发生。在 .gvimrc 里可用它来
                                定位窗口: 
<code class="example">        :autocmd GUIEnter * winpos 100 50</code>
                                                        <b class="vimtag"> <a name="GUIFailed">GUIFailed</a> </b>
GUIFailed                       启动 GUI 失败后。如果可能，Vim 会继续在终端模
                                式下运行 (仅当在 Unix 相容系统上连接 X 服务器
                                失败后)。如果此时你想退出 Vim: 
<code class="example">        :autocmd GUIFailed * qall</code>
                                                        <b class="vimtag"> <a name="InsertChange">InsertChange</a> </b>
InsertChange                    在插入或替换模式下输入 <code class="special">&lt;Insert&gt;</code> 时。
                                 <a href="eval.html#v:insertmode">v:insertmode</a>  变量指明新模式。
                                小心: 不要移动光标或做任何用户意想不到的事情。
                                                        <b class="vimtag"> <a name="InsertCharPre">InsertCharPre</a> </b>
InsertCharPre                   插入模式输入每个字符前。
                                 <a href="eval.html#v:char">v:char</a>  变量指向正在输入的字符，事件处理时
                                可以改变此变量，从而更改插入的字符。
                                如果  <a href="eval.html#v:char">v:char</a>  被设为多于一个字符，按本义插入。
                                文本锁激活时不能改变文本  <a href="eval.html#textlock">textlock</a> 。
                                <a href="options.html#'paste'">'paste'</a> 置位时不触发本事件。
                                <code class="notvi">{仅当编译时加入  <a href="various.html#+eval">+eval</a>  特性才有效}</code>
                                                        <b class="vimtag"> <a name="InsertEnter">InsertEnter</a> </b>
InsertEnter                     刚开始插入模式之前。也适用于替换模式和虚拟替换
                                模式。 <a href="eval.html#v:insertmode">v:insertmode</a>  变量指明该模式。
                                小心: 不要做任何用户意想不到的事情。
                                光标位置事后会恢复。如果不想如此，设置
                                 <a href="eval.html#v:char">v:char</a>  为某个非空的字符串。
                                                        <b class="vimtag"> <a name="InsertLeavePre">InsertLeavePre</a> </b>
InsertLeavePre                  刚离开插入模式之前。也用于 <code class="keystroke">CTRL-O</code>  <a href="insert.html#i_CTRL-O">i_CTRL-O</a> 。
                                小心不要在这里切换模式或使用  <a href="various.html#:normal">:normal</a> ，可能会
                                引起麻烦。
                                                        <b class="vimtag"> <a name="InsertLeave">InsertLeave</a> </b>
InsertLeave                     刚离开插入模式后。也用于 <code class="keystroke">CTRL-O</code>  <a href="insert.html#i_CTRL-O">i_CTRL-O</a> ，但
                                不用于  <a href="insert.html#i_CTRL-C">i_CTRL-C</a> 。
                                                        <b class="vimtag"> <a name="KeyInputPre">KeyInputPre</a> </b>
KeyInputPre                     应用映射之后，按键刚开始处理之前。模式匹配和
                                 <code class="badlink">mode(1)</code>  相同的指示当前模式的字符串。
                                 <a href="eval.html#v:char">v:char</a>  变量指示按下的键，本事件可改变之，使
                                待处理的变成另一个键。 <a href="eval.html#v:char">v:char</a>  如果不是单个字
                                符或者特殊键，使用首个字符。
                                设置下述的  <a href="eval.html#v:event">v:event</a>  值:
                                   typed        键是否按下。
                                   typedchar    最近一次  <a href="autocmd.html#KeyInputPre">KeyInputPre</a>  调用后
                                                (实际) 按下的键。
                                <code class="note">注意</code>: 如果连续处理完多个  <a href="autocmd.html#KeyInputPre">KeyInputPre</a>  自动命
                                令，"typedchar" 可能为空。
                                此处不允许改变文本  <a href="eval.html#textlock">textlock</a>  或当前模式。
                                <code class="notvi">{仅当编译时加入  <a href="various.html#+eval">+eval</a>  特性才有效}</code>
                                                        <b class="vimtag"> <a name="MenuPopup">MenuPopup</a> </b>
MenuPopup                       刚要显示弹出菜单前 (鼠标右键下)。用于根据光标
                                或鼠标指针下的内容调整菜单。
                                对应的模式匹配代表模式的一或两个字符:
                                        n       普通
                                        v       可视
                                        o       操作符等待
                                        i       插入
                                        c       命令行
                                        tl      终端
                                                        <b class="vimtag"> <a name="ModeChanged">ModeChanged</a> </b>
ModeChanged                     改变模式后。自动命令的模式需匹配
                                 <code class="badlink">'旧模式:新模式'</code> ，例如要模拟  <a href="autocmd.html#CmdlineEnter">CmdlineEnter</a> ，
                                可指定匹配模式  <code class="badlink">*:c*</code> 。
                                设置  <a href="eval.html#v:event">v:event</a>  的以下值:
                                   old_mode     改变前的模式。
                                   new_mode     新模式，以非零参数调用
                                                 <a href="builtin.html#mode()">mode()</a>  也可返回此值。
                                触发 ModeChanged 时，old_mode 的值是该事件上次
                                触发时的 new_mode 值。
                                次要模式的每次改变都会触发此事件。
                                以下示例中，在进入可视模式时使用相对行号: 
<code class="example">        :au ModeChanged [vV\x16]*:* let &amp;l:rnu = mode() =~# '^[vV\x16]'</code>
<code class="example">        :au ModeChanged *:[vV\x16]* let &amp;l:rnu = mode() =~# '^[vV\x16]'</code>
<code class="example">        :au WinEnter,WinLeave * let &amp;l:rnu = mode() =~# '^[vV\x16]'</code>
                                                        <b class="vimtag"> <a name="OptionSet">OptionSet</a> </b>
OptionSet                       设置选项时。模式匹配的是长选项名。
                                <code class="special">&lt;amatch&gt;</code> 指出选项是否被置位。

                                 <a href="eval.html#v:option_type">v:option_type</a>  说明是全局还是局部值，
                                 <a href="eval.html#v:option_command">v:option_command</a>  说明使用的 set/let 命令的类
                                型 (跟随标签可见对应表)。
                                 <a href="eval.html#v:option_new">v:option_new</a>  给出新设选项值，
                                 <a href="eval.html#v:option_oldlocal">v:option_oldlocal</a>  给出旧局部选项值，
                                 <a href="eval.html#v:option_oldglobal">v:option_oldglobal</a>  给出旧全局选项值，
                                 <a href="eval.html#v:option_old">v:option_old</a>  给出旧选项值，

                                只有用  <a href="options.html#:set">:set</a> 、 <a href="options.html#:setlocal">:setlocal</a>  或  <a href="options.html#modeline">modeline</a>  设置
                                选项时才会设置  <a href="eval.html#v:option_oldlocal">v:option_oldlocal</a> 。相似地，只
                                有用  <a href="options.html#:set">:set</a>  或  <a href="options.html#:setglobal">:setglobal</a>  时才设置
                                 <a href="eval.html#v:option_oldglobal">v:option_oldglobal</a> 。

                                不设置  <a href="cmdline.html#%3Cabuf%3E">&lt;abuf&gt;</a> ，可用  <a href="builtin.html#bufnr()">bufnr()</a> 。

                                <code class="note">注意</code> 用  <a href="options.html#:set">:set</a>  设置  <a href="options.html#global-local">global-local</a>  字符串选项
                                时， <a href="eval.html#v:option_old">v:option_old</a>  是旧的全局值。但对其它类型
                                的选项 (局部字符串选项、全局-局部数值选项，等
                                等)，它是旧的局部值。

                                启动时不触发 OptionSet，<a href="options.html#'key'">'key'</a> 选项亦然。其理甚
                                明。

                                示例: 检查 <a href="options.html#'backupdir'">'backupdir'</a> 和 <a href="options.html#'undodir'">'undodir'</a> 选项使用的
                                目录是否存在，不存在时建立目录。

                                <code class="note">注意</code>: 在此自动命令里建议不要复位选项，可能会对
                                插件破坏。用  <a href="autocmd.html#:noa">:noa</a>  可避免执行此自动命令。

                                自动命令中使用  <a href="options.html#:set">:set</a>  时，此事件不再触发。
                                                        <b class="vimtag"> <a name="QuickFixCmdPre">QuickFixCmdPre</a> </b>
QuickFixCmdPre                  开始执行快速修复命令前 ( <a href="quickfix.html#:make">:make</a> 、 <a href="quickfix.html#:lmake">:lmake</a> 、
                                 <a href="quickfix.html#:grep">:grep</a> 、 <a href="quickfix.html#:lgrep">:lgrep</a> 、 <a href="quickfix.html#:grepadd">:grepadd</a> 、 <a href="quickfix.html#:lgrepadd">:lgrepadd</a> 、
                                 <a href="quickfix.html#:vimgrep">:vimgrep</a> 、 <a href="quickfix.html#:lvimgrep">:lvimgrep</a> 、 <a href="quickfix.html#:vimgrepadd">:vimgrepadd</a> 、
                                 <a href="quickfix.html#:lvimgrepadd">:lvimgrepadd</a> 、 <a href="if_cscop.html#:cscope">:cscope</a> 、 <a href="quickfix.html#:cfile">:cfile</a> 、
                                 <a href="quickfix.html#:cgetfile">:cgetfile</a> 、 <a href="quickfix.html#:caddfile">:caddfile</a> 、 <a href="quickfix.html#:lfile">:lfile</a> 、
                                 <a href="quickfix.html#:lgetfile">:lgetfile</a> 、 <a href="quickfix.html#:laddfile">:laddfile</a> 、 <a href="helphelp.html#:helpgrep">:helpgrep</a> 、
                                 <a href="helphelp.html#:lhelpgrep">:lhelpgrep</a> 、 <a href="quickfix.html#:cexpr">:cexpr</a> 、 <a href="quickfix.html#:cgetexpr">:cgetexpr</a> 、
                                 <a href="quickfix.html#:caddexpr">:caddexpr</a> 、 <a href="quickfix.html#:cbuffer">:cbuffer</a> 、 <a href="quickfix.html#:cgetbuffer">:cgetbuffer</a> 、
                                 <a href="quickfix.html#:caddbuffer">:caddbuffer</a> )。
                                对应的模式匹配执行的命令。如果使用  <a href="quickfix.html#:grep">:grep</a>  但
                                <a href="options.html#'grepprg'">'grepprg'</a> 设为 "internal"，仍然匹配 "grep"。
                                该命令不能用于设置 <a href="options.html#'makeprg'">'makeprg'</a> 和 <a href="options.html#'grepprg'">'grepprg'</a> 变
                                量。
                                如果该命令出错，不执行快速修复命令。
                                                        <b class="vimtag"> <a name="QuickFixCmdPost">QuickFixCmdPost</a> </b>
QuickFixCmdPost                 类似于 QuickFixCmdPre，但在执行快速修复命令
                                后，跳转到第一个位置之前。 <a href="quickfix.html#:cfile">:cfile</a>  和  <a href="quickfix.html#:lfile">:lfile</a> 
                                等命令则在读入错误文件后，跳转到第一个位置之前
                                执行。
                                见  <a href="quickfix.html#QuickFixCmdPost-example">QuickFixCmdPost-example</a> 。
                                                        <b class="vimtag"> <a name="QuitPre">QuitPre</a> </b>
QuitPre                          <a href="editing.html#:quit">:quit</a> 、 <a href="editing.html#:wq">:wq</a>  或  <a href="editing.html#:qall">:qall</a>  调用时，在决定是否
                                关闭当前窗口或退出 Vim 之前。 <a href="editing.html#:wq">:wq</a>  在 QuitPre
                                触发前先写入缓冲区。可用于在当前窗口是最后一个
                                普通窗口时关闭辅助的窗口。
                                另见  <a href="autocmd.html#ExitPre">ExitPre</a> 。
                                                        <b class="vimtag"> <a name="RemoteReply">RemoteReply</a> </b>
RemoteReply                     Vim 作为服务器时收到应答时  <a href="builtin.html#server2client()">server2client()</a> 。
                                模式匹配的是 <code class="special">{serverid}</code>。<code class="special">&lt;amatch&gt;</code> 是发出应答的
                                机器的 <code class="special">{serverid}</code>，而 <code class="special">&lt;afile&gt;</code> 是实际的应答字符
                                串。
                                <code class="note">注意</code> 即使定义了自动命令，还是要用
                                 <a href="builtin.html#remote_read()">remote_read()</a>  来取走应答。
                                                        <b class="vimtag"> <a name="SafeState">SafeState</a> </b>
SafeState                       没有任何待定字符，等待用户键入字符时。
                                以下情形之一不触发:
                                - 操作符等待中
                                - 用 "r 输入了寄存器时
                                - 命令执行到一半时
                                - 执行映射时
                                - 有预输入 (typeahead) 时
                                - 插入模式补全激活时
                                - 命令行模式补全激活时
                                 <a href="builtin.html#mode()">mode()</a>  可用来找到 Vim 所处的状态。可以是:
                                - 可视模式
                                - 普通模式
                                - 插入模式
                                - 命令行模式
                                取决于你想做什么，也可用  <a href="builtin.html#state()">state()</a>  检查更多信
                                息，如是否因消息导致了屏幕滚动等。
                                                        <b class="vimtag"> <a name="SafeStateAgain">SafeStateAgain</a> </b>
SafeStateAgain                  类似于 SafeState，但在处理完任何信息和回调调用
                                后。此事件可能会经常触发，不要做耗时的事情。

                                                        <b class="vimtag"> <a name="SessionLoadPost">SessionLoadPost</a> </b>
SessionLoadPost                 载入  <a href="starting.html#:mksession">:mksession</a>  命令建立的会话文件后。
                                                        <b class="vimtag"> <a name="SessionWritePost">SessionWritePost</a> </b>
SessionWritePost                调用  <a href="starting.html#:mksession">:mksession</a>  命令写入会话文件后。
                                                        <b class="vimtag"> <a name="ShellCmdPost">ShellCmdPost</a> </b>
ShellCmdPost                    执行用  <a href="various.html#:!cmd">:!cmd</a> 、 <a href="various.html#:shell">:shell</a> 、 <a href="quickfix.html#:make">:make</a>  和  <a href="quickfix.html#:grep">:grep</a> 
                                指定的外壳命令后。可用于检查任何文件的改变。
                                                        <b class="vimtag"> <a name="ShellFilterPost">ShellFilterPost</a> </b>
ShellFilterPost                 执行用 ":<code class="special">{range}</code>!cmd"、":w !cmd" 或 ":r !cmd"
                                指定的外壳命令后。可用于检查任何文件的改变。
                                                        <b class="vimtag"> <a name="SourcePre">SourcePre</a> </b>
SourcePre                       执行 Vim 脚本前。 <a href="repeat.html#:source">:source</a>  <code class="special">&lt;afile&gt;</code> 是待执行的
                                文件名。
                                                        <b class="vimtag"> <a name="SourcePost">SourcePost</a> </b>
SourcePost                      执行 Vim 脚本后。 <a href="repeat.html#:source">:source</a>  <code class="special">&lt;afile&gt;</code> 是待执行的
                                文件名。
                                脚本执行被中断后不触发。
                                SourceCmd 自动命令触发后也会触发此事件。
                                                        <b class="vimtag"> <a name="SourceCmd">SourceCmd</a> </b>
SourceCmd                       执行 Vim 脚本时。 <a href="repeat.html#:source">:source</a>  <code class="special">&lt;afile&gt;</code> 是待执行的
                                文件名。自动命令应实现执行该文件的操作。
                                 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                        <b class="vimtag"> <a name="SpellFileMissing">SpellFileMissing</a> </b>
SpellFileMissing                试图载入拼写检查文件，但找不到该文件时。模式匹
                                配的是语言名。<code class="special">&lt;amatch&gt;</code> 指定语言，和 <a href="options.html#'encoding'">'encoding'</a>
                                也有关。见  <a href="spell.html#spell-SpellFileMissing">spell-SpellFileMissing</a> 。
                                                        <b class="vimtag"> <a name="StdinReadPost">StdinReadPost</a> </b>
StdinReadPost                   从标准输入读取输入到缓冲区后，执行模式行前。仅
                                用于 Vim 启动时使用了 "-" 参数时发生  <a href="starting.html#--">--</a> 。
                                                        <b class="vimtag"> <a name="StdinReadPre">StdinReadPre</a> </b>
StdinReadPre                    从标准输入读取输入到缓冲区前。仅用于 Vim 启动
                                时使用了 "-" 参数时发生  <a href="starting.html#--">--</a> 。
                                                        <b class="vimtag"> <a name="SwapExists">SwapExists</a> </b>
SwapExists                      开始编辑文件时检测到交换文件已存在。只有此时，
                                可以选择处理此情形的方法，也在此时，Vim 可能会
                                询问用户应该如何做。
                                 <a href="eval.html#v:swapname">v:swapname</a>  变量保存找到的交换文件名。<code class="special">&lt;afile&gt;</code>
                                则是待编辑的文件。 <a href="eval.html#v:swapcommand">v:swapcommand</a>  可以包含该文
                                件打开后执行的命令。
                                此事件的命令应该设置  <a href="eval.html#v:swapchoice">v:swapchoice</a>  变量为包含
                                单字符的字符串，指示 Vim 下一步应该做什么:
                                        'o'     以只读方式打开
                                        'e'     仍然编辑文件
                                        'r'     恢复
                                        'd'     删除交换文件
                                        'q'     退出，不编辑文件
                                        'a'     中止，就像按了 <code class="keystroke">CTRL-C</code> 一样
                                如果设为空串，则询问用户，就像没有 SwapExists
                                自动命令那样。
                                                        <b class="vimtag"> <a name="E812">E812</a> </b>
                                此处不允许切换到其它缓冲区、为缓冲区换名或者更
                                改目录。
                                <code class="notvi">{仅当编译时加入  <a href="various.html#+eval">+eval</a>  特性才有效}</code>
                                                        <b class="vimtag"> <a name="Syntax">Syntax</a> </b>
Syntax                          设置 <a href="options.html#'syntax'">'syntax'</a> 选项时。模式匹配的是语法名。
                                <code class="special">&lt;afile&gt;</code> 可以用来取得设置该选项的文件名，而
                                <code class="special">&lt;amatch&gt;</code> 则是 <a href="options.html#'syntax'">'syntax'</a> 的新值。参见
                                 <a href="syntax.html#:syn-on">:syn-on</a> 。
                                                        <b class="vimtag"> <a name="TabClosed">TabClosed</a> </b>
TabClosed                       关闭标签页后。
                                                        <b class="vimtag"> <a name="TabClosedPre">TabClosedPre</a> </b>
TabClosedPre                    关闭标签页前。窗口布局被锁定，也就是，不允许打
                                开和关闭窗口。
                                                        <b class="vimtag"> <a name="TabEnter">TabEnter</a> </b>
TabEnter                        刚进入标签页后。 <a href="tabpage.html#tab-page">tab-page</a> 
                                在触发 WinEnter 事件之后和 BufEnter 事件之前发
                                生。
                                                        <b class="vimtag"> <a name="TabLeave">TabLeave</a> </b>
TabLeave                        刚要离开标签页前。 <a href="tabpage.html#tab-page">tab-page</a> 
                                WinLeave 事件在此之前已经触发。
                                                        <b class="vimtag"> <a name="TabNew">TabNew</a> </b>
TabNew                          创建标签页时。 <a href="tabpage.html#tab-page">tab-page</a> 
                                在此前，WinEnter 事件首先触发，TabEnter 其次。
                                                        <b class="vimtag"> <a name="TermChanged">TermChanged</a> </b>
TermChanged                     <a href="options.html#'term'">'term'</a> 的值发生改变后。可用来重新读入语法文
                                件，更新色彩、字体和其他终端相关的设置。对所
                                有已载入的缓冲区执行。
                                                        <b class="vimtag"> <a name="TerminalOpen">TerminalOpen</a> </b>
TerminalOpen                    用  <a href="terminal.html#:terminal">:terminal</a>  或  <a href="terminal.html#term_start()">term_start()</a>  建立终端缓冲
                                区后。即使以 ++hidden 选项创建无窗口的缓冲区也
                                会触发此事件。
                                                        <b class="vimtag"> <a name="TerminalWinOpen">TerminalWinOpen</a> </b>
TerminalWinOpen                 用  <a href="terminal.html#:terminal">:terminal</a>  或  <a href="terminal.html#term_start()">term_start()</a>  建立终端缓冲
                                区后。仅当缓冲区创立时带了窗口才会触发此事件。
                                可用于设置终端窗口的局部于窗口的选项。
                                                        <b class="vimtag"> <a name="TermResponse">TermResponse</a> </b>
TermResponse                    收到终端对  <a href="term.html#t_RV">t_RV</a>  的应答后。
                                可用  <a href="eval.html#v:termresponse">v:termresponse</a>  的值判别终端版本。
                                 <a href="starting.html#defaults.vim">defaults.vim</a>  用此事件检测 putty 终端并设置深
                                色背景: 
<code class="example"></code>
<code class="example">                                au TermResponse *</code>
<code class="example">                                \ if v:termresponse == "\e[&gt;0;136;0c"</code>
<code class="example">                                \    set bg=dark</code>
<code class="example">                                \ endif</code>

                                <code class="note">注意</code> 本事件可能在另一事件执行半途中激发，特别
                                是在文件 I/O，外壳命令等耗时的操作进行时尤有可
                                能。
                                                        <b class="vimtag"> <a name="TermResponseAll">TermResponseAll</a> </b>
TermResponseAll                 收到终端对  <a href="term.html#t_RV">t_RV</a> 、 <a href="term.html#t_RC">t_RC</a> 、 <a href="term.html#t_RS">t_RS</a> 、 <a href="term.html#t_u7">t_u7</a>  或任
                                何 OSC 命令的应答后。分别可用
                                 <a href="eval.html#v:termresponse">v:termresponse</a> 、 <a href="eval.html#v:termblinkresp">v:termblinkresp</a> 、
                                 <a href="eval.html#v:termstyleresp">v:termstyleresp</a> 、 <a href="eval.html#v:termu7resp">v:termu7resp</a>  和
                                 <a href="eval.html#v:termosc">v:termosc</a>  的值获取应答。
                                <code class="special">&lt;amatch&gt;</code> 会被设为以下各值之一:
                                    "version"、
                                    "cursorblink"、
                                    "cursorshape"、
                                    "ambiguouswidth"、
                                    "osc"
                                <code class="note">注意</code> 本事件可能在另一事件执行半途中激发，特别
                                是在文件 I/O，外壳命令等耗时的操作进行时尤有可
                                能。
                                <code class="note">注意</code>: 传统上 TermResponseAll 也用于
                                "foreground" 和 "background" 模式。它们现在视
                                为 "osc" 值的一部分被处理。为了后向兼容，
                                $VIMRUNTIME/plugin/colorresp.vim 插件在碰到
                                "foreground" 和 "background" 值时，会处理
                                "osc" 事件并触发 TermResponseAll 自动命令事
                                件。
                                                        <b class="vimtag"> <a name="TextChanged">TextChanged</a> </b>
TextChanged                     普通模式修改当前缓冲区文本之后。即
                                 <a href="eval.html#b:changedtick">b:changedtick</a>  改变 (TextChanged 自动命令定义
                                之前发生的也算) 之后。
                                有预输入或有操作符等待时不触发。
                                <code class="note">注意</code>:  <a href="autocmd.html#:noautocmd">:noautocmd</a>  不会跳过此事件。
                                小心: 本事件发生非常频繁，不要做任何用户意想不
                                到或需时很久的事情。
                                                        <b class="vimtag"> <a name="TextChangedI">TextChangedI</a> </b>
TextChangedI                    插入模式修改当前缓冲区文本之后。
                                弹出菜单可见时不触发。其他事项同 TextChanged。
                                                        <b class="vimtag"> <a name="TextChangedP">TextChangedP</a> </b>
TextChangedP                    插入模式修改当前缓冲区文本之后。
                                只适用于弹出菜单可见时。其他事项同
                                TextChanged。
                                                        <b class="vimtag"> <a name="TextChangedT">TextChangedT</a> </b>
TextChangedT                    终端模式修改当前缓冲区文本之后。其他事项同
                                TextChanged。
                                                        <b class="vimtag"> <a name="TextYankPost">TextYankPost</a> </b>
TextYankPost                    当前缓冲区的文本被抽出或删除后。
                                 <a href="eval.html#v:event">v:event</a>  的值可用于决定触发此自动命令的操作，
                                如下所示:
                                   inclusive    动作为  <a href="motion.html#inclusive">inclusive</a>  时为 TRUE，
                                                反之则动作为  <a href="motion.html#exclusive">exclusive</a> 。
                                   operator     执行的操作。
                                   regcontents  寄存器里以行列表形式保存的文
                                                本，相当于: 
<code class="example">                                                getreg(r, 1, 1)</code>
                                   regname      寄存器名，无名寄存器返回空串，
                                                见  <a href="change.html#registers">registers</a> 。
                                   regtype      寄存器类型，参见
                                                 <a href="builtin.html#getregtype()">getregtype()</a> 。
                                用  <a href="change.html#quote_">quote_</a>  时不触发，递归调用时也是。
                                此事件不允许改变缓冲区文本，参见  <a href="eval.html#textlock">textlock</a> 。
                                <b class="vimtag"> <a name="E1064">E1064</a> </b>
                                Vim 因为 <a href="options.html#'guioptions'">'guioptions'</a> 或 <a href="options.html#'clipboard'">'clipboard'</a> 里设置了
                                "autoselect" 而试图成为可视区域的拥有者时，也
                                间接触发此事件。
                                <code class="notvi">{仅当编译时加入  <a href="various.html#+eval">+eval</a>  特性才有效}</code>
                                                        <b class="vimtag"> <a name="User">User</a> </b>
User                            不会自动执行。只有用 ":doautocmd" 执行自动命令
                                时才会调用。
                                <code class="note">注意</code> 使用 `:doautocmd User MyEvent` 如果没有匹
                                配的自动命令，会报错。如果不想，先用
                                 <code class="badlink">exists('#User#MyEvent')</code>  检查命令是否已定义，
                                或者自己定义一个空自动命令。
                                示例: 
<code class="example">                                    if exists('#User#MyEvent')</code>
<code class="example">                                        doautocmd User MyEvent</code>
<code class="example">                                    endif</code>

                                                        <b class="vimtag"> <a name="SigUSR1">SigUSR1</a> </b>
SigUSR1                         检测到 SIGUSR1 信号后。
                                如果其它通知 Vim 的手段不可行，这也不失为一种
                                方法。例如，可用于检查某耗时的编译的结果，或当
                                动作感应被触发时。
                                <code class="notvi">{仅用于 Unix}</code>

                                                        <b class="vimtag"> <a name="UserGettingBored">UserGettingBored</a> </b>
UserGettingBored                用户按同一个键 42 遍的时候。开玩笑的！
                                                        <b class="vimtag"> <a name="VimEnter">VimEnter</a> </b>
VimEnter                        做完所有启动任务后，包括载入 .vimrc 文件，执行
                                "-c cmd" 参数，创建所有的窗口并在其中载入所有
                                缓冲区。
                                在此事件触发之前，置位  <a href="eval.html#v:vim_did_enter">v:vim_did_enter</a>  变
                                量，所以你可以做: 
<code class="example">                                   if v:vim_did_enter</code>
<code class="example">                                     call s:init()</code>
<code class="example">                                   else</code>
<code class="example">                                     au VimEnter * call s:init()</code>
<code class="example">                                   endif</code>
                                                        <b class="vimtag"> <a name="VimLeave">VimLeave</a> </b>
VimLeave                        退出 Vim 前，刚写入 .viminfo 文件之后。和
                                VimLeavePre 一样，只执行一次。
                                要检测非正常的退出，使用  <a href="eval.html#v:dying">v:dying</a> 。
                                退出时如果 v:dying 至少为 2，不触发此事件。
                                要得到退出代码，可用  <a href="eval.html#v:exiting">v:exiting</a> 。
                                                        <b class="vimtag"> <a name="VimLeavePre">VimLeavePre</a> </b>
VimLeavePre                     退出 Vim 时刚写入 .viminfo 文件之前。如果匹配
                                退出时当前缓冲区的名字匹配才会触发。只执行一
                                次。通常指定 "*" 模式。 
<code class="example">        :autocmd VimLeavePre * call CleanupStuff()</code>
                                要检测非正常的退出，使用  <a href="eval.html#v:dying">v:dying</a> 。
                                退出时如果 v:dying 至少为 2，不触发此事件。
                                要得到退出代码，可用  <a href="eval.html#v:exiting">v:exiting</a> 。
                                                        <b class="vimtag"> <a name="VimResized">VimResized</a> </b>
VimResized                      在 Vim 窗口的大小改变后，因而 <a href="options.html#'lines'">'lines'</a> 和/或
                                <a href="options.html#'columns'">'columns'</a> 也已随之改变。不过，启动时不用。
                                                        <b class="vimtag"> <a name="VimResume">VimResume</a> </b>
VimResume                       在 Vim 实例被暂停和  <a href="autocmd.html#VimSuspend">VimSuspend</a>  触发后继续运
                                行时。用于触发  <a href="editing.html#:checktime">:checktime</a>  以确保 Vim 暂停后
                                缓冲区内容不改变: 
<code class="example">        :autocmd VimResume * checktime</code>
                                                        <b class="vimtag"> <a name="VimSuspend">VimSuspend</a> </b>
VimSuspend                      在 Vim 实例被暂停时。仅当 Vim 内键入 <code class="keystroke">CTRL-Z</code>
                                或 SIGTSTP 信号被发送到 Vim 时触发。而 SIGSTOP
                                信号不会。
                                                        <b class="vimtag"> <a name="WinClosed">WinClosed</a> </b>
WinClosed                       关闭窗口时，刚要从窗口布局中删除前。模式匹配的
                                是  <a href="windows.html#window-ID">window-ID</a> 。<code class="special">&lt;amatch&gt;</code> 和 <code class="special">&lt;afile&gt;</code> 都设为
                                 <a href="windows.html#window-ID">window-ID</a> 。非递归 (事件不会触发自身)。
                                                        <b class="vimtag"> <a name="WinEnter">WinEnter</a> </b>
WinEnter                        进入别的窗口后。不包括 Vim 启动时的第一个窗
                                口。
                                可用来设定窗口的高度。
                                如果该窗口显示缓冲区，Vim 在 WinEnter 自动命令
                                之后执行 BufEnter 自动命令。
                                <code class="note">注意</code>: 对分割和标签页诸命令来说，WinEnter 事件
                                在这些分割或标签命令之后但在文件载入之前发生。

                                                        <b class="vimtag"> <a name="WinLeave">WinLeave</a> </b>
WinLeave                        离开某窗口前。如果将要进入的窗口要显示的是别的
                                缓冲区，Vim 在 WinLeave 自动命令前先执行
                                BufLeave 自动命令 (但不包括 ":new")。
                                ":qa" 或 ":q" 退出 Vim 时不会触发此事件。

                                                        <b class="vimtag"> <a name="WinNewPre">WinNewPre</a> </b>
WinNewPre                       创建新窗口前。在创建分割从而修改窗口布局的命令
                                前触发。
                                创建标签页及首个窗口时不触发，因为窗口结构此时
                                尚未初始化，所以一般而言此时并不安全。
                                执行 WinNewPre 里的命令时不允许修改窗口布局。
                                最常用于保存当前窗口布局并在窗口创建后和新布局
                                相比较。

                                                        <b class="vimtag"> <a name="WinNew">WinNew</a> </b>
WinNew                          创建新窗口时。不用于 Vim 启动时的首个窗口。在
                                WinEnter 事件之前触发。

                                                        <b class="vimtag"> <a name="WinScrolled">WinScrolled</a> </b>
WinScrolled                     在当前标签页的任何窗口里滚动文本 (横向或纵向)
                                或改变宽高后。见  <a href="windows.html#win-scrolled-resized">win-scrolled-resized</a> 。

                                <code class="note">注意</code>: 不能用  <a href="autocmd.html#:noautocmd">:noautocmd</a>  跳过此事件，因为它在
                                Vim 处理完普通模式命令后返回到主循环时触发。要
                                屏蔽此事件，考虑设置 <a href="options.html#'eventignore'">'eventignore'</a> 选项。

                                模式匹配的是首个滚动或改变大小的窗口
                                 <a href="windows.html#window-ID">window-ID</a> 。<code class="special">&lt;amatch&gt;</code> 和 <code class="special">&lt;afile&gt;</code> 都设为
                                 <a href="windows.html#window-ID">window-ID</a> 。

                                 <a href="eval.html#v:event">v:event</a>  设为大小和滚动改变的相关信息。
                                 <a href="windows.html#WinScrolled-event">WinScrolled-event</a> 

                                仅当系统启动完毕且首次屏幕重画完成后才会开始触
                                发。首个 WinScrolled 或 WinResized 事件在定义
                                时不触发，但加入更多事件时可能会。

                                非递归: WinScrolled 事件执行命令时不会触发自
                                身。不过，如果其中的命令导致窗口滚动或大小改
                                变，之后会触发另一个 WinScrolled 事件。新增自
                                动命令时，不会触发此事件，仅在首次滚动或改变大
                                小后才触发。


                                                        <b class="vimtag"> <a name="WinResized">WinResized</a> </b>
WinResized                      在当前标签页的某个窗口改变宽高后。
                                见  <a href="windows.html#win-scrolled-resized">win-scrolled-resized</a> 。

                                 <a href="eval.html#v:event">v:event</a>  设为大小改变的相关信息。
                                 <a href="windows.html#WinResized-event">WinResized-event</a> 

                                模式、触发和递归性同  <a href="autocmd.html#WinScrolled">WinScrolled</a> 。

</section><hr class="doubleline" /><section class=inner>
<h4>6. 模式                                         <b class="vimtag"> <a name="autocmd-patterns">autocmd-patterns</a> </b> <b class="vimtag"> <a name="{aupat}">{aupat}</a> </b></h4>
 <a href="autocmd.html#:autocmd">:autocmd</a>  的 <code class="special">{aupat}</code> 参数可以是逗号分隔的列表，相当于对每个模式分别给出该命
令。因而: 
<code class="example">        :autocmd BufRead *.txt,*.info set et</code>
等价于: 
<code class="example">        :autocmd BufRead *.txt set et</code>
<code class="example">        :autocmd BufRead *.info set et</code>
<code class="example"></code>
文件模式 <code class="special">{aupat}</code> 用以下两种方式之一匹配文件名:
1. 如果模式里没有 '/'，只匹配文件名的尾部 (不包括它之前的目录路径)。
2. 如果模式里有 '/'，既匹配短本件名 (你输入的)，也匹配完整文件名 (扩展为完整路
   径并进行完符号链接的解析以后)。

特殊模式 <code class="special">&lt;buffer&gt;</code> 或 &lt;buffer=N&gt; 用于局部于缓冲区的自动命令
 <a href="autocmd.html#autocmd-buflocal">autocmd-buflocal</a> 。该模式不是用来匹配缓冲区的名字的。

例如: 
<code class="example">        :autocmd BufRead *.txt          set et</code>
为所有的文本文件置位 <a href="options.html#'et'">'et'</a> 选项。 
<code class="example"></code>
<code class="example">        :autocmd BufRead /vim/src/*.c   set cindent</code>
为所有 /vim/src 目录下的 C 文件置位 <a href="options.html#'cindent'">'cindent'</a> 选项。 
<code class="example"></code>
<code class="example">        :autocmd BufRead /tmp/*.c       set ts=5</code>
如果你有一个从 "/tmp/test.c" 到 "/home/nobody/src/test.c" 的链接并且开始编辑
"/tmp/test.c"，该自动命令会匹配。

<code class="note">注意</code>: 要匹配部分路径而不从根目录开始指定，第一个字符用 '*'。例如: 
<code class="example">        :autocmd BufRead */doc/*.txt    set tw=78</code>
该自动命令会在例如 "/tmp/doc/xx.txt" 和 "/usr/home/piet/doc/yy.txt" 上执行。目
录的层次此处无关紧要。


模式匹配的是通配符扩展后的文件名。这样: 
<code class="example">        :e $ROOTDIR/main.$EXT</code>
的参数会在匹配自动命令模式前先被扩展成: 
<code class="example">        /usr/root/main.py</code>
小心 FileReadCmd 这样的事件使用的 <code class="special">&lt;amatch&gt;</code> 的值未必如你所料。


模式里可以指定环境变量: 
<code class="example">        :autocmd BufRead $VIMRUNTIME/doc/*.txt  set expandtab</code>
而 ~ 也可以指定主目录 (如果定义了 $HOME): 
<code class="example">        :autocmd BufWritePost ~/.vimrc   so ~/.vimrc</code>
<code class="example">        :autocmd BufRead ~archive/*      set readonly</code>
在自动命令的定义时扩展环境变量，而不是在执行时进行。这和命令的处理不同！

                                                        <b class="vimtag"> <a name="file-pattern">file-pattern</a> </b>
这里，模式的解释和文件名里的模式大致相同:
        *       匹配任何字符序列
        ?       匹配任何单个字符；特别的是，也包括路径分隔符
        \?      匹配 '?'
        .       匹配 '.'
        ~       匹配 '~'
        ,       分隔模式
        \,      匹配 ','
        { }     类似于  <a href="pattern.html#pattern">pattern</a>  里的 \( \)
        ,       在 { } 里: 类似于  <a href="pattern.html#pattern">pattern</a>  里的 \|
        \}      本义的 }
        \{      本义的 {
        \\\<code class="special">{n,m\}</code>  类似于  <a href="pattern.html#pattern">pattern</a>  里的 \<code class="special">{n,m}</code>
        \       类似于  <a href="pattern.html#pattern">pattern</a>  里的特殊含义
        <code class="special">[ch]</code>    匹配 'c' 或 'h'
        [^ch]   匹配除了 'c' 和 'h' 的任何字符

<code class="note">注意</code> 在任何系统上，'/' 字符都被用作路径分隔符 (即使 MS-Windows 也是如此)。如此
做是因为反斜杠在模式里很难使用，而且也为了自动命令能在不同系统间可以相互移植。

可以使用普通模式的项目，但请见上述的特定转译，可能和你的预期有所落差。

                                                        <b class="vimtag"> <a name="autocmd-changes">autocmd-changes</a> </b>
模式的匹配是在事件触发时进行的。即使某个自动命令改变了缓冲区名字甚至删除了缓冲
区，也不会改变执行的是哪个自动命令。例如: 
<code class="example"></code>
<code class="example">        au BufEnter *.foo  bdel</code>
<code class="example">        au BufEnter *.foo  set modified</code>
<code class="example"></code>
会删除当前缓冲区，并置位取代当前缓冲区的新缓冲区的 <a href="options.html#'modified'">'modified'</a> 标志。Vim 不管
"*.foo" 此时已经不匹配该缓冲区名字。"*.foo" 在该事件被触发时匹配当时的缓冲区名
字。

不过，局部于缓冲区的自动命令在用  <a href="windows.html#:bwipe">:bwipe</a>  彻底删除的缓冲区上不会执行。如果 用
 <a href="windows.html#:bdel">:bdel</a>  删除缓冲区，该缓冲区其实还是存在的 (它只是不被列出)，因而这些自动命令
还会执行。

</section><hr class="doubleline" /><section class=inner>
<h4>7. 局部于缓冲区的自动命令       <b class="vimtag"> <a name="autocmd-buflocal">autocmd-buflocal</a> </b> <b class="vimtag"> <a name="autocmd-buffer-local">autocmd-buffer-local</a> </b></h4>                                        <b class="vimtag"> <a name="%3Cbuffer%20N%3E">&lt;buffer=N&gt;</a> </b> <b class="vimtag"> <a name="%3Cbuffer%20abuf%3E">&lt;buffer=abuf&gt;</a> </b> <b class="vimtag"> <a name="E680">E680</a> </b>

局部于缓冲区的自动命令和特定缓冲区相联系。它们可用于没有名字或者名字不匹配特定
模式的缓冲区。但这也意味着必须为每个缓冲区显式地加入这些自动命令。

局部于缓冲区的自动命令不用模式，而用如下的形式:
        <code class="special">&lt;buffer&gt;</code>        当前缓冲区
        &lt;buffer=99&gt;     缓冲区号 99
        &lt;buffer=abuf&gt;   用 <code class="special">&lt;abuf&gt;</code> (只当执行自动命令时适用)  <a href="cmdline.html#%3Cabuf%3E">&lt;abuf&gt;</a> 

示例: 
<code class="example">    :au CursorHold &lt;buffer&gt;  echo 'hold'</code>
<code class="example">    :au CursorHold &lt;buffer=33&gt;  echo 'hold'</code>
<code class="example">    :au BufNewFile * au CursorHold &lt;buffer=abuf&gt;  echo 'hold'</code>
<code class="example"></code>
所有自动命令的命令都可用于局部于缓冲区的自动命令，只要简单地用这些特殊字符串来
替代模式就行了。例如: 
<code class="example">    :au! * &lt;buffer&gt;                  " 删除当前缓冲区的局部于缓冲区的自动命令</code>
<code class="example">    :au! * &lt;buffer=33&gt;               " 删除缓冲区 #33 的局部于缓冲区的自动命令</code>
<code class="example">    :bufdo :au! CursorHold &lt;buffer&gt;  " 删除所有缓冲区里给定事件的自动命令</code>
<code class="example">    :au * &lt;buffer&gt;                   " 列出当前缓冲区的局部于缓冲区的自动命令</code>

<code class="note">注意</code> 如果为当前缓冲区定义自动命令，保存时记住的是它的缓冲区号。这里用的形式是
"&lt;buffer=12&gt;"，其中 12 是当前缓冲区的编号。例如，列出自动命令时你看到的就是这
种形式。

要测试局部于缓冲区的自动命令是否存在，用  <a href="builtin.html#exists()">exists()</a>  函数: 
<code class="example">    :if exists("#CursorHold#&lt;buffer=12&gt;") | ... | endif</code>
<code class="example">    :if exists("#CursorHold#&lt;buffer&gt;") | ... | endif    " 指定当前缓冲区</code>
<code class="example"></code>
如果缓冲区被彻底删除，其局部于缓冲区的自动命令当然也没有了。<code class="note">注意</code> 缓冲区如果被
删除，比如用 ":bdel"，它只是不被列出而已，其自动命令还是存在的。要观察局部于缓
冲区的自动命令的删除情况: 
<code class="example">    :set verbose=6</code>
<code class="example"></code>
不能为还不存在的缓冲区定义局部于缓冲区的自动命令。

</section><hr class="doubleline" /><section class=inner>
<h4>8. 组                                                   <b class="vimtag"> <a name="autocmd-groups">autocmd-groups</a> </b></h4>
自动命令可以被一起放在一个组里。这可用于删除或者执行一组自动命令。例如，所有有
关语法高亮的自动命令被放在 "highlight" 组里，这样在 GUI 启动时可以一并执行
":doautoall highlight BufRead"。

如果没有指定特殊的组名，Vim 使用缺省组。缺省组没有名字。你不能单独执行缺省组的
所有自动命令；只有在执行所有组里的自动命令时才会执行它们。

正常情况下，在自动执行自动命令时，Vim 使用所有组的自动命令。组只有在用
":doautocmd" 或 ":doautoall" 执行自动命令或者在定义或删除自动命令时才用的上。

组名可以包含任何非空白字符。但组名 "end" 保留 (包括大写形式)。

组名是区分大小写的。<code class="note">注意</code> 这和事件名不同！

                                                        <b class="vimtag"> <a name=":aug">:aug</a> </b> <b class="vimtag"> <a name=":augroup">:augroup</a> </b>
:aug[roup] <code class="special">{name}</code>               定义其后的 ":autocmd" 命令使用的自动命令组名。
                                名字 "end" 或者 "END" 选择缺省组。
                                为了避免混淆，此处不要用和已有 <code class="special">{event}</code> 名重名
                                的名字，很可能和你想做的不同。

                                        <b class="vimtag"> <a name=":augroup-delete">:augroup-delete</a> </b> <b class="vimtag"> <a name="E367">E367</a> </b> <b class="vimtag"> <a name="W19">W19</a> </b> <b class="vimtag"> <a name="E936">E936</a> </b>
:aug[roup]! <code class="special">{name}</code>              删除自动命令组 <code class="special">{name}</code>。如果还有自动命令使用该
                                组，不要这么做！不然，系统会<code class="note">警告</code>你。而且如果该
                                组是当前组，会报错 E936。

要为某个组输入自动命令，使用如下方法:
1. 用 ":augroup <code class="special">{name}</code>" 选择组。
2. 用 ":au!" 删除所有旧的自动命令。
3. 定义自动命令。
4. 用 "augroup END" 回到缺省组。

例如: 
<code class="example">        :augroup uncompress</code>
<code class="example">        :  au!</code>
<code class="example">        :  au BufEnter *.gz     %!gunzip</code>
<code class="example">        :augroup END</code>
<code class="example"></code>
这样可以防止自动命令被多次定义 (例如，再次执行 .vimrc 文件)。

                                                <b class="vimtag"> <a name="FileExplorer">FileExplorer</a> </b>
Vim 识别以下命令组: FileExplorer。如果该组存在，Vim 便假定目录可以编辑，并触发
一个插件来列出该目录中的文件。 <a href="pi_netrw.html#netrw">netrw</a>  插件使用此特性。这样就可以用: 
<code class="example">        browse edit</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>9. 执行自动命令                                 <b class="vimtag"> <a name="autocmd-execute">autocmd-execute</a> </b></h4>
Vim 也可以非自动地执行自动命令。如果你修改了自动命令或者 Vim 执行了不正确的自
动命令 (例如文件模式的匹配不正确)，这也许会有用。

<code class="note">注意</code> <a href="options.html#'eventignore'">'eventignore'</a> 选项也适用于此。不会为该选项列出的事件执行任何命令。

                                <b class="vimtag"> <a name=":do">:do</a> </b> <b class="vimtag"> <a name=":doau">:doau</a> </b> <b class="vimtag"> <a name=":doaut">:doaut</a> </b> <b class="vimtag"> <a name=":doautocmd">:doautocmd</a> </b> <b class="vimtag"> <a name="E217">E217</a> </b>
:do[autocmd] [<code class="special">&lt;nomodeline&gt;</code>] <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">[fname]</code>
                        应用匹配 <code class="special">[fname]</code> (缺省是当前文件名) 和针对当前缓冲区的
                        <code class="special">{event}</code> 事件的自动命令。如果当前文件不匹配正确的模式，
                        修改完设置，或者想手动执行某一特定的事件的自动命令的时
                        候，都可以使用该命令。
                        自动命令中也可以使用，这样你可以用基于一个扩展名的自动
                        命令来应用于另一个扩展名。例如: 
<code class="example">                                :au BufEnter *.cpp so ~/.vimrc_cpp</code>
<code class="example">                                :au BufEnter *.cpp doau BufEnter x.c</code>
                        要小心避免死循环，参见  <a href="autocmd.html#autocmd-nested">autocmd-nested</a> 。

                        如果没有给出 <code class="special">[group]</code> 参数，Vim 执行所有组里的自动命
                        令。如果给出 <code class="special">[group]</code> 参数，Vim 只执行该组里匹配的自动
                        命令。<code class="note">注意</code>: 如果你使用未定义的组名，Vim 会报错。

                                                        <b class="vimtag"> <a name="%3Cnomodeline%3E">&lt;nomodeline&gt;</a> </b>
                        应用完自动命令后，会执行模式行。其中的设置可以否决自动
                        命令里的设置，一如编辑文件时那样。给出 <code class="special">&lt;nomodeline&gt;</code> 参
                        数时，跳过这一步骤。对那些不用于缓冲区载入时的事件，如
                         <a href="autocmd.html#User">User</a> ，这一参数较为有用。
                        如果没有匹配的自动命令可执行，也不会处理模式行。

                                                <b class="vimtag"> <a name=":doautoa">:doautoa</a> </b> <b class="vimtag"> <a name=":doautoall">:doautoall</a> </b>
:doautoa[ll] [<code class="special">&lt;nomodeline&gt;</code>] <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">[fname]</code>
                        类似于 ":doautocmd"，但对每个已载入的缓冲区应用自动命
                        令。当前缓冲区被最后应用。

                        <code class="note">注意</code> <code class="special">[fname]</code> 用于选择自动命令，而不是其应用的缓冲区。
                        示例: 
<code class="example">                                augroup mine</code>
<code class="example">                                  autocmd!</code>
<code class="example">                                  autocmd FileType * echo expand('&lt;amatch&gt;')</code>
<code class="example">                                augroup END</code>
<code class="example">                                doautoall mine FileType Loaded-Buffer</code>
                        执行此脚本，每个已载入的缓冲区都会回显一行
                        "Loaded-Buffer"。

                        要小心: 不要用这个命令执行删除缓冲区、切换到别的缓冲区
                        或者修改缓冲区内容的自动命令；否则结果不可预测。该命令
                        是设计用来执行类似于设置选项、修改高亮等任务的自动命令
                        的。

</section><hr class="doubleline" /><section class=inner>
<h4>10. 自动命令的使用                                      <b class="vimtag"> <a name="autocmd-use">autocmd-use</a> </b></h4>
对于文件的 <code class="emphasis">写入</code> ，有四组可能的事件。Vim 对一个写入命令只会执行其中的一组:

BufWriteCmd     BufWritePre     BufWritePost    写回整个缓冲区
                FilterWritePre  FilterWritePost 写入过滤程序的临时文件
FileAppendCmd   FileAppendPre   FileAppendPost  附加到文件
FileWriteCmd    FileWritePre    FileWritePost   其他的文件写入

如果定义了 "*Cmd" 自动命令，它应该完成相应写入的操作。因而，其他的写入操作不会
进行，其他的事件也不会被触发。 <a href="autocmd.html#Cmd-event">Cmd-event</a> 

<code class="note">注意</code> *WritePost 命令应该撤销 *WritePre 命令对缓冲区所做的任何改动；否则，文件
的写入会有不应该有的修改缓冲区的副作用。

开始执行自动命令前，写入的行所在的缓冲区暂时成为当前缓冲区。除非自动命令修改了
当前缓冲区或者删除了先前的那个当前缓冲区，先前的那个又会重新成为当前的。

*WritePre 和 *AppendPre 自动命令不能删除写入的行所在的那个缓冲区。

'[ 和 '] 位置标记有特殊的位置:
- 在 *ReadPre 事件之前，'[ 标记设为新行将要插入的位置上方的那行。
- 在 *ReadPost 事件之前，'[ 标记设为新读入的内容的第一行，'] 则为其最后一行。
- 开始执行 *WriteCmd、*WritePre 和 *AppendPre 自动命令前，'[ 标记设为要写入的
  内容的第一行，'] 则为其最后一行。
小心: '[ 和 '] 指定的位置在使用修改缓冲区的命令时会改变。

在期待文件名的命令里，你可以使用 "<code class="special">&lt;afile&gt;</code>" 指定被读入的文件名  <a href="cmdline.html#:%3Cafile%3E">:&lt;afile&gt;</a>  (你可
以用 "%" 指定当前文件名)。"<code class="special">&lt;abuf&gt;</code>" 指定当前有效的缓冲区的缓冲区号。它可以用
于没有名字的缓冲区，但不适用于没有缓冲区的文件 (例如，用 ":r file")。

                                                        <b class="vimtag"> <a name="gzip-example">gzip-example</a> </b>
读写压缩文件的示例: 
<code class="example">  :augroup gzip</code>
<code class="example">  :  autocmd!</code>
<code class="example">  :  autocmd BufReadPre,FileReadPre     *.gz set bin</code>
<code class="example">  :  autocmd BufReadPost,FileReadPost   *.gz '[,']!gunzip</code>
<code class="example">  :  autocmd BufReadPost,FileReadPost   *.gz set nobin</code>
<code class="example">  :  autocmd BufReadPost,FileReadPost   *.gz execute ":doautocmd BufReadPost " .. expand("%:r")</code>
<code class="example">  :  autocmd BufWritePost,FileWritePost *.gz !mv &lt;afile&gt; &lt;afile&gt;:r</code>
<code class="example">  :  autocmd BufWritePost,FileWritePost *.gz !gzip &lt;afile&gt;:r</code>
<code class="example"></code>
<code class="example">  :  autocmd FileAppendPre              *.gz !gunzip &lt;afile&gt;</code>
<code class="example">  :  autocmd FileAppendPre              *.gz !mv &lt;afile&gt;:r &lt;afile&gt;</code>
<code class="example">  :  autocmd FileAppendPost             *.gz !mv &lt;afile&gt; &lt;afile&gt;:r</code>
<code class="example">  :  autocmd FileAppendPost             *.gz !gzip &lt;afile&gt;:r</code>
<code class="example">  :augroup END</code>
<code class="example"></code>
我们用 "gzip" 组执行 ":autocmd!"，从而能在脚本文件被执行两次时，删除已经定义的
自动命令。

("<code class="special">&lt;afile&gt;</code>:r" 是去掉扩展名的文件名，参见  <a href="cmdline.html#:_%:">:_%:</a> )

BufNewFile、BufRead/BufReadPost、BufWritePost、FileAppendPost 和 VimLeave 事件
执行的自动命令不置位或复位缓冲区的修改标志。当你用 BufReadPost 自动命令解压缓
冲区时，你还可以用 ":q" 直接退出。当你在 BufWritePost 里用 ":undo" 撤销
BufWritePre 命令所做的改变时，你也可以用 ":q" (所以，也可以用 "ZZ")。如果你想
使缓冲区设为修改过的，置位 <a href="options.html#'modified'">'modified'</a> 选项。

要在自动命令里执行普通模式的命令，用 ":normal" 命令。要小心: 如果普通模式命令
没能结束，用户需要键入字符 (例如，":normal m" 之后需要输入一个位置标记名)。

如果你在缓冲区修改后想使之成为未修改状态，复位 <a href="options.html#'modified'">'modified'</a> 选项。这使得用 ":q"
退出缓冲区 (而不用 ":q!") 成为可能。

                                                        <b class="vimtag"> <a name="autocmd-nested">autocmd-nested</a> </b> <b class="vimtag"> <a name="E218">E218</a> </b>
自动命令缺省不会嵌套。例如，如果你在自动命令里用 ":e" 或者 ":w"，Vim 不会执行
这些命令相应的 BufRead 和 BufWrite 自动命令。如果你需要这么做，在需要嵌套的命
令的定义里加上 "nested" 标志位。例如: 
<code class="example">  :autocmd FileChangedShell *.c ++nested e!</code>
为了防止递归循环，嵌套限定为 10 层。

自动命令里可以用 ":au" 命令。甚至可以用来实现自我修改的命令。这适用于只执行一
次的自动命令。

要想为单个命令跳过自动命令，使用  <a href="autocmd.html#:noautocmd">:noautocmd</a>  命令修饰符，或者 <a href="options.html#'eventignore'">'eventignore'</a>
选项。

<code class="note">注意</code>: 读入文件时 (用 ":read file" 或者过滤命令)，如果文件的最后一行没有换行符
<code class="special">&lt;EOL&gt;</code>，Vim 记住这一点。下一次写 (用 ":write file" 或者过滤命令) 的时候，如果最
后一行不变 <code class="emphasis">而且</code> 置位了 <a href="options.html#'binary'">'binary'</a>，Vim 不会自己提供 <code class="special">&lt;EOL&gt;</code>。这使得在刚读入的行上
的过滤命令写入相同的文件时写的内容和读入的完全一致，也使得在刚过滤过的行上的写
入命令写入相同文件时写的和从过滤程序读取的完全相同。例如，另一个写压缩文件的方
法是: 
<code class="example"></code>
<code class="example">  :autocmd FileWritePre *.gz   set bin|'[,']!gzip</code>
<code class="example">  :autocmd FileWritePost *.gz  undo|set nobin</code>

                                                        <b class="vimtag"> <a name="autocommand-pattern">autocommand-pattern</a> </b>
你可以指定逗号分隔的多个模式。以下是一些示例。 
<code class="example"></code>
<code class="example">  :autocmd BufRead   *          set tw=79 nocin ic infercase fo=2croq</code>
<code class="example">  :autocmd BufRead   .letter    set tw=72 fo=2tcrq</code>
<code class="example">  :autocmd BufEnter  .letter    set dict=/usr/lib/dict/words</code>
<code class="example">  :autocmd BufLeave  .letter    set dict=</code>
<code class="example">  :autocmd BufRead,BufNewFile   *.c,*.h set tw=0 cin noic</code>
<code class="example">  :autocmd BufEnter  *.c,*.h    abbr FOR for (i = 0; i &lt; 3; ++i)&lt;CR&gt;{&lt;CR&gt;}&lt;Esc&gt;O</code>
<code class="example">  :autocmd BufLeave  *.c,*.h    unabbr FOR</code>
<code class="example"></code>
要指定 makefiles (makefile、Makefile、imakefile、makefile.unix 等等): 
<code class="example"></code>
<code class="example">  :autocmd BufEnter  ?akefile*  set include=^s\=include</code>
<code class="example">  :autocmd BufLeave  ?akefile*  set include&amp;</code>
<code class="example"></code>
要使得 C 程序的编辑从第一个函数开始: 
<code class="example"></code>
<code class="example">  :autocmd BufRead   *.c,*.h    1;/^{</code>
<code class="example"></code>
上面如果没有 "1;"，搜索会从文件进入的位置开始，而不是文件的开始处。

                                                <b class="vimtag"> <a name="skeleton">skeleton</a> </b> <b class="vimtag"> <a name="template">template</a> </b>
要开始编辑新文件时读入一个骨架 (样板) 文件: 
<code class="example"></code>
<code class="example">  :autocmd BufNewFile  *.c      0r ~/vim/skeleton.c</code>
<code class="example">  :autocmd BufNewFile  *.h      0r ~/vim/skeleton.h</code>
<code class="example">  :autocmd BufNewFile  *.java   0r ~/vim/skeleton.java</code>
<code class="example"></code>
要在写入一个 *.html 文件时插入当前日期和时间: 
<code class="example"></code>
<code class="example">  :autocmd BufWritePre,FileWritePre *.html   ks|call LastMod()|'s</code>
<code class="example">  :fun LastMod()</code>
<code class="example">  :  if line("$") &gt; 20</code>
<code class="example">  :    let l = 20</code>
<code class="example">  :  else</code>
<code class="example">  :    let l = line("$")</code>
<code class="example">  :  endif</code>
<code class="example">  :  exe "1," .. l .. "g/Last modified: /s/Last modified: .*/Last modified: " ..</code>
<code class="example">  :  \ strftime("%Y %b %d")</code>
<code class="example">  :endfun</code>
<code class="example"></code>
要这段代码工作，你需要在文件开始的 20 行里有这行 "Last modified: &lt;date
time&gt;"。 Vim 把 &lt;date time&gt; (包括该行其后的任何内容) 替换为当前的日期和时间。
解释:
        ks              保存当前位置到 's' 标记
        call LastMod()  调用 LastMod() 函数完成工作
        's              光标回到旧的位置
LastMode() 函数先检查文件是否少于 20 行，然后用 ":g" 命令查找包含 "Last
Modified:" 的行。在这些行上执行 ":s" 命令实现从已有的时间到当前时间的替换。
":execute" 命令使 ":g" 和 ":s" 命令可以使用表达式。日期用 strftime() 函数取
得。它可以用别的参数取得不同格式的日期字符串。

在命令行上输入 :autocmd 的时候，事件和命令名字在可能的情况可以用 <code class="special">&lt;Tab&gt;</code>，<code class="keystroke">CTRL-D</code>
等进行自动补全。

Vim 根据你定义的顺序执行所有匹配的自动命令。建议第一个自动命令使用 "*" 作为文
件模式，从而使之适用于所有文件。这意味着你可以在这里设定任何选项的缺省值，如果
有别的匹配的自动命令，可以把这些缺省值覆盖。但如果没有，至少你的缺省设置得到保
证 (如果从另一个能够匹配自动命令的文件进入这个文件)。<code class="note">注意</code> "*" 也会匹配以 "."
开始的文件，这一点和 Unix 外壳不同。

                                                    <b class="vimtag"> <a name="autocmd-searchpat">autocmd-searchpat</a> </b>
自动命令不会改变当前的搜索模式。Vim 在执行自动命令前保存当前的搜索模式，在完成
后恢复之。这意味着自动命令不会影响 <a href="options.html#'hlsearch'">'hlsearch'</a> 选项指定的高亮字符串。自动命令里
你可以正常的使用模式搜索。例如，用 "n" 命令。如果你想要自动命令设置在命令完成
后仍然可用的搜索模式，用 ":let @/ =" 命令。自动命令里不能用 ":nohlsearch" 关闭
高亮部分。不过，在启动 Vim 的时候，可以用 <a href="options.html#'viminfo'">'viminfo'</a> 选项里的 'h' 标志位关闭搜
索高亮功能。

                                                        <b class="vimtag"> <a name="Cmd-event">Cmd-event</a> </b>
在使用 "*Cmd" 事件之一时，匹配的自动命令应该负责执行文件读取、写入或脚本执行操
作。这可以用以操作特殊的文件，例如在远程文件系统上。
小心: 如果你不正确使用这些事件，造成的效果是你无法读写匹配的文件！确保你小心的
测试过这些自动命令。最好使用的是不会匹配正常文件的模式，例如 "ftp://*"。

定义 BufReadCmd 以后，Vim 很难从崩溃的编辑会话恢复。从原始文件恢复的时候，Vim
只会读取交换文件里不存在的部分。因为这用 BufReadCmd 不可能做到，用  <a href="recover.html#:preserve">:preserve</a> 
可以保证恢复的时候不需要原始的文件。应该只有在文件被修改的时候你才想这么做。

对于文件读写命令， <a href="eval.html#v:cmdarg">v:cmdarg</a>  变量保存当前有效的 "++enc=" 和 "++ff=" 参数。在读
写文件的命令里应该用到这些参数。用 "!" 后缀时， <a href="eval.html#v:cmdbang">v:cmdbang</a>  参数为 1，不然其为
0。

示例参见 $VIMRUNTIME/plugin/netrwPlugin.vim。

</section><hr class="doubleline" /><section class=inner>
<h4>11. 屏蔽自动命令                                        <b class="vimtag"> <a name="autocmd-disable">autocmd-disable</a> </b></h4>
要在一段时间里屏蔽自动命令，使用 <a href="options.html#'eventignore'">'eventignore'</a> 选项。<code class="note">注意</code> 这可能会导致意料不到
的效果。确信在此之后恢复 <a href="options.html#'eventignore'">'eventignore'</a>，可用带  <a href="eval.html#:finally">:finally</a>  的  <a href="eval.html#:try">:try</a>  块。

要无限期地在特定窗口里屏蔽自动命令，可用 <a href="options.html#'eventignorewin'">'eventignorewin'</a> 选项。只能用于屏蔽窗
口和缓冲区相关的事件。

                                                        <b class="vimtag"> <a name=":noautocmd">:noautocmd</a> </b> <b class="vimtag"> <a name=":noa">:noa</a> </b>
要为单个命令屏蔽自动命令，使用 ":noautocmd" 命令修饰符。它会在下一个命令的执行
期间把 <a href="options.html#'eventignore'">'eventignore'</a> 设为 "all"。例如: 
<code class="example"></code>
<code class="example">        :noautocmd w fname.gz</code>
<code class="example"></code>
这样，可以写入文件而不触发 gzip 插件定义的自动命令。

<code class="note">注意</code> 有些自动事件不会立即触发，而会在之后发生。特别适用于  <a href="autocmd.html#CursorMoved">CursorMoved</a>  和
 <a href="autocmd.html#TextChanged">TextChanged</a> 。


 vim:tw=78:ts=8:noet:ft=help:norl:
</section>
</article>
<footer>
Generated by vim2html
</footer>
</body>
</html>
