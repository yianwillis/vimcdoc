<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<![endif]-->
<title>VIM 中文帮助: 语法高亮</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css" />
<link rel="canonical" href="https://yianwillis.github.io/vimcdoc/doc/syntax.html" />
<script type="text/javascript" src="vimcdoc.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
<nav id=banner>
<form action=tags.html target="tag_iframe">
  <input type="text" name="tag" id="tag" placeholder="标签搜索">
</form>
<iframe name="tag_iframe" src=""></iframe>
<a href="help.html">帮助总览</a> &middot;
<hr/>
<a href="quickref.html">快速参考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="eval.html#functions">函数列表</a> &middot;
<a href="quickref.html#option-list">选项列表</a> &middot;
<hr/>
<a href="usr_toc.html">用户手册</a> &middot;
<a href="help.html#reference_toc">参考手册</a> &middot;
</nav>

<header>
<h2>syntax</h2>
</header>
<article id=outer>
<section class=inner>
<b class="vimtag"> <a name="syntax.txt">syntax.txt</a> </b>    适用于 Vim 9.0 版本。   最近更新: 2025年3月


                  <code class="vim">VIM 参考手册    by Bram Moolenaar</code>
                                <code class="vim">译者</code>: Willis


语法高亮                        <b class="vimtag"> <a name="syntax">syntax</a> </b> <b class="vimtag"> <a name="syntax-highlighting">syntax-highlighting</a> </b> <b class="vimtag"> <a name="coloring">coloring</a> </b>

语法高亮使得 Vim 可以用不同的字体或颜色显示文本的不同部分。这些部分可以是特定
的关键字，或者匹配某模式的文本。Vim 不会分析整个文件 (为了保持快速)，所以高亮
功能有其限制。词法高亮或者是一个更合适的名字，但既然大家都使用语法高亮，我们也
就如此称呼。

Vim 支持所有终端上的语法高亮。但因为多数普通的终端只有有限的高亮的选择，GUI 版
本 gvim 的语法高亮的效果最好。

用户手册里:
 <a href="usr_06.html#usr_06.txt">usr_06.txt</a>  介绍语法高亮。
 <a href="usr_44.html#usr_44.txt">usr_44.txt</a>  介绍如何写语法文件。

1.  快速入门                     <a href="syntax.html#:syn-qstart">:syn-qstart</a> 
2.  语法文件                     <a href="syntax.html#:syn-files">:syn-files</a> 
3.  语法载入过程                 <a href="syntax.html#syntax-loading">syntax-loading</a> 
4.  转换为 HTML                  <a href="syntax.html#2html.vim">2html.vim</a> 
5.  语法文件附注                 <a href="syntax.html#:syn-file-remarks">:syn-file-remarks</a> 
6.  定义语法                     <a href="syntax.html#:syn-define">:syn-define</a> 
7.  :syntax 参数                 <a href="syntax.html#:syn-arguments">:syn-arguments</a> 
8.  语法模式                     <a href="syntax.html#:syn-pattern">:syn-pattern</a> 
9.  语法簇                       <a href="syntax.html#:syn-cluster">:syn-cluster</a> 
10. 包含语法文件                 <a href="syntax.html#:syn-include">:syn-include</a> 
11. 同步                         <a href="syntax.html#:syn-sync">:syn-sync</a> 
12. 列出语法项目                 <a href="syntax.html#:syntax">:syntax</a> 
13. 色彩方案                     <a href="syntax.html#color-schemes">color-schemes</a> 
14. Highlight 命令               <a href="syntax.html#:highlight">:highlight</a> 
15. 链接组                       <a href="syntax.html#:highlight-link">:highlight-link</a> 
16. 清理                         <a href="syntax.html#:syn-clear">:syn-clear</a> 
17. 高亮标签                     <a href="syntax.html#tag-highlight">tag-highlight</a> 
18. 窗口局部语法                 <a href="syntax.html#:ownsyntax">:ownsyntax</a> 
19. 彩色 xterm                   <a href="syntax.html#xterm-color">xterm-color</a> 
20. 语法太慢了                   <a href="syntax.html#:syntime">:syntime</a> 

<code class="notvi">{Vi 无此功能}</code>

如果编译时关闭了  <a href="various.html#+syntax">+syntax</a>  特性，就不会有语法高亮的功能。

</section><hr class="doubleline" /><section class=inner>
<h4>1. 快速入门                                             <b class="vimtag"> <a name=":syn-qstart">:syn-qstart</a> </b></h4>
                                                <b class="vimtag"> <a name=":syn-enable">:syn-enable</a> </b> <b class="vimtag"> <a name=":syntax-enable">:syntax-enable</a> </b>
这个命令打开语法高亮: 
<code class="example"></code>
<code class="example">        :syntax enable</code>
<code class="example"></code>
实际上，它只是执行如下命令 
<code class="example">        :source $VIMRUNTIME/syntax/syntax.vim</code>
<code class="example"></code>
如果没有设置 VIM 环境变量，Vim 会试图用其它方法找到该路径 (见  <a href="starting.html#$VIMRUNTIME">$VIMRUNTIME</a> )。
通常总能找到，如果不行，你可以自己设置 VIM 环境变量为存放 Vim 相关文件所在的
目录。例如，如果你的语法文件放在 "/usr/vim/vim82/syntax" 目录，设置
$VIMRUNTIME 为 "/usr/vim/vim82"。启动 Vim 前，你必须在外壳上进行此设置。
当 GUI 已经在运行或即将运行时，此命令也执行  <a href="gui.html#menu.vim">menu.vim</a>  脚本。要避免可见
 <a href="options.html#'go-M'">'go-M'</a> 。

                                                        <b class="vimtag"> <a name=":syn-on">:syn-on</a> </b> <b class="vimtag"> <a name=":syntax-on">:syntax-on</a> </b>
`:syntax enable` 命令会保持绝大部分你当前的色彩设置。这样，不管在使用此命令的
前后，你都可以用  <a href="syntax.html#:highlight">:highlight</a>  命令设置你喜欢的颜色。如果你希望 Vim 用缺省值覆
盖你自己的，只要用: 
<code class="example">        :syntax on</code>

                                        <b class="vimtag"> <a name=":hi-normal">:hi-normal</a> </b> <b class="vimtag"> <a name=":highlight-normal">:highlight-normal</a> </b>
如果你运行在 GUI 环境里，你可以这样得到黑底白字: 
<code class="example">        :highlight Normal guibg=Black guifg=White</code>
关于色彩终端，见  <a href="syntax.html#:hi-normal-cterm">:hi-normal-cterm</a> 。
关于设置你自己的语法高亮色彩，见  <a href="syntax.html#syncolor">syncolor</a> 。

<code class="note">注意</code>: MS-Windows 上的语法文件以 <code class="special">&lt;CR&gt;</code><code class="special">&lt;NL&gt;</code> 结束每一行。Unix 上则以 <code class="special">&lt;NL&gt;</code> 结尾。这
意味着你需要为自己的系统选择合适的文件。不过，在 MS-Windows 上，如果
<a href="options.html#'fileformats'">'fileformats'</a> 选项非空，会自动选择正确的格式。

<code class="note">注意</code>: 使用反转视频时 ("gvim -fg white -bg black")，<a href="options.html#'background'">'background'</a> 的缺省值直到
GUI 窗口打开时才会设置。这发生在  <a href="gui.html#gvimrc">gvimrc</a>  的读入之后，从而会使用错误的缺省高
亮。要在打开高亮前设置 <a href="options.html#'background'">'background'</a> 的缺省值，在  <a href="gui.html#gvimrc">gvimrc</a>  文件里包含 ":gui" 命
令: 
<code class="example"></code>
<code class="example">   :gui         " 打开窗口并设置 'background' 的缺省值</code>
<code class="example">   :syntax on   " 启动语法高亮，使用 'background' 来设置颜色</code>
<code class="example"></code>
<code class="note">注意</code>: 在  <a href="gui.html#gvimrc">gvimrc</a>  里使用 ":gui" 意味着 "gvim -f" 不会在前台打开！这时，要使用
":gui -f"。

                                                        <b class="vimtag"> <a name="g:syntax_on">g:syntax_on</a> </b>
你可以用这个命令切换语法的打开/关闭 
<code class="example">   :if exists("g:syntax_on") | syntax off | else | syntax enable | endif</code>
<code class="example"></code>
要把它放到映射里，你可以用: 
<code class="example">   :map &lt;F7&gt; :if exists("g:syntax_on") &lt;Bar&gt;</code>
<code class="example">        \   syntax off &lt;Bar&gt;</code>
<code class="example">        \ else &lt;Bar&gt;</code>
<code class="example">        \   syntax enable &lt;Bar&gt;</code>
<code class="example">        \ endif &lt;CR&gt;</code>
[使用  <a href="intro.html#%3C%3E">&lt;&gt;</a>  记法，按本义输入]

细节:
":syntax" 命令是用执行文件脚本实现的。要了解它到底干了什么，察看以下文件:
<code class="section">    命令                文件 </code>
    :syntax enable      $VIMRUNTIME/syntax/syntax.vim
    :syntax on          $VIMRUNTIME/syntax/syntax.vim
    :syntax manual      $VIMRUNTIME/syntax/manual.vim
    :syntax off         $VIMRUNTIME/syntax/nosyntax.vim
另见  <a href="syntax.html#syntax-loading">syntax-loading</a> 。

<code class="note">注意</code>: 如果显示长行很慢而关闭语法高亮就能加快，考虑设置 <a href="options.html#'synmaxcol'">'synmaxcol'</a> 选项为一个
较小的值。

</section><hr class="doubleline" /><section class=inner>
<h4>2. 语法文件                                                     <b class="vimtag"> <a name=":syn-files">:syn-files</a> </b></h4>
某个语言的语法和高亮命令通常存在一个语法文件里。命名惯例是: "<code class="special">{name}</code>.vim"。其
中，<code class="special">{name}</code> 是语言的名字或者缩写 (一旦在 DOS 文件系统上，要适用 8.3 字符的名字
限制)。
例如:
        c.vim           perl.vim        java.vim        html.vim
        cpp.vim         sh.vim          csh.vim

语法文件可以包含任何 Ex 命令，就像 vimrc 文件那样。但应该只有适用于特定语言的
命令才放在里面。如果该语言是另外一个语言的超集，它可以包含那个语言对应的文件。
例如，cpp.vim 可以包含 c.vim 文件: 
<code class="example">   :so $VIMRUNTIME/syntax/c.vim</code>
<code class="example"></code>
.vim 文件通常使用自动命令载入。例如: 
<code class="example">   :au Syntax c     runtime! syntax/c.vim</code>
<code class="example">   :au Syntax cpp   runtime! syntax/cpp.vim</code>
这些命令通常出现在 $VIMRUNTIME/syntax/synload.vim 文件里。

如果你有多个文件，可以用文件类型作为目录名。该目录下的所有 "*.vim" 文件都会被
使用。例如:
        ~/.vim/after/syntax/c/one.vim
        ~/.vim/after/syntax/c/two.vim


创 立 你 自 己 的 语 法 文 件                           <b class="vimtag"> <a name="mysyntaxfile">mysyntaxfile</a> </b>

一旦你创立自己的语法文件，并且需要 Vim 在使用 ":syntax enable" 的时候自动调用
它们的时候，按如下操作进行:

1. 建立自己的用户运行时目录。通常，把它放在 <a href="options.html#'runtimepath'">'runtimepath'</a> 选项的第一项。Unix
的例子: 
<code class="example">        mkdir ~/.vim</code>
<code class="example"></code>
2. 在其中建立 "syntax" 目录。Unix 上: 
<code class="example">        mkdir ~/.vim/syntax</code>
<code class="example"></code>
3. 编写 Vim 语法文件。或者从 internet 下载。然后写入你的 syntax 目录。例如，对
于 "mine" 语言的语法: 
<code class="example">        :w ~/.vim/syntax/mine.vim</code>
<code class="example"></code>
现在你可以手动启动语法文件: 
<code class="example">        :set syntax=mine</code>
这时，你并不需要退出 Vim。

如果你想 Vim 也实现文件类型的检测，见  <a href="filetype.html#new-filetype">new-filetype</a> 。

如果你想为多个用户设立系统，而不希望每个用户增加相同的语法文件的话，可以使用
<a href="options.html#'runtimepath'">'runtimepath'</a> 里的其它目录。


添 加 到 已 存 在 的 语 法 文 件                <b class="vimtag"> <a name="mysyntaxfile-add">mysyntaxfile-add</a> </b>

如果你对已有的语法文件大体满意，只需要增加或者修正一些高亮项目，执行以下步骤即
可:

1. 建立你的 <a href="options.html#'runtimepath'">'runtimepath'</a> 里的用户目录，见上。

2. 在那里建立目录 "after/syntax"。Unix 上: 
<code class="example">        mkdir ~/.vim/after</code>
<code class="example">        mkdir ~/.vim/after/syntax</code>
<code class="example"></code>
3. 编写 Vim 脚本，包含你希望使用的命令。例如，要在 C 语法里改变颜色: 
<code class="example">        highlight cComment ctermfg=Green guifg=Green</code>
<code class="example"></code>
4. 把该文件写道 "after/syntax" 目录。使用该语法的名字，另加上 ".vim"。对于我们
的 C 语法: 
<code class="example">        :w ~/.vim/after/syntax/c.vim</code>
<code class="example"></code>
这样就行了。下一次你编辑 C 文件时，Comment 色彩就不会一样了。你甚至不需要重启
Vim。


替 换 已 存 在 的 语 法 文 件                   <b class="vimtag"> <a name="mysyntaxfile-replace">mysyntaxfile-replace</a> </b>

如果你不喜欢发布的语法文件版本，或者你下载了新版本。可以采用上述的
 <a href="syntax.html#mysyntaxfile">mysyntaxfile</a>  相同的步骤。只要确保你写的语法文件在 <a href="options.html#'runtimepath'">'runtimepath'</a> 较早的位置就
可以了。Vim 只会载入第一个找到的语法文件，假定它是用来设置 b:current_syntax 的
那个文件。


命 名 惯 例                         <b class="vimtag"> <a name="group-name">group-name</a> </b> <b class="vimtag"> <a name="{group-name}">{group-name}</a> </b> <b class="vimtag"> <a name="E669">E669</a> </b> <b class="vimtag"> <a name="W18">W18</a> </b>

高亮组名用于匹配相同类型事物的高亮项目。它们被链接到用于指定颜色的高亮组。语法
组名本身不指定任何颜色或属性。

高亮或者语法组的名字必须由 ASCII 字母、数字、下划线、句号或连字符组成。如使用
正则表达式表示: "[a-zA-Z0-9_.-]*"。不过，使用其它字符时 Vim 不报错。组名最大长
度大约是 200 字节。 <b class="vimtag"> <a name="E1249">E1249</a> </b>

要允许每个用户选择他们自己喜欢的色彩系列，许多语言应该使用相同的高亮组名。以下
是建议的组名 (如果语法高亮能够正确工作，你应该能看到实际的颜色，除了 "Ignore"
以外):

        *Comment        v 任何注释

        *Constant       v 任何常数
         String         v 字符串常数: "这是字符串"
         Character      v 字符常数: 'c'、'\n'
         Number         v 数值常数: 234、0xff
         Boolean        v 布尔型常数: TRUE、false
         Float          v 浮点常数: 2.3e10

        *Identifier     v 任何变量名
         Function       v 函数名 (也包括: 类的方法名)

        *Statement      v 任何语句
         Conditional    v if、then、else、endif、switch 等
         Repeat         v for、do、while 等
         Label          v case、default 等
         Operator       v "sizeof"、"+"、"*" 等
         Keyword        v 其它关键字
         Exception      v try、catch、throw

        *PreProc        v 通用预处理命令
         Include        v 预处理命令 #include
         Define         v 预处理命令 #define
         Macro          v 同 Define
         PreCondit      v 预处理命令 #if、#else、#endif 等

        *Type           v int、long、char 等
         StorageClass   v static、register、volatile 等
         Structure      v struct、union、enum 等
         Typedef        v typedef 定义

        *Special        v 任何特殊符号
         SpecialChar    v 常数中的特殊字符
         Tag            v 可以使用 <code class="keystroke">CTRL-]</code> 的项目
         Delimiter      v 需要<code class="note">注意</code>的字符
         SpecialComment v 注释里的特殊部分
         Debug          v 调试语句

        *Underlined     v 需要突出的文本，HTML 链接

        *Ignore         v 留空，被隐藏   <a href="syntax.html#hl-Ignore">hl-Ignore</a> 

        *Error          v 有错的构造

        *Todo           v 需要特殊<code class="note">注意</code>的部分；主要是关键字 TODO FIXME 和 XXX

* 标记的名字是主要组，其它是次要组。对主要组而言，"syntax.vim" 文件包含缺省的
高亮设置。次要组则链接到主要组。所以它们拥有相同的高亮设置。不过，你可以通过
":highlight" 命令在 "syntax.vim" 文件之后改变所有组的缺省值。

<code class="note">注意</code> 高亮组的名字对大小写不敏感。"String" 和 "string" 可用来表示相同的组。

以下名字是保留字，它们不应用作组名:
        NONE   ALL   ALLBUT   contains   contained

                                                        <b class="vimtag"> <a name="hl-Ignore">hl-Ignore</a> </b>
如果你使用 Ignore 组，也可以考虑使用隐藏机制。见  <a href="syntax.html#conceal">conceal</a> 。

</section><hr class="doubleline" /><section class=inner>
<h4>3. 语法载入过程                                         <b class="vimtag"> <a name="syntax-loading">syntax-loading</a> </b></h4>
这里解释命令 ":syntax enable" 执行的细节。Vim 初始化自身时，它寻找运行时文件的
位置。其值用来设置这里使用的变量  <a href="starting.html#$VIMRUNTIME">$VIMRUNTIME</a> 。

":syntax enable" 和 ":syntax on" 完成以下步骤:

    执行 $VIMRUNTIME/syntax/syntax.vim
    |
    +-  清除旧的语法: 执行 $VIMRUNTIME/syntax/nosyntax.vim
    |
    +-  先执行 <a href="options.html#'runtimepath'">'runtimepath'</a> 里的 syntax/synload.vim
    |   |
    |   +-  为语法高亮设置色彩。如果已经定义了色彩方案，使用 ":colors <code class="special">{name}</code>"
    |   |   再次载入。不然，执行 ":runtime! syntax/syncolor.vim"。":syntax on"
    |   |   会覆盖已有的颜色，而 ":syntax enable" 只会设置没有设置过的组。
    |   |
    |   +-  设置 syntax 自动命令，以便在设置 <a href="options.html#'syntax'">'syntax'</a> 选项时，自动载入合适的语
    |   |   法文件。 <b class="vimtag"> <a name="synload-1">synload-1</a> </b>
    |   |
    |   +-  通过  <a href="syntax.html#mysyntaxfile">mysyntaxfile</a>  变量，载入用户可选的文件。这只是为了和 Vim 5.x
    |   |   兼容。 <b class="vimtag"> <a name="synload-2">synload-2</a> </b>
    |
    +-  执行 ":filetype on"，后者又执行 ":runtime! filetype.vim"。它载入任何找
    |   到的 filetype.vim。其中，总会执行 $VIMRUNTIME/filetype.vim。后者执行:
    |   |
    |   +-  根据后缀名，安装自动命令来设置 <a href="options.html#'filetype'">'filetype'</a> 选项。这为已知的文件类型
    |   |   建立了文件名和文件类型的联系。 <b class="vimtag"> <a name="synload-3">synload-3</a> </b>
    |   |
    |   +-  通过 <b class="vimtag"> <a name="myfiletypefile">myfiletypefile</a> </b> 变量，载入用户可选的文件。这只是为了和 Vim
    |   |   5.x 兼容。 <b class="vimtag"> <a name="synload-4">synload-4</a> </b>
    |   |
    |   +-  安装自动命令，在没有检测到文件类型时执行 scripts.vim 。
    |   |   <b class="vimtag"> <a name="synload-5">synload-5</a> </b>
    |   |
    |   +-  执行 $VIMRUNTIME/menu.vim，设置 Syntax 菜单。 <a href="gui.html#menu.vim">menu.vim</a> 
    |
    +-  安装 FileType 自动命令，在检测到文件类型时，设置 <a href="options.html#'syntax'">'syntax'</a> 选项。
    |   <b class="vimtag"> <a name="synload-6">synload-6</a> </b>
    |
    +-  执行 syntax 自动命令，为每个已经载入的缓冲区启动语法高亮。


载入文件时，Vim 这样查找相关的语法文件:

    文件的载入激活 BufReadPost 自动命令。
    |
    +-  如果和  <a href="syntax.html#synload-3">synload-3</a>  中的一个自动命令匹配 (已知的文件类型) 或者
    |    <a href="syntax.html#synload-4">synload-4</a>  (用户的文件类型)，<a href="options.html#'filetype'">'filetype'</a> 选项设为文件的所属类型。
    |
    +-  如果文件类型没有找到，激活  <a href="syntax.html#synload-5">synload-5</a>  中的自动命令，并在
    |   <a href="options.html#'runtimepath'">'runtimepath'</a> 里找寻 scripts.vim。其中，总是会执行
    |   $VIMRUNTIME/scripts.vim。后者执行以下步骤。
    |   |
    |   +-  通过 <b class="vimtag"> <a name="myscriptsfile">myscriptsfile</a> </b> 变量，载入用户可选的文件。这只是为了和 Vim
    |   |   5.x 兼容。
    |   |
    |   +-  如果文件类型仍然未知，检查文件的内容，并使用类似于
    |       "getline(1) =~ pattern" 的检查确定文件类型能否识别，并设置
    |       <a href="options.html#'filetype'">'filetype'</a>。
    |
    +-  如果文件类型被确定并且设置了 <a href="options.html#'filetype'">'filetype'</a>，激活 FileType 自动命令，见上
    |   面的  <a href="syntax.html#synload-6">synload-6</a> 。根据确定的文件类型设置 <a href="options.html#'syntax'">'syntax'</a>。
    |
    +-  上面设置 <a href="options.html#'syntax'">'syntax'</a> 选项的步骤激活  <a href="syntax.html#synload-1">synload-1</a>  (和  <a href="syntax.html#synload-2">synload-2</a> ) 设置的自
    |   动命令。它会使用以下命令找到 <a href="options.html#'runtimepath'">'runtimepath'</a> 里的主语法文件:
    |           runtime! syntax/<code class="special">&lt;name&gt;</code>.vim
    |
    +-  激活任何用户安装的 FileType 或 Syntax 自动命令。这可以用来为某项语法修
        正高亮方式。

</section><hr class="doubleline" /><section class=inner>
<h4>4. 转换为 HTML                                  <b class="vimtag"> <a name="2html.vim">2html.vim</a> </b> <b class="vimtag"> <a name="convert-to-HTML">convert-to-HTML</a> </b></h4>
2html 本身并不是语法文件，只是一个把当前窗口转换成 HTML 的脚本。Vim 打开一个新
窗口，在那里它构造 HTML 文件。

保存结果文件以后，你可以使用任何浏览器浏览。那里的颜色应该和你在 Vim 里看到的
一模一样。 <a href="syntax.html#g:html_line_ids">g:html_line_ids</a>  可使你通过在浏览器的地址栏中 URL 尾部加入 (例如)
#L123 或 #123 来跳到指定行。 <a href="syntax.html#g:html_dynamic_folds">g:html_dynamic_folds</a>  则使你可以打开或关闭 Vim 中
的折叠。

你不应该设置 <a href="options.html#'filetype'">'filetype'</a> 或 <a href="options.html#'syntax'">'syntax'</a> 选项为 "2html"！执行此脚本，以转换当前文
件: 
<code class="example"></code>
<code class="example">        :runtime! syntax/2html.vim</code>

许多变量可用来调整 2html.vim 的结果；见下。列出的开关选项可以通过显式设置其值
来达到打开和关闭的目的，也可以通过用  <a href="eval.html#:unlet">:unlet</a>  删除变量的方式来恢复其缺省值。

评注:
- 一些真的很老的浏览器可能不会显示背景色。
- 你可以在大多数浏览器里打印文件 (而且有颜色)！
- 本版本的 TOhtml 可以和旧版本的 Vim 共用，但某些功能，例如隐藏 (conceal) 支持
  不会工作，而对编译时没有加入 GUI 支持的旧版本，色彩也可能不对。

此处是一个如何在 Unix 外壳上给所有的 .c 和 .h 文件运行此脚本的例子: 
<code class="example">   for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done</code>

                                        <b class="vimtag"> <a name="g:html_start_line">g:html_start_line</a> </b> <b class="vimtag"> <a name="g:html_end_line">g:html_end_line</a> </b>
要限制转换的行范围，给下面介绍的  <a href="syntax.html#:TOhtml">:TOhtml</a>  命令加上行范围，或者设置
"g:html_start_line" 和 "g:html_end_line" 分别为要转换的第一行和最后一行。例
如，要指定最近设置的可视区域: 
<code class="example"></code>
<code class="example">        :let g:html_start_line = line("'&lt;")</code>
<code class="example">        :let g:html_end_line = line("'&gt;")</code>
<code class="example">        :runtime! syntax/2html.vim</code>

                                                        <b class="vimtag"> <a name=":TOhtml">:TOhtml</a> </b>
:<code class="special">[range]</code>TOhtml          ":TOhtml" 命令在一个标准插件里定义。该命令为你执行
                         <a href="syntax.html#2html.vim">2html.vim</a> 。给出范围时，此命令设置
                         <a href="syntax.html#g:html_start_line">g:html_start_line</a>  和  <a href="syntax.html#g:html_end_line">g:html_end_line</a>  分别为范围的
                        开始和结束行。缺省范围是整个缓冲区。

                        如果窗口处于比较模式，除非置位了
                         <a href="syntax.html#g:html_diff_one_file">g:html_diff_one_file</a> ，:TOhtml 会在生成的 HTML 里把当
                        前标签页里所有参与比较的窗口并排放在一个 <code class="special">&lt;table&gt;</code>
                        元素里。 <a href="syntax.html#g:html_line_ids">g:html_line_ids</a>  还可以允许你跳到指定窗口的指
                        定行，(例如) #W1L42 跳到首个参加比较的窗口的第 42 行，
                        #W3L87 则是第三个窗口的第 87 行。

                        示例: 
<code class="example"></code>
<code class="example">        :10,40TOhtml " 把第 10-40 行转换为 html</code>
<code class="example">        :'&lt;,'&gt;TOhtml " 转换当前/最近的可视选择</code>
<code class="example">        :TOhtml      " 转换整个缓冲区</code>

                                                        <b class="vimtag"> <a name="g:html_diff_one_file">g:html_diff_one_file</a> </b>
缺省: 0。
为 0 时， <a href="syntax.html#:TOhtml">:TOhtml</a>  会在生成的 HTML 里把当前标签页里所有参与比较的窗口并排放在
一个 <code class="special">&lt;table&gt;</code> 元素里。
为 1 时，只转换当前的缓冲区。
示例: 
<code class="example"></code>
<code class="example">        let g:html_diff_one_file = 1</code>

                                                         <b class="vimtag"> <a name="g:html_whole_filler">g:html_whole_filler</a> </b>
缺省: 0。
为 0 时，如果  <a href="syntax.html#g:html_diff_one_file">g:html_diff_one_file</a>  为 1，连续多于三行的填充行显示为三行，中
间行提示插入的总行数。
为 1 里，显示所有的插入行，这也是  <a href="syntax.html#g:html_diff_one_file">g:html_diff_one_file</a>  没有置位时的行为。

<code class="example">    :let g:html_whole_filler = 1</code>

                                     <b class="vimtag"> <a name="TOhtml-performance">TOhtml-performance</a> </b> <b class="vimtag"> <a name="g:html_no_progress">g:html_no_progress</a> </b>
缺省: 0。
为 0 时，2html.vim 转换的每个主要步骤都会在状态行上显示进度条。
为 1 时，不显示进度条。会有很不显著的速度提高，但你无法估计转换过程要花多长时
间；对大文件而言可能会挺久的！
示例: 
<code class="example"></code>
<code class="example">        let g:html_no_progress = 1</code>
<code class="example"></code>
通过指示 Vim 以非交互方式运行会得到更好的效率提高，因为不用在脚本切换缓冲区和
窗口时花时间重画屏幕，例如: 
<code class="example"></code>
<code class="example">  vim -E -s -c "let g:html_no_progress=1" -c "syntax on" -c "set ft=c" -c "runtime syntax/2html.vim" -cwqa myfile.c</code>

<code class="note">注意</code> -s 标志位停止 .vimrc 和任何插件的载入，因此必须显式执行/打开影响 HTML
转换的设置。详见  <a href="starting.html#-E">-E</a>  和  <a href="starting.html#-s-ex">-s-ex</a> 。最好单独建一个脚本来代替这里的 -c 命令，然后
用 -u 标志位载入之，这样就不用一个个列出要执行的命令了。

                                    <b class="vimtag"> <a name="hl-TOhtmlProgress">hl-TOhtmlProgress</a> </b> <b class="vimtag"> <a name="TOhtml-progress-color">TOhtml-progress-color</a> </b>
如果显示，随着 HTML 转换程度的推进，进度条会沿着状态行显示带色彩的方块。缺省，
背景色使用当前的 "DiffDelete" 高亮组。如果 "DiffDelete" 和 "StatusLine" 有相同
的背景色，TOhtml 会自动调整颜色以区别。如果你不喜欢自动选择的颜色，可自定义进
度条的高亮色。示例: 
<code class="example"></code>
<code class="example">        hi TOhtmlProgress guifg=#c0ffee ctermbg=7</code>

                                                         <b class="vimtag"> <a name="g:html_number_lines">g:html_number_lines</a> </b>
缺省: 当前的 <a href="options.html#'number'">'number'</a> 设置。
为 0 时，生成的 HTML 里显示缓冲区文本时不带行号。
为 1 时，生成的 HTML 里加入行号列，和 Vim 的行号列相同高亮 ( <a href="syntax.html#hl-LineNr">hl-LineNr</a> ) 。
要强制给行编号，即使没有置位 <a href="options.html#'number'">'number'</a>: 
<code class="example">   :let g:html_number_lines = 1</code>
要强制关闭行号: 
<code class="example">   :let g:html_number_lines = 0</code>
要回到缺省情况，即使用 <a href="options.html#'number'">'number'</a> 的设置，可删除此变量: 
<code class="example">   :unlet g:html_number_lines</code>

                                                        <b class="vimtag"> <a name="g:html_line_ids">g:html_line_ids</a> </b>
缺省: 1 如果  <a href="syntax.html#g:html_number_lines">g:html_number_lines</a>  置位，否则为 0。
为 1 时，为每个行号加上 HTML 的 id 属性，或者如果行号不显示，为同样的目的加入
一个空的 <code class="special">&lt;span&gt;</code> 。单个缓冲区的 HTML 页面的 ID 属性形如 L123，比较视图的页面则
形如 W2L123，可以用 ID 来跳转到该行 (或比较视图中某个窗口)。同时，加入
Javascript 代码，在跳到指定行之前打开其所在的已关闭的动态折叠
( <a href="syntax.html#g:html_dynamic_folds">g:html_dynamic_folds</a> )。
Javascript 还可以让你在 url 中省略窗口号或开头的那个 L。
示例: 
<code class="example"></code>
<code class="example">        page.html#L123  跳转到单个缓冲区文件的第 123 行</code>
<code class="example">        page.html#123   同上</code>
<code class="example"></code>
<code class="example">        diff.html#W1L42 跳转到比较的首个窗口的第 42 行</code>
<code class="example">        diff.html#42    同上</code>

                                                              <b class="vimtag"> <a name="g:html_use_css">g:html_use_css</a> </b>
缺省: 1。
为 1 时，生成使用层叠样式表 (CSS) 的合法 HTML 5 文件，所有的现代浏览器和许多旧
式的浏览器都支持。
为 0 时，生成 <code class="special">&lt;font&gt;</code> 标签和类似的过时标记。不推荐，但对真的很老的浏览器、电邮
客户端、论坛帖子和类似不支持基本 CSS 的情形，可能会更好些。
例如: 
<code class="example">   :let g:html_use_css = 0</code>

                                                       <b class="vimtag"> <a name="g:html_ignore_conceal">g:html_ignore_conceal</a> </b>
缺省: 0。
为 0 时，可隐藏文本被从 HTML 中去除，并取决于 <a href="options.html#'conceallevel'">'conceallevel'</a> 的当前值，用
 <a href="syntax.html#:syn-cchar">:syn-cchar</a>  或 <a href="options.html#'listchars'">'listchars'</a> 代替。
为 1 时，在生成的 HTML 中包括所有的缓冲区文本，即使是经过隐藏 ( <a href="syntax.html#conceal">conceal</a> )。

以下两个命令的任何一个都可以确保缓冲区的所有文本都包含在生成的 HTML 里 (除非有
折叠的情况): 
<code class="example">   :let g:html_ignore_conceal = 1</code>
<code class="example">   :setl conceallevel=0</code>

                                                       <b class="vimtag"> <a name="g:html_ignore_folding">g:html_ignore_folding</a> </b>
缺省: 0。
为 0 时，关闭折叠里的实际文本被 Vim 显示折叠所用的文本 ( <a href="fold.html#fold-foldtext">fold-foldtext</a> ) 代
替。如果你还想允许在 HTML 中用户可以扩展折叠看到实际文本，就像 Vim 可以做的那
样的话，另见  <a href="syntax.html#g:html_dynamic_folds">g:html_dynamic_folds</a> 。
为 1 时，在生成的 HTML 中包括所有的缓冲区文本；不管文本是否在折叠中都一样。此
时， <a href="syntax.html#g:html_dynamic_folds">g:html_dynamic_folds</a>  无效。

以下两个命令的任何一个都可以确保缓冲区的所有文本都包含在生成的 HTML 里 (除非有
隐藏 (conceal) 的情况): 
<code class="example">   zR</code>
<code class="example">   :let g:html_ignore_folding = 1</code>

                                                        <b class="vimtag"> <a name="g:html_dynamic_folds">g:html_dynamic_folds</a> </b>
缺省: 0。
为 0 时，生成的 HTML 不包含关闭折叠里的文本。
为 1 时，生成 Javascript 以动态打开折叠并显示其中的文本，如同 Vim 那样。

设置此变量为 1 时，2html.vim 总是使用 CSS 生成样式，不管  <a href="syntax.html#g:html_use_css">g:html_use_css</a>  的设
置。

 <a href="syntax.html#g:html_ignore_folding">g:html_ignore_folding</a>  置位时，忽略此变量。

<code class="example">   :let g:html_dynamic_folds = 1</code>

                                                        <b class="vimtag"> <a name="g:html_no_foldcolumn">g:html_no_foldcolumn</a> </b>
缺省: 0。
为 0 时，如果  <a href="syntax.html#g:html_dynamic_folds">g:html_dynamic_folds</a>  为 1，生成折叠列，如同 vim 的 foldcolumn
( <a href="fold.html#fold-foldcolumn">fold-foldcolumn</a> ) 那样，用户点击该列时切换折叠的开与关。
为 1 时，不生成折叠列；如果置位了  <a href="syntax.html#g:html_hover_unfold">g:html_hover_unfold</a> ，可以用鼠标移到折叠文
本来打开折叠。

<code class="example">   :let g:html_no_foldcolumn = 1</code>

                                <b class="vimtag"> <a name="TOhtml-uncopyable-text">TOhtml-uncopyable-text</a> </b> <b class="vimtag"> <a name="g:html_prevent_copy">g:html_prevent_copy</a> </b>
缺省: 空字符串。
如果在浏览器中选中生成的 HTML 文档的全部文本并复制，此选项防止其中部分区域被复
制。此项功能用于保证用户只复制-粘贴原始的文本，而不包括生成内容显示的折叠列或
行号。可以这样来指定不被复制的区域:
        f:      折叠列
        n:      行号 (也包括折叠文本中的)
        t:      折叠文本
        d:      比较填充行

例如，要使折叠列和行号不被复制: 
<code class="example">        :let g:html_prevent_copy = "fn"</code>

此功能目前的实现方法是插入只读的 <code class="special">&lt;input&gt;</code> 元素来包围不想复制的区域。这不总是适
用。若干理解 HTML 的应用还是会粘贴 <code class="special">&lt;input&gt;</code> 元素。但只接受平凡文本的粘贴目标应
该都行。
在生成页中用于防止复制的方法取决于  <a href="syntax.html#g:html_use_input_for_pc">g:html_use_input_for_pc</a>  的值。

                                                    <b class="vimtag"> <a name="g:html_use_input_for_pc">g:html_use_input_for_pc</a> </b>
缺省: "none"
如果  <a href="syntax.html#g:html_prevent_copy">g:html_prevent_copy</a>  非空，则:

为 "all" 时，使用只读的 <code class="special">&lt;input&gt;</code> 元素来代替不可复制区域的普通文本。在有些浏览
器，特别是旧一些的浏览器上，选择整页并复制选择内容时，不随页面文本一起粘贴
<code class="special">&lt;input&gt;</code> 标签。如果  <a href="syntax.html#g:html_no_invalid">g:html_no_invalid</a>  为 0，<code class="special">&lt;input&gt;</code> 标签会带有非法类型，这会
在更多的浏览器上工作，但页面不能通过合法验证。
<code class="note">注意</code>: 此方法 <code class="emphasis">不</code> 能用于最近版本的 Chrome 和等价的浏览器上；<code class="special">&lt;input&gt;</code> 标签会随着文
本一起粘贴。

为 "fallback" (缺省值) 时，为旧浏览器生成相同的 <code class="special">&lt;input&gt;</code> 元素，但新浏览器 (通过
CSS 特性查询来检测) 会隐藏 <code class="special">&lt;input&gt;</code> 元素，取而代之的是把生成的内容放在 ::before
伪元素里面来显示不可复制的文本。此方法适用于最多数量的浏览器，既包括旧也包括和
新的。

为 "none" 时，完全不生成 <code class="special">&lt;input&gt;</code> 元素。只使用生成内容方法，这意味着旧浏览器，
尤其是 Interenet Explorer，会使本不应复制的文本要么能复制，要么会完全消失不
见。不过，这是最合标准的方法，使用的标注也会少得多。

                                                           <b class="vimtag"> <a name="g:html_no_invalid">g:html_no_invalid</a> </b>
缺省: 0。
为 0 时，如  <a href="syntax.html#g:html_prevent_copy">g:html_prevent_copy</a>  非空且  <a href="syntax.html#g:html_use_input_for_pc">g:html_use_input_for_pc</a>  不是
"none"，有意地给不能复制的区域里的 <code class="special">&lt;input&gt;</code> 元素插入一个非法的属性。这使一些应
用不会粘贴这些 <code class="special">&lt;input&gt;</code> 元素。特别地，有些版本的 Microsoft Word 不会粘贴有非法
属性的 <code class="special">&lt;input&gt;</code> 元素。
为 1 时，不会有意插入非法的标记，生成的页面总是合法的。不过，有些应用里一旦粘
贴了 <code class="special">&lt;input&gt;</code> 元素，很难在之后去掉。

                                                         <b class="vimtag"> <a name="g:html_hover_unfold">g:html_hover_unfold</a> </b>
缺省: 0。
为 0 时，打开 2html.vim 用  <code class="badlink">g:html_dynmaic_folds</code>  设置产生折叠的唯一方法是点击
生成的折叠列。
为 1 时，用 CSS 2.0 机制，使得用户把鼠标移到显示的折叠文本上时可以打开折叠。对
不想打开 Javascript 但想看到折叠文本的用户会有用。

<code class="note">注意</code> 旧版本的浏览器 (尤其是 Internet Explorer 6) 不支持该功能。我们生成 IE6 浏
览器特定的 HTML 标记，使之回归到普通的 CSS 1 代码，这样折叠还能在此浏览器下正
常显示，但没有折叠列它们无法被打开。

<code class="example">   :let g:html_hover_unfold = 1</code>

                                                              <b class="vimtag"> <a name="g:html_id_expr">g:html_id_expr</a> </b>
缺省: ""
动态折叠和行号的跳转依赖于文档中生成的 ID 的唯一性。如果生成的 HTML 被复制到更
大的文档时，ID 的唯一性就很难保证了。设置  <a href="syntax.html#g:html_id_expr">g:html_id_expr</a>  可以指定一个表达
式，让 Vim 用来生成唯一的字符串，附加到给定文档中的每个 ID 之后，以保证生成的
完整 ID 即使和更大的 HTML 文档的其他内容合并时也保持唯一。例如，要给每个 ID 后
附加 _ 和缓冲区号: 
<code class="example"></code>
<code class="example">        :let g:html_id_expr = '"_" .. bufnr("%")'</code>

要给每个 ID 号附加字符串 "_mystring": 
<code class="example"></code>
<code class="example">        :let g:html_id_expr = '"_mystring"'</code>

<code class="note">注意</code> 转换比较视图到 HTML 时，只对比较中的首个窗口计算此表达式，计算结果会用于
所有的窗口。

                                          <b class="vimtag"> <a name="TOhtml-wrap-text">TOhtml-wrap-text</a> </b> <b class="vimtag"> <a name="g:html_pre_wrap">g:html_pre_wrap</a> </b>
缺省: 当前 <a href="options.html#'wrap'">'wrap'</a> 的设置。
为 0 时，如果  <a href="syntax.html#g:html_no_pre">g:html_no_pre</a>  为 0 或未设，生成的 HTML 中的文本在浏览器窗口
边缘处不回绕。
为 1 时，如果  <a href="syntax.html#g:html_use_css">g:html_use_css</a>  为 1，使用 CSS 2.0 的 "white-space:pre-wrap"
值，使文本在浏览器窗口边缘处回绕。
要显式打开回绕: 
<code class="example">   :let g:html_pre_wrap = 1</code>
要关闭回绕: 
<code class="example">   :let g:html_pre_wrap = 0</code>
回归到缺省值，由 <a href="options.html#'wrap'">'wrap'</a> 设置值来决定回绕与否: 
<code class="example">   :unlet g:html_pre_wrap</code>

                                                               <b class="vimtag"> <a name="g:html_no_pre">g:html_no_pre</a> </b>
缺省: 0。
为 0 时，生成的 HTML 用 <code class="special">&lt;pre&gt;</code>...&lt;/pre&gt; 标签来包围缓冲区文本。连续空格的显示如
同 Vim 那样，无需特别标记，制表符也可以按本义使用 (见  <a href="syntax.html#g:html_expand_tabs">g:html_expand_tabs</a> )。
为 1 时 (不推荐)，使用普通的 <code class="special">&lt;div&gt;</code> 代替 <code class="special">&lt;pre&gt;</code> 标签，用一串 "&amp;nbsp;" 来显示连续
的空格，<code class="special">&lt;br&gt;</code> 用于结束每行。这是支持生成的 HTML 中文本回绕的另一个方法，此方法
和旧式的浏览器更兼容，但 2html.vim 生成的页面显示效果与 Vim 的差别显著。

<code class="example">   :let g:html_no_pre = 1</code>

                                                               <b class="vimtag"> <a name="g:html_no_doc">g:html_no_doc</a> </b>
缺省: 0。
为 1 时，不生成带 DOCTYPE、<code class="special">&lt;head&gt;</code>、<code class="special">&lt;body&gt;</code> 等的完整的 HTML 文档。如果打开
 <a href="syntax.html#g:html_use_css">g:html_use_css</a>  (缺省)，需要手动定义 CSS。 <a href="syntax.html#g:html_dynamic_folds">g:html_dynamic_folds</a>  和
 <a href="syntax.html#g:html_line_ids">g:html_line_ids</a>  设置 (缺省关闭) 也会插入一些 JavaScript。


                                                             <b class="vimtag"> <a name="g:html_no_links">g:html_no_links</a> </b>
缺省: 0。
不为形如 URL 的文本生成 <code class="special">&lt;a&gt;</code> 标签。

                                                          <b class="vimtag"> <a name="g:html_no_modeline">g:html_no_modeline</a> </b>
缺省: 0。
不生成关闭折叠的模式行。

                                                          <b class="vimtag"> <a name="g:html_expand_tabs">g:html_expand_tabs</a> </b>
缺省: 0 如果 <a href="options.html#'tabstop'">'tabstop'</a> 为 8，<a href="options.html#'expandtab'">'expandtab'</a> 为 0，不使用 <a href="options.html#'vartabstop'">'vartabstop'</a>，且生成的
               HTML 不用折叠列或行号；
      1 不然。
为 1 时，缓冲区文本中的 <code class="special">&lt;Tab&gt;</code> 被合适数目的空格，或当  <a href="syntax.html#g:html_no_pre">g:html_no_pre</a>  为 1 时，
&amp;nbsp；，所替代。
为 0 时，如果  <a href="syntax.html#g:html_no_pre">g:html_no_pre</a>  为 0 或未设，在生成的 HTML 中保留缓冲区文本中的
<code class="special">&lt;Tab&gt;</code> 字符。这使得浏览器中复制粘贴不会丢失原始文档中的实际空白。<code class="note">注意</code> 除非按照
缺省设置的那些条件，这会很容易打乱 HTML 中文本的对齐和缩进。

强制  <a href="syntax.html#2html.vim">2html.vim</a>  保留 <code class="special">&lt;Tab&gt;</code> 字符: 
<code class="example">   :let g:html_expand_tabs = 0</code>
<code class="example"></code>
强制扩展制表符: 
<code class="example">   :let g:html_expand_tabs = 1</code>

                                    <b class="vimtag"> <a name="TOhtml-encoding-detect">TOhtml-encoding-detect</a> </b> <b class="vimtag"> <a name="TOhtml-encoding">TOhtml-encoding</a> </b>
强烈建议用  <a href="syntax.html#g:html_use_encoding">g:html_use_encoding</a>  来为任何要放到网页服务器上的内容指定编码。

如果没有指定编码， <a href="syntax.html#2html.vim">2html.vim</a>  使用 <a href="options.html#'fileencoding'">'fileencoding'</a> 的当前值 (如设置) 或者
<a href="options.html#'encoding'">'encoding'</a> 值的 IANA 的推荐名字来设置。
对某些 <a href="options.html#'buftype'">'buftype'</a> 类型，总使用 <a href="options.html#'encoding'">'encoding'</a>。会根据选中的文档编码相应的设置
<a href="options.html#'fileencoding'">'fileencoding'</a> 的值。

自动检测适用于所有  <a href="mbyte.html#encoding-names">encoding-names</a>  指定的编码，但 TOhtml 目前只自动使用那些广
为浏览器支持的编码，对缺省不自动检测的特定编码，你可以强制其检测 (见下面的选
项)。IANA 名字可见 <a href="http://www.iana.org/assignments/character-sets">http://www.iana.org/assignments/character-sets</a>。

<code class="note">备注</code>，缺省所有 Unicode 编码所生成的 HTML 会转化为不带 BOM 的 UTF-8，这是 W3C
建议的:

        <a href="http://www.w3.org/International/questions/qa-choosing-encodings">http://www.w3.org/International/questions/qa-choosing-encodings</a>
        <a href="http://www.w3.org/International/questions/qa-byte-order-mark">http://www.w3.org/International/questions/qa-byte-order-mark</a>

                                                         <b class="vimtag"> <a name="g:html_use_encoding">g:html_use_encoding</a> </b>
缺省: 无，使用 <a href="options.html#'fileencoding'">'fileencoding'</a> 的当前值的 IANA 名字，见上述。
要完全跳过自动字符集检测，设置 g:html_use_encoding 为你要使用的字符集。强烈
建议对所有要放上网页服务器的内容设置此值为广为支持的编码，如 UTF-8: 
<code class="example">   :let g:html_use_encoding = "UTF-8"</code>
如果不想产生指定字符集的 HTML 行，设置 g:html_use_encoding 为空字符串 ( <code class="emphasis">不</code> 推
荐): 
<code class="example">   :let g:html_use_encoding = ""</code>
要回到自动的机制，删除 g:html_use_encoding 变量: 
<code class="example">   :unlet g:html_use_encoding</code>

                                                    <b class="vimtag"> <a name="g:html_encoding_override">g:html_encoding_override</a> </b>
缺省: 无，autoload/tohtml.vim 包含  <a href="mbyte.html#encoding-names">encoding-names</a>  中提到名字的编码的转换。
如果用  <a href="syntax.html#g:html_use_encoding">g:html_use_encoding</a>  指定的编码不在缺省的转换列表中，本选项可以使
 <a href="syntax.html#2html.vim">2html.vim</a>  检测到正确的 <a href="options.html#'fileencoding'">'fileencoding'</a>。

这是个由字符集到编码的组对所构成的字典，它会替代 TOhtml 自动检测所生成的相应组
对，或扩充新组对以支持新的字符集。

要检测 HTML 字符集 "windows-1252" 对应的编码为 "8bit-cp1252"，用: 
<code class="example">   :let g:html_encoding_override = {'windows-1252': '8bit-cp1252'}</code>

                                                     <b class="vimtag"> <a name="g:html_charset_override">g:html_charset_override</a> </b>
缺省: 无，autoload/tohtml.vim 包含  <a href="mbyte.html#encoding-names">encoding-names</a>  中提到名字的和有广泛浏览器
                支持的转换。
本选项指定  <a href="syntax.html#2html.vim">2html.vim</a>  不能自动检测的 <a href="options.html#'fileencoding'">'fileencoding'</a> 或 <a href="options.html#'encoding'">'encoding'</a> 所对应的
HTML 字符集。也可用来覆盖现有的编码到字符集的组对。例如，
TOhtml 缺省对所有 Unicode/UCS 编码使用 UTF-8。要用 UTF-16 和 UTF-32 代替之，
用: 
<code class="example">   :let g:html_charset_override = {'ucs-4': 'UTF-32', 'utf-16': 'UTF-16'}</code>
<code class="example"></code>
<code class="note">注意</code> UTF-32 或 UTF-16 编码的文档和已知至少一个主要浏览器有兼容问题。

                                                                 <b class="vimtag"> <a name="g:html_font">g:html_font</a> </b>
缺省: "monospace"
用 g:html_font 可以指定转换后的文档使用的字体或字体集。如果本选项设为字符串，
以单引号括起该值。如果本选项设为列表，以单引号括起每个列表项目，然后以逗号连接
列表。不管哪种方式，加入 "monospace" 作为后备的通用字体族名，然后把整个结果用
作 font family (用 CSS 时) 或 font face (不用 CSS 时)。例如: 
<code class="example"></code>
<code class="example">   " font-family: 'Consolas', monospace;</code>
<code class="example">   :let g:html_font = "Consolas"</code>
<code class="example"></code>
<code class="example">   " font-family: 'DejaVu Sans Mono', 'Consolas', monospace;</code>
<code class="example">   :let g:html_font = ["DejaVu Sans Mono", "Consolas"]</code>

                        <b class="vimtag"> <a name="convert-to-XML">convert-to-XML</a> </b> <b class="vimtag"> <a name="convert-to-XHTML">convert-to-XHTML</a> </b> <b class="vimtag"> <a name="g:html_use_xhtml">g:html_use_xhtml</a> </b>
缺省: 0。
为 0 时，生成标准 HTML 4.01 (如有可能，strict)。
为 1 时，生成 XHTML 1.0 (XML 兼容的 HTML)。

<code class="example">    :let g:html_use_xhtml = 1</code>

</section><hr class="doubleline" /><section class=inner>
<h4>5. 语法文件附注                                         <b class="vimtag"> <a name=":syn-file-remarks">:syn-file-remarks</a> </b></h4>
                                                <b class="vimtag"> <a name="b:current_syntax-variable">b:current_syntax-variable</a> </b>
Vim 把载入的语法的名字保存在 "b:current_syntax" 变量里。你可用来根据当前激活的
是哪部语法来载入其它设定。例如: 
<code class="example">   :au BufReadPost * if b:current_syntax == "csh"</code>
<code class="example">   :au BufReadPost *   做一些事</code>
<code class="example">   :au BufReadPost * endif</code>
<code class="example"></code>
<code class="example"></code>
<code class="example"></code>
ABEL                                            <b class="vimtag"> <a name="abel.vim">abel.vim</a> </b> <b class="vimtag"> <a name="ft-abel-syntax">ft-abel-syntax</a> </b>

ABEL 高亮设置提供一些用户定义的选项。要打开这些选项，给相应的选项设置任意值。
例如: 
<code class="example">        :let abel_obsolete_ok=1</code>
可用 ":unlet" 关闭。例如: 
<code class="example">        :unlet abel_obsolete_ok</code>
<code class="example"></code>
<code class="section">变量                            高亮 </code>
abel_obsolete_ok                废弃的关键字接受为 statement，而非 error
abel_cpp_comments_illegal       不把 '//' 解释为行内注释的引导符


ADA

见  <a href="ft_ada.html#ft-ada-syntax">ft-ada-syntax</a> 


ANT                                             <b class="vimtag"> <a name="ant.vim">ant.vim</a> </b> <b class="vimtag"> <a name="ft-ant-syntax">ft-ant-syntax</a> </b>

ant 语法文件缺省提供了 javascript 和 python 的语法高亮。其他脚本语言的语法高亮
可以通过 AntSyntaxScript() 函数安装。它接受的第一个参数是标签名，而第二个是脚
本语法文件名。例如: 
<code class="example"></code>
<code class="example">        :call AntSyntaxScript('perl', 'perl.vim')</code>
<code class="example"></code>
会为下面的 ant 代码提供 Perl 的语法高亮 
<code class="example"></code>
<code class="example">        &lt;script language = 'perl'&gt;&lt;![CDATA[</code>
<code class="example">            # 这里的一切都作为 perl 脚本高亮</code>
<code class="example">        ]]&gt;&lt;/script&gt;</code>
<code class="example"></code>
 <a href="syntax.html#mysyntaxfile-add">mysyntaxfile-add</a>  说明如何永久的安装脚本语言。


APACHE                                          <b class="vimtag"> <a name="apache.vim">apache.vim</a> </b> <b class="vimtag"> <a name="ft-apache-syntax">ft-apache-syntax</a> </b>

Apache 语法文件为 Apache HTTP 服务器 2.2.3 版本提供语法高亮。


                <b class="vimtag"> <a name="asm.vim">asm.vim</a> </b> <b class="vimtag"> <a name="asmh8300.vim">asmh8300.vim</a> </b> <b class="vimtag"> <a name="nasm.vim">nasm.vim</a> </b> <b class="vimtag"> <a name="masm.vim">masm.vim</a> </b> <b class="vimtag"> <a name="asm68k">asm68k</a> </b>
ASSEMBLY        <b class="vimtag"> <a name="ft-asm-syntax">ft-asm-syntax</a> </b> <b class="vimtag"> <a name="ft-asmh8300-syntax">ft-asmh8300-syntax</a> </b> <b class="vimtag"> <a name="ft-nasm-syntax">ft-nasm-syntax</a> </b>
                <b class="vimtag"> <a name="ft-masm-syntax">ft-masm-syntax</a> </b> <b class="vimtag"> <a name="ft-asm68k-syntax">ft-asm68k-syntax</a> </b> <b class="vimtag"> <a name="fasm.vim">fasm.vim</a> </b>

匹配 "*.i" 的可以是 Progress 或者汇编文件。如果自动检测对你不工作，或者你从来
不编辑 Progress，在你启动的 vimrc 里这么用: 
<code class="example">   :let filetype_i = "asm"</code>
把 "asm" 替换成你实际使用的汇编语言。

许多类型的汇编语言都使用相同的文件扩展名。因而，你或者需要自己选择类型，或者在
汇编文件里增加使 Vim 能识别的行。目前，包含了以下的语法文件:
        asm             GNU 汇编 (缺省)
        asm68k          Motorola 680x0 汇编
        asmh8300        Hitachi H-8300 版本的 GNU 汇编
        ia64            Intel Itanium 64
        fasm            Flat 汇编 (<a href="http://flatassembler.net">http://flatassembler.net</a>)
        masm            Microsoft 汇编 (可能适用于任何 80x86)
        nasm            Netwide 汇编
        tasm            Turbo 汇编 (提供到 Penitum 和 MMX 的 80x86 操作码)
        pic             PIC 汇编 (目前支持 PIC16F84)

最灵活的方式是在你的汇编文件里加上如下一行: 
<code class="example">        asmsyntax=nasm</code>
把 "nasm" 换成实际的汇编语法的名字。该行必须是文件头五行中的一行。此文本前后不
能紧接着非空白的其它文本。<code class="note">注意</code> 指定 asmsyntax=foo 等价于在  <a href="options.html#modeline">modeline</a>  中设置
ft=foo，如果两者有冲突，模式行的设置优先 (尤其，如果模式行上有 ft=asm，总是使
用 GNU 的语法高亮，而不管 asmsyntax 如何设置)。

语法类型可以为某个缓冲区定制。方法是设置 b:asmsyntax 变量: 
<code class="example">        :let b:asmsyntax = "nasm"</code>
<code class="example"></code>
如果没有设置 b:asmsyntax，不管是自动还是手动，就会使用全局变量 asmsyntax 的
值。它可以看作是缺省的汇编语言: 
<code class="example">        :let asmsyntax = "nasm"</code>
<code class="example"></code>
如果什么都没有定义，最后就假定是 "asm" 语法。


<code class="section">Netwide 汇编器 (nasm.vim) 可选高亮特性 </code>

要打开特性: 
<code class="example">        :let   {variable}=1|set syntax=nasm</code>
要关闭特性: 
<code class="example">        :unlet {variable}  |set syntax=nasm</code>
<code class="example"></code>
<code class="section">变量                    高亮 </code>
nasm_loose_syntax       非正式的分析器允许的语法不视为错误 (取决于分析器；不推
                        荐)
nasm_ctx_outside_macro  宏之外的上下文不视为错误
nasm_no_warn            潜在有危险的语法不视为 Todo 那样的<code class="note">警告</code>


ASPPERL 和 ASPVBS                       <b class="vimtag"> <a name="ft-aspperl-syntax">ft-aspperl-syntax</a> </b> <b class="vimtag"> <a name="ft-aspvbs-syntax">ft-aspvbs-syntax</a> </b>

*.asp 和 *.asa 文件可以是 Perl 或者 Visual Basic 脚本。因为很难检测，你可以设
置两个全局变量，来告诉 Vim 你要用哪一个。Perl 脚本可用: 
<code class="example">        :let g:filetype_asa = "aspperl"</code>
<code class="example">        :let g:filetype_asp = "aspperl"</code>
Visual Basic 可用: 
<code class="example">        :let g:filetype_asa = "aspvbs"</code>
<code class="example">        :let g:filetype_asp = "aspvbs"</code>
<code class="example"></code>
<code class="example"></code>
BAAN                                                <b class="vimtag"> <a name="baan.vim">baan.vim</a> </b> <b class="vimtag"> <a name="baan-syntax">baan-syntax</a> </b>

baan.vim 提供 BaanIV 到 SSA ERP LN 发行版的 BaanC 的语法支持，用于 3 GL 和 4
GL 编程。支持很多的标准宏定义/常数。

如果你在某个  <a href="starting.html#.vimrc">.vimrc</a>  里指定下面这行，不合编码标准的一些特殊错误会被报告: 
<code class="example">        let baan_code_stds=1</code>
<code class="example"></code>
<b class="vimtag"> <a name="baan-folding">baan-folding</a> </b>

使用下面提到的变量，可以在不同层次上打开语法折叠 (在  <a href="starting.html#.vimrc">.vimrc</a>  里设置)。源代码
块和 SQL 上越复杂的折叠越需要 CPU。

要允许折叠并在函数级别上打开折叠: 
<code class="example">        let baan_fold=1</code>
可以在源代码块级别上打开折叠，如 if、while、for，... 这里开始/结束关键字之前的
缩进必须一致 (空格不等于制表)。 
<code class="example">        let baan_fold_block=1</code>
可以为内嵌的 SQL 块打开折叠，如 SELECT、SELECTDO、SELECTEMPTY，... 这里开始/结
束关键字之前的缩进必须一致 (空格不等于制表)。 
<code class="example">        let baan_fold_sql=1</code>

<code class="note">注意</code>: 代码块级别的折叠可能产生许多小的折叠。建议在 .vimrc 里用  <a href="options.html#:set">:set</a>  设置选项
<a href="options.html#'foldminlines'">'foldminlines'</a> 和 <a href="options.html#'foldnestmax'">'foldnestmax'</a>，在 .../after/syntax/baan.vim 里用  <a href="options.html#:setlocal">:setlocal</a> 
设置也可以 (见  <a href="options.html#after-directory">after-directory</a> )。例如: 
<code class="example">        set foldminlines=5</code>
<code class="example">        set foldnestmax=6</code>
<code class="example"></code>
<code class="example"></code>
BASIC                   <b class="vimtag"> <a name="basic.vim">basic.vim</a> </b> <b class="vimtag"> <a name="vb.vim">vb.vim</a> </b> <b class="vimtag"> <a name="ft-basic-syntax">ft-basic-syntax</a> </b> <b class="vimtag"> <a name="ft-vb-syntax">ft-vb-syntax</a> </b>

Visual Basic 和 "普通的" BASIC 都使用扩展名 ".bas"。要检测使用的是哪一个，Vim
在文件的头五行检查字符串 "VB_Name"。如果没找到，文件类型将是 "basic"，不然就是
"vb"。带 ".frm" 扩展名的文件总被视为 Visual Basic 类型。

如果自动检测不行或者比如说你只能编辑 FreeBASIC 文件，可在 .vimrc 里指定: 
<code class="example">   :let filetype_bas = "freebasic"</code>
<code class="example"></code>
<code class="example"></code>
C                                                       <b class="vimtag"> <a name="c.vim">c.vim</a> </b> <b class="vimtag"> <a name="ft-c-syntax">ft-c-syntax</a> </b>

C 高亮的一些设置是可选的。要打开，给相应的变量赋任何值 (包括零)。例如: 
<code class="example">        :let c_comment_strings = 1</code>
<code class="example">        :let c_no_bracket_error = 0</code>
可用  <a href="eval.html#:unlet">:unlet</a>  关闭。例如: 
<code class="example">        :unlet c_comment_strings</code>
这里设置值为零是不行的！

一个替代办法是切换到 C++ 高亮: 
<code class="example">        :set filetype=cpp</code>
<code class="example"></code>
<code class="section">变量                    高亮 </code>
<b class="vimtag"> <a name="c_gnu">c_gnu</a> </b>                 GNU gcc 专用的项目
<b class="vimtag"> <a name="c_comment_strings">c_comment_strings</a> </b>     注释里的字符串和数字
<b class="vimtag"> <a name="c_space_errors">c_space_errors</a> </b>        行尾的空格和 <code class="special">&lt;Tab&gt;</code> 之前的空格
<b class="vimtag"> <a name="c_no_trail_space_error">c_no_trail_space_error</a> </b> ... 不包括行尾的空格
<b class="vimtag"> <a name="c_no_tab_space_error">c_no_tab_space_error</a> </b>   ... 不包括 <code class="special">&lt;Tab&gt;</code> 之前的空格
<b class="vimtag"> <a name="c_no_bracket_error">c_no_bracket_error</a> </b>    不高亮 <code class="special">{}</code>；如果在 [] 里面视为错误
<b class="vimtag"> <a name="c_no_curly_error">c_no_curly_error</a> </b>      不高亮 <code class="special">{}</code>；如果在 [] 和 () 里面视为错误；
                                除了出现在首列的 { 和 } 以外
                                缺省高亮它们，否则找不到缺失的 ")"。
<b class="vimtag"> <a name="c_curly_error">c_curly_error</a> </b>         通过寻找所有的对来高亮丢失的 }；强制从文件首开始同步，
                        因而可能会较慢
<b class="vimtag"> <a name="c_no_ansi">c_no_ansi</a> </b>             不使用 ANSI 标准类型和常数
<b class="vimtag"> <a name="c_ansi_typedefs">c_ansi_typedefs</a> </b>        ... 但使用 ANSI 标准类型
<b class="vimtag"> <a name="c_ansi_constants">c_ansi_constants</a> </b>       ... 但使用 ANSI 标准常数
<b class="vimtag"> <a name="c_no_utf">c_no_utf</a> </b>              不高亮字符串里的 \u 和 \U
<b class="vimtag"> <a name="c_syntax_for_h">c_syntax_for_h</a> </b>        *.h 文件使用 C 语法，而不是 C++ 的，用 objc 语法，而不
                        是 objcpp 的
<b class="vimtag"> <a name="c_no_if0">c_no_if0</a> </b>              不把 "#if 0" 块高亮为注释
<b class="vimtag"> <a name="c_no_cformat">c_no_cformat</a> </b>          不高亮字符串里的 %-格式
<b class="vimtag"> <a name="c_no_c99">c_no_c99</a> </b>              不高亮 C99 标准的项目
<b class="vimtag"> <a name="c_no_c11">c_no_c11</a> </b>              不高亮 C11 标准的项目
<b class="vimtag"> <a name="c_no_bsd">c_no_bsd</a> </b>              不高亮 BSD 特定类型

如果 <a href="options.html#'foldmethod'">'foldmethod'</a> 设为 "syntax"，那么 /* */ 注释和 { } 块成为折叠。如果你不想
让注释成为折叠: 
<code class="example">        :let c_no_comment_fold = 1</code>
"#if 0" 块也被折叠，除非: 
<code class="example">        :let c_no_if0_fold = 1</code>
<code class="example"></code>
如果你<code class="note">注意</code>到往回滚动时，高亮出现问题，但 <code class="keystroke">CTRL-L</code> 重画又可以修正的话，尝试设置
"c_minlines" 内部变量为较大的值: 
<code class="example">        :let c_minlines = 100</code>
这使得语法同步在第一个显示行之前的 100 行开始。缺省值为 50 (如果设置了
c_no_if0，则为 15)。使用较大的值的缺点是重画会变慢。

如果使用 "#if 0" / "#endif" 风格的注释高亮，<code class="note">注意</code>它只适用于 "#if 0" 出现在窗口
顶部往上不超过 "c_minlines" 行的场合。如果你有很长的 "#if 0" 构造，它不会被正
确地高亮。

要匹配注释里的附加项目，使用 cCommentGroup 簇。例如: 
<code class="example">   :au Syntax c call MyCadd()</code>
<code class="example">   :function MyCadd()</code>
<code class="example">   :  syn keyword cMyItem contained Ni</code>
<code class="example">   :  syn cluster cCommentGroup add=cMyItem</code>
<code class="example">   :  hi link cMyItem Title</code>
<code class="example">   :endfun</code>
<code class="example"></code>
ANSI 常数使用 "cConstant" 组高亮。这包括 "NULL"、"SIG_IGN" 还有其它。但不包
括，比如说，"TRUE"。因为它不在 ANSI 标准里。如果你觉得弄不清楚，删除 cConstant
高亮: 
<code class="example">        :hi link cConstant NONE</code>
<code class="example"></code>
如果你看到 '{' 和 '}' 被高亮为错误，而实际并非如此的时候，复位 cErrInParen 和
cErrInBracket 的高亮。

如果想在你的 C 文件里使用折叠，可以在 <a href="options.html#'runtimepath'">'runtimepath'</a> 的 "after" 目录下的一个文
件里加上这些行。Unix 上，这会是 ~/.vim/after/syntax/c.vim. 
<code class="example">    syn sync fromstart</code>
<code class="example">    set foldmethod=syntax</code>
<code class="example"></code>
CH                                              <b class="vimtag"> <a name="ch.vim">ch.vim</a> </b> <b class="vimtag"> <a name="ft-ch-syntax">ft-ch-syntax</a> </b>

C/C++ 解释器。Ch 的语法高亮和 C 相似，它基于 C 语法文件。 <a href="syntax.html#c.vim">c.vim</a>  说明所有 C 可
用的设置。

设置此变量，告诉 Vim 用 Ch 语法来处理 *.h 文件，而不是 C 或 C++ 语法: 
<code class="example">        :let ch_syntax_for_h = 1</code>
<code class="example"></code>
<code class="example"></code>
CHILL                                           <b class="vimtag"> <a name="chill.vim">chill.vim</a> </b> <b class="vimtag"> <a name="ft-chill-syntax">ft-chill-syntax</a> </b>

Chill 语法高亮和 C 类似。可用的设置见  <a href="syntax.html#c.vim">c.vim</a> 。此外，还有:

chill_space_errors      类似于 c_space_errors
chill_comment_string    类似于 c_comment_strings
chill_minlines          类似于 c_minlines


CHANGELOG                               <b class="vimtag"> <a name="changelog.vim">changelog.vim</a> </b> <b class="vimtag"> <a name="ft-changelog-syntax">ft-changelog-syntax</a> </b>

ChangeLog 支持行首的空格高亮。如果你不喜欢，在你的 .vimrc 里加入下行: 
<code class="example">        let g:changelog_spacing_errors = 0</code>
下次你编辑 changelog 文件时，就会应用。你也可以使用
"b:changelog_spacing_errors" 来为每个缓冲区分别设置 (在载入语法文件以前)。

你可以改变现在使用的高亮，例如把空格标记为错误: 
<code class="example">        :hi link ChangelogError Error</code>
或者避免高亮: 
<code class="example">        :hi link ChangelogError NONE</code>
这些会立即生效。


CLOJURE                                                 <b class="vimtag"> <a name="ft-clojure-syntax">ft-clojure-syntax</a> </b>

                                                <b class="vimtag"> <a name="g:clojure_syntax_keywords">g:clojure_syntax_keywords</a> </b>

缺省提供 "clojure.core" 的公共变量的语法高亮，要高亮额外符号，可把它们加到
 <a href="syntax.html#g:clojure_syntax_keywords">g:clojure_syntax_keywords</a>  变量。其值应为语法组名映射到标识符的  <a href="eval.html#List">List</a>  的
 <a href="eval.html#Dictionary">Dictionary</a> :

<code class="example">        let g:clojure_syntax_keywords = {</code>
<code class="example">            \   'clojureMacro': ["defproject", "defcustom"],</code>
<code class="example">            \   'clojureFunc': ["string/join", "string/replace"]</code>
<code class="example">            \ }</code>

合法的语法组名可参见 Closure 语法脚本。

还有 <b class="vimtag"> <a name="b:clojure_syntax_keywords">b:clojure_syntax_keywords</a> </b> ，是此变量的缓冲区局部版本，插件
作者可用来动态高亮符号。

设置 <b class="vimtag"> <a name="b:clojure_syntax_without_core_keywords">b:clojure_syntax_without_core_keywords</a> </b> 变量时，缺省不高亮
"clojure.core" 的变量。这可用于设置了 `(:refer-clojure :only [])` 的命名空间。


                                                        <b class="vimtag"> <a name="g:clojure_fold">g:clojure_fold</a> </b>

置位  <a href="syntax.html#g:clojure_fold">g:clojure_fold</a>  为  <code class="badlink">1</code>  打开 Clojure 代码的折叠。任何超过一行的 list、
vector 或 map 会使用标准 Vim  <a href="fold.html#fold-commands">fold-commands</a>  进行折叠。


                                                <b class="vimtag"> <a name="g:clojure_discard_macro">g:clojure_discard_macro</a> </b>

置位此变量为  <code class="badlink">1</code>  可以打开 Clojure 的 "丢弃阅读器宏 (discard reader macro)" 的
基本高亮。

<code class="example">        #_(defn foo [x]</code>
<code class="example">            (println x))</code>

<code class="note">注意</code> 此选项不能正确高亮层叠的丢弃宏 (如  <code class="badlink">#_#_</code> )。


COBOL                                           <b class="vimtag"> <a name="cobol.vim">cobol.vim</a> </b> <b class="vimtag"> <a name="ft-cobol-syntax">ft-cobol-syntax</a> </b>

COBOL 高亮对传统的代码和新开发的代码有不同的需要。这来自于需求的差异 (维护还是
开发)，以及一些其它因素。要使用传统代码的高亮，在 .vimrc 里加上此行: 
<code class="example">        :let cobol_legacy_code = 1</code>
要再次关闭，可用: 
<code class="example">        :unlet cobol_legacy_code</code>
<code class="example"></code>
<code class="example"></code>
COLD FUSION                     <b class="vimtag"> <a name="coldfusion.vim">coldfusion.vim</a> </b> <b class="vimtag"> <a name="ft-coldfusion-syntax">ft-coldfusion-syntax</a> </b>

ColdFusion 有 HTML 注释的自己的版本。要打开 ColdFusion 风格的注释高亮，在你的
启动文件里加上此行: 
<code class="example"></code>
<code class="example">        :let html_wrong_comments = 1</code>
<code class="example"></code>
ColdFusion 语法文件是基于 HTML 的语法文件的。


CPP                                             <b class="vimtag"> <a name="cpp.vim">cpp.vim</a> </b> <b class="vimtag"> <a name="ft-cpp-syntax">ft-cpp-syntax</a> </b>

多数设置同  <a href="syntax.html#ft-c-syntax">ft-c-syntax</a> 。

<code class="section">变量                    特色 </code>
cpp_no_cpp11            不高亮 C++11 标准项目
cpp_no_cpp14            不高亮 C++14 标准项目
cpp_no_cpp17            不高亮 C++17 标准项目
cpp_no_cpp20            不高亮 C++20 标准项目


CSH                                             <b class="vimtag"> <a name="csh.vim">csh.vim</a> </b> <b class="vimtag"> <a name="ft-csh-syntax">ft-csh-syntax</a> </b>

这里讨论名为 "csh" 的外壳。<code class="note">注意</code> 有的系统实际使用的是 tcsh。

要检测一个文件是 csh 还是 tcsh 异常困难。有的系统把 /bin/csh 符号链接到
/bin/tcsh，使得区别 csh 和 tcsh 几乎不可能。如果 VIM 猜错，你可以自己设置
"filetype_csh" 变量。要使用 csh:  <b class="vimtag"> <a name="g:filetype_csh">g:filetype_csh</a> </b>

<code class="example">        :let g:filetype_csh = "csh"</code>
<code class="example"></code>
要使用 tcsh: 
<code class="example"></code>
<code class="example">        :let g:filetype_csh = "tcsh"</code>
<code class="example"></code>
带 tcsh 扩展名的脚本或者 tcsh 的标准文件名 (.tcshrc、tcsh.tcshrc、tcsh.login)
会使用文件类型 tcsh。其它的 tcsh/csh 脚本也会被识别为 tcsh， <code class="emphasis">除非</code> 存在
"filetype_csh" 变量。如果存在 "filetype_csh" 变量，文件类型会设为该变量的值。


CYNLIB                                          <b class="vimtag"> <a name="cynlib.vim">cynlib.vim</a> </b> <b class="vimtag"> <a name="ft-cynlib-syntax">ft-cynlib-syntax</a> </b>

Cynlib 文件是使用 Cynlib 类库的 C++ 文件。它们使用 C++ 来为硬件建模和模拟。通
常 Cynlib 文件使用 .cc 或 .cpp 扩展名，这使得它们和普通的 C++ 文件难以区别。因
而，要使用 Cynlib 为 .cc 文件高亮，在你的 .vimrc 文件里加上此行: 
<code class="example"></code>
<code class="example">        :let cynlib_cyntax_for_cc=1</code>
<code class="example"></code>
cpp 文件也类似 (该扩展名通常为 Windows 使用) 
<code class="example"></code>
<code class="example">        :let cynlib_cyntax_for_cpp=1</code>
<code class="example"></code>
要再次关闭，可用: 
<code class="example"></code>
<code class="example">        :unlet cynlib_cyntax_for_cc</code>
<code class="example">        :unlet cynlib_cyntax_for_cpp</code>


CWEB                                            <b class="vimtag"> <a name="cweb.vim">cweb.vim</a> </b> <b class="vimtag"> <a name="ft-cweb-syntax">ft-cweb-syntax</a> </b>

匹配 "*.w" 的文件可为 Progress 文件或者 cweb 文件。如果自动检测不行，或者你从
来不编辑 Progress，可以在启动的 vimrc 文件里用: 
<code class="example">   :let filetype_w = "cweb"</code>
<code class="example"></code>
<code class="example"></code>
DART                                            <b class="vimtag"> <a name="dart.vim">dart.vim</a> </b> <b class="vimtag"> <a name="ft-dart-syntax">ft-dart-syntax</a> </b>

Dart 是面向对象，强类型的，有类定义的，垃圾回收的语言，用于开发移动、台式、网
站和后台应用。Dart 使用来源于 C、Java 和 JavaScript 的 C 风格的语法，提供来自
Smalltalk、Python、Ruby 和其它语言的特性。

关于语言和其开发环境的详情，可见官方 Dart 语言网站 <a href="https://dart.dev">https://dart.dev</a>

dart.vim 语法检测并高亮 Dart 语句、保留字、类型声明、存储类、条件句、循环、插
值和注释。没有 Flutter 或其它 Dart 框架的习惯用法的支持。

改动，修正？请这样提交议题或拉取请求:

<a href="https://github.com/pr3d4t0r/dart-vim-syntax/">https://github.com/pr3d4t0r/dart-vim-syntax/</a>


DESKTOP                                    <b class="vimtag"> <a name="desktop.vim">desktop.vim</a> </b> <b class="vimtag"> <a name="ft-desktop-syntax">ft-desktop-syntax</a> </b>

该语法文件的主要目的是根据 freedesktop.org 标准:
<a href="https://specifications.freedesktop.org/desktop-entry-spec/latest/">https://specifications.freedesktop.org/desktop-entry-spec/latest/</a>
来高亮 .desktop 和 .directory 文件。
要高亮不以 X- 开头的非标准扩展，设置 
<code class="example">        let g:desktop_enable_nonstd = 1</code>
<code class="note">注意</code> 这可能会导致不正确的高亮。
要高亮 KDE 的保留特性，设置 
<code class="example">        let g:desktop_enable_kde = 1</code>
如果未显式提供，g:desktop_enable_kde 追随 g:desktop_enable_nonstd。


DIFF                                                    <b class="vimtag"> <a name="diff.vim">diff.vim</a> </b>

比较高亮通常会寻找翻译的头部。如果文件里有很长的行，这会变慢。这样关闭翻译: 
<code class="example"></code>
<code class="example">        :let diff_translations = 0</code>
<code class="example"></code>
另见  <a href="diff.html#diff-slow">diff-slow</a> 。


DIRCOLORS                              <b class="vimtag"> <a name="dircolors.vim">dircolors.vim</a> </b> <b class="vimtag"> <a name="ft-dircolors-syntax">ft-dircolors-syntax</a> </b>

dircolors 工具的高亮定义有一个选项。它的存在是为了和 Slackware GNU/Linux 发布
版本里的该命令兼容。它增加了一些多数版本忽略的关键字。在 Slackware 系统中，该
工具接受这些关键字并在处理中应用。要允许使用 Slackware 关键字，在你的启动文件
里加入如下一行: 
<code class="example">        let dircolors_is_slackware = 1</code>
<code class="example"></code>
<code class="example"></code>
DOCBOOK                                 <b class="vimtag"> <a name="docbk.vim">docbk.vim</a> </b> <b class="vimtag"> <a name="ft-docbk-syntax">ft-docbk-syntax</a> </b> <b class="vimtag"> <a name="docbook">docbook</a> </b>
DOCBOOK XML                             <b class="vimtag"> <a name="docbkxml.vim">docbkxml.vim</a> </b> <b class="vimtag"> <a name="ft-docbkxml-syntax">ft-docbkxml-syntax</a> </b>
DOCBOOK SGML                            <b class="vimtag"> <a name="docbksgml.vim">docbksgml.vim</a> </b> <b class="vimtag"> <a name="ft-docbksgml-syntax">ft-docbksgml-syntax</a> </b>

有两种类型的 DocBook 文件: SGML 和 XML。要指定使用那种类型，需要设置
"b:docbk_type" 变量。如果 Vim 能够识别，它会自动设置该变量。如果 Vim 猜不到，
缺省的类型是 XML。
你可以手动设置: 
<code class="example">        :let docbk_type = "sgml"</code>
或者: 
<code class="example">        :let docbk_type = "xml"</code>
你需要在载入语法文件前作如此设置，这有点复杂。
更简单的方法是设置文件类型为 "docbkxml" 或 "docbksgml": 
<code class="example">        :set filetype=docbksgml</code>
或: 
<code class="example">        :set filetype=docbkxml</code>
<code class="example"></code>
可以指定 DocBook 版本: 
<code class="example">        :let docbk_ver = 3</code>
如无指定假定为 4。

DOSBATCH                                <b class="vimtag"> <a name="dosbatch.vim">dosbatch.vim</a> </b> <b class="vimtag"> <a name="ft-dosbatch-syntax">ft-dosbatch-syntax</a> </b>

dosbatch_cmdextversion 变量选择 Windows 命令解释器支持的扩展集。Windows NT
(Windows 2000 之前) 版本上，它应该取值为 1，Windows 2000 及之后版本应该为 2。
下面这行可以选择你想要的版本: 
<code class="example"></code>
<code class="example">   :let dosbatch_cmdextversion = 1</code>
<code class="example"></code>
如果没有定义该变量，缺省设为 2，以支持 Windows 2000 及之后版本。

原始 MS-DOS 支持使用双冒号 (::) 作为引导注释行的代替方法。当前 Windows 命令解
释器支持此方法，但在 ( ... ) 命令块里会触发问题。相关讨论可见 Stack Overflow -

<a href="https://stackoverflow.com/questions/12407800/which-comment-style-should-i-use-in-batch-files">https://stackoverflow.com/questions/12407800/which-comment-style-should-i-use-in-batch-files</a>

要允许在 Windows 命令解释器或 MS-DOS bat 文件里用 :: 来引导注释，设置
dosbatch_colons_comment 变量为任何值: 
<code class="example"></code>
<code class="example">   :let dosbatch_colons_comment = 1</code>
<code class="example"></code>
有个选项可以控制 *.btm 文件是否被识别为 "dosbatch" 类型 (MS-DOS 批处理文件) 或
"btm" 类型 (4DOS 批处理文件)。缺省使用后者。下行可以让你选择前者: 
<code class="example"></code>
<code class="example">   :let g:dosbatch_syntax_for_btm = 1</code>
<code class="example"></code>
如果此变量无定义或为零，选择 btm 语法。



DOXYGEN                                         <b class="vimtag"> <a name="doxygen.vim">doxygen.vim</a> </b> <b class="vimtag"> <a name="doxygen-syntax">doxygen-syntax</a> </b>

Doxygen 使用特殊的文档格式生成代码文档 (和 Javadoc 类似)。本语法脚本为 c、
cpp、idl 和 php 文件加入 Doxygen 的高亮，Java 应该也能用。

有几个办法可以打开 Doxygen 格式。首先，在文件的模式行上可以给 syntax 加入
".doxygen"，进行显式设置。示例: 
<code class="example">        :set syntax=c.doxygen</code>
或 
<code class="example">        // vim:syntax=c.doxygen</code>
<code class="example"></code>
对于 C、C++、C#、IDL 和 PHP 文件，也可以设置全局或局部于缓冲区变量
load_doxygen_syntax 来自动完成这个操作。在 .vimrc 里加上 
<code class="example">        :let g:load_doxygen_syntax=1</code>
<code class="example"></code>
有一些变量影响语法高亮，它们大多和非标准的高亮选项有关。

<code class="section">变量                            缺省    效果 </code>
g:doxygen_enhanced_color
g:doxygen_enhanced_colour       0       Doxygen 注释使用非标准的高亮。

doxygen_my_rendering            0       关闭 HTML 粗体、斜体和
                                        html_my_rendering 下划线的高亮。

doxygen_javadoc_autobrief       1       如果为 0，关闭 Javadoc autobrief 色彩
                                        高亮。

doxygen_end_punctuation         '[.]'   匹配 brief 结束标点的正则表达式。

还有一些高亮组值得提提，你可以对它们进行配置。

<code class="section">高亮                            效果 </code>
doxygenErrorComment             如果 code、verbatim 或 dot 段里丢失标点，注释
                                尾部的颜色。
doxygenLinkError                如果丢失 \link 段的 \endlink，注释尾部的颜色。


DTD                                             <b class="vimtag"> <a name="dtd.vim">dtd.vim</a> </b> <b class="vimtag"> <a name="ft-dtd-syntax">ft-dtd-syntax</a> </b>

DTD 语法高亮缺省是大小写敏感的。如果不想如此，在你的启动文件里加入以下一行: 
<code class="example"></code>
<code class="example">        :let dtd_ignore_case=1</code>
<code class="example"></code>
DTD 语法会把未知的标签高亮为错误。如果这很讨厌，在执行 dtd.vim 语法文件之前，
可以用以下设置来关闭: 
<code class="example"></code>
<code class="example">        :let dtd_no_tag_errors=1</code>
<code class="example"></code>
参数实体 (parameter entity) 的名字使用 'Type' 高亮组高亮，标点和 '%' 使用
'Comment'。参数实体的实例使用 'Constant' 高亮组高亮，定界符 % 和 ; 则使用
'Type' 高亮组。以下设置可以关闭这些设定: 
<code class="example"></code>
<code class="example">        :let dtd_no_param_entities=1</code>
<code class="example"></code>
xml.vim 也包含了 DTD 语法文件，用以高亮内嵌的 dtd。

EIFFEL                                  <b class="vimtag"> <a name="eiffel.vim">eiffel.vim</a> </b> <b class="vimtag"> <a name="ft-eiffel-syntax">ft-eiffel-syntax</a> </b>

尽管 Eiffel 不是大小写敏感的，它的风格指南鼓励如此，而且语法高亮文件也鼓励这样
使用。这使得同一类名的高亮可以不同。如果你想关闭大小写敏感的语法高亮，在启动文
件里加上这行: 
<code class="example"></code>
<code class="example">        :let eiffel_ignore_case=1</code>
<code class="example"></code>
大小写对类名和注释里的 TODO 标记仍然有影响。

相反，要更严格的检查，加入以下诸行之一: 
<code class="example"></code>
<code class="example">        :let eiffel_strict=1</code>
<code class="example">        :let eiffel_pedantic=1</code>
<code class="example"></code>
设置 eiffel_strict 只会捕获以下五个预定义的单词错误的大小写: "Current"、
"Void"、"Result"、"Precursor" 和 "NONE"。用于<code class="note">警告</code>它们可能被不小心用作特性或类
名。

设置 eiffel_pedantic 会非常严格地遵循 Eiffel 风格指南 (例如，大小写字母的任意
混合和其它过时的大写关键字的方法都会被捕获)。

如果希望使用小写版本的 "Current"、"Void"、"Result" 和 "Precursor"，可以用 
<code class="example"></code>
<code class="example">        :let eiffel_lower_case_predef=1</code>
<code class="example"></code>
而不用完全关闭大小写敏感的高亮方式。

一些编译器里已经能够实验性地处理 ISE 推荐的新的创建语法，要打开此语法: 
<code class="example"></code>
<code class="example">        :let eiffel_ise=1</code>
<code class="example"></code>
最后，有的供应商支持十六进制的常数。在你的启动文件里加上这行就可以处理它们 
<code class="example"></code>
<code class="example">        :let eiffel_hex_constants=1</code>
<code class="example"></code>
<code class="example"></code>
EUPHORIA            <b class="vimtag"> <a name="euphoria3.vim">euphoria3.vim</a> </b> <b class="vimtag"> <a name="euphoria4.vim">euphoria4.vim</a> </b> <b class="vimtag"> <a name="ft-euphoria-syntax">ft-euphoria-syntax</a> </b>

Euphoria 有两种语法高亮文件。一种用于 Euphoria 3.1.1 版本，这是缺省的语法高亮
文件，另一种用于 Euphoria 4.0.5 或更新版本。

Euphoria 3.1.1 版本 (<a href="http://www.rapideuphoria.com/">http://www.rapideuphoria.com/</a>) 对开发 DOS 平台上的应用还
是需要的，Euphoria 4 (<a href="http://www.openeuphoria.org/">http://www.openeuphoria.org/</a>) 不再支持。

以下文件扩展名被自动识别为 Euphoria 文件类型:

        *.e, *.eu, *.ew, *.ex, *.exu, *.exw
        *.E, *.EU, *.EW, *.EX, *.EXU, *.EXW

要选择 Euphoria 的语法文件，同时也自动识别 *.e 和 *.E 文件扩展名为 Euphoria 文
件类型，在启动文件里加入以下一行: 
<code class="example"></code>
<code class="example">        :let g:filetype_euphoria = "euphoria3"</code>
<code class="example"></code>
        或 
<code class="example"></code>
<code class="example">        :let g:filetype_euphoria = "euphoria4"</code>
<code class="example"></code>
Elixir 和 Euphoria 共享 *.ex 文件扩展名。如果通过 g:filetype_euphoria 变量专门
设置文件类型为 Euphoria，或者通过文件里的关键字判断为 Euphoria，则文件类型设为
Euphoria。否则，文件类型缺省为 Elixir。

ERLANG                                          <b class="vimtag"> <a name="erlang.vim">erlang.vim</a> </b> <b class="vimtag"> <a name="ft-erlang-syntax">ft-erlang-syntax</a> </b>

Erlang 是 Ericsson 开发的函数编程语言。下列文件后缀被识别为 Erlang 文件: erl、
hrl、yaws。

缺省打开 BIF (内建函数) 的高亮。要关闭之，在 .vimrc 里加上: 
<code class="example"></code>
<code class="example">        :let g:erlang_highlight_bifs = 0</code>
<code class="example"></code>
要打开某些特殊原子 (atom) 的高亮，在 .vimrc 里加上: 
<code class="example"></code>
<code class="example">        :let g:erlang_highlight_special_atoms = 1</code>
<code class="example"></code>
<code class="example"></code>
ELIXIR                                          <b class="vimtag"> <a name="elixir.vim">elixir.vim</a> </b> <b class="vimtag"> <a name="ft-elixir-syntax">ft-elixir-syntax</a> </b>

Elixir 是动态函数型语言，用于构建规模化可维护的应用。

以下文件扩展名自动检测为 Elixir 文件类型:

        *.ex, *.exs, *.eex, *.leex, *.lock

Elixir 和 Euphoria 共享 *.ex 文件扩展名。如果通过 g:filetype_euphoria 变量专门
设置文件类型为 Euphoria，或者通过文件里的关键字判断为 Euphoria，则文件类型设为
Euphoria。否则，文件类型缺省为 Elixir。


FLEXWIKI                                <b class="vimtag"> <a name="flexwiki.vim">flexwiki.vim</a> </b> <b class="vimtag"> <a name="ft-flexwiki-syntax">ft-flexwiki-syntax</a> </b>

FlexWiki 是基于 ASP.NET 的 wiki 包，从 <a href="http://www.flexwiki.com">http://www.flexwiki.com</a> 可以获得。
<code class="note">备注</code>: 此网站已不可用，Wikipedia 指出开发已在 2009 年停止。

多数常用的 FlexWiki 语法元素都提供了语法高亮。本文件类型插件脚本设置了若干局部
于缓冲区的选项，使 FlexWiki 页面的编辑更加便捷。因为 FlexWiki 把换行符看成新段
落的开始，所以本插件设置 <a href="options.html#'tw'">'tw'</a>=0 (无限行长)，置位 <a href="options.html#'wrap'">'wrap'</a> (回绕长行而不使用水平
滚动)，也置位 <a href="options.html#'linebreak'">'linebreak'</a> (在 <a href="options.html#'breakat'">'breakat'</a> 包含的字符而不是在屏幕最后一个字符上回
绕)，等等。本插件也包含了一些键盘映射，但它们缺省是关闭的。

如果你打开键盘映射，"j" 和 "k" 和光标键就会在显示行间上下移动。为此，在 .vimrc
里加入: 
<code class="example">        :let flexwiki_maps = 1</code>
<code class="example"></code>
<code class="example"></code>
FORM                                            <b class="vimtag"> <a name="form.vim">form.vim</a> </b> <b class="vimtag"> <a name="ft-form-syntax">ft-form-syntax</a> </b>

FORM 文件里的语法元素的色彩方案使用缺省模式: Conditional、Number、Statement、
Comment、PreProc、Type 和 String。它遵循 1991 年版荷兰 CAN 组织
J.A.M. Vermaseren 编著的语言说明书 'Symbolic Manipulation with FORM'。

如果你想自己增加对缺省颜色的修改，需要重新定义以下语法组:

    - formConditional
    - formNumber
    - formStatement
    - formHeaderStatement
    - formComment
    - formPreProc
    - formDirective
    - formType
    - formString

<code class="note">注意</code> 缺省，form.vim 语法文件使用相同的语法组里实现 FORM 预处理器命令和指令。

预定义的 FORM 增强色彩模式可以用来区别头部语句和 FORM 程序本体的语句。要激活此
模式，在你的 vimrc 文件里定义以下变量 
<code class="example"></code>
<code class="example">        :let form_enhanced_color=1</code>
<code class="example"></code>
在深色 gvim 显示中，增强模式也利用了附加的色彩特性。这里，语句
(formStatement) 使用 LightYellow 而不是 Yellow。而条件句 (formConditional) 使
用 LightBlue，以达到更好的区分度。

Visual Basic 和 FORM 都使用扩展名 ".frm"。要检测文件类型，Vim 在文件头五行检查
"VB_Name" 字符串。如果找到，文件类型为 "vb"，不然为 "form"。

如果自动检测不行或者比如说你只能编辑 FORM 文件，可在 vimrc 里指定: 
<code class="example">   :let filetype_frm = "form"</code>
<code class="example"></code>
<code class="example"></code>
FORTH                                           <b class="vimtag"> <a name="forth.vim">forth.vim</a> </b> <b class="vimtag"> <a name="ft-forth-syntax">ft-forth-syntax</a> </b>

匹配 "*.f" 的文件可能是 Fortran 或是 Forth，而匹配 "*.fs" 的文件可能是 F# 或是
Forth。如果自动检测不行或者比如说你不想编辑 F# 或 Fortran 文件，可在 vimrc 里
指定: 
<code class="example">   :let filetype_f  = "forth"</code>
<code class="example">   :let filetype_fs = "forth"</code>
<code class="example"></code>
<code class="example"></code>
FORTRAN                                 <b class="vimtag"> <a name="fortran.vim">fortran.vim</a> </b> <b class="vimtag"> <a name="ft-fortran-syntax">ft-fortran-syntax</a> </b>

<code class="section">缺省高亮方式和方言 </code>
缺省使用适合 Fortran 2008 的高亮方式。这样的选择应该适用于绝大多数的用户，因为
Fortran 2008 几乎是以前所有版本的超集 (Fortran 2003、95、90 和 77)。

<code class="section">Fortran 源代码形式 </code>
Fortran 代码可以使用固定宽度的源代码，也可以使用自由形式。<code class="note">注意</code> 如果形式设置错
误，语法高亮也不会正确。

创建新的 Fortran 文件时，语法脚本假定使用的是固定宽度的源代码。如果你总是使用
自由形式，那么在你的 .vimrc 里，把 
<code class="example">    :let fortran_free_source=1</code>
放在 :syntax 命令前。如果你总是使用固定宽度格式，那么在你的 .vimrc 里，把 
<code class="example">    :let fortran_fixed_source=1</code>
放在 .syntax 命令前。

如果以非标准的形式让源代码的格式取决于文件扩展名，那么最方便的方法是在
ftplugin 文件里设置 fortran_free_source。关于 ftplugin 文件的更多信息，见
 <a href="usr_51.html#ftplugin">ftplugin</a> 。<code class="note">注意</code>，要使之工作，你需要在 .vimrc 文件的 "syntax on" 命令之前加上
"filetype plugin indent on" 命令。

编辑已有的 Fortran 文件时，如果定义了 fortran_free_source 变量，语法脚本假定使
用自由形式，如果定义了 fortran_fixed_source 变量，则假定使用固定宽度形式。如果
两者都没有，语法脚本检验通用于 ifort、gfortran、Cray、NAG 和 PathScale 编译器
惯例的文件扩展名 (.f、.for、.f77 为固定宽度，.f90、.f95、.f03、.f08 为自由形
式)。如果都不行，脚本再检查文件的头 500 行的头 5 列。如果没有发现自由形式的迹
象，那么假定文件为固定宽度形式的源文件。这个算法应该在绝大多数情况下适用。有的
情况下，比如文件的开始有 500 行或更多完整行的注释，该脚本也许会错误地认为该
Fortran 代码使用的是固定宽度形式。如果此种情况真的发生，只要在前 500 行的头 5
列里的任何地方加上一个非注释的语句，然后保存 (:w) 并重新读入 (:e!) 文件就可以
了。

<code class="section">Fortran 文件里的制表键 </code>
Fortran 标准不识别制表键。在固定宽度格式的 Fortran 源代码里，制表不是一个好主
意，因为需要固定的列边界。因此，制表被识别为错误。不过，有的程序员喜欢使用制
表。如果你的 Fortran 文件里包含制表，那么需要在 .vimrc 里使用这样的命令来设置
变量 fortran_have_tabs 
<code class="example">    :let fortran_have_tabs=1</code>
并把它放在 :syntax 命令之前。不幸的是，制表的使用意味着语法文件无法识别不正确
的边界。

<code class="section">Fortran 文件的语法折叠 </code>
如果你希望使用 foldmethod=syntax，那么你需要先使用命令设置变量 fortran_fold 
<code class="example">    :let fortran_fold=1</code>
来指示语法脚本为程序单元定义折叠区域。程序单元 (program unit) 包括程序语句开始
的主程序、子例程、函数子程序、块数据子程序、接口块和模块。如果你也使用如下命令
设置变量 fortran_fold_conditionals 
<code class="example">    :let fortran_fold_conditionals=1</code>
那么也会为 do 循环、if 块和 select case 构造定义折叠区域。如果你同时使用如下命
令设置变量 fortran_fold_multilinecomments 
<code class="example">    :let fortran_fold_multilinecomments=1</code>
那么还会为三行或更多连续的注释定义折叠区域。<code class="note">注意</code> 定义折叠区域会使大文件变慢。

如果设置了 fortran_fold 和可能的 fortran_fold_conditionals 与/或
fortran_fold_multilinecomments，vim 会在你使用 foldmethod=syntax 时折叠文件。
两个程序单元之间的注释或空行不会被折叠，因为它们不被视作任何一个程序单元的一部
分。

<code class="section">更精确的 Fortran 语法 </code>
如果使用如下命令设置变量 fortran_more_precise 
<code class="example">    :let fortran_more_precise=1</code>
那么语法高亮会更精确，但也更慢。特别是，能够识别 do、goto 和算术 if 语句使用的
语句标签，还有 do、if、select、或 forall 构造结尾的构造名。

<code class="section">非缺省的 Fortran 方言 </code>
本语法脚本支持两种 Fortran 方言: f08 和 F。缺省高亮方式 (f08) 基本令人满意。一
些 2008 标准宣告过时或删除的传统结构被高亮为 todo 项目。

如果你使用 F，设置合适的方言的优点包括，F 排除的传统特性会被高亮为 todo 项目；
还有，总是假定使用自由形式的源程序。

有几个方式选择方言。如果你所有的 Fortran 文件使用相同的方言，在你的 .vimrc 文
件里 syntax 命令之前设置 fortran_dialect。可以接受的 fortran_dialect 的值是大
小写敏感的，而且必须是 "f08" 或 "F"。不合法的 fortran_dialect 的值被忽略。

如果源代码的格式取决于文件扩展名，那么最方便的方法是在 ftplugin 文件里设置一个
缓冲区局部变量。关于 ftplugin 文件的详情，见  <a href="usr_51.html#ftplugin">ftplugin</a> 。例如，如果你使用 .f90
扩展名的所有 Fortran 文件都使用 F 子集，那么在你的 ftplugin 文件里应该包含代码

<code class="example">    let s:extfname = expand("%:e")</code>
<code class="example">    if s:extfname ==? "f90"</code>
<code class="example">        let b:fortran_dialect="F"</code>
<code class="example">    else</code>
<code class="example">        unlet! b:fortran_dialect</code>
<code class="example">    endif</code>

<code class="note">注意</code> 只有在你的 .vimrc 文件的 "syntax on" 命令前加上了
"filetype plugin indent on" 命令，才能使这段代码工作。

如果文件扩展名还不能唯一确定方言，那么你需要更精细的控制。可以为每个文件定制方
言。方法是在文件的头三行内加上指令 "fortran_dialect=xx" (其中 xx=F 或 f08)。例
如，你较老的 .f 文件可能用传统代码编写，但较新的那些可能使用 F，那么你需要在后
者每个文件的头三行内加上以下形式的 Fortran 注释，以便标识 
<code class="example">  ! fortran_dialect=F</code>
<code class="example"></code>
使用较早的语法版本的用户，可能会设置 fortran_dialet 为现已废弃的值 "f77"、
"f90"、"f95" 或 "elf"。这些设置都会被悄悄地当作 "f08" 处理。"elf" 用户可能想
试试 "F" 也许会更好。

syntax/fortran.vim 脚本包含内嵌注释，说明如何为某些行加上注释和/或去掉注释来
(a) 识别一些非标准厂商自定的内在过程 (intrinsic)，(b) 使某些 2008 标准删除或废
止的功能不采用 todo 项目高亮。

<code class="section">限制 </code>
括号检查不能发现过少的闭括号。也不能识别 Hollerith 字符串。有些关键字可能高亮
不正确，因为 Fortran90 没有保留字。

更多关于 Fortran 的信息可见  <a href="indent.html#ft-fortran-indent">ft-fortran-indent</a>  和  <a href="filetype.html#ft-fortran-plugin">ft-fortran-plugin</a> 。

FREEBASIC                               <b class="vimtag"> <a name="freebasic.vim">freebasic.vim</a> </b> <b class="vimtag"> <a name="ft-freebasic-syntax">ft-freebasic-syntax</a> </b>

FreeBASIC 文件可为四种可用的方言，"fb"、"qb"、"fblite" 和 "deprecated" 提供不
同的高亮。关于如何选择正确的方言，可见  <a href="filetype.html#ft-freebasic-plugin">ft-freebasic-plugin</a> 。

进一步地，可用如下变量配置高亮。

<code class="section">变量                            高亮 </code>
<b class="vimtag"> <a name="freebasic_no_comment_fold">freebasic_no_comment_fold</a> </b>     关闭多行注释折叠
<b class="vimtag"> <a name="freebasic_operators">freebasic_operators</a> </b>           非字母操作符
<b class="vimtag"> <a name="freebasic_space_errors">freebasic_space_errors</a> </b>        拖尾空格和 <code class="special">&lt;Tab&gt;</code> 之前的空格
<b class="vimtag"> <a name="freebasic_type_suffixes">freebasic_type_suffixes</a> </b>       QuickBASIC 风格的类型后缀



FVWM 配 置 文 件                                <b class="vimtag"> <a name="fvwm.vim">fvwm.vim</a> </b> <b class="vimtag"> <a name="ft-fvwm-syntax">ft-fvwm-syntax</a> </b>

要使得 Vim 识别不符合模式 <b class="vimtag"> <a name="fvwmrc">fvwmrc</a> </b> 或 <b class="vimtag"> <a name="fvwm2rc">fvwm2rc</a> </b> 的 Fvwm 配置文件，你需要在你
myfiletypes.vim 文件里放入附加适合你系统的模式。对于这些模式，你需要设置变量
"b:fvwm_version" 为 Fvwm 的主版本号，同时设置 <a href="options.html#'filetype'">'filetype'</a> 选项为 fvwm。

例如，要使 Vim 识别 /etc/X11/fvwm2/ 里的所有文件为 Fvwm2 的配置文件，可以这样
设置: 
<code class="example"></code>
<code class="example">  :au! BufNewFile,BufRead /etc/X11/fvwm2/*  let b:fvwm_version = 2 |</code>
<code class="example">                                         \ set filetype=fvwm</code>
<code class="example"></code>
GSP                                             <b class="vimtag"> <a name="gsp.vim">gsp.vim</a> </b> <b class="vimtag"> <a name="ft-gsp-syntax">ft-gsp-syntax</a> </b>

GSP 页面的缺省色彩风格由  <a href="syntax.html#html.vim">html.vim</a>  定义，而 Java 代码 (在 Java 标签里或反引号
之间的内含代码) 的颜色由  <a href="syntax.html#java.vim">java.vim</a>  定义。 <a href="syntax.html#html.vim">html.vim</a>  里定义的以下 HTML 组在这
里被重新定义，以配合高亮的内含 (inline) Java 代码:

    htmlString
    htmlValue
    htmlEndTag
    htmlTag
    htmlTagN

多数你看到内含 Java 代码的地方，高亮应该没问题，但在一些特殊情况下可能有问题。
要加入其它可包含内含 Java 代码而高亮不正确的 HTML 组，只要从  <a href="syntax.html#html.vim">html.vim</a>  里把你
想要的行复制出来，并在 contains 子句里加上 gspJava 就可以了。

反引号里的内含 Java 使用 htmlError 组高亮，使之更易看清。


GROFF                                           <b class="vimtag"> <a name="groff.vim">groff.vim</a> </b> <b class="vimtag"> <a name="ft-groff-syntax">ft-groff-syntax</a> </b>

groff 语法文件是  <a href="syntax.html#nroff.vim">nroff.vim</a>  的包装，见该标题下的说明参阅使用和配置的示例。提
供这个包装的目的是通过  <a href="options.html#modeline">modeline</a>  或个人的文件类型文件 (见  <a href="filetype.html#filetype.txt">filetype.txt</a> ) 来
设置文件类型，从而设置 groff 专用的语法扩展。


HASKELL                      <b class="vimtag"> <a name="haskell.vim">haskell.vim</a> </b> <b class="vimtag"> <a name="lhaskell.vim">lhaskell.vim</a> </b> <b class="vimtag"> <a name="ft-haskell-syntax">ft-haskell-syntax</a> </b>

Haskell 语法文件支持普通的 Haskell 代码和文学的 (literate) Haskell 代码，后者
包括 Bird 风格和 Tex 风格。Haskell 语法高亮也能高亮 C 预处理指令。

如果你想高亮定界符 (适用于浅色背景)，在 .vimrc 里加上: 
<code class="example">        :let hs_highlight_delimiters = 1</code>
要把 True 和 False 识别为关键字而不是普通的标识符，加上: 
<code class="example">        :let hs_highlight_boolean = 1</code>
要把基本类型的名字识别为关键字: 
<code class="example">        :let hs_highlight_types = 1</code>
要把更多相对常用的类型识别为关键字: 
<code class="example">        :let hs_highlight_more_types = 1</code>
如果想高亮调试函数的名字，在你的 .vimrc 里加上: 
<code class="example">        :let hs_highlight_debug = 1</code>
<code class="example"></code>
Haskell 语法高亮也高亮 C 预处理指令，但非法的 # 开始的指令被标记为错误。这和
Haskell 的操作符语法有冲突，因为它们可能会用 # 开始。如果你想高亮这些为操作符
而不是错误，在 .vimrc 里加入: 
<code class="example">        :let hs_allow_hash_operator = 1</code>
<code class="example"></code>
文学的 Haskell 代码的语法高亮会试图自动猜测你的文学 Haskell 代码是否包含 Tex
标记，并相应地高亮 Tex 构造或什么也不做。要在全局改变此行为，在你的 .vimrc 文
件里放上 
<code class="example">        :let lhs_markup = none</code>
就可完全关闭高亮。或者 
<code class="example">        :let lhs_markup = tex</code>
强制使用 Tex 标记风格的高亮。更灵活的方法是使用该变量的局部于缓冲区的版本，例
如 
<code class="example">        :let b:lhs_markup = tex</code>
会强制为特定的缓冲区使用 TeX 高亮。必须在该缓冲区打开语法高亮或者载入文件前设
置。


HTML                                            <b class="vimtag"> <a name="html.vim">html.vim</a> </b> <b class="vimtag"> <a name="ft-html-syntax">ft-html-syntax</a> </b>

HTML 文件里，标签的色彩方案工作方式如下。

开放标签的 <code class="special">&lt;&gt;</code> 和关闭标签的 &lt;/&gt; 的颜色不同。这是有意的！开放标签使用 'Function'
色，而关闭标签使用 'Identifier' 色 (察看 syntax.vim 了解它们是如何为你定义
的)。

已知的标签名使用 C 语句 (Statement) 的色彩。未知的标签名分别和相应的 <code class="special">&lt;&gt;</code> 或 &lt;/&gt;
颜色相同，以便纠错。

<code class="note">注意</code> 这同样适用于参数 (或属性) 名。已知的属性名和未知的颜色不同。

一些 HTML 标签用于改变文本的显示。html.vim 语法色彩文件识别以下的标签，并相应
地改变普通文本的显示方式: <code class="special">&lt;B&gt;</code> <code class="special">&lt;I&gt;</code> <code class="special">&lt;U&gt;</code> <code class="special">&lt;EM&gt;</code> <code class="special">&lt;STRONG&gt;</code> (<code class="special">&lt;EM&gt;</code> 是 <code class="special">&lt;I&gt;</code> 的别名，而
<code class="special">&lt;STRONG&gt;</code> 是 <code class="special">&lt;B&gt;</code> 的别名)，<code class="special">&lt;H1&gt;</code> - <code class="special">&lt;H6&gt;</code>，<code class="special">&lt;HEAD&gt;</code>，<code class="special">&lt;TITLE&gt;</code> 和 <code class="special">&lt;A&gt;</code> (<code class="special">&lt;A&gt;</code> 必须在作为链
接，即包含了 href，才会如此。如 &lt;A href="somefile.html"&gt;)。

如果你想改变文本显示的方式，必须重定义以下的语法组:

    - htmlBold
    - htmlBoldUnderline
    - htmlBoldUnderlineItalic
    - htmlUnderline
    - htmlUnderlineItalic
    - htmlItalic
    - htmlTitle 设定标题
    - htmlH1 - htmlH6 设定标题头部 (header) 的文本

要使得重定义能够工作，你必须重定义所有的组，最后两组 (htmlTitle 和 htmlH[1-6]
可选) 可以除外。在你的 vimrc (这是根据初始化时读入文件的顺序) 里定义下面的变量

<code class="example">        :let html_my_rendering=1</code>
<code class="example"></code>
要想看一个例子，下载 <a href="http://www.fleiner.com/vim/download.html">http://www.fleiner.com/vim/download.html</a> 的 mysyntax.vim
文件。

在你的 vimrc 文件里加上这行，可以屏蔽这种显示方式: 
<code class="example">        :let html_no_rendering=1</code>
<code class="example"></code>
HTML 注释相当特别 (详情见 HTML 的参考文档)，此语法高亮方案会高亮所有的错误。不
过，如果你喜欢不太正确 (以 &lt;!-- 开始并以 --&gt; 结束) 的风格，可以定义 
<code class="example">        :let html_wrong_comments=1</code>
<code class="example"></code>
HTML 文档的内嵌 (embedded) JavaScript 和 Visual Basic 使用 'Special' 高亮，而
其中的语句、注释、字符串等使用标准的编程语言的颜色。<code class="note">注意</code> 现在只支持 JavaScript
和 Visual Basic，还没有加入其它的脚本语言。

内嵌和内含 (inline) 的层叠样式表 (CSS) 也被高亮。

有多种 html 预处理器语言，html.vim 的编写方式使得包含它非常容易。要想这么做，
只要在相应语言的语法高亮文件里加入如下两行 (该例子来自 asp.vim 文件) 就可以了:

<code class="example">    runtime! syntax/html.vim</code>
<code class="example">    syn cluster htmlPreproc add=asp</code>
<code class="example"></code>
现在你只需要把所有包含预处理语言的区域项目加到 htmlPreproc 簇里就可以了。

                                                        <b class="vimtag"> <a name="html-folding">html-folding</a> </b>
HTML 语法文件提供起始标签和结束标签之间的高亮  <a href="fold.html#folding">folding</a>  (见  <a href="syntax.html#:syn-fold">:syn-fold</a> )。可如
此打开 
<code class="example"></code>
<code class="example">        :let g:html_syntax_folding = 1</code>
<code class="example">        :set foldmethod=syntax</code>
<code class="example"></code>
<code class="note">注意</code>: 语法折叠可能会显著减慢语法高亮，大文件尤其明显。


HTML/OS (Aestiva 提供)                          <b class="vimtag"> <a name="htmlos.vim">htmlos.vim</a> </b> <b class="vimtag"> <a name="ft-htmlos-syntax">ft-htmlos-syntax</a> </b>

HTML/OS 的色彩高亮方案工作方式如下:

缺省为函数和变量名使用相同的颜色，因为 VIM 并不为 Function 和 Identifier 指定
不同的颜色。要改变这一点 (如果你希望函数名能用不同的颜色加以识别的话，建议使
用)，你需要在 ~/.vimrc 里加入下行: 
<code class="example">  :hi Function term=underline cterm=bold ctermfg=LightGray</code>
<code class="example"></code>
当然如果你愿意，ctermfg 可以使用别的颜色。

HTML/OS 碰到的另一个问题是没有特殊的指示 HTML/OS 编码的文件类型。打开文件并用
下面的方法打开 HTML/OS 语法，你就可以改变这一点: 
<code class="example">  :set syntax=htmlos</code>
<code class="example"></code>
最后要提醒一下，启动 HTML/OS 代码块的打开和关闭字符序列分别是 &lt;&lt; 或 [[ 和 &gt;&gt;
或 ]]。


IA64                            <b class="vimtag"> <a name="ia64.vim">ia64.vim</a> </b> <b class="vimtag"> <a name="intel-itanium">intel-itanium</a> </b> <b class="vimtag"> <a name="ft-ia64-syntax">ft-ia64-syntax</a> </b>

为 Intel Itanium 64 汇编语言提供高亮。 <a href="syntax.html#asm.vim">asm.vim</a>  说明如何识别该文件类型。

要识别 *.inc 文件为 IA64，在你的 .vimrc 文件里加入这行: 
<code class="example">        :let g:filetype_inc = "ia64"</code>
<code class="example"></code>
<code class="example"></code>
INFORM                                          <b class="vimtag"> <a name="inform.vim">inform.vim</a> </b> <b class="vimtag"> <a name="ft-inform-syntax">ft-inform-syntax</a> </b>

Inform 高亮包含 Inform 库提供的符号，因为多数程序大量使用它们。如果不希望高亮
这些库里的符号，在你的 vim 启动文件里加入: 
<code class="example">        :let inform_highlight_simple=1</code>
<code class="example"></code>
缺省假定 Inform 程序面向 Z 机器。并适当地高亮 Z 机器的汇编语言符号。如果期望程
序面向 Glulx/Glk 环境，你需要在启动文件的序列中加入: 
<code class="example">        :let inform_highlight_glulx=1</code>
<code class="example"></code>
这样就只高亮 Glulx 操作码，并把 glk() 加到高亮的系统函数集合里。

Inform 编译器遇到特定已废弃的关键字时，会标记它们为错误。通常，Vim 也把这些关
键字标为错误。如果不想高亮这些错误，你必须在启动文件的序列中加入: 
<code class="example">        :let inform_suppress_obsolete=1</code>
<code class="example"></code>
缺省的高亮设置符合编译器版本 6.30 和库版本 6.11 的语言特性。如果你使用较老的
Inform 开发环境，可能需要在启动文件的序列中加入: 
<code class="example">        :let inform_highlight_old=1</code>
<code class="example"></code>
IDL                                                     <b class="vimtag"> <a name="idl.vim">idl.vim</a> </b> <b class="vimtag"> <a name="idl-syntax">idl-syntax</a> </b>

IDL (Interface Definition Language，接口定义语言) 文件用于定义 RFC 调用。
Microsoft 的领地里也用来定义 COM 接口和调用。

IDL 的结构足够简单，所以可以分析完整语法，而不需要一些启发式的猜测。结果很大，
甚至可能有些重复工作，但看来能用了。

这里有一些 Microsft 的 idl 文件扩展。有些可以通过 idl_no_ms_extensions 关闭。

更复杂的扩展可以通过定义 idl_no_extensions 来关闭。

<code class="section">变量                            效果 </code>

idl_no_ms_extensions            关闭一些 Microsoft 专用的扩展
idl_no_extensions               关闭复杂扩展
idlsyntax_showerror             显示 IDL 错误 (可能过于侵略性，但很有用)
idlsyntax_showerror_soft        使缺省的错误颜色柔和一些


JAVA                                            <b class="vimtag"> <a name="java.vim">java.vim</a> </b> <b class="vimtag"> <a name="ft-java-syntax">ft-java-syntax</a> </b>

java.vim 语法高亮文件提供若干选项:

在 Java 1.0.2 里，小括号里不可能有大括号，所以这被标识为错误。但从 Java 1.1 开
始，这是合法的 (无名类的使用)，因而它不再标为错误。如果你喜欢旧的方式，在 vim
启动文件里加入下行: 
<code class="example">        :let java_mark_braces_in_parens_as_errors=1</code>
<code class="example"></code>
所有 java.lang.* 的标识符在所有的类里都是可见的。要高亮它们，可用: 
<code class="example">        :let java_highlight_java_lang_ids=1</code>
<code class="example"></code>
如果你从 <a href="http://www.fleiner.com/vim/download.html">http://www.fleiner.com/vim/download.html</a> 下载 javaid.vim 脚本，你也可
以高亮大多数标准 java 包里的标识符。
如果你只想高亮特定包里的标识符，比如说 java.io，可以用: 
<code class="example">        :let java_highlight_java_io=1</code>
察看 javaid.vim 文件，可以得到它支持的所有包的列表。

函数名不会高亮，因为找到函数的方法取决于你如何写 Java 代码。语法文件知道两种可
以高亮函数的方法:

如果你的函数定义总是使用一个制表、8 个空格或者 2 个空格的缩进，可以设置 
<code class="example">        :let java_highlight_functions="indent"</code>
不过，如果你遵循 Java 指南里函数和类的命名规则 (关于大小写)，就可以用 
<code class="example">        :let java_highlight_functions="style"</code>
如果两个选项都不合适，但你仍然期望高亮函数声明，修改 java.vim 里的定义或者创建
你自己的 java.vim。你自己的版本应该包含原来的版本，并增加高亮函数的代码。

Java 1.1 里，只应该用函数 System.out.println() 和 System.err.println() 来进行
调试。所以你可以用不同的方式高亮调试语句。要这么做，你必须在启动文件里加上以下
定义: 
<code class="example">        :let java_highlight_debug=1</code>
结果那些语句会被高亮为 'Special' 字符序列。如果你喜欢用不同的方式分别高亮，必
须为以下各组定义新的高亮:
    Debug、DebugSpecial、DebugString、DebugBoolean、DebugType
它们分别用来高亮语句本身，调试字符串里的特殊字符、字符串、布尔常量和类型
(this，super)。我本人喜欢给语句设置别的背景。

Javadoc 是一个程序，它接受特殊的 Java 程序文件里的注释，并创建 HTML 页面。标准
的配置会以类似于 HTML 文件 (见  <a href="syntax.html#html.vim">html.vim</a> ) 方式高亮该 HTML 代码，你甚至可以在
代码里加入 Javascript 和 CSS (见下)。但有四处不同:
  1. 标题 (第一个后面有若干空白跟随的 '.' 或第一个 '@' 之前的所有字符) 使用不
     同的颜色 (要改变其颜色，修改 CommentTitle 组)。
  2. 文本使用 'Comment' 高亮。
  3. HTML 注释使用 'Special' 高亮。
  4. 特殊的 Javadoc 标签 (@see、@param、...) 用 Special 高亮。 而 ( @see、
     @param、@exception 的)参数则使用 Function 高亮。
要关闭该特性，在你的启动文件里加入该行: 
<code class="example">        :let java_ignore_javadoc=1</code>
<code class="example"></code>
如果你使用上述的特殊 Javadoc 注释高亮方式，你也可以打开 Javascript、Visual
Basic 脚本和内嵌 CSS (样式表) 的特殊高亮。只有在你实际有包含 Javascript 或内
嵌 CSS 的 Javadoc 注释时，这才有意义。要使用的选项分别是 
<code class="example">        :let java_javascript=1</code>
<code class="example">        :let java_css=1</code>
<code class="example">        :let java_vb=1</code>
<code class="example"></code>
要以不同的颜色高亮嵌套的括号，分别定义 javaParen、javaParen1 和 javaParen2 的
颜色。比如用 
<code class="example">        :hi link javaParen Comment</code>
或 
<code class="example">        :hi javaParen ctermfg=blue guifg=#0000ff</code>
<code class="example"></code>
如果你<code class="note">注意</code>到往回滚动时，高亮出现问题，但 <code class="keystroke">CTRL-L</code> 重画又可以修正的话，尝试设置
"java_minlines" 内部变量为较大的值: 
<code class="example">        :let java_minlines = 50</code>
这使得语法同步在第一个显示行之前的 50 行开始。缺省值为 10。使用较大的值的缺点
是重画会变慢。


JSON                                            <b class="vimtag"> <a name="json.vim">json.vim</a> </b> <b class="vimtag"> <a name="ft-json-syntax">ft-json-syntax</a> </b>

json 语法文件缺省提供带隐藏支持的语法高亮。要关闭隐藏: 
<code class="example">        let g:vim_json_conceal = 0</code>
<code class="example"></code>
要关闭错误的语法高亮: 
<code class="example">        let g:vim_json_warnings = 0</code>
<code class="example"></code>
<code class="example"></code>
LACE                                            <b class="vimtag"> <a name="lace.vim">lace.vim</a> </b> <b class="vimtag"> <a name="ft-lace-syntax">ft-lace-syntax</a> </b>

Lace (Language for Assembly of Classes in Eiffel，Eiffel 类整合语言) 对大小写
不敏感，但风格指南不是这么建议的。如果你喜欢对大小写不敏感的高亮，在启动文件里
定义 vim 变量 'lace_case_insensitive': 
<code class="example">        :let lace_case_insensitive=1</code>
<code class="example"></code>
<code class="example"></code>
LEX                                             <b class="vimtag"> <a name="lex.vim">lex.vim</a> </b> <b class="vimtag"> <a name="ft-lex-syntax">ft-lex-syntax</a> </b>

Lex 使用强力攻击 (brute-force) 的方式进行同步，因为 "^%%$" 段定界符没有提供任
何关于后续段的提示。因而，如果用户有同步问题的话 (比如使用很大的 lex 文件)，
他/她可以尝试改变 
<code class="example">        :syn sync minlines=300</code>
的值。


LIFELINES                               <b class="vimtag"> <a name="lifelines.vim">lifelines.vim</a> </b> <b class="vimtag"> <a name="ft-lifelines-syntax">ft-lifelines-syntax</a> </b>

要把废弃函数高亮为错误，在 .vimrc 中加入: 
<code class="example"></code>
<code class="example">        :let g:lifelines_deprecated = 1</code>


LISP                                            <b class="vimtag"> <a name="lisp.vim">lisp.vim</a> </b> <b class="vimtag"> <a name="ft-lisp-syntax">ft-lisp-syntax</a> </b>

Lisp 语法高亮提供两个选项: 
<code class="example"></code>
<code class="example">        g:lisp_instring : 如果存在，那么 "(...)" 字符串会被高亮，就像字符串里</code>
<code class="example">                          的内容是 Lisp 代码一样。对 AutoLisp 有用。</code>
<code class="example">        g:lisp_rainbow  : 如果存在且非零，那么不同的括号层次产生不同的高亮。</code>

g:lisp_rainbow 选项为小括号和反引号提供 10 层不同的色彩。因为色彩层次的数量关
系，不同于非 rainbow (彩虹) 方式，rainbow 模式直接使用 ctermfg 和 guifg 指定高
亮色彩，而回避了标准的使用高亮组的色彩方案控制。实际使用的高亮值仍然取决于深/
浅设置 (见  <a href="options.html#'bg'">'bg'</a> )。


LITE                                            <b class="vimtag"> <a name="lite.vim">lite.vim</a> </b> <b class="vimtag"> <a name="ft-lite-syntax">ft-lite-syntax</a> </b>

lite 语法高亮有两个选项。

如果你喜欢字符串里的 SQL 语法高亮，使用: 
<code class="example"></code>
<code class="example">        :let lite_sql_query = 1</code>
<code class="example"></code>
同步的缺省 minlines 为 100。如果你喜欢别的值，可以把 "lite_minlines" 设为你想
要的值。例如: 
<code class="example"></code>
<code class="example">        :let lite_minlines = 200</code>
<code class="example"></code>
<code class="example"></code>
LPC                                             <b class="vimtag"> <a name="lpc.vim">lpc.vim</a> </b> <b class="vimtag"> <a name="ft-lpc-syntax">ft-lpc-syntax</a> </b>

LPC 代表一种简单又节省内存的语言: Lars Pensjö C。LPC 的文件名通常是 *.c。把这
些文件识别为 LPC 会惹恼那些只用 C 程序的用户。如果你想使用 Vim 的 LPC 语法，在
你的 .vimrc 文件里设置变量: 
<code class="example"></code>
<code class="example">        :let lpc_syntax_for_c = 1</code>
<code class="example"></code>
如果这对某些特殊的 C 或 LPC 文件不能工作，用模式行。在 LPC 文件里: 
<code class="example"></code>
<code class="example">        // vim:set ft=lpc:</code>
<code class="example"></code>
对于被识别为 LPC 的 C 文件: 
<code class="example"></code>
<code class="example">        // vim:set ft=c:</code>
<code class="example"></code>
如果你不想设置此变量，在 <code class="emphasis">每个</code>  LPC 文件里使用模式行。

LPC 有若干实现，我们打算支持最常用的实现。这里缺省的 LPC 语法基于 MudOS 系列。
对于 MudOS v22 和以前的版本。你应该关闭合适的修饰符，它也会把 v22 之后的新的
efuns 认定为非法。如果你使用最新的 MudOS 版本，不要设置该变量: 
<code class="example"></code>
<code class="example">        :let lpc_pre_v22 = 1</code>
<code class="example"></code>
对于 LpMud 3.2 系列的 LPC: 
<code class="example"></code>
<code class="example">        :let lpc_compat_32 = 1</code>
<code class="example"></code>
对于 LPC4 系列的 LPC: 
<code class="example"></code>
<code class="example">        :let lpc_use_lpc4_syntax = 1</code>
<code class="example"></code>
对于 uLPC 系列的 LPC:
uLPC 是为 Pike 开发的，所以你应该使用 Pike 的语法，而且源文件应该是 *.pike。


LUA                                             <b class="vimtag"> <a name="lua.vim">lua.vim</a> </b> <b class="vimtag"> <a name="ft-lua-syntax">ft-lua-syntax</a> </b>

Lua 语法文件可用于 Lua 4.0、5.0、5.1 或 5.2 (5.2 是缺省)。用全局变量
lua_version 和 lua_subversion 可以选择其中一个版本。例如，如果要激活 Lua 5.1
高亮，设置变量如下: 
<code class="example"></code>
<code class="example">        :let lua_version = 5</code>
<code class="example">        :let lua_subversion = 1</code>
<code class="example"></code>
<code class="example"></code>
MAIL                                            <b class="vimtag"> <a name="mail.vim">mail.vim</a> </b> <b class="vimtag"> <a name="ft-mail.vim">ft-mail.vim</a> </b>

Vim 高亮 email 的所有标准元素 (信头、签名、引用文本和 URL / email 地址)。要符
合标准的习惯，签名应该以 "--" 开头，跟随可选的若干空格并以回车结束的一行开始。

Vim 把 ']'、'}'、'|'、'&gt;' 或者有 '&gt;' 跟随的单词开始的行高亮为引用文本。不过，
只有在引用文本用 '&gt;' 的方式引用 (后面可跟一个可选的空格)，Vim 才把把该文本里的
信头和签名高亮为引用文本。

mail.vim 缺省从第一个显示行之前的 100 行开始同步语法。如果你的机器很慢，而且通
常处理的 email 的信头不长，你可以把它设为较小的值: 
<code class="example"></code>
<code class="example">    :let mail_minlines = 30</code>
<code class="example"></code>
<code class="example"></code>
MAKE                                            <b class="vimtag"> <a name="make.vim">make.vim</a> </b> <b class="vimtag"> <a name="ft-make-syntax">ft-make-syntax</a> </b>

Makefile 里，命令通常被高亮以便你发现错误。不过，如果你觉得颜色太多了，可以这
样关闭此特性: 
<code class="example"></code>
<code class="example">        :let make_no_commands = 1</code>
<code class="example"></code>
<code class="example"></code>
MAPLE                                           <b class="vimtag"> <a name="maple.vim">maple.vim</a> </b> <b class="vimtag"> <a name="ft-maple-syntax">ft-maple-syntax</a> </b>

Waterloo Maple Inc 的 Maple V 支持符号代数。该语言支持很多函数包，用户可以选择
性地装载。如果用户愿意，可以高亮 Maple V release 4 提供的标准包函数。用户可以
在 .vimrc 文件里加入: 
<code class="example"></code>
<code class="example">        :let mvpkg_all= 1</code>
<code class="example"></code>
来高亮所有的包里的函数。用户也可以通过从下表选择变量/包来挑选一个子集，并在
.vimrc 文件里 (在执行 $VIMRUNTIME/syntax/syntax.vim 之前) 设置挑选的变量为 1
就可以了。

                        Maple V 包函数选择器表 
<code class="example">  mv_DEtools     mv_genfunc     mv_networks     mv_process</code>
<code class="example">  mv_Galois      mv_geometry    mv_numapprox    mv_simplex</code>
<code class="example">  mv_GaussInt    mv_grobner     mv_numtheory    mv_stats</code>
<code class="example">  mv_LREtools    mv_group       mv_orthopoly    mv_student</code>
<code class="example">  mv_combinat    mv_inttrans    mv_padic        mv_sumtools</code>
<code class="example">  mv_combstruct  mv_liesymm     mv_plots        mv_tensor</code>
<code class="example">  mv_difforms    mv_linalg      mv_plottools    mv_totorder</code>
<code class="example">  mv_finance     mv_logic       mv_powseries</code>
<code class="example"></code>
<code class="example"></code>
MARKDOWN                                                <b class="vimtag"> <a name="ft-markdown-syntax">ft-markdown-syntax</a> </b>

如果有很长的区域，高亮可能会出错。以减慢显示速度为代价，可以让引擎反向查找更
远去同步区域开始处，例如反向 500 行: 
<code class="example"></code>
<code class="example">        :let g:markdown_minlines = 500</code>
<code class="example"></code>
<code class="example"></code>
MATHEMATICA             <b class="vimtag"> <a name="mma.vim">mma.vim</a> </b> <b class="vimtag"> <a name="ft-mma-syntax">ft-mma-syntax</a> </b> <b class="vimtag"> <a name="ft-mathematica-syntax">ft-mathematica-syntax</a> </b>

自动假设空白的 *.m 文件为 Matlab 文件，除非你在 .vimrc 里指定了: 
<code class="example"></code>
<code class="example">        let filetype_m = "mma"</code>
<code class="example"></code>
<code class="example"></code>
MOO                                             <b class="vimtag"> <a name="moo.vim">moo.vim</a> </b> <b class="vimtag"> <a name="ft-moo-syntax">ft-moo-syntax</a> </b>

如果你在表达式里使用 C 风格的注释但发现它影响了高亮，可以尝试使用扩展的 (会变
慢！) C 风格注释的匹配: 
<code class="example"></code>
<code class="example">        :let moo_extended_cstyle_comments = 1</code>
<code class="example"></code>
要关闭字符串里的代词替换 (pronoun substitution) 模式高亮: 
<code class="example"></code>
<code class="example">        :let moo_no_pronoun_sub = 1</code>
<code class="example"></code>
要关闭正则表达式 '%|' 操作符和字符串里匹配的 '%(' 和 '%)' 所用的高亮: 
<code class="example"></code>
<code class="example">        :let moo_no_regexp = 1</code>
<code class="example"></code>
可以识别不匹配的双引号并高亮为错误: 
<code class="example"></code>
<code class="example">        :let moo_unmatched_quotes = 1</code>
<code class="example"></code>
要高亮内建的属性 (.name、.location、.programmer 等): 
<code class="example"></code>
<code class="example">        :let moo_builtin_properties = 1</code>
<code class="example"></code>
可以识别未知的内建函数并高亮为错误。如果你使用该选项，应该把自己的扩展加到
mooKnownBuiltinFunction 组里。要打开该选项: 
<code class="example"></code>
<code class="example">        :let moo_unknown_builtin_functions = 1</code>
<code class="example"></code>
把 sprintf() 加到已知内建函数列表的例子: 
<code class="example"></code>
<code class="example">        :syn keyword mooKnownBuiltinFunction sprintf contained</code>
<code class="example"></code>
<code class="example"></code>
MSQL                                            <b class="vimtag"> <a name="msql.vim">msql.vim</a> </b> <b class="vimtag"> <a name="ft-msql-syntax">ft-msql-syntax</a> </b>

msql 语法高亮有两个选项。

如过你希望高亮字符串里的 SQL 语法，使用: 
<code class="example"></code>
<code class="example">        :let msql_sql_query = 1</code>
<code class="example"></code>
同步的 minlines 缺省为 100。如果你喜欢别的值，可以设置 "msql_minlines" 为你所
希望的值。例如: 
<code class="example"></code>
<code class="example">        :let msql_minlines = 200</code>
<code class="example"></code>
<code class="example"></code>
N1QL                                            <b class="vimtag"> <a name="n1ql.vim">n1ql.vim</a> </b> <b class="vimtag"> <a name="ft-n1ql-syntax">ft-n1ql-syntax</a> </b>

N1QL 是类 SQL 的声明式语言，用于操作 Couchbase Server 数据库的JSON 文档。

Vim 语法高亮 N1QL 语句、关键字、操作符、类型、注释和特殊值。Vim 忽略 SQL 或它
的许多方言中特定的如 COLUMN 或 CHAR 等 N1QL 不存在的语法成分。


NCF                                             <b class="vimtag"> <a name="ncf.vim">ncf.vim</a> </b> <b class="vimtag"> <a name="ft-ncf-syntax">ft-ncf-syntax</a> </b>

NCF 语法高亮有一个选项。

如果你想把不能识别的 (依据 ncf.vim) 语句高亮为错误，使用: 
<code class="example"></code>
<code class="example">        :let ncf_highlight_unknowns = 1</code>
<code class="example"></code>
如果你不想高亮它们为错误，留着该变量不设置就可以了。


NROFF                                           <b class="vimtag"> <a name="nroff.vim">nroff.vim</a> </b> <b class="vimtag"> <a name="ft-nroff-syntax">ft-nroff-syntax</a> </b>

nroff 语法文件可直接用于 AT&amp;T n/troff 而无需修改。如果要使用 GNU groff，你需要
在使用之前激活语法文件里的一些附加特性。

例如，Linux 和 BSD 的发布版本使用 groff 作为缺省的文本处理包。要激活 groff
附加的语法高亮特性，使文件被识别为 groff 文件 (见  <a href="syntax.html#ft-groff-syntax">ft-groff-syntax</a> ) 或在你的
启动文件里加入以下选项: 
<code class="example"></code>
<code class="example">  :let nroff_is_groff = 1</code>
<code class="example"></code>
Groff 和老的 AT&amp;T n/troff 不同，后者还可以在 Solaris 找到。Groff 宏和请求名可
以超过 2 个字符，而且有语言基本命令之外的扩展。例如，AT&amp;T troff 里你可以用请求
\(yr 得到 2 位数的年份。groff 里为了照顾兼容性，可以使用相同的请求，你也可以直
接使用 groff 本身的宏: \[year]。宏请求可以超过 2 个字符，比如，GNU mm 接受
".VERBON" 和 ".VERBOFF" 请求，以创建 verbatim (不作转换的) 环境。

要得到 g/troff 能给出的最好的输出，需要遵循一些关于空格和标点的简单的规则。

1. 不要在行尾留空白。

2. 在句尾的句号、感叹号等之后留且只留一个空格。

3. 由于下面的原因，最好在所有的句号之后立即回车。

这些不寻常的提示的背后原因是，如果你不遵循上面的这些规则，g/n/troff 使用的换行
算法很容易弄错。

和 TeX 不同，troff 逐行而不是逐段填充文本。此外，它没有 glue (可伸缩的距离) 或
stretch 的概念，所有的水平和垂直空白输入都直接成为输出。

因此你必须小心，不要在句子之间留下比你在最终文档想要的更多的空白。因此，通常在
每个标点符号之后都立即插入一个回车。如果你想要最终处理过的文本 "对齐"，需要在
输入文本里维持常规的空间。要把行尾的空格和标点之后两个或更多的空格标为错误，可
用: 
<code class="example"></code>
<code class="example">  :let nroff_space_errors = 1</code>
<code class="example"></code>
另一个检测额外的空格和其它错误的技术会影响你文件的正确排版。这个方法是在你的配
置文件里定义语法组 "nroffDefinition" 和 "nroffDefSpecial" 显眼的高亮定义。例
如: 
<code class="example"></code>
<code class="example">  hi def nroffDefinition term=italic cterm=italic gui=reverse</code>
<code class="example">  hi def nroffDefSpecial term=italic,bold cterm=italic,bold</code>
<code class="example">                         \ gui=reverse,bold</code>
<code class="example"></code>
如果你想像段标记符那样方便地浏览源文件里的预处理项目，可以在 .vimrc 文件里激活
以下选项: 
<code class="example"></code>
<code class="example">        let b:preprocs_as_sections = 1</code>
<code class="example"></code>
还有，语法文件为 ms 包里设置带缩进的 (exdented) 段落宏 (.XP) 增加了一个附加的
段标记符。

最后，有一个  <a href="syntax.html#groff.vim">groff.vim</a>  语法文件，可以基于每个文件或，缺省情况下，在全局打开
groff 的语法高亮。


OCAML                                           <b class="vimtag"> <a name="ocaml.vim">ocaml.vim</a> </b> <b class="vimtag"> <a name="ft-ocaml-syntax">ft-ocaml-syntax</a> </b>

OCaml 语法文件处理带以下后缀的文件: .ml、.mli、.mll 和 .mly。设置以下变量 
<code class="example"></code>
<code class="example">        :let ocaml_revised = 1</code>
<code class="example"></code>
你就可以切换标准的 OCaml 语法为 camlp4 预处理器支持的改进的语法。设置变量 
<code class="example"></code>
<code class="example">        :let ocaml_noend_error = 1</code>
<code class="example"></code>
防止把 "end" 高亮为错误，这可用于源程序包含很长的结构而 Vim 不再能保持同步的场
合。


PAPP                                            <b class="vimtag"> <a name="papp.vim">papp.vim</a> </b> <b class="vimtag"> <a name="ft-papp-syntax">ft-papp-syntax</a> </b>

PApp 语法文件处理 .papp 文件和，在一定程度上，.pxml 和 .pxsl 文件。它们都是
perl / xml / html / 其它格式 的混合，并使用 xml 作为顶层的文件格式。缺省，所有
phtml 和 pxml 段里的内容都被处理为包含内嵌预处理器命令的字符串。如果你在启动文
件里设置变量: 
<code class="example"></code>
<code class="example">        :let papp_include_html=1</code>
<code class="example"></code>
它就会试图语法高亮 pthml 段里的 html 代码，但这相对较慢，而且对于有效的编辑未
免色彩太鲜艳了些 ;)

可以在 <a href="http://papp.plan9.de">http://papp.plan9.de</a> 找到最新的 papp.vim 语法文件的版本。


PASCAL                                          <b class="vimtag"> <a name="pascal.vim">pascal.vim</a> </b> <b class="vimtag"> <a name="ft-pascal-syntax">ft-pascal-syntax</a> </b>

匹配 "*.p" 的文件可以是 Progress 或者 Pascal 的，而匹配 "*.pp" 的也可以是
Puppet 或 Pascal 的。如果自动检测对你不适用，或者你只编辑 Pascal 文件，在启动
vimrc 里加入: 
<code class="example"></code>
<code class="example">   :let filetype_p = "pascal"</code>
<code class="example">   :let filetype_pp = "pascal"</code>
<code class="example"></code>
Pascal 语法文件被扩展，以支持 Turbo Pascal、Free Pascal 编译器和 GNU Pascal 编
译器的一些扩展。也支持 Delphi 的关键字。缺省打开 Turbo Pascal 7.0 特性。如果你
只想使用标准的 Pascal 关键字，在你的启动文件里加入下行: 
<code class="example"></code>
<code class="example">   :let pascal_traditional=1</code>
<code class="example"></code>
要打开 Delphi 专用的构造 (比如单行注释、关键字、等等): 
<code class="example"></code>
<code class="example">   :let pascal_delphi=1</code>
<code class="example"></code>
<code class="example"></code>
pascal_symbol_operator 选项控制符号 (symbol) 操作符，如 +、* 等，是否使用
Operator 的色彩高亮。要给符号的操作符加上颜色，在你的启动文件里加入下行: 
<code class="example"></code>
<code class="example">   :let pascal_symbol_operator=1</code>
<code class="example"></code>
有些函数缺省是高亮的。要关闭: 
<code class="example"></code>
<code class="example">   :let pascal_no_functions=1</code>
<code class="example"></code>
另外，一些编译器有专门的变量。除了 pascal_delphi 以外，还有 pascal_gpc 和
pascal_fpc。缺省试图匹配 Turbo Pascal 的扩展。 
<code class="example"></code>
<code class="example">   :let pascal_gpc=1</code>
<code class="example"></code>
或 
<code class="example"></code>
<code class="example">   :let pascal_fpc=1</code>
<code class="example"></code>
要确保字符串在一行内定义，你可以定义 pascal_one_line_string 变量。 
<code class="example"></code>
<code class="example">   :let pascal_one_line_string=1</code>
<code class="example"></code>
如果你不喜欢 <code class="special">&lt;Tab&gt;</code> 字符，你可以设置 pascal_no_tabs 变量。制表会被高亮为
Error。 
<code class="example"></code>
<code class="example">   :let pascal_no_tabs=1</code>
<code class="example"></code>
<code class="example"></code>
<code class="example"></code>
PERL                                            <b class="vimtag"> <a name="perl.vim">perl.vim</a> </b> <b class="vimtag"> <a name="ft-perl-syntax">ft-perl-syntax</a> </b>

perl 的语法高亮有一些可用的选项。

现在缺省打开内建 POD 的高亮。如果不希望因 Perl 文件内嵌的 POD 高亮增加复杂度，
可以把 'perl_include_pod'  选项设为 0: 
<code class="example"></code>
<code class="example">        :let perl_include_pod = 0</code>
<code class="example"></code>
要减低分析的复杂度 (同时提高了效率)，你可以关闭变量名和内容的分析过程的两个元
素。

要使变量和函数名里对包的引用与名字的其它部分不区别显示 (如 '$PkgName::VarName'
里的 'PkgName::'): 
<code class="example"></code>
<code class="example">        :let perl_no_scope_in_variables = 1</code>
<code class="example"></code>
(Vim 6.x 里相反，用 "perl_want_scope_in_variables" 打开区别显示。)

如果你不想分析复杂的结构，比如 '@{${"foo"}}': 
<code class="example"></code>
<code class="example">        :let perl_no_extended_vars = 1</code>
<code class="example"></code>
(Vim 6.x 里相反，用 "perl_extended_vars" 打开此项分析。)

你可以改变颜色字符串。缺省，字符串和 qq 等变形会像下面第一行那样高亮。如果你设
置了变量 perl_string_as_statement，那么就像下面第二行那样高亮。
   "hello world!"; qq|hello world|;
   ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^N       (unlet perl_string_as_statement)
   S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^SN       (let perl_string_as_statement)

(^ = perlString、S = perlStatement、N = 什么都没有)

同步有三个选项。前两个关掉一些激活同步的方法，而只有在无法正确工作的时候你才需
要它们。比如，如果滚动时突然全屏的颜色发生改变，那么你应该尝试改变并关闭其中的
某一个。如果你可以发现哪一行导致这种错误，请告诉我。

大致上，其中一个在 "^\s*sub\s*" 上激活，另一个则在 "^[$@%]" 上。 
<code class="example"></code>
<code class="example">        :let perl_no_sync_on_sub</code>
<code class="example">        :let perl_no_sync_on_global_var</code>
<code class="example"></code>
下面，你还可以设置 VIM 往前找语法高亮的起始点的最大距离。 
<code class="example"></code>
<code class="example">        :let perl_sync_dist = 100</code>
<code class="example"></code>
如果你想要在 perl 里使用折叠，设置 perl_fold: 
<code class="example"></code>
<code class="example">        :let perl_fold = 1</code>
<code class="example"></code>
如果你想折叠 if 等语句块，设置如下: 
<code class="example"></code>
<code class="example">        :let perl_fold_blocks = 1</code>
<code class="example"></code>
'perl_fold' 置位时，缺省折叠例程。如果不想要，可以设置
'perl_nofold_subs': 
<code class="example"></code>
<code class="example">        :let perl_nofold_subs = 1</code>
<code class="example"></code>
缺省不折叠无名例程；可以用 'perl_fold_anonymous_subs' 打开之: 
<code class="example"></code>
<code class="example">        :let perl_fold_anonymous_subs = 1</code>
<code class="example"></code>
'perl_fold' 置位时，缺省对包折叠。如果不想要，可以设置
'perl_nofold_packages': 
<code class="example"></code>
<code class="example">        :let perl_nofold_packages = 1</code>
<code class="example"></code>
PHP3 和 PHP4            <b class="vimtag"> <a name="php.vim">php.vim</a> </b> <b class="vimtag"> <a name="php3.vim">php3.vim</a> </b> <b class="vimtag"> <a name="ft-php-syntax">ft-php-syntax</a> </b> <b class="vimtag"> <a name="ft-php3-syntax">ft-php3-syntax</a> </b>

[<code class="note">注意</code>: 以前这被称为 "php3"，但因为现在这也支持 php4，它被改名为 "php"]

php 的语法高亮支持以下选项。

如果你喜欢字符串里的 SQL 语法高亮: 
<code class="example"></code>
<code class="example">  let php_sql_query = 1</code>
<code class="example"></code>
要高亮 Baselib 方法: 
<code class="example"></code>
<code class="example">  let php_baselib = 1</code>
<code class="example"></code>
打开字符串里的 HTML 语法高亮: 
<code class="example"></code>
<code class="example">  let php_htmlInStrings = 1</code>
<code class="example"></code>
使用旧的色彩风格: 
<code class="example"></code>
<code class="example">  let php_oldStyle = 1</code>
<code class="example"></code>
打开 ASP 风格的短标签的高亮: 
<code class="example"></code>
<code class="example">  let php_asp_tags = 1</code>
<code class="example"></code>
关闭短标签: 
<code class="example"></code>
<code class="example">  let php_noShortTags = 1</code>
<code class="example"></code>
要高亮外层 ] 或 ) 的错误: 
<code class="example"></code>
<code class="example">  let php_parent_error_close = 1</code>
<code class="example"></code>
要在有打开的 ( 和 [ 但没有相应的结束符号的情况下跳过 php 结束标签: 
<code class="example"></code>
<code class="example">  let php_parent_error_open = 1</code>
<code class="example"></code>
打开类和函数的折叠: 
<code class="example"></code>
<code class="example">  let php_folding = 1</code>
<code class="example"></code>
选择同步方法: 
<code class="example"></code>
<code class="example">  let php_sync_method = x</code>
<code class="example"></code>
x = -1 使得同步以搜索方法进行 (缺省)，
x &gt; 0 使得同步至少往回 x 行，
x = 0 使得同步从头开始。


PLAINTEX                                <b class="vimtag"> <a name="plaintex.vim">plaintex.vim</a> </b> <b class="vimtag"> <a name="ft-plaintex-syntax">ft-plaintex-syntax</a> </b>

TeX 是排版语言，而 plaintex 是代表 Tex 的 "平凡" 变种的文件类型。如果你想
*.tex 文件被识别为平凡 TeX，见  <a href="filetype.html#ft-tex-plugin">ft-tex-plugin</a> 。

此语法文件有以下选项 
<code class="example"></code>
<code class="example">        let g:plaintex_delimiters = 1</code>
<code class="example"></code>
如果你想高亮方括号 "[]" 和大括号 "<code class="special">{}</code>" 的话。


PPWIZARD                                        <b class="vimtag"> <a name="ppwiz.vim">ppwiz.vim</a> </b> <b class="vimtag"> <a name="ft-ppwiz-syntax">ft-ppwiz-syntax</a> </b>

PPWizard 是 HTML 和 OS/2 INF 文件的预处理器。

该语法文件有如下选项:

- ppwiz_highlight_defs : 决定 PPWizard 定义的高亮模式。可能值是

  ppwiz_highlight_defs = 1 : PPWizard #define 语句保留其内容的色彩 (比如，
    PPWizard 的宏和变量)。

  ppwiz_highlight_defs = 2 : 预处理器 #define 和 #evaluate 语句使用单色显示，
    除了续行符以外。

  缺省 ppwiz_highlight_defs 的设置为 1。

- ppwiz_with_html : 如果该值为 1 (缺省)，高亮按本义出现的 HTML 代码；如果为
  0，把 HTML 代码当成普通的文本。


PHTML                                           <b class="vimtag"> <a name="phtml.vim">phtml.vim</a> </b> <b class="vimtag"> <a name="ft-phtml-syntax">ft-phtml-syntax</a> </b>

phtml 语法高亮有两个选项。

如果你喜欢字符串里的 SQL 语法高亮，使用: 
<code class="example"></code>
<code class="example">        :let phtml_sql_query = 1</code>
<code class="example"></code>
同步的 minlines 缺省为 100。如果你喜欢别的值，可以设置 "phtml_minlines" 为你所
希望的值。例如: 
<code class="example"></code>
<code class="example">        :let phtml_minlines = 200</code>
<code class="example"></code>
<code class="example"></code>
POSTSCRIPT                              <b class="vimtag"> <a name="postscr.vim">postscr.vim</a> </b> <b class="vimtag"> <a name="ft-postscr-syntax">ft-postscr-syntax</a> </b>

PostScript 的高亮有若干选项。

首先决定是 PostScript 语言的哪个版本要高亮。目前定义了三个语言版本。Level 1 是
原始和基础的版本，包括所有的 Level 2 发布之前的扩展。Level 2 是最常用的版本，
包括 Level 3 发布之前它自身的所有扩展。Level 3 是目前支持的最高版本。你可以
这样定义 postscr_level 变量，以选择需要高亮的 PostScript 的语言级别: 
<code class="example"></code>
<code class="example">        :let postscr_level=2</code>
<code class="example"></code>
如果该变量没有定义，缺省值为 2 (Level 2)，因为这是目前最常用的版本。

<code class="note">注意</code>: 不是所有的 PS 解释器都支持某一特定语言级别的所有语言特性。特别是，PS 文
件开头的 %!PS-Adobe-3.0 并 <code class="emphasis">不</code> 意味着使用的 PostScript 是 Level 3 的
PostScript！

如果你使用 Display PostScript，可以这样定义 postscr_display 变量来包含 Display
PS 语言特性的高亮: 
<code class="example"></code>
<code class="example">        :let postscr_display=1</code>
<code class="example"></code>
如果你使用 Ghostscript，可以这样定义 postscr_ghostscript 变量来包含
Ghostscript 特有的语言特性的高亮: 
<code class="example"></code>
<code class="example">        :let postscr_ghostscript=1</code>
<code class="example"></code>
PostScript 是一个很大的语言，有许多预定义的元素。尽管包含所有这些元素的高亮很
有用，在较慢的机器上这会使得 Vim 变慢。为了使得对机器更友善，缺省不给字体名和
字符编码高亮。如果你不是显式地打开它们，应该没有问题。如果你确实想看到它们的高
亮，可以设置下面之中的一个或两个变量: 
<code class="example"></code>
<code class="example">        :let postscr_fonts=1</code>
<code class="example">        :let postscr_encodings=1</code>
<code class="example"></code>
关于 and、or 和 not 的高亮有一个风格的选项。PostScript 里，这些操作符的函数取
决于它们操作数的类型 - 如果操作数都是布尔型，它们是逻辑操作符。如果是整数，它
们是二进制操作符。如果二进制和布尔型操作符高亮方式不同，它们可以用任何一种方式
高亮。缺省它们被作为逻辑操作符。如果这样定义 postscr_andornot_binary 变量，它
们可以用二进制操作符方式进行高亮: 
<code class="example"></code>
<code class="example">        :let postscr_andornot_binary=1</code>


                        <b class="vimtag"> <a name="ptcap.vim">ptcap.vim</a> </b> <b class="vimtag"> <a name="ft-printcap-syntax">ft-printcap-syntax</a> </b>
PRINTCAP 和 TERMCAP     <b class="vimtag"> <a name="ft-ptcap-syntax">ft-ptcap-syntax</a> </b> <b class="vimtag"> <a name="ft-termcap-syntax">ft-termcap-syntax</a> </b>

该语法文件适用于 printcap 和 termcap 数据库。

要使得 Vim 识别不匹配模式 "printcap" 或 "termcap" 的 printcap/termcap 文件，你
需要在  <a href="syntax.html#myfiletypefile">myfiletypefile</a>  文件里定义合适你的系统的附加的模式。对这些模式，你必须
设置变量 "b:ptcap_type" 为 "print" 或 "term"，然后设置 <a href="options.html#'filetype'">'filetype'</a> 选项为
ptcap。

比如，要使得 Vim 识别 /etc/termcaps/ 里的所有文件为 termcap 文件，加入下行: 
<code class="example"></code>
<code class="example">   :au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = "term" |</code>
<code class="example">                                       \ set filetype=ptcap</code>
<code class="example"></code>
如果你<code class="note">注意</code>到往回滚动时高亮有问题，但 <code class="keystroke">CTRL-L</code> 又可以修正的时候，尝试设置
"ptcap_minlines" 内部变量为一个大的数字: 
<code class="example"></code>
<code class="example">   :let ptcap_minlines = 50</code>
<code class="example"></code>
(缺省为 20 行。)


PROGRESS                                <b class="vimtag"> <a name="progress.vim">progress.vim</a> </b> <b class="vimtag"> <a name="ft-progress-syntax">ft-progress-syntax</a> </b>

匹配 "*.w" 的文件可以是 Progress 或者 cweb 的。如果自动识别对你无效，或者你从
来不编辑 cweb，在你的启动 vimrc 里加入: 
<code class="example">   :let filetype_w = "progress"</code>
这同样适用于可为汇编文件的 "*.i" 和可为 Pascal 文件的 "*.p"。如果你不使用汇编
和 Pascal，你可以这么用: 
<code class="example">   :let filetype_i = "progress"</code>
<code class="example">   :let filetype_p = "progress"</code>
<code class="example"></code>
<code class="example"></code>
PYTHON                                          <b class="vimtag"> <a name="python.vim">python.vim</a> </b> <b class="vimtag"> <a name="ft-python-syntax">ft-python-syntax</a> </b>

有六个选项可以控制 Python 的语法高亮。

关于高亮数值: 
<code class="example">        :let python_no_number_highlight = 1</code>
<code class="example"></code>
关于高亮内建函数: 
<code class="example">        :let python_no_builtin_highlight = 1</code>
<code class="example"></code>
关于高亮标准例外: 
<code class="example">        :let python_no_exception_highlight = 1</code>
<code class="example"></code>
关于高亮 doctest 和其中的代码: 
<code class="example">        :let python_no_doctest_highlight = 1</code>
或 
<code class="example">        :let python_no_doctest_code_highlight = 1</code>
第一个选项隐含第二个。

要高亮行尾的空白还有空格和制表的混合: 
<code class="example">        :let python_space_error_highlight = 1</code>
<code class="example"></code>
如果你想要所有可能的 Python 高亮: 
<code class="example">        :let python_highlight_all = 1</code>
这里的效果等同于置位 python_space_error_highlight 及复位其余选项。

如果使用 Python 2 或跨式代码 (同时兼容 Python 2 和 3)，可以强制使用支持 Python
2 直到 Python 3.5 的旧语法文件。 
<code class="example">        :let python_use_python2_syntax = 1</code>
此选项会排除所有 Python 3.6 或更新的版本的现代特性。

<code class="note">注意</code>: 对以上选项，只关心其存在于否，值并不重要，可以把上面的 1 换成任何值。

QUAKE                                           <b class="vimtag"> <a name="quake.vim">quake.vim</a> </b> <b class="vimtag"> <a name="ft-quake-syntax">ft-quake-syntax</a> </b>

Quake 语法定义应可用于多数基于某个 Quake 引擎的 FPS (First Person Shooter)。不
过，在相关的三个游戏 (Quake、Quake 2 和 Quake 3 Arena) 中，命令的名字略有不
同。所以，语法定义检查三个全局变量是否存在，从而使用户可以指定他们的文件里哪些
命令是合法的。这三个变量的设置有如下效果。

设置使得高亮命令只适用于 Quake: 
<code class="example">        :let quake_is_quake1 = 1</code>
<code class="example"></code>
设置使得高亮命令只适用于 Quake 2: 
<code class="example">        :let quake_is_quake2 = 1</code>
<code class="example"></code>
设置使得高亮命令只适用于 Quake 3 Arena: 
<code class="example">        :let quake_is_quake3 = 1</code>
<code class="example"></code>
组合这三个变量的使用也是可以的，不过高亮的命令也许比你的游戏里实际可用的命令要
多。


R                                                       <b class="vimtag"> <a name="r.vim">r.vim</a> </b> <b class="vimtag"> <a name="ft-r-syntax">ft-r-syntax</a> </b>

R 代码的语法高亮的解析从反向 40 行前开始，但在  <a href="starting.html#vimrc">vimrc</a>  里可设置不同的值。如: 
<code class="example">        let r_syntax_minlines = 60</code>
<code class="example"></code>
也可以关闭 ROxygen 的语法高亮: 
<code class="example">        let r_syntax_hl_roxygen = 0</code>
<code class="example"></code>
打开小括号、方括号和花括号括起的代码的折叠: 
<code class="example">        let r_syntax_folding = 1</code>
<code class="example"></code>
把所有后跟开括号的关键字作为函数来高亮: 
<code class="example">        let r_syntax_fun_pattern = 1</code>
<code class="example"></code>
<code class="example"></code>
R MARKDOWN                                      <b class="vimtag"> <a name="rmd.vim">rmd.vim</a> </b> <b class="vimtag"> <a name="ft-rmd-syntax">ft-rmd-syntax</a> </b>

要关闭 YAML 头部的语法高亮，在  <a href="starting.html#vimrc">vimrc</a>  加入: 
<code class="example">        let rmd_syn_hl_yaml = 0</code>
<code class="example"></code>
要关闭引用键的语法高亮: 
<code class="example">        let rmd_syn_hl_citations = 0</code>
<code class="example"></code>
要高亮 knitr 块头部的 R 代码: 
<code class="example">        let rmd_syn_hl_chunk = 1</code>
<code class="example"></code>
缺省，R 代码块使用 R 语言的规则进行高亮。如果要其它语言块正确的语法高亮，应把
它们加入  <code class="badlink">markdown_fenced_languages</code>  或  <code class="badlink">rmd_fenced_languages</code>  中。例如要正确
地同时高亮 R 和 Python，在  <a href="starting.html#vimrc">vimrc</a>  加入: 
<code class="example">        let rmd_fenced_languages = ['r', 'python']</code>
<code class="example"></code>
<code class="example"></code>
R RESTRUCTURED TEXT                             <b class="vimtag"> <a name="rrst.vim">rrst.vim</a> </b> <b class="vimtag"> <a name="ft-rrst-syntax">ft-rrst-syntax</a> </b>

要高亮 knitr 块头部的 R 代码，在  <a href="starting.html#vimrc">vimrc</a>  加入: 
<code class="example">        let rrst_syn_hl_chunk = 1</code>
<code class="example"></code>
<code class="example"></code>
READLINE                                <b class="vimtag"> <a name="readline.vim">readline.vim</a> </b> <b class="vimtag"> <a name="ft-readline-syntax">ft-readline-syntax</a> </b>

readline 库主要由 BASH 外壳使用，在已有的命令和选项的基础上，它又增加了不少。
要高亮这些附加的命令和选项，可以把这行加到你的  <a href="starting.html#vimrc">vimrc</a>  里，或者在载入使用
readline 语法的文件前，在命令行输入: 
<code class="example">        let readline_has_bash = 1</code>
<code class="example"></code>
这使得 BASH (2.05a 和其后的版本，也包括部分以前的) 增加的命令被高亮。


REGO                                            <b class="vimtag"> <a name="rego.vim">rego.vim</a> </b> <b class="vimtag"> <a name="ft-rego-syntax">ft-rego-syntax</a> </b>

Rego 是 Styra 开发的查询语言。主要用作 kubernetes 的政策语言，但可用于几乎任何
功能。带以下扩展名的文件被认为是 rego 文件: .rego。


RESTRUCTURED TEXT                       <b class="vimtag"> <a name="rst.vim">rst.vim</a> </b> <b class="vimtag"> <a name="ft-rst-syntax">ft-rst-syntax</a> </b>

对一些特定的文件类型，打开文档内代码块的语法高亮。缺省的语法列表见
$VIMRUNTIME/syntax/rst.vim。

要设置用户定义的代码块语法高亮的列表: 
<code class="example">        let rst_syntax_code_list = ['vim', 'lisp', ...]</code>
<code class="example"></code>
要把多个代码块类型赋给同一个语法，定义  <code class="badlink">rst_syntax_code_list</code>  为如下映射: 
<code class="example">        let rst_syntax_code_list = {</code>
<code class="example">                \ 'cpp': ['cpp', 'c++'],</code>
<code class="example">                \ 'bash': ['bash', 'sh'],</code>
<code class="example">                ...</code>
<code class="example">        \ }</code>
<code class="example"></code>
要使用色彩高亮来强调文本: 
<code class="example">        let rst_use_emphasis_colors = 1</code>
<code class="example"></code>
要打开段的折叠: 
<code class="example">        let rst_fold_enabled = 1</code>
<code class="example"></code>
<code class="note">备注</code> 某些平台上折叠可能造成性能问题。


REXX                                            <b class="vimtag"> <a name="rexx.vim">rexx.vim</a> </b> <b class="vimtag"> <a name="ft-rexx-syntax">ft-rexx-syntax</a> </b>

如果你<code class="note">注意</code>到往回滚动时，高亮出现问题，但 <code class="keystroke">CTRL-L</code> 重画又可以修正的话，尝试设置
"rexx_minlines" 内部变量为较大的值: 
<code class="example">        :let rexx_minlines = 50</code>
这使得语法同步在第一个显示行之前的 50 行开始。缺省值为 10。使用较大的值的缺点
是重画会变慢。

Vim 试图自己猜测 ".r" 文件的真实类型。如果无法检测 (根据注释行内容)，假定为
"r"。要使缺省为 rexx，给 .vimrc 文件加上:  <b class="vimtag"> <a name="g:filetype_r">g:filetype_r</a> </b>

<code class="example">        :let g:filetype_r = "r"</code>
<code class="example"></code>
<code class="example"></code>
RUBY                                            <b class="vimtag"> <a name="ruby.vim">ruby.vim</a> </b> <b class="vimtag"> <a name="ft-ruby-syntax">ft-ruby-syntax</a> </b>

    Ruby: 操作符高亮                     <a href="syntax.html#ruby_operators">ruby_operators</a> 
    Ruby: 空白错误                       <a href="syntax.html#ruby_space_errors">ruby_space_errors</a> 
    Ruby: 折叠                           <a href="syntax.html#ruby_fold">ruby_fold</a>   <a href="syntax.html#ruby_foldable_groups">ruby_foldable_groups</a> 
    Ruby: 减少昂贵操作                   <a href="syntax.html#ruby_no_expensive">ruby_no_expensive</a>   <a href="syntax.html#ruby_minlines">ruby_minlines</a> 
    Ruby: 拼写检查字符串                 <a href="syntax.html#ruby_spellcheck_strings">ruby_spellcheck_strings</a> 

                                                <b class="vimtag"> <a name="ruby_operators">ruby_operators</a> </b>
<code class="section"> Ruby: 操作符高亮 </code>

可通过定义 "ruby_operators" 来高亮操作符: 
<code class="example"></code>
<code class="example">        :let ruby_operators = 1</code>

                                                <b class="vimtag"> <a name="ruby_space_errors">ruby_space_errors</a> </b>
<code class="section"> Ruby: 空白错误 </code>

可以通过定义 "ruby_space_errors" 打开空白错误的高亮: 
<code class="example"></code>
<code class="example">        :let ruby_space_errors = 1</code>

会高亮行尾的空白，而空格后的制表也被认为是错误。通过定义
"ruby_no_trail_space_error" 和 "ruby_no_tab_space_error"，可以进一步限定。这两
个变量分别忽略行尾空白和空格之后的制表。

                                        <b class="vimtag"> <a name="ruby_fold">ruby_fold</a> </b> <b class="vimtag"> <a name="ruby_foldable_groups">ruby_foldable_groups</a> </b>
<code class="section"> Ruby: 折叠 </code>

定义 "ruby_fold" 可以打开折叠: 
<code class="example"></code>
<code class="example">        :let ruby_fold = 1</code>

会把局部于当前缓冲区或窗口的 <a href="options.html#'foldmethod'">'foldmethod'</a> 选项设为 "syntax"，它打开 Ruby 文件
类型编辑时的基于语法的折叠。

缺省折叠相当详细，例如，"if"、"do"、"%w[]" 那样的小的语法单元会创建对应的折叠
层次。

可以设置 "ruby_foldable_groups" 来限制可折叠的组: 
<code class="example"></code>
<code class="example">        :let ruby_foldable_groups = 'if case %'</code>

可选值为空格分隔的关键字列表:

<code class="section">    关键字       含义 </code>
<code class="section">    --------  ------------------------------------- </code>
    ALL        绝大多数的块语法 (缺省)
    NONE       无
    if         "if" 或 "unless" 块
    def        "def" 块
    class      "class" 块
    module     "module" 块
    do         "do" 块
    begin      "begin" 块
    case       "case" 块
    for        "for"、"while"、"until" 循环
    {          花括号块或哈希字面值
    [          数组字面值
    %          "%" 记号的字面值，如: %w(STRING)、%!STRING!
    /          正则表达式
    string     字符串和外壳命令输出 (被 '、"、` 包围)
    :          符号
    #          多行注释
    &lt;&lt;         Here 文档
    __END__    "__END__" 指令之后的源代码

                                                <b class="vimtag"> <a name="ruby_no_expensive">ruby_no_expensive</a> </b>
<code class="section"> Ruby: 减少昂贵操作 </code>

缺省，"end" 关键字根据它关闭的块对应的打开语句设定颜色。尽管很有用，该特性很消
耗资源: 如果你发现重画变慢 (或者你所在的终端色彩支持不好)，你可能想关闭该特
性，只要定义 "ruby_no_expensive" 变量即可: 
<code class="example"></code>
<code class="example">        :let ruby_no_expensive = 1</code>

此时，所有的控制关键字使用相同的颜色。

                                                <b class="vimtag"> <a name="ruby_minlines">ruby_minlines</a> </b>

如果你想使用该特性，但<code class="note">注意</code>到往回滚动时，高亮出现问题，但 <code class="keystroke">CTRL-L</code> 重画又可以修正
的话，尝试设置 "ruby_minlines" 变量超过 50: 
<code class="example"></code>
<code class="example">        :let ruby_minlines = 100</code>

理想的话，该值应该足够大，使得最大的类或模块能够得到处理。

                                                <b class="vimtag"> <a name="ruby_spellcheck_strings">ruby_spellcheck_strings</a> </b>
<code class="section"> Ruby: 拼写检查字符串 </code>

定义 "ruby_spellcheck_strings" 可以用 Ruby 语法来执行字符串的拼写检查: 
<code class="example"></code>
<code class="example">        :let ruby_spellcheck_strings = 1</code>


SCHEME                                          <b class="vimtag"> <a name="scheme.vim">scheme.vim</a> </b> <b class="vimtag"> <a name="ft-scheme-syntax">ft-scheme-syntax</a> </b>

缺省只高亮 R7RS 关键字并进行适当的缩进。

scheme.vim 也支持 Chicken Scheme-&gt;C compiler 的扩展。如果需要，定义
b:is_chicken 或 g:is_chicken。


SDL                                             <b class="vimtag"> <a name="sdl.vim">sdl.vim</a> </b> <b class="vimtag"> <a name="ft-sdl-syntax">ft-sdl-syntax</a> </b>

SDL 的高亮可能会缺少一些关键字，但 SDL 的关键字太多了，完全照顾过来是不太可能
的。

新的标准 SDL-2000 指定所有的标识符都是大小写敏感的 (以前并非如此)，而所有使用
的关键字必须或者是完全小写，或者完全大写。要使得高亮能够反映这些特性，你可以设
置如下的变量: 
<code class="example">        :let sdl_2000=1</code>
<code class="example"></code>
这也会设置很多新的关键字。如果你想屏蔽旧的关键字 (其实，这是个好主意)，可以
用: 
<code class="example">        :let SDL_no_96=1</code>
<code class="example"></code>
缩进可能还没完全处理好，不过我在自己的项目目前的应用里已经相当满意了。


SED                                             <b class="vimtag"> <a name="sed.vim">sed.vim</a> </b> <b class="vimtag"> <a name="ft-sed-syntax">ft-sed-syntax</a> </b>

要使得制表在普通的空白里突出显示 (方法是在制表上使用 Todo 高亮)，在 vimrc 文件
里如此定义 "g:sed_highlight_tabs" 
<code class="example"></code>
<code class="example">        :let g:sed_highlight_tabs = 1</code>
<code class="example"></code>
(这种特殊高亮只适用于搜索模式、替换文本、地址或者 Append/Change/Insert
命令里包含的文本中的制表。) 如果你打开该选项，那么最好把制表宽度设为一个字符；
这么做，你很容易计算字符串里的制表数量。

GNU sed 允许注释出现在同一行的文本之后。BSD sed 只允许注释出现在首字符为 "#"
的行。要强制 BSD-风格的注释，即把出现行尾的注释视为错误，可用: 
<code class="example"></code>
<code class="example">        :let g:sed_dialect = "bsd"</code>
<code class="example"></code>
<code class="note">注意</code> GNU sed 和 BSD sed 有其它区别，(还) 未受此设置影响。

漏洞:

  transform 命令 (y) 和 substitute 命令的处理相同。也就是说，就语法文件而言，
  transform 和 substitute 接受相同的标志。这不正确 (Transform 不接受标志)。但
  我容忍这个问题，因为牵涉的命令需要很复杂的处理 (95 个模式，每个可能的模式定
  界符就需要一个模式)。


SGML                                            <b class="vimtag"> <a name="sgml.vim">sgml.vim</a> </b> <b class="vimtag"> <a name="ft-sgml-syntax">ft-sgml-syntax</a> </b>

SGML 文件里，标签的色彩方案工作方式如下。

开放标签的 <code class="special">&lt;&gt;</code> 和关闭标签的 &lt;/&gt; 的色彩不同。这是有意的。开放标签使用 'Function'
色彩，而关闭标签使用 'Type' 色彩 (见 syntax.vim 察看它们是怎么定义的)。

已知的标签名和 C 语句的色彩相同。未知的标签名和相应的 <code class="special">&lt;&gt;</code> 或 &lt;/&gt; 颜色相同，以便
纠错。

<code class="note">注意</code> 这也适用于参数 (或属性) 的名字。已知的属性名和未知的标色不同。

一些 SGML 标签用于改变文本的显示。sgml.vim 语法色彩文件识别以下的标签，并相应
地改变普通文本的显示方式: <code class="special">&lt;varname&gt;</code> <code class="special">&lt;emphasis&gt;</code> <code class="special">&lt;command&gt;</code> <code class="special">&lt;function&gt;</code> <code class="special">&lt;literal&gt;</code>
<code class="special">&lt;replaceable&gt;</code> <code class="special">&lt;ulink&gt;</code> 和 <code class="special">&lt;link&gt;</code>。

如果你想改变文本显示的方式，必须重定义以下的语法组:

    - sgmlBold
    - sgmlBoldItalic
    - sgmlUnderline
    - sgmlItalic
    - sgmlLink 设定链接

要使得重定义能够工作，你必须重定义所有的组。在你的 vimrc (这是根据初始化时读入
文件的顺序) 里定义下面的变量 
<code class="example">        :let sgml_my_rendering=1</code>
<code class="example"></code>
在你的 vimrc 文件里加上这行，可以屏蔽这种显示方式: 
<code class="example">        :let sgml_no_rendering=1</code>
<code class="example"></code>
(从 Claudio Fleiner &lt;claudio@fleiner.com&gt; 的 html.vim 的帮助文本转来)


                <b class="vimtag"> <a name="ft-posix-syntax">ft-posix-syntax</a> </b> <b class="vimtag"> <a name="ft-dash-syntax">ft-dash-syntax</a> </b>
SH              <b class="vimtag"> <a name="sh.vim">sh.vim</a> </b>  <b class="vimtag"> <a name="ft-sh-syntax">ft-sh-syntax</a> </b>  <b class="vimtag"> <a name="ft-bash-syntax">ft-bash-syntax</a> </b>  <b class="vimtag"> <a name="ft-ksh-syntax">ft-ksh-syntax</a> </b>

这里讨论较古老的 Unix (Bourne) sh 和较新的外壳如 bash、dash、posix 和 Korn
shell 的语法高亮。

Vim 试图根据文件名决定使用的外壳类型，例如: 
<code class="example"></code>
<code class="example">    ksh : .kshrc* *.ksh</code>
<code class="example">    bash: .bashrc* bashrc bash.bashrc .bash_profile* *.bash</code>

关于模式的完整列表，见 $VIMRUNTIME/filetype.vim。如果这些都不符，那么就检查文
件的第一行 (比如寻找 /bin/sh  /bin/ksh /bin/bash)。如果第一行指定了外壳类型，
那么就使用该类型。不过有的文件 (比如 .profile) 肯定是外壳文件，但其类型并不容
易推出。另外，有的系统里 sh 被符号链接到 "bash" (linux、Windows+cygwin) 或
"ksh" (posix)。

你可以在 &lt;.vimrc&gt; 里设置下列变量中的一个，以指定全局的缺省值:

    ksh: 
<code class="example">        let g:is_kornshell = 1</code>
    posix: (和设置 g:is_kornshell 为 1 效果几乎相同) 
<code class="example">        let g:is_posix     = 1</code>
    bash: 
<code class="example">        let g:is_bash      = 1</code>
    sh: (缺省) Bourne shell 
<code class="example">        let g:is_sh        = 1</code>
<code class="example"></code>
    (dash 用户应使用 posix)

如果没有 "#! ..." 一行，而用户也没有用上述方法设定缺省的 sh.vim 语法设置，那么
syntax/sh.vim 假定使用 Bourne shell 语法。请不要在错误报告里引用 RFC 或者市场
占有率的统计数据 (<code class="vim">译者注</code>: 此处大概指希望使用其它缺省值的用户) -- 自己选择系统
使用的缺省 sh 版本并在 &lt;.vimrc&gt; 文件里安装相应的 "let..." 就可以了。

syntax/sh.vim 文件提供若干级别的基于语法的折叠: 
<code class="example"></code>
<code class="example">        let g:sh_fold_enabled= 0     (缺省，无语法高亮)</code>
<code class="example">        let g:sh_fold_enabled= 1     (打开函数折叠)</code>
<code class="example">        let g:sh_fold_enabled= 2     (打开 here 文档折叠)</code>
<code class="example">        let g:sh_fold_enabled= 4     (打开 if/do/for 折叠)</code>

那么若干语法项目 (即 Here 文档和函数体) 就可以进行语法折叠 (见  <a href="syntax.html#:syn-fold">:syn-fold</a> )。
把这些值加在一起可以得到多种项目的折叠: 
<code class="example"></code>
<code class="example">        let g:sh_fold_enabled= 3     (打开函数和 here 文档的折叠)</code>
<code class="example"></code>
如果你<code class="note">注意</code>到往回滚动时，高亮出现问题，但 <code class="keystroke">CTRL-L</code> 重画又可以修正的话，尝试设置
"sh_minlines" 内部变量为较大的值: 
<code class="example">        :let sh_minlines = 500</code>
这使得语法同步在第一个显示行之前的 500 行开始。缺省值为 200。使用较大的值的缺
点是重画会变慢。

如果你没有要同步的东西，但显示又很慢，可以设置 "sh_maxlines" 内部变量来加速。
比如: 
<code class="example"></code>
<code class="example">        let sh_maxlines = 100</code>

缺省值是 sh_minlines 的两倍。设置为较小的值可以提高显示的速度。缺点是高亮错误
出现的可能性也较大。

syntax/sh.vim 试图标记若干问题为错误；包括常见没有匹配的 ']'、<code class="badlink">'done'</code>、<code class="badlink">'fi'</code> 等
情况。如果发现错误处理对你有问题，可以在 .vimrc 里这样屏蔽错误高亮: 
<code class="example"></code>
<code class="example">        let g:sh_no_error= 1</code>


                                                <b class="vimtag"> <a name="sh-embed">sh-embed</a> </b>  <b class="vimtag"> <a name="sh-awk">sh-awk</a> </b>
<code class="section"> Sh: 内 嵌 语 言</code>

你也许想要在 sh 里内嵌其他语言。多谢 Lorance Stinson 提供了一个 awk 的例子。
把下面内容写入 $HOME/.vim/after/syntax/sh/awkembed.vim: 
<code class="example"></code>
<code class="example">    " AWK Embedding:</code>
<code class="example">    " ==============</code>
<code class="example">    " Shamelessly ripped from aspperl.vim by Aaron Hope.</code>
<code class="example">    if exists("b:current_syntax")</code>
<code class="example">      unlet b:current_syntax</code>
<code class="example">    endif</code>
<code class="example">    syn include @AWKScript syntax/awk.vim</code>
<code class="example">    syn region AWKScriptCode matchgroup=AWKCommand start=+[=\\]\@&lt;!'+ skip=+\\'+ end=+'+ contains=@AWKScript contained</code>
<code class="example">    syn region AWKScriptEmbedded matchgroup=AWKCommand start=+\&lt;awk\&gt;+ skip=+\\$+ end=+[=\\]\@&lt;!'+me=e-1 contains=@shIdList,@shExprList2 nextgroup=AWKScriptCode</code>
<code class="example">    syn cluster shCommandSubList add=AWKScriptEmbedded</code>
<code class="example">    hi def link AWKCommand Type</code>

此代码会接受如下单引号括起的 awk 代码: 
<code class="example">        awk '...awk code here...'</code>
使之采用 awk 高亮语法。显然此方法可以类似地扩展到其他语言上。


SPEEDUP                                         <b class="vimtag"> <a name="spup.vim">spup.vim</a> </b> <b class="vimtag"> <a name="ft-spup-syntax">ft-spup-syntax</a> </b>
(AspenTech plant simulator)

Speedup 语法文件有如下选项:

- strict_subsections : 如果定义该变量，只有段 (section) 和子段 (subsection) 里
  的关键字会作为 Statement 高亮，而其它关键字不会 (比如 OPERATION 段里的
  WITHIN)。

- highlight_types : 该变量的定义使得流类型 (stream type)，比如 temperature 或
  pressure，用 Type 高亮，而不是普通的 Identifier。这里包括 DECLARE 段常见的类
  型；如果定义了自己的类型，要在语法文件里自己加入。

- oneline_comments : 该值可选 1 到 3，它决定了 # 风格的注释的高亮方式。

  oneline_comments = 1 : 允许偶数个 # 之后的正常 Speedup 代码。

  oneline_comments = 2 : 第二个 # 开始的代码显示为出错。这是缺省设置。

  oneline_comments = 3 : 如果某行包含超过一个 #，把整行显示为出错。

特别因为 OPERATION 段因为 PRESET (预设) 的变量而可能会很大，同步的正确设置很重
要。如果你的机器足够快，你可以在语法文件的末尾增加 minlines 和/或 maxlines 的
值。


SQL                                             <b class="vimtag"> <a name="sql.vim">sql.vim</a> </b> <b class="vimtag"> <a name="ft-sql-syntax">ft-sql-syntax</a> </b>
                                <b class="vimtag"> <a name="sqlinformix.vim">sqlinformix.vim</a> </b> <b class="vimtag"> <a name="ft-sqlinformix-syntax">ft-sqlinformix-syntax</a> </b>
                                <b class="vimtag"> <a name="sqlanywhere.vim">sqlanywhere.vim</a> </b> <b class="vimtag"> <a name="ft-sqlanywhere-syntax">ft-sqlanywhere-syntax</a> </b>

尽管有 ANSI 的 SQL 标准，多数数据库引擎都增加了自己的扩展。Vim 目前支持 Oracle
和 Informix 的 SQL 方言。Vim 缺省假设 "*.sql" 文件使用 Oracle SQL。

Vim 目前通过不同语法脚本提供不同供应商的 SQL 支持。你可以把 Vim 的缺省设置从
Oracle 改为任何目前支持的 SQL 类型。你也可以方便地为每个缓冲区设置不同的 SQL
方言。

详细的操作可见  <a href="ft_sql.html#ft_sql.txt">ft_sql.txt</a> 。


SQUIRREL                                <b class="vimtag"> <a name="squirrel.vim">squirrel.vim</a> </b> <b class="vimtag"> <a name="ft-squirrel-syntax">ft-squirrel-syntax</a> </b>

Squirrel 是高级指令式面向对象程序语言，设计目标是轻量级的脚本语言，满足视频游
戏之类应用的大小、内存带宽和实时的需求。以下扩展名的文件识别为 squirrel 文件:
.nut。


TCSH                                            <b class="vimtag"> <a name="tcsh.vim">tcsh.vim</a> </b> <b class="vimtag"> <a name="ft-tcsh-syntax">ft-tcsh-syntax</a> </b>

这里讨论名为 "tcsh" 的外壳。这是 csh 的超集。关于如何检测文件类型，见
 <a href="syntax.html#csh.vim">csh.vim</a> 。

Tcsh 不允许字符串里的 \"，除非设置了 "backslash_quote" 外壳变量。如果你希望
VIM 认定不应该存在反斜杠 + 引号的构造，在 .vimrc 里加入这行: 
<code class="example"></code>
<code class="example">        :let tcsh_backslash_quote = 0</code>
<code class="example"></code>
如果你<code class="note">注意</code>到往回滚动时，高亮出现问题，但 <code class="keystroke">CTRL-L</code> 重画又可以修正的话，尝试设置
"tcsh_minlines" 内部变量为较大的值: 
<code class="example">        :let tcsh_minlines = 1000</code>
这使得语法同步在第一个显示行之前的 1000 行开始。如果设置 "tcsh_minlines" 为
"fromstart"，同步从文件开始处进行。tcsh_minlines 的缺省值为 100。使用较大的值
的缺点是重画会变慢。


TEX                             <b class="vimtag"> <a name="tex.vim">tex.vim</a> </b> <b class="vimtag"> <a name="ft-tex-syntax">ft-tex-syntax</a> </b> <b class="vimtag"> <a name="latex-syntax">latex-syntax</a> </b>
                                <b class="vimtag"> <a name="syntax-tex">syntax-tex</a> </b> <b class="vimtag"> <a name="syntax-latex">syntax-latex</a> </b>

<code class="section">                        Tex 内容</code>
        Tex: 要语法折叠么？                              <a href="syntax.html#tex-folding">tex-folding</a> 
        Tex: 不想拼写检查                                <a href="syntax.html#g:tex_nospell">g:tex_nospell</a> 
        Tex: 不想检查注释里的拼写？                      <a href="syntax.html#tex-nospell">tex-nospell</a> 
        Tex: 需要在 Verbatim 区中使用拼写检查？          <a href="syntax.html#tex-verb">tex-verb</a> 
        Tex: 在注释还是数学模式里                        <a href="syntax.html#tex-runon">tex-runon</a> 
        Tex: 语法高亮很慢？                              <a href="syntax.html#tex-slow">tex-slow</a> 
        Tex: 想高亮更多的命令？                          <a href="syntax.html#tex-morecommands">tex-morecommands</a> 
        Tex: 过多的 Error 高亮？                         <a href="syntax.html#tex-error">tex-error</a> 
        Tex: 需要新的数学模式的组？                      <a href="syntax.html#tex-math">tex-math</a> 
        Tex: 开始新的风格？                              <a href="syntax.html#tex-style">tex-style</a> 
        Tex: 利用隐藏模式                                <a href="syntax.html#tex-conceal">tex-conceal</a> 
        Tex: 选择性的隐藏模式                            <a href="syntax.html#g:tex_conceal">g:tex_conceal</a> 
        Tex: 控制 iskeyword                              <a href="syntax.html#g:tex_isk">g:tex_isk</a> 
        Tex: 下标和上标的精细控制                        <a href="syntax.html#tex-supersub">tex-supersub</a> 
        Tex: 匹配检查控制                                <a href="syntax.html#tex-matchcheck">tex-matchcheck</a> 

                                <b class="vimtag"> <a name="tex-folding">tex-folding</a> </b> <b class="vimtag"> <a name="g:tex_fold_enabled">g:tex_fold_enabled</a> </b>
<code class="section"> Tex: 要语法折叠么？ </code>

&lt;syntax/tex.vim&gt; 的版本 28 支持基于语法的 part、chapter、section、subsection
等等的折叠。把 
<code class="example">        let g:tex_fold_enabled=1</code>
放到你的 &lt;.vimrc&gt; 里，并 :set fdm=syntax。我建议把后者放到你的 LaTeX 文件末尾
的模式行里来执行: 
<code class="example">        % vim: fdm=syntax</code>
如果系统过慢，可以看看 
<code class="example">        https://vimhelp.org/vim_faq.txt.html#faq-29.7</code>

                                                <b class="vimtag"> <a name="g:tex_nospell">g:tex_nospell</a> </b>
<code class="section"> Tex: 不想拼写检查</code>

如果不想 LaTeX 文档在任何地方检查拼写，在 .vimrc 里加入 
<code class="example">        let g:tex_nospell=1</code>
如果只想关闭注释中的拼写检查，见  <a href="syntax.html#g:tex_comment_nospell">g:tex_comment_nospell</a> 。

                                <b class="vimtag"> <a name="tex-nospell">tex-nospell</a> </b> <b class="vimtag"> <a name="g:tex_comment_nospell">g:tex_comment_nospell</a> </b>
<code class="section"> Tex: 不想检查注释里的拼写？ </code>

有些家伙喜欢在注释里写源代码，所以希望在 LaTeX 文件的注释里关闭拼写检查。为
此，在 &lt;.vimrc&gt; 里放上: 
<code class="example">      let g:tex_comment_nospell= 1</code>
如果你要关闭 LaTeX 文档中所有地方的拼写检查，见  <a href="syntax.html#g:tex_nospell">g:tex_nospell</a> 。

                                <b class="vimtag"> <a name="tex-verb">tex-verb</a> </b> <b class="vimtag"> <a name="g:tex_verbspell">g:tex_verbspell</a> </b>
<code class="section"> Tex: 需要在 Verbatim 区中使用拼写检查？</code>

通常 verbatim 区域用于源代码这类的东西；很少有人想对源代码进行拼写检查。如果你
真的想要对 verbatim 区进行拼写检查，在 &lt;.vimrc&gt; 里放入: 
<code class="example">        let g:tex_verbspell= 1</code>

                                        <b class="vimtag"> <a name="tex-runon">tex-runon</a> </b> <b class="vimtag"> <a name="tex-stopzone">tex-stopzone</a> </b>
<code class="section"> Tex: 在注释还是数学模式里？</code>

&lt;syntax/tex.vim&gt; 高亮支持 TeX、LaTeX 和部分的 AmsTeX。高亮支持包括三个主要的区
域: normal、texZone 和 texMathZone。尽管付出了相当的努力使得这些区域能正确地
终止，$..$ 和$$..$$ 定界的区域无法同步，因为开始和结束模式无法区别。因而，提供
了一个特殊的 "TeX 注释" 
<code class="example">        %stopzone</code>
它会使得 texZone 或 texMathZone 强迫终止。

                                        <b class="vimtag"> <a name="tex-slow">tex-slow</a> </b> <b class="vimtag"> <a name="tex-sync">tex-sync</a> </b>
<code class="section"> Tex: 语法高亮很慢？</code>

如果你使用机器速度很慢，可能会想减小这些变量的值 
<code class="example">        :syn sync maxlines=200</code>
<code class="example">        :syn sync minlines=50</code>
(特别是后者)。如果你的机器很快，可以考虑增大它们的值。它们主要影响同步 (确切地
说也就是: 如果有的话，哪个语法组包含屏幕顶部的文本？)。

另外一个高亮缓慢的原因是基于语法的折叠；解决办法见  <a href="syntax.html#tex-folding">tex-folding</a> 。

                                        <b class="vimtag"> <a name="g:tex_fast">g:tex_fast</a> </b>

最后，如果语法高亮还是太慢，可以在 .vimrc 里设置

        :let g:tex_fast= ""

g:tex_fast 变量使得语法高亮脚本避免定义任何语法区域和相关的同步。这使得语法高
亮速度大大加快；作为代价: 高亮和基于语法的折叠会少很多，也不能进行基于语法的错
误检查。

可以选择接受若干而非全部的语法项目；用下表可以选择性地打开部分语法高亮: 
<code class="example"></code>
<code class="example">    b : 接受粗体和斜体语法</code>
<code class="example">    c : 接受 texComment 语法</code>
<code class="example">    m : 接受 texMatcher 语法 (即 {...} 和 [...])</code>
<code class="example">    M : 接受 texMath 语法</code>
<code class="example">    p : 接受 部分、章节、小节等的语法</code>
<code class="example">    r : 接受 texRefZone 语法 (nocite、bibliography、label、pageref、eqref)</code>
<code class="example">    s : 接受 上标/下标区域</code>
<code class="example">    S : 接受 texStyle 语法</code>
<code class="example">    v : 接受 verbatim 语法</code>
<code class="example">    V : 接受 texNewEnv 和 texNewCmd 语法</code>

例如，g:tex_fast= "M" 会打开数学相关的高亮但关闭其他基于区域的语法高亮。
(另见:  <a href="syntax.html#g:tex_conceal">g:tex_conceal</a>  和  <a href="syntax.html#tex-supersub">tex-supersub</a> )

                                            <b class="vimtag"> <a name="tex-morecommands">tex-morecommands</a> </b> <b class="vimtag"> <a name="tex-package">tex-package</a> </b>
<code class="section"> Tex: 想高亮更多的命令？ </code>

LaTeX 是可编程的语言，因而有数以千计的包，包含各种专门的 LaTeX 命令、语法和字
体。如果你用了某个包，当然希望发布的 syntax/tex.vim 能支持它。但这显然是不实际
的。请考虑使用  <a href="syntax.html#mysyntaxfile-add">mysyntaxfile-add</a>  介绍的技术来扩展或者修改 syntax/tex.vim 提供
的高亮处理。任何你编写的扩展一般应放在 $HOME/after/syntax/tex/[pkgname].vim，
并请考虑上传到 <a href="http://vim.sf.net/">http://vim.sf.net/</a>。

在我的网站上有若干流行包的支持: 
<code class="example"></code>
<code class="example">        http://www.drchip.org/astronaut/vim/index.html#LATEXPKGS</code>

那里的语法文件可以放到你的 .../after/syntax/tex/ 目录。

                                        <b class="vimtag"> <a name="tex-error">tex-error</a> </b> <b class="vimtag"> <a name="g:tex_no_error">g:tex_no_error</a> </b>
<code class="section"> Tex: 过多的 Error 高亮？</code>

&lt;tex.vim&gt; 支持各种的词法检查。尽管错误检查经常很有用，它指示的地方实际上可能没
有错误。如果你有这个问题，可以在 &lt;.vimrc&gt; 里放上如下的语句: 
<code class="example">        let g:tex_no_error=1</code>
从而 &lt;tex.vim&gt; 提供的所有错误检查都会被抑制。

                                                                <b class="vimtag"> <a name="tex-math">tex-math</a> </b>
<code class="section"> Tex: 需要新的数学模式的组？</code>

如果你需要在 LaTeX 里包含新的数学组，下面的代码给出一个告诉你可以如何操作的例
子: 
<code class="example">        call TexNewMathZone(sfx,mathzone,starform)</code>
你需要为新数学组起一个独一无二的后缀 (目前，A-L 和 V-Z 被 &lt;syntax/tex.vim&gt; 自
己占用)。比如，看看 &lt;syntax/tex.vm&gt; 是怎么设置 eqnarray 的: 
<code class="example">        call TexNewMathZone("D","eqnarray",1)</code>
需要把 "mathzone" 换成新数学组的组名，然后在 .vim/after/syntax/tex.vim 里调
用。如果 "starform" 变量为真，意味着新数学组有星号的形式 (比如， eqnarray*)。

                                        <b class="vimtag"> <a name="tex-style">tex-style</a> </b> <b class="vimtag"> <a name="b:tex_stylish">b:tex_stylish</a> </b>
<code class="section"> Tex: 开始新的风格？</code>

你可以在 *.tex 文件里使用 "\makeatletter"，从而在命令里可用 "@"。不过，因为
*.tex 文件没有如下的后缀: sty cls clo dtx ltx，语法高亮会把这里使用的 @ 标为错
误。要解决这个问题: 
<code class="example"></code>
<code class="example">        :let b:tex_stylish = 1</code>
<code class="example">        :set ft=tex</code>
<code class="example"></code>
把 "let g:tex_stylish=1" 放到你的 &lt;.vimrc&gt; 里，这会使得 &lt;syntax/tex.vim&gt; 总能
接受 @ 的这种使用方式。

                                        <b class="vimtag"> <a name="tex-cchar">tex-cchar</a> </b> <b class="vimtag"> <a name="tex-cole">tex-cole</a> </b> <b class="vimtag"> <a name="tex-conceal">tex-conceal</a> </b>
<code class="section"> Tex: 利用隐藏模式</code>

如果你设置  <a href="options.html#'conceallevel'">'conceallevel'</a>  为 2 而编码是 utf-8，若干字符序列会翻译为合适的
utf-8 字形，包括各种重音字符、数学模式的希腊字母。数学模式的上标和下标。不是所
有的字符都可以转为上标和下标；这是由于 utf-8 支持的限制。事实上，只有很少的字
符支持下标。

一个用法是垂直分割窗口 (见  <a href="windows.html#CTRL-W_v">CTRL-W_v</a> )；其中一个把  <a href="options.html#'conceallevel'">'conceallevel'</a>  设为 0，另
一个设为 2；两者都用  <a href="options.html#'scrollbind'">'scrollbind'</a> 。

                                        <b class="vimtag"> <a name="g:tex_conceal">g:tex_conceal</a> </b>
<code class="section"> Tex: 选择性的隐藏模式</code>

通过在 &lt;.vimrc&gt; 中设置 g:tex_conceal，可以有选择性地使用隐藏模式。缺省的设置为
"admgs"，隐藏以下对应的字符集合: 
<code class="example"></code>
<code class="example">        a = 重音/连写体 (accents/ligatures)</code>
<code class="example">        b = 粗体和斜体</code>
<code class="example">        d = 定界符</code>
<code class="example">        m = 数学符号</code>
<code class="example">        g = 希腊字母</code>
<code class="example">        s = 上标/下标</code>

省略其中一个或几个字符关闭对应的使用隐藏字符进行替代的操作。

                                                <b class="vimtag"> <a name="g:tex_isk">g:tex_isk</a> </b> <b class="vimtag"> <a name="g:tex_stylish">g:tex_stylish</a> </b>
<code class="section"> Tex: 控制 iskeyword</code>

通常，LaTeX 关键字只支持 0-9, a-z, A-Z, 192-255。Latex 关键字不支持下划线，除
了 *.sty 文件以外。语法高亮脚本使用以下的逻辑:

        * 如果 g:tex_stylish 存在且为 1
                文件被作为 "sty" 文件对待，允许 "_" 成为关键字一的部分
                (独立于 g:tex_isk)
        * 否则如果文件名后缀是 sty、cls、clo、dtx 或 ltx
                文件被作为 "sty" 文件对待，允许 "_" 成为关键字一的部分
                (独立于 g:tex_isk)

        * 如果 g:tex_isk 存在，它被用作局部的 <a href="options.html#'iskeyword'">'iskeyword'</a>
        * 否则局部的 <a href="options.html#'iskeyword'">'iskeyword'</a> 设为 48-57,a-z,A-Z,192-255

                        <b class="vimtag"> <a name="tex-supersub">tex-supersub</a> </b> <b class="vimtag"> <a name="g:tex_superscripts">g:tex_superscripts</a> </b> <b class="vimtag"> <a name="g:tex_subscripts">g:tex_subscripts</a> </b>
<code class="section"> Tex: 下标和上标的精细控制</code>

        关于如何打开隐藏字符的替换，见  <a href="syntax.html#tex-conceal">tex-conceal</a> 。

        关于如何选择性的隐藏重音、粗体/斜体、数学、希腊文、和上标/下标，见
         <a href="syntax.html#g:tex_conceal">g:tex_conceal</a> 。

        可以更加精细地控制基于语法地隐藏哪些上标和下标 (见  <a href="syntax.html#:syn-cchar">:syn-cchar</a> )。因为
        不是所有的字体都支持所有字符，可以覆盖隐藏替换列表；缺省这些列表是这样
        给出的: 
<code class="example"></code>
<code class="example">            let g:tex_superscripts= "[0-9a-zA-W.,:;+-&lt;&gt;/()=]"</code>
<code class="example">            let g:tex_subscripts= "[0-9aehijklmnoprstuvx,+-/().]"</code>

        例如，我用 Luxi Mono Bold；它不支持下标字符 "hklmnpst"，所以我在
        ~/.vim/ftplugin/tex/tex.vim 里放上 
<code class="example">                let g:tex_subscripts= "[0-9aeijoruvx,+-/().]"</code>
        以防止出现不可理解的 utf8 字形。

                                        <b class="vimtag"> <a name="tex-matchcheck">tex-matchcheck</a> </b> <b class="vimtag"> <a name="g:tex_matchcheck">g:tex_matchcheck</a> </b>
<code class="section"> Tex: Match Check Control</code>

        有时我们可能实际需要不匹配的小括号，方括号和/或花括号；例如，
        \text{(1, 10]} 是一个从 1 (开) 到 10 (闭) 的范围。这种需要和提供界限符
        错误匹配检测的愿望当然有冲突。为了平衡这些冲突的目标，syntax/tex.vim
        提供了 
<code class="example">                g:tex_matchcheck = '[({[]'</code>
        此处显示其缺省的设置。如果要跳过 [] 和 () 错误匹配的检查，可用 
<code class="example">                let g:tex_matchcheck= '[{}]'</code>
        如果不想要粗体和斜体区域内的匹配， 
<code class="example">                let g:tex_excludematcher= 1</code>
        会在那些区域中排除 texMatcher 组。

TF                                              <b class="vimtag"> <a name="tf.vim">tf.vim</a> </b> <b class="vimtag"> <a name="ft-tf-syntax">ft-tf-syntax</a> </b>

tf 语法高亮有一个选项。

同步的 minlines 缺省为 100。如果你希望设为别的值，可以把 "tf_minlines" 设为你
希望的值。例如: 
<code class="example"></code>
<code class="example">        :let tf_minlines = 你的选择</code>

VIM                     <b class="vimtag"> <a name="vim.vim">vim.vim</a> </b>               <b class="vimtag"> <a name="ft-vim-syntax">ft-vim-syntax</a> </b>
                        <b class="vimtag"> <a name="g:vimsyn_minlines">g:vimsyn_minlines</a> </b>     <b class="vimtag"> <a name="g:vimsyn_maxlines">g:vimsyn_maxlines</a> </b>

准确的语法高亮和屏幕刷新速度需要一定的折衷。要提高准确性，你可能想增加
g:vimsyn_minlines 变量的值。而 g:vimsyn_maxlines 变量可以用来增加屏幕的刷新速
度 (详情可见  <a href="syntax.html#:syn-sync">:syn-sync</a> )。

        g:vimsyn_minlines : 用于设置同步的 minlines
        g:vimsyn_maxlines : 用于设置同步的 maxlines

        (g:vim_minlines 和 g:vim_maxlines 是这些选项过时的名字)

                                                <b class="vimtag"> <a name="g:vimsyn_embed">g:vimsyn_embed</a> </b>
g:vimsyn_embed 选项允许用户选择是否使用及使用何种类型的嵌入脚本高亮。 
<code class="example"></code>
<code class="example">   g:vimsyn_embed == 0   : 不支持任何内嵌脚本</code>
<code class="example">   g:vimsyn_embed =~ 'l' : 支持内嵌 lua</code>
<code class="example">   g:vimsyn_embed =~ 'm' : 支持内嵌 mzscheme</code>
<code class="example">   g:vimsyn_embed =~ 'p' : 支持内嵌 perl</code>
<code class="example">   g:vimsyn_embed =~ 'P' : 支持内嵌 python</code>
<code class="example">   g:vimsyn_embed =~ 'r' : 支持内嵌 ruby</code>
<code class="example">   g:vimsyn_embed =~ 't' : 支持内嵌 tcl</code>

g:vimsyn_embed 缺省是代表 vim 自身支持的解释器的字符串。连接多个字符以支持多个
内嵌解释器的类型；例如 g:vimsyn_embed= "mp" 支持内嵌的 mzscheme 和内嵌 perl。
                                                <b class="vimtag"> <a name="g:vimsyn_folding">g:vimsyn_folding</a> </b>

syntax/vim.vim 现在支持一些折叠: 
<code class="example"></code>
<code class="example">   g:vimsyn_folding == 0 或不存在: 没有基于语法的折叠</code>
<code class="example">   g:vimsyn_folding =~ 'a' : 自动命令组</code>
<code class="example">   g:vimsyn_folding =~ 'f' : 折叠函数</code>
<code class="example">   g:vimsyn_folding =~ 'l' : 折叠 lua      脚本</code>
<code class="example">   g:vimsyn_folding =~ 'm' : 折叠 mzscheme 脚本</code>
<code class="example">   g:vimsyn_folding =~ 'p' : 折叠 perl     脚本</code>
<code class="example">   g:vimsyn_folding =~ 'P' : 折叠 python   脚本</code>
<code class="example">   g:vimsyn_folding =~ 'r' : 折叠 ruby     脚本</code>
<code class="example">   g:vimsyn_folding =~ 't' : 折叠 tcl      脚本</code>

                                                        <b class="vimtag"> <a name="g:vimsyn_noerror">g:vimsyn_noerror</a> </b>
syntax/vim.vim 给出的错误高亮未必都正确；Vim 脚本是一个要正确高亮难度很高的语
言。如果不想出现错误高亮，在你的  <a href="starting.html#vimrc">vimrc</a>  里放上: 
<code class="example"></code>
<code class="example">        let g:vimsyn_noerror = 1</code>
<code class="example"></code>
<code class="example"></code>
WDL                                                     <b class="vimtag"> <a name="wdl.vim">wdl.vim</a> </b> <b class="vimtag"> <a name="wdl-syntax">wdl-syntax</a> </b>

工作流描述语言是一种使用人类可读和可写的语法来指定数据处理的工作流的方法。多用
于生物信息学。规格详见: <a href="https://github.com/openwdl/wdl">https://github.com/openwdl/wdl</a>


XF86CONFIG                              <b class="vimtag"> <a name="xf86conf.vim">xf86conf.vim</a> </b> <b class="vimtag"> <a name="ft-xf86conf-syntax">ft-xf86conf-syntax</a> </b>

XFree86 v3.x 和 v4.x 版本里，XF86Config 文件的语法有所不同。两者都支持且有自动
检测，但离完善还很远。你可能仍然需要手动指定版本。根据你的 XFree86 的版本，在
.vimrc 里把 xf86conf_xfree86_version 变量设为 3 或 4。例如: 
<code class="example">        :let xf86conf_xfree86_version=3</code>
如果混合使用多种版本，设置 b:xf86conf_xfree86_version 变量。

<code class="note">注意</code> 不支持选项名的空格和下划线。如果你想高亮选项名，使用 "SyncOnGreen" 而不是
"__s yn con gr_e_e_n"。


XML                                             <b class="vimtag"> <a name="xml.vim">xml.vim</a> </b> <b class="vimtag"> <a name="ft-xml-syntax">ft-xml-syntax</a> </b>

缺省高亮 Xml 的命名空间。设置了下面的全局变量以后可以继承此设置: 
<code class="example"></code>
<code class="example">        :let g:xml_namespace_transparent=1</code>

                                                        <b class="vimtag"> <a name="xml-folding">xml-folding</a> </b>
xml 语法文件提供打开和关闭标签间的语法折叠  <a href="fold.html#folding">folding</a>  (见  <a href="syntax.html#:syn-fold">:syn-fold</a> )。这可以
用下面的代码打开 
<code class="example"></code>
<code class="example">        :let g:xml_syntax_folding = 1</code>
<code class="example">        :set foldmethod=syntax</code>

<code class="note">注意</code>: 语法折叠会显著地减慢语法高亮。大文件尤其如此。


X Pixmaps (XPM)                                 <b class="vimtag"> <a name="xpm.vim">xpm.vim</a> </b> <b class="vimtag"> <a name="ft-xpm-syntax">ft-xpm-syntax</a> </b>

xpm.vim 根据 XPM 文件的内容动态地建立语法项目。这样你就可以修改色彩规格字符
串。修改后，可用 ":set syn=xpm" 再次执行。

要复制带某颜色的像素，使用 "yl" 命令抽出 "像素" 然后在别的地方使用 "P" 插入。

你想用鼠标画图么？试试这些代码: 
<code class="example">   :function! GetPixel()</code>
<code class="example">   :   let c = getline(".")[col(".") - 1]</code>
<code class="example">   :   echo c</code>
<code class="example">   :   exe "noremap &lt;LeftMouse&gt; &lt;LeftMouse&gt;r" .. c</code>
<code class="example">   :   exe "noremap &lt;LeftDrag&gt;  &lt;LeftMouse&gt;r" .. c</code>
<code class="example">   :endfunction</code>
<code class="example">   :noremap &lt;RightMouse&gt; &lt;LeftMouse&gt;:call GetPixel()&lt;CR&gt;</code>
<code class="example">   :set guicursor=n:hor20          " 可以看到光标下的颜色</code>
这使得右键变成像素提取工具，而左键成为一支笔。该代码只可用于每个像素一个字符的
XPM 文件，而且你不能在像素字符串之外点击。不过，你自己可以尝试改进之。

如果使用大小减半的字体，看其来会舒服得多。比如，在 X 上: 
<code class="example">        :set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*</code>
<code class="example"></code>
<code class="example"></code>
YAML                                            <b class="vimtag"> <a name="yaml.vim">yaml.vim</a> </b> <b class="vimtag"> <a name="ft-yaml-syntax">ft-yaml-syntax</a> </b>

                                        <b class="vimtag"> <a name="g:yaml_schema">g:yaml_schema</a> </b> <b class="vimtag"> <a name="b:yaml_schema">b:yaml_schema</a> </b>
YAML 模型是一个标签集合和解析非特定标签的机制的组合。对用户来说，这意味着取决
于简单向量内容，YAML 分析器可把简单向量 (实际可以只是字符串而没有其它) 当作其
它类型的值: null、布尔型、浮点数、整数。 <a href="syntax.html#g:yaml_schema">g:yaml_schema</a>  选择决定根据什么模型来
对值进行特殊高亮。支持的模型为

<code class="section">模型            描述 </code>
failsafe        没有额外高亮。
json            支持 JSON 风格的数值、布尔型和 null。
core            支持更多风格的数值、布尔型和 null。
pyyaml          除了 core 模型以外，还支持高亮时间戳，但和 core 模型识别的数值
                有些区别，也有很多 core 模型没有的附加的布尔值。

缺省的模型是  <code class="badlink">core</code> 。

<code class="note">注意</code> 模型实际不局限于简单的向量，但这是 YAML 规格定义的模型的唯一区别，也是语
法文件定义的唯一区别。


ZSH                                                 <b class="vimtag"> <a name="zsh.vim">zsh.vim</a> </b> <b class="vimtag"> <a name="ft-zsh-syntax">ft-zsh-syntax</a> </b>

zsh 的语法高亮脚本打开基于语法的折叠: 
<code class="example"></code>
<code class="example">        :let g:zsh_fold_enable = 1</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>6. 定义语法                                             <b class="vimtag"> <a name=":syn-define">:syn-define</a> </b> <b class="vimtag"> <a name="E410">E410</a> </b></h4>
Vim 理解三种语法项目的类型:

1. 关键字
   它只能包含由  <a href="syntax.html#:syn-iskeyword">:syn-iskeyword</a>  或 <a href="options.html#'iskeyword'">'iskeyword'</a> 选项定义的关键字字符，而且不能
   包含其它语法项目。它必须匹配完整的单词 (在匹配的前后不能有其它的关键字字
   符)。关键词 "if" 只在 "if(a=b)" 里匹配，而不在 "ifdef x" 里匹配。因为 "("
   不是关键字字符，但 "d" 是。

2. 匹配
   它匹配单个正则表达式模式。

3. 区域
   它始于 "start" 正则表达式模式的匹配，结束于 "end" 正则表达式模式的匹配。两
者之间可以包含任何文本。其中，"skip" 正则表达式模式可以用来避免 "end" 模式的匹
配。

若干语法*项目*可以放在一个语法*组*里。你可以为一个语法组设置高亮属性。例如，你
可以定义 "/* .. */" 注释为一个项目，"// .." 注释为另一个，并把两者都放在
"Comment" 组里。这时，你就可以设置 "Comment" 以粗体字体和蓝色出现。你可以自由
选择各种组合，比如为每个语法项目设置一个高亮组，乃至把所有项目都放到一个组。这
取决于你如何指定你的高亮属性。把每个项目放到单独的组里的后果是你需要为很多组指
定高亮属性。

<code class="note">注意</code> 语法组和高亮组类似。你为高亮组指定高亮属性，而这些属性会被用于同名的语法
组。

如果有多个项目在相同位置匹配，*最后*定义的那个胜出。这样，你可以覆盖较早定义的
匹配相同文本的语法项目。不过，关键字总是优先于匹配和区域，而匹配大小写的关键字
又优先于忽略大小写的关键字。


优 先 级                                                <b class="vimtag"> <a name=":syn-priority">:syn-priority</a> </b>

如果多个语法项目可以匹配，使用如下规则:

1. 如果多个匹配或区域项目在相同的位置开始，最后定义者优先。
2. 关键字比匹配和区域项目优先。
3. 从较早位置开始的项目优先于从较后位置开始的项目。


定 义 大 小 写 敏 感                                    <b class="vimtag"> <a name=":syn-case">:syn-case</a> </b> <b class="vimtag"> <a name="E390">E390</a> </b>

:sy[ntax] case [match | ignore]
        要求其后的 ":syntax" 命令在本设定为 "match" 时必须匹配大小写，本设定为
        "ignore" 时则可以忽略大小写。<code class="note">注意</code>，它不影响之前的项目，而只影响其后直
        到下一个 ":syntax case" 命令为止的所有项目。

:sy[ntax] case
        显示 "syntax case match" 或 "syntax case ignore" 之一。


定 义 折 叠 级 别                                       <b class="vimtag"> <a name=":syn-foldlevel">:syn-foldlevel</a> </b>

:sy[ntax] foldlevel start
:sy[ntax] foldlevel minimum
        定义使用 foldmethod=syntax 时，如何计算行的折叠级别 (见  <a href="fold.html#fold-syntax">fold-syntax</a> 
        和  <a href="syntax.html#:syn-fold">:syn-fold</a> ):

        start:          使用包含行开始处项目的级别。
        minimum:        使用行上所有项目的局部最小值级别的最小值。

        缺省是 "start"。使用 "minimum" 会水平搜索行所包含的后跟更高级别的级别
        的最小值。如果一行内水平不同的语法项目可能会关闭和打开，这会生成更自然
        的折叠。

:sy[ntax] foldlevel
        显示当前折叠级别的计算方法，"syntax foldlevel start" 或
        "syntax foldlevel minimum" 两者之一。

        <code class="notvi">{仅当 Vim 编译时带有  <a href="various.html#+folding">+folding</a>  特性才有意义}</code>


拼 写 检 查                                             <b class="vimtag"> <a name=":syn-spell">:syn-spell</a> </b>

:sy[ntax] spell toplevel
:sy[ntax] spell notoplevel
:sy[ntax] spell default
        定义不在任何语法项目里的文本在何处进行拼写检查:

        toplevel:       文本进行拼写检查。
        notoplevel:     文本不进行拼写检查。
        default:        如果有 @Spell 簇，不进行拼写检查。

        语法项目里的文本用 @Spell 和 @NoSpell 簇  <a href="spell.html#spell-syntax">spell-syntax</a> 。如果没有
        @Spell 和 @NoSpell 簇，那么 "default" 和 "toplevel" 进行拼写检查。

        要激活拼写检查，必须置位 <a href="options.html#'spell'">'spell'</a> 选项。

:sy[ntax] spell
        显示当前语法拼写检查方法，"syntax spell toplevel"、
        "syntax spell notoplevel" 或 "syntax spell default" 之一。


语 法 ISKEYWORD 设 置                                   <b class="vimtag"> <a name=":syn-iskeyword">:syn-iskeyword</a> </b>

:sy[ntax] iskeyword [clear | <code class="special">{option}</code>]
        定义关键字字符。类似于 <a href="options.html#'iskeyword'">'iskeyword'</a> 选项，但只适用于语法高亮。

        clear:          关闭语法特定的 iskeyword 设置，使用局部于缓冲区的
                        <a href="options.html#'iskeyword'">'iskeyword'</a> 设置。
        <code class="special">{option}</code>        设置语法的 <a href="options.html#'iskeyword'">'iskeyword'</a> 选项为新值。

        示例: 
<code class="example">  :syntax iskeyword @,48-57,192-255,$,_</code>

        这使得语法特定的 iskeyword 选项包含所有的字母、数位，所有的重音字符，
        还包含 "_" 和 "$"。

        如果不给出参数，输出当前值。

        此选项的设置影响语法模式中的  <a href="pattern.html#%2F\k">/\k</a>  匹配，也决定新匹配会如何检查
         <a href="syntax.html#:syn-keyword">:syn-keyword</a> 。

        建议写语法文件时，使用此命令也为特定的语法语言设置正确的值，而不改变
        <a href="options.html#'iskeyword'">'iskeyword'</a> 选项。

定 义 关 键 字                                          <b class="vimtag"> <a name=":syn-keyword">:syn-keyword</a> </b>

:sy[ntax] keyword <code class="special">{group-name}</code> [<code class="special">{options}</code>] <code class="special">{keyword}</code> .. [<code class="special">{options}</code>]

        定义一系列关键字。

        <code class="special">{group-name}</code>    是语法组名，比如 "Comment"。
        [<code class="special">{options}</code>]     见下  <a href="syntax.html#:syn-arguments">:syn-arguments</a> 。
        <code class="special">{keyword}</code> ..    是关键字列表，这些关键字成为该组的成员。

        示例: 
<code class="example">  :syntax keyword   Type   int long char</code>

        <code class="special">{options}</code> 可以在该行的任何位置给出。它们应用于所有的关键字，包括选项之
        前的关键字。以下例子完全相同: 
<code class="example">  :syntax keyword   Type   contained int long char</code>
<code class="example">  :syntax keyword   Type   int long contained char</code>
<code class="example">  :syntax keyword   Type   int long char contained</code>
                                                                <b class="vimtag"> <a name="E789">E789</a> </b> <b class="vimtag"> <a name="E890">E890</a> </b>
        如果像 Vim 里的 Ex 命令那样，使用有可选尾部的关键字并把可选字符放在 []
        里，你可以一次定义各种变化形式: 
<code class="example">  :syntax keyword   vimCommand   ab[breviate] n[ext]</code>

        不要忘记只有所有字符都包含在 <a href="options.html#'iskeyword'">'iskeyword'</a> 选项里才能作为关键字识别。如
        果有一个字符不是，该关键字永远不会被识别。不过，可以使用多字节字符，它
        们不需要出现在 <a href="options.html#'iskeyword'">'iskeyword'</a> 里。
         <a href="syntax.html#:syn-iskeyword">:syn-iskeyword</a>  说明如何定义语法特定的 iskeyword 设置。

        关键字比匹配和区域有更高的优先级。如果有多个项目匹配，会优先使用关键
        字。关键字不会嵌套，也不能包含其它项目。

        <code class="note">注意</code> 你不能使用和选项同名的关键字 (即使这里不允许的选项也不行)。这时，
        应该使用匹配。

        关键字的最大长度为 80 个字符。

        根据被包含与否的不同，可以多次定义同一关键字，例如，你可以定义一次不被
        包含的关键字并使用一个高亮组。而为被包含的同一关键字使用不同的高亮组。
        例如: 
<code class="example">  :syn keyword vimCommand tag</code>
<code class="example">  :syn keyword vimSetting contained tag</code>
        如果发现独立于别的语法项目之外的 "tag"，使用 "vimCommand" 高亮组。如果
        发现 "tag" 出现在能包含 "vimSetting" 的项目里，则使用 "vimSetting"。


定 义 匹 配                                             <b class="vimtag"> <a name=":syn-match">:syn-match</a> </b>

:sy[ntax] match <code class="special">{group-name}</code> [<code class="special">{options}</code>]
                <code class="special">[excludenl]</code>
                <code class="special">[keepend]</code>
                <code class="special">{pattern}</code>
                [<code class="special">{options}</code>]

        定义一个匹配。

        <code class="special">{group-name}</code>            语法组名，比如 "Comment"。
        [<code class="special">{options}</code>]             见下  <a href="syntax.html#:syn-arguments">:syn-arguments</a> 。
        <code class="special">[excludenl]</code>             使得包含行尾匹配 "$" 的模式不扩展包含本项目的
                                匹配或者区域项目。必须在模式之前给出。
                                 <a href="syntax.html#:syn-excludenl">:syn-excludenl</a> 
        keepend                 不允许被包含的匹配项目超越结束模式的匹配文本。
                                见  <a href="syntax.html#:syn-keepend">:syn-keepend</a> 。
        <code class="special">{pattern}</code>               定义匹配的搜索模式。见下面的  <a href="syntax.html#:syn-pattern">:syn-pattern</a> 。
                                <code class="note">注意</code> 模式可以匹配多于一行的模式，这使得匹配依
                                赖于 Vim 从哪里开始搜索模式。你需要确信同步机
                                制能正确处理这个问题。

        例如 (匹配字符常数): 
<code class="example">  :syntax match Character /'.'/hs=s+1,he=e-1</code>


定 义 区 域             <b class="vimtag"> <a name=":syn-region">:syn-region</a> </b> <b class="vimtag"> <a name=":syn-start">:syn-start</a> </b> <b class="vimtag"> <a name=":syn-skip">:syn-skip</a> </b> <b class="vimtag"> <a name=":syn-end">:syn-end</a> </b>
                                                        <b class="vimtag"> <a name="E398">E398</a> </b> <b class="vimtag"> <a name="E399">E399</a> </b>
:sy[ntax] region <code class="special">{group-name}</code> [<code class="special">{options}</code>]
                [matchgroup=<code class="special">{group-name}</code>]
                <code class="special">[keepend]</code>
                <code class="special">[extend]</code>
                <code class="special">[excludenl]</code>
                start=<code class="special">{start-pattern}</code> ..
                [skip=<code class="special">{skip-pattern}</code>]
                end=<code class="special">{end-pattern}</code> ..
                [<code class="special">{options}</code>]

        定义一个区域。区域可以覆盖多行。

        <code class="special">{group-name}</code>            语法组名，比如 "Comment"。
        [<code class="special">{options}</code>]             见下  <a href="syntax.html#:syn-arguments">:syn-arguments</a> 。
        [matchgroup=<code class="special">{group-name}</code>]  其后定义的开始或者结束模式的匹配文本专用的
                                语法组。该语法组并不用于两者之间的文本。如果不
                                想开始或结束匹配使用另外的语法组，可以用 NONE
                                作为组名来复位。
                                见  <a href="syntax.html#:syn-matchgroup">:syn-matchgroup</a> 。
        keepend                 不允许被包含的匹配项目越过结束模式的匹配文本。
                                见  <a href="syntax.html#:syn-keepend">:syn-keepend</a> 。
        extend                  否决包含本区域的项目的 "keepend" 设置。见
                                 <a href="syntax.html#:syn-extend">:syn-extend</a> 。
        excludenl               使得包含行尾匹配 "$" 的模式不扩展包含本项目的
                                匹配或者区域。只适用于结束模式。必须在该模式之
                                前给出。 <a href="syntax.html#:syn-excludenl">:syn-excludenl</a> 
        start=<code class="special">{start-pattern}</code>   定义区域开始的搜索模式。见下  <a href="syntax.html#:syn-pattern">:syn-pattern</a> 。
        skip=<code class="special">{skip-pattern}</code>     定义不需要查找结束模式的区域内部文本的搜索模
                                式。见下  <a href="syntax.html#:syn-pattern">:syn-pattern</a> 。
        end=<code class="special">{end-pattern}</code>       定义区域结束的搜索模式。见下  <a href="syntax.html#:syn-pattern">:syn-pattern</a> 。

        示例: 
<code class="example">  :syntax region String   start=+"+  skip=+\\"+  end=+"+</code>

        开始 / 跳过 / 结束模式和其它选项可用任何顺序给出。跳过模式可有零到一
        个。开始和结束模式必须有一个或更多。这意味着，你可以忽略跳过模式，但你
        必须给出至少一个的开始和结束模式。在等号前后，可以使用空白字符 (不过多
        数情况下，其实没有空白字符更清楚一些)。

        如果给出多于一个的开始模式，只须匹配其中任何一个。这意味着这些开始模式
        之间是*或*的关系。如有多个匹配，使用最后一个。结束模式也是如此。

        结束模式从开始模式之后立即开始搜索，这里不考虑位移。这意味着，结束模式
        的匹配文本永远不会与开始模式的重叠。

        跳过和结束模式可以跨行匹配，但因为模式的搜索可以从任何一行开始，这经常
        不能如你所愿。跳过模式也不能避免下一行中结束模式的匹配。要避免麻烦，最
        好使用单行的模式。

        <code class="note">注意</code>: 一个区域的开始完全取决于开始模式的匹配。不检查是否存在结束模式的
        匹配。下面 <code class="emphasis">不能</code> 工作: 
<code class="example">                :syn region First  start="("  end=":"</code>
<code class="example">                :syn region Second start="("  end=";"</code>
        Second 总是在 First 之前得到匹配 (最后定义的模式享有更高的优先权)。
        Second 区域会继续到后面出现的 ';' 为止。这之前是否出现 ':' 无关紧要。
        要解决这个问题，可以使用匹配: 
<code class="example">                :syn match First  "(\_.\{-}:"</code>
<code class="example">                :syn match Second "(\_.\{-};"</code>
        该模式使用 "\_." 匹配任何字符或换行符，并以 "\<code class="special">{-}</code>" 重复 (重复尽量少的
        次数)。

                                                        <b class="vimtag"> <a name=":syn-keepend">:syn-keepend</a> </b>
        缺省，被包含的项目可以隐藏结束模式的匹配。这对嵌套有用。比如，"{" 开始
        "}" 结束的区域可以包含另一个这样的区域。第一个遇到的 "}" 会结束被包含
        的区域，不是外面的那个:
            {           开始外层 "<code class="special">{}</code>" 区域
                {       开始被包含的 "<code class="special">{}</code>" 区域
                }       结束被包含的 "<code class="special">{}</code>" 区域
            }           结束外层 "<code class="special">{}</code> 区域
        如果你不希望如此，"keepend" 参数可以使得外层区域结束模式的匹配同时结束
        任何包含在内的项目。这使得相同区域的嵌套不再可能，但可以允许被包含项目
        高亮结束模式的部分内容，而不会因此跳过结束模式的匹配。例如: 
<code class="example">  :syn match  vimComment +"[^"]\+$+</code>
<code class="example">  :syn region vimCommand start="set" end="$" contains=vimComment keepend</code>
        "keepend" 使得 vimCommand 总是在行尾结束，即使被包含的 vimComment 包括
        了 <code class="special">&lt;EOL&gt;</code> 的匹配也不例外。

        如果不使用 "keepend"，在每个被包含项目的匹配文本之后，才会重新尝试结束
        模式的匹配。如果使用 "keepend"，寻找结束模式第一次出现的匹配，并截断任
        何被包含的项目。
                                                        <b class="vimtag"> <a name=":syn-extend">:syn-extend</a> </b>
        "keepend" 的行为可以被 "extend" 参数改变。当一个项目使用 "extend" 的时
        候，包含它的外层项目所用的 "keepend" 被忽略，从而使得那个项目可以得到
        扩展。
        这可以使一些被包含的项目能扩展某区域，而另一些则不能。例如: 
<code class="example"></code>
<code class="example">   :syn region htmlRef start=+&lt;a&gt;+ end=+&lt;/a&gt;+ keepend contains=htmlItem,htmlScript</code>
<code class="example">   :syn match htmlItem +&lt;[^&gt;]*&gt;+ contained</code>
<code class="example">   :syn region htmlScript start=+&lt;script+ end=+&lt;/script[^&gt;]*&gt;+ contained extend</code>
<code class="example"></code>
        这里，htmlItem 项目不扩展 htmlRef 项目，它只是用来高亮 <code class="special">&lt;&gt;</code> 条目。而
        htmlScript 项目则扩展 htmlRef 项目。

        另一个例子: 
<code class="example">   :syn region xmlFold start="&lt;a&gt;" end="&lt;/a&gt;" fold transparent keepend extend</code>
        定义使用 "keepend" 的区域，使得它的结尾不会被包含在内的项目所改变，比
        如匹配 "&lt;/a&gt;" 以赋予不同高亮属性的那些项目。但如果 xmlFold 区域本身嵌
        套 (自己包含自己)，则应用 "extend"，使得嵌套在内的 "&lt;/a&gt;" 只会结束里面
        的区域，而不是包含该区域的外层区域。

                                                        <b class="vimtag"> <a name=":syn-excludenl">:syn-excludenl</a> </b>
        当一个匹配项目的模式或者区域项目的结束模式包含 '$' 以匹配行尾的时候，
        包含该项目的外部区域项目会在下一行继续。比如，使用 "\\$" (行尾出现的反
        斜杠) 的匹配项目可以使得一个通常在行尾结束的区域继续下去。这是缺省的行
        为。如果你不希望如此，有两个解决方法:
        1. 外部项目使用 "keepend"。这会使得所有被包含的项目不能扩展外部的匹配
           或区域项目。这可用于所有被包含的项目都不能扩展外部项目的场合。
        2. 在被包含的项目中使用 "excludenl"。这使得该匹配不能扩展外部的匹配或
           区域项目。这可用于只有一些被包含的项目不需要扩展外部项目的场合。
           "excludenl" 必须在它适用的模式之前给出。

                                                        <b class="vimtag"> <a name=":syn-matchgroup">:syn-matchgroup</a> </b>
        "matchgroup" 可以用来高亮开始和/或结束模式，使之和区域本体不同。例
        如: 
<code class="example">  :syntax region String matchgroup=Quote start=+"+  skip=+\\"+  end=+"+</code>
        会使得引号本身使用 "Quote" 组高亮。而其中的文本使用 "String" 高亮组。
        "matchgroup" 用于其后所有的开始和结束模式，直到下一个 "matchgroup" 为
        止。使用 "matchgroup=NONE" 回到不使用 matchgroup 的情况。

        用 "matchgroup" 高亮的开始或结束模式的匹配文本不会用于包含在该区域内的
        项目。这样可以避免被包含项目也能在开始或结束模式的匹配文本中匹配。
        "transparent" 选项不适用于使用 "matchgroup" 高亮的开始或结束模式的匹配
        文本。

        这里是一个例子，它以不同的颜色高亮三层括号: 
<code class="example">   :sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2</code>
<code class="example">   :sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained</code>
<code class="example">   :sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained</code>
<code class="example">   :hi par1 ctermfg=red guifg=red</code>
<code class="example">   :hi par2 ctermfg=blue guifg=blue</code>
<code class="example">   :hi par3 ctermfg=darkgreen guifg=darkgreen</code>

                                                <b class="vimtag"> <a name="E849">E849</a> </b>
语法组的最大数目为 19999。

</section><hr class="doubleline" /><section class=inner>
<h4>7. :syntax 参数                                         <b class="vimtag"> <a name=":syn-arguments">:syn-arguments</a> </b></h4>
定义语法项目的 :syntax 命令接受多个参数。其中，通用的部分在这里解释。这些参数
可以用任何顺序给出，也可和模式相互间杂。

不是所有的命令都接受每个参数。下表显示什么参数不能在所有命令里使用:
                                                        <b class="vimtag"> <a name="E395">E395</a> </b>
<code class="section">                    contains  oneline   fold  display  extend concealends</code>
:syntax keyword          -       -       -       -       -       -
:syntax match           是       -      是      是      是       -
:syntax region          是      是      是      是      是      是

以下参数可以在所有三个命令里使用:
        conceal
        cchar
        contained
        containedin
        nextgroup
        transparent
        skipwhite
        skipnl
        skipempty

conceal                                         <b class="vimtag"> <a name="conceal">conceal</a> </b> <b class="vimtag"> <a name=":syn-conceal">:syn-conceal</a> </b>

如果给出 "conceal" 参数，本项目被标为可隐藏。实际隐藏与否取决于 <a href="options.html#'conceallevel'">'conceallevel'</a>
选项的值。<a href="options.html#'concealcursor'">'concealcursor'</a> 选项决定当前行的可隐藏项目是否会以正常方式显示，以便
对本行进行编辑。
另一个隐藏文本的办法是用  <a href="builtin.html#matchadd()">matchadd()</a> 。

concealends                                             <b class="vimtag"> <a name=":syn-concealends">:syn-concealends</a> </b>

如果给出 "concealends" 参数，区域的开始和结束匹配 (不包括区域内容本身) 被标为
可隐藏，实际隐藏与否取决于 <a href="options.html#'conceallevel'">'conceallevel'</a> 选项的设置。只有这种方式，区域结束处
才可以用 "matchgroup" 来定义自己单独的高亮隐藏方式。

cchar                                                   <b class="vimtag"> <a name=":syn-cchar">:syn-cchar</a> </b>
                                                        <b class="vimtag"> <a name="E844">E844</a> </b>
"cchar" 参数定义代替可隐藏项目的字符 (只有给出 conceal 参数时设置 "cchar" 才有
意义)。如果没有给出 "cchar"，缺省的隐藏代替字符是 <a href="options.html#'listchars'">'listchars'</a> 选项定义的字符。
该字符不能是控制字符，如制表符。示例: 
<code class="example">   :syntax match Entity "&amp;amp;" conceal cchar=&amp;</code>
关于高亮，见  <a href="syntax.html#hl-Conceal">hl-Conceal</a> 。

contained                                               <b class="vimtag"> <a name=":syn-contained">:syn-contained</a> </b>

如果给出 "contained" 参数，本项目在顶层不会被识别。只有包含在另外一个项目里才
可以，而且那个项目必须给出 "contains" 参数且其中包含本项目。例如: 
<code class="example">   :syntax keyword Todo    TODO    contained</code>
<code class="example">   :syntax match   Comment "//.*"  contains=Todo</code>
<code class="example"></code>
<code class="example"></code>
display                                                 <b class="vimtag"> <a name=":syn-display">:syn-display</a> </b>

如果给出 "display" 参数，本项目会在检测到高亮不会显示的时候被跳过。这样，高亮
速度可以加快，因为只要发现要显示的文本的语法状态就可以跳过本项目。

通常，你使用 "display" 来匹配满足以下条件的匹配和区域项目:
- 该项目不会跨过行尾。C 的例子: 包含 "/*" 的注释不能使用 "display"，因为它会在
  下一行继续。
- 该项目不包含会跨过行尾或使得本项目在下一行继续的项目。
- 该项目不改变任何包含它在内的项目的大小。C 的例子: 预处理指令里的匹配 "\\$"
  不能使用 "display"，因为它可以使得预处理指令的匹配变短。
- 该项目不允许其它项目匹配本来不能匹配的内容，而所扩展的匹配文本会走的太远。C
  的例子: 定义 "//" 注释的匹配不能使用 "display"，因为在该注释里的 "/*" 这时会
  匹配并开始一个跨越行尾的注释。

例如，在 C 程序里，"display" 可以用在:
- 数值的匹配
- 标签的匹配


transparent                                             <b class="vimtag"> <a name=":syn-transparent">:syn-transparent</a> </b>

如果给出 "transparent" (透明) 参数，本项目自身不会被高亮，但会使用包含它的外层
项目的高亮属性。这对本身不需要特殊高亮但要用来跳过一段文本的语法项目有用。

除非包含 transparent 的这个项目本身包含了 "contains" 参数，"contains="
参数会从外层的项目继承，要避免包含不需要的项目，可使用 "contains=NONE"。例如，
高亮字符串里的单词，但不包括 "vim": 
<code class="example">        :syn match myString /'[^']*'/ contains=myWord,myVim</code>
<code class="example">        :syn match myWord   /\&lt;[a-z]*\&gt;/ contained</code>
<code class="example">        :syn match myVim    /\&lt;vim\&gt;/ transparent contained contains=NONE</code>
<code class="example">        :hi link myString String</code>
<code class="example">        :hi link myWord   Comment</code>
"myVim" 匹配出现在 "myWord" 之后，因而它是更优先的匹配 (在相同的位置上，后出
现的匹配优先于先出现的匹配)。"transparent" 参数使得 "myVim" 的匹配使用和
"myString" 相同的高亮，但它本身不再包含其它项目。如果没有指定 "contains=NONE"
参数，那么 "myVim" 会使用 myString 的 contains 参数，从而包含了 "myWord"，因而
被高亮为 Comment。这之所以会发生，是因为被包含的项目不会在同样的位置上匹配外层
同一个语法项目，所以这里，在最内层的 "myVim" 匹配不能否决 "myWord" 的匹配。

如果你看有色彩的文本，它实际上是由一层层被包含的项目组成的。被包含的项目在包含
它的项目之上，因而你能看到被包含的项目。如果一个被包含的项目是透明的，你会看透
它，从而看到包含它的项目。以图示之:

                从这里看

            |   |   |   |   |   |
            V   V   V   V   V   V

               xxxx       yyy           被包含更深的项目
            ....................        被包含项目 (透明)
        =============================   第一个项目

'x'、'y' 和 '=' 分别表示一种高亮的语法项目。'.' 代表透明层。

你实际看到的是:

        =======xxxx=======yyy========

这里，你 "看穿" 了透明的 "...."。


oneline                                                 <b class="vimtag"> <a name=":syn-oneline">:syn-oneline</a> </b>

"oneline" 参数指示本区域不会跨过行边界。它必须在当前行内完整匹配。不过，如果本
区域包含跨行的项目，那么本区域还是会从下一行继续。被包含的项目可以用来识别续行
模式。不过，结束模式必须仍然在第一行上匹配，不然本区域根本不会开始。

如果开始模式包含 "\n" 从而匹配换行符，结束模式必须在开始模式结束处所在的同一行
上找到。该结束模式也可以包含换行符。因而，"oneline" 参数只是意味着开始模式的结
束处和结束模式的开始处必须在同一行上。这一点，即使跳过模式包含换行符也不能改
变。


fold                                                    <b class="vimtag"> <a name=":syn-fold">:syn-fold</a> </b>

"fold" 参数使得本项目的折叠级别加 1。示例: 
<code class="example">   :syn region myFold start="{" end="}" transparent fold</code>
<code class="example">   :syn sync fromstart</code>
<code class="example">   :set foldmethod=syntax</code>
这使得每个 <code class="special">{}</code> 块形成一个折叠。

该折叠从项目开始的行开始，而在项目结束之行上结束。如果开始和结束处在同一行，则
不形成折叠。<a href="options.html#'foldnestmax'">'foldnestmax'</a> 选项限制语法折叠的嵌套级别。
 <a href="syntax.html#:syn-foldlevel">:syn-foldlevel</a>  控制如何从一行的语法项目中计算其折叠级别。
<code class="notvi">{仅当 Vim 编译时带  <a href="various.html#+folding">+folding</a>  特性才有效}</code>


                        <b class="vimtag"> <a name=":syn-contains">:syn-contains</a> </b> <b class="vimtag"> <a name="E405">E405</a> </b> <b class="vimtag"> <a name="E406">E406</a> </b> <b class="vimtag"> <a name="E407">E407</a> </b> <b class="vimtag"> <a name="E408">E408</a> </b> <b class="vimtag"> <a name="E409">E409</a> </b>
contains=<code class="special">{group-name}</code>,..

"contains" 参数跟随语法组名的列表。这些组因而被允许包含在本项目里 (它们可能扩
展包含它们的组的结束位置)。这使得匹配和区域的递归嵌套成为可能。如果没有
"contains" 参数，本项目不能包含任何组。组名不需要在这里的使用前定义。

contains=ALL
                如果唯一在包含列表里出现的名字是 "ALL"，那么本项目里可以包含所
                有的组。

contains=ALLBUT,<code class="special">{group-name}</code>...
                如果包含列表的第一个名字是 "ALLBUT"，那么除了列出的那些以外，
                所有的组都可以出现在本项目里。例如: 
<code class="example">  :syntax region Block start="{" end="}" ... contains=ALLBUT,Function</code>
<code class="example"></code>
contains=TOP
                如果包含列表的第一个名字是 "TOP"，那么所有不包含 "contained"
                参数的组都可以接受。
contains=TOP，<code class="special">{group-name}</code>,..
                类似于 "TOP"，但除了列出的组以外。

contains=CONTAINED
                如果包含列表的第一个名字是 "CONTAINED"，那么所有包含
                "contained" 参数的组都可以接受。
contains=CONTAINED，<code class="special">{group-name}</code>,..
                类似于 "CONTAINED"，但列出的组除外。


"contains" 列表里的 <code class="special">{group-name}</code> 可以是模式。所有匹配该模式的组名都会包含进来
(或者排除出去，如果使用 "ALLBUT" 的话)。该模式不能包含空白或者 ','。例如: 
<code class="example">   ... contains=Comment.*,Keyw[0-3]</code>
在执行 syntax 命令时完成该匹配。后来定义的组不会再参与匹配。另外，如果本
syntax 命令自己定义一个新组，它也不会参与匹配。小心: 在文件里放入 syntax 命令
的时候，你不能指望某些组 <code class="emphasis">没有</code> 定义，因为该文件以前可能已经执行过。而
":syn clear" 并不会删除组名。

被包含的组也会匹配一个区域项目的开始和结束模式。如果不想如此，可以用
"matchgroup" 参数  <a href="syntax.html#:syn-matchgroup">:syn-matchgroup</a> 。"ms=" 和 "me=" 位移可以用来调整被包含项
目能够匹配的区域。<code class="note">注意</code> 这同时可能限制了高亮的区域。


containedin=<code class="special">{group-name}</code>...                             <b class="vimtag"> <a name=":syn-containedin">:syn-containedin</a> </b>

"containedin" 参数跟随语法组名的列表。然后，本项目就可以包含在那些组里，就像那
些项目使用了包含本项目的 "contains=" 参数一样。

<code class="special">{group-name}</code>... 的使用方式和 "contains" 相同，见上面的解释。

这可以用于后加的语法项目。一个项目可以告知要包含在已经存在的项目里面，而无须修
改后者的定义。例如，要在载入 C 语法以后高亮 C 注释里的一个单词:
<code class="section">        :syn keyword myword HELP containedin=cComment contained </code>
<code class="note">注意</code> 同时使用了 "contained" 参数是为了避免本项目在顶层得到匹配。

"containedin" 的匹配被加到该项目可以出现的其它地方。像平常一样，本项目也可以使
用 "contains" 参数。不要忘记关键字项目不可能包含其它项目。所以把它们加在
"containedin" 里是徒劳的。


nextgroup=<code class="special">{group-name}</code>,..                               <b class="vimtag"> <a name=":syn-nextgroup">:syn-nextgroup</a> </b>

"nextgroup" (下一个组) 参数跟随语法组名的列表，以逗号分隔 (和 "contains" 类
似，你也可以使用模式)。

如果给出 "nextgroup" 参数，提到的语法组会在本匹配或区域结束之后尝试匹配。如果
没有一个组能够匹配，高亮和平常一样继续。如果有匹配，则使用匹配的组高亮，即使该
组没有在当前组的 "contains" 字段里提到，就像这里的组给赋予了比其它的组更高的优
先级一样。例如: 
<code class="example">   :syntax match  ccFoobar  "Foo.\{-}Bar"  contains=ccFoo</code>
<code class="example">   :syntax match  ccFoo     "Foo"           contained nextgroup=ccFiller</code>
<code class="example">   :syntax region ccFiller  start="."  matchgroup=ccBar  end="Bar"  contained</code>
<code class="example"></code>
会分别高亮 "Foo" 和 "Bar"，但只有在 "Bar" 跟在 "Foo" 之后才行。在下面的文本行
里，"f" 显示使用 ccFoo 的高亮，而 "bbb" 则是使用 ccBar 的地方。

   Foo asdfasd Bar asdf Foo asdf Bar asdf
   fff         bbb      fff      bbb

<code class="note">注意</code> ".\<code class="special">{-}</code>" 的使用跳过尽可能少的内容以到达下一个 Bar。如果使用了 ".*"，"Bar"
和 "Foo" 之间的 "asdf" 会以 "ccFoobar" 组高亮，因为 ccBar 匹配行内第一个 "Foo"
和最后一个 "Bar" 的全部内容 (见  <a href="pattern.html#pattern">pattern</a> )。


skipwhite                                               <b class="vimtag"> <a name=":syn-skipwhite">:syn-skipwhite</a> </b>
skipnl                                                  <b class="vimtag"> <a name=":syn-skipnl">:syn-skipnl</a> </b>
skipempty                                               <b class="vimtag"> <a name=":syn-skipempty">:syn-skipempty</a> </b>

这些参数只能和 "nextgroup" 组合使用。它们可以用来指定如何跳过一些文本到达下一
个组:
        skipwhite       跳过空格和制表字符
        skipnl          跳过换行符
        skipempty       跳过空行 (意味着 "skipnl")

如果 "skipwhite" 存在，空白字符只有在没有下一个组会匹配空白时才会跳过。

如果 "skipnl" 存在，下一个组的匹配会在第二行内寻找。这只有在当前项目在行尾结束
时才会发生！如果 "skipnl" 不存在，下一个组只会在当前项目相同的行上寻找。

如果在寻找下一个组时跳过文本，其它组的匹配就会忽略。只有在没有下一个组匹配时，
其它的项目才会重新尝试被匹配。这意味着下一个组，包括跳过的空白和 <code class="special">&lt;EOL&gt;</code>，的匹配
比其它项目的优先级要高。

示例: 
<code class="example">  :syn match ifstart "\&lt;if.*"   nextgroup=ifline skipwhite skipempty</code>
<code class="example">  :syn match ifline  "[^ \t].*" nextgroup=ifline skipwhite skipempty contained</code>
<code class="example">  :syn match ifline  "endif"    contained</code>
<code class="note">注意</code> "[^ \t].*" 匹配所有的非空白文本。这样，它也能匹配 "endif"。所以 "endif"
匹配项目必须放在最后，以取得优先权。
<code class="note">注意</code> 本例子不适用于嵌套的 "if"。你需要加上 "contains" 参数才行 (本例之所以省
略，是为了简洁起见)。

隐 含 隐 藏                                             <b class="vimtag"> <a name=":syn-conceal-implicit">:syn-conceal-implicit</a> </b>

:sy[ntax] conceal [on|off]
        指令后续的 ":syntax" 命令所定义的关键字、匹配或区域是否会自动带上
        "conceal" 标志位。":syn conceal on" 之后的所有 ":syn keyword"、
        ":syn match" 或 ":syn region" 会隐含地带上 "conceal" 标志位。而
        ":syn conceal off" 回复到正常状态，必须显式给出 "conceal" 标志位。

:sy[ntax] conceal
        显示 "syntax conceal on" 或 "syntax conceal off" 之一。

</section><hr class="doubleline" /><section class=inner>
<h4>8. 语法模式                                     <b class="vimtag"> <a name=":syn-pattern">:syn-pattern</a> </b> <b class="vimtag"> <a name="E401">E401</a> </b> <b class="vimtag"> <a name="E402">E402</a> </b></h4>
在 syntax 命令里，模式必须被两个相同的字符包围。这和 ":s" 命令类似。最常用的是
双引号。但如果模式本身包含双引号，你可以使用别的不在模式里出现的字符。例如: 
<code class="example">  :syntax region Comment  start="/\*"  end="\*/"</code>
<code class="example">  :syntax region String   start=+"+    end=+"+   skip=+\\"+</code>
<code class="example"></code>
关于模式的解释，见  <a href="pattern.html#pattern">pattern</a> 。对语法模式的解释总是假设打开了 <a href="options.html#'magic'">'magic'</a> 选项，而
与实际的 <a href="options.html#'magic'">'magic'</a> 值无关。而且也假设 <a href="options.html#'cpoptions'">'cpoptions'</a> 里没有 'l' 标志位。这些设置使
得语法文件易移植，而独立于 <a href="options.html#'compatible'">'compatible'</a> 和 <a href="options.html#'magic'">'magic'</a> 的设置。

要避免能够匹配空字符串的模式，比如 "[a-z]*"。这会显著减慢高亮，因为这样的模式
会在任何地方得到匹配。

                                                <b class="vimtag"> <a name=":syn-pattern-offset">:syn-pattern-offset</a> </b>
模式可以后跟一个字符位移。它可以用来修改高亮的部分，也可以修改匹配或区域项目的
文本区域 (只有其它项目的匹配会受影响)。两者都是相对于已经匹配的模式的。跳过模
式的字符位移可以用来指示从哪里开始继续寻找结束模式。

位移的形式是 "<code class="special">{what}</code>=<code class="special">{offset}</code>"
<code class="special">{what}</code> 可以是七种字符串之一:

ms      匹配开始        匹配文本开始的偏移
me      匹配结束        匹配文本结束的偏移
hs      高亮开始        高亮开始的偏移
he      高亮结束        高亮开始的偏移
rs      区域开始        区域本体开始的偏移
re      区域结束        区域本体结束的偏移
lc      引导上下文      超越模式的 "引导上下文" 的偏移

<code class="special">{offset}</code> 可以是:

s       模式匹配部分的开始位置
s+<code class="special">{nr}</code>  模式匹配部分的开始位置向右 <code class="special">{nr}</code> 个字符
s-<code class="special">{nr}</code>  模式匹配部分的开始位置向左 <code class="special">{nr}</code> 个字符
e       模式匹配部分的结束位置
e+<code class="special">{nr}</code>  模式匹配部分的结束位置向右 <code class="special">{nr}</code> 个字符
e-<code class="special">{nr}</code>  模式匹配部分的结束位置向左 <code class="special">{nr}</code> 个字符
<code class="special">{nr}</code>    (只用于 "lc"): 从开始处向右 <code class="special">{nr}</code> 个字符开始匹配

例如: "ms=s+1"，"hs=e-2"，"lc=3"。

尽管所有的位移形式在任何模式之后都能接受，它们不都有意义。下表说明什么样的位移
在实际中会应用到:

<code class="section">                    ms   me   hs   he   rs   re   lc </code>
匹配项目            是   是   是   是   -    -    是
区域项目开始模式    是   -    是   -    是   -    是
区域项目跳过模式    -    是   -    -    -    -    是
区域项目结束模式    -    是   -    是   -    是   是

位移可用 ',' 连接。例如: 
<code class="example">  :syn match String  /"[^"]*"/hs=s+1,he=e-1</code>

    一些 "字符串" 文本
          ^^^^^^                高亮部分

<code class="note">注意</code>:
- 模式和位移字符之间不能有空白。
- 高亮区域永远不会超出匹配文本的范围。
- 结束模式上的负偏移不一定总能用，因为结束模式可能在高亮本应结束的地方才检测
  到。
- Vim 7.2 之前，位移用字节数而不是字符数计算。这对多字节字符不适用，所以 Vim
  7.2 版本发行时改了。
- 匹配不能从实际匹配的模式所在的行之外开始。这样不行: "a\nb"ms=e。高亮可以从另
  一个行开始，这样没有问题: "a\nb"hs=e。

示例 (匹配注释，但不高亮 /* 和 */): 
<code class="example">  :syntax region Comment start="/\*"hs=e+1 end="\*/"he=s-1</code>

        /* 这是一个注释 */
          ^^^^^^^^^^^^^^          高亮部分

一个更复杂的例子: 
<code class="example">  :syn region Exa matchgroup=Foo start="foo"hs=s+2,rs=e+2 matchgroup=Bar end="bar"me=e-1,he=e-1,re=s-1</code>

         abcfoostringbarabc
            mmmmmmmmmmm     匹配
              ssrrrreee     高亮 开始 (s)/区域 (r)/结束 (e)
                                ("Foo"、"Exa" 和 "Bar")

引导上下文                      <b class="vimtag"> <a name=":syn-lc">:syn-lc</a> </b> <b class="vimtag"> <a name=":syn-leading">:syn-leading</a> </b> <b class="vimtag"> <a name=":syn-context">:syn-context</a> </b>

<code class="note">注意</code>: 这是一个已经废弃的特性，包含它只是为了和以前的 Vim 版本后向兼容。现在，
我们推荐使用在模式里使用  <a href="pattern.html#%2F\@%3C%20">/\@&lt;=</a>  构造。经常也可用  <a href="pattern.html#%2F\zs">/\zs</a> 。

"lc" 位移指定引导上下文 -- 模式的一部分: 必须存在，但不包含在实际的匹配中。形
如 "lc=n" 的位移会使得 Vim 在试图匹配模式前先后退 n 列，从而可以使得已在较早的
模式中匹配的字符仍然可以做为本匹配的引导上下文。这可用于，比如说，要求本匹配不
出现在某个前导的 "转义" 字符之后: 
<code class="example"></code>
<code class="example">  :syn match ZNoBackslash "[^\\]z"ms=s+1</code>
<code class="example">  :syn match WNoBackslash "[^\\]w"lc=1</code>
<code class="example">  :syn match Underline "_\+"</code>

          ___zzzz ___wwww
          ^^^     ^^^     匹配 Underline
              ^ ^         匹配 ZNoBackslash
                     ^^^^ 匹配 WNoBackslash

"ms" 位移自动设为与 "lc" 位移相同的值，除非你显式地设置 "ms"。


多行模式                                                <b class="vimtag"> <a name=":syn-multi-line">:syn-multi-line</a> </b>

模式里可以包含 "\n" 匹配换行符。多数情况下，它能正常工作，但有以下一些例外。

使用带位移的开始模式时，匹配不允许从真实匹配之后的行开始。不过，高亮不存在这样
的问题。"\zs" 项目也同样需要匹配的开始不能移动到另一行。

跳过模式可以包含 "\n"，但结束模式的搜索会从下一行的第一个字符开始，即使跳过模
式匹配该字符也是如此。这是因为重画可以从区域中间的任何一行启动，而不会检查跳过
模式是否从那一行之前就已经开始的缘故。例如，如果跳过模式是 "a\nb" 而结束模式为
"b"，结束模式的确会匹配下面情况的第二行: 
<code class="example">         x x a</code>
<code class="example">         b x x</code>
通常，这意味着跳过模式不应匹配 "\n" 之后的任何字符。


外部匹配                                                <b class="vimtag"> <a name=":syn-ext-match">:syn-ext-match</a> </b>

以下附加的正则表达式项目可以用在区域项目的模式中:

                                        <b class="vimtag"> <a name="%2F\z(">/\z(</a> </b> <b class="vimtag"> <a name="%2F\z(\)">/\z(\)</a> </b> <b class="vimtag"> <a name="E50">E50</a> </b> <b class="vimtag"> <a name="E52">E52</a> </b> <b class="vimtag"> <a name="E879">E879</a> </b>
    \z(\)       标记该子表达式为 "外部的"，这意味着它可以在别的模式匹配里访
                问。目前，只能在语法区域的开始模式中应用。

                                        <b class="vimtag"> <a name="%2F\z1">/\z1</a> </b> <b class="vimtag"> <a name="%2F\z2">/\z2</a> </b> <b class="vimtag"> <a name="%2F\z3">/\z3</a> </b> <b class="vimtag"> <a name="%2F\z4">/\z4</a> </b> <b class="vimtag"> <a name="%2F\z5">/\z5</a> </b>
    \z1  ...  \z9                       <b class="vimtag"> <a name="%2F\z6">/\z6</a> </b> <b class="vimtag"> <a name="%2F\z7">/\z7</a> </b> <b class="vimtag"> <a name="%2F\z8">/\z8</a> </b> <b class="vimtag"> <a name="%2F\z9">/\z9</a> </b> <b class="vimtag"> <a name="E66">E66</a> </b> <b class="vimtag"> <a name="E67">E67</a> </b>
                匹配和前面的开始模式匹配里相应子表达式的匹配的相同的字符串。

有时区域项目的开始和结束模式需要共享一个相同的子表达式。常见的例子是 Perl 和许
多 Unix 外壳里的 "here" 文档。这种效果可以通过特殊的 "\z" 正则表达式项目完成。
它把子表达式标为 "外部的"，也就是说可以从定义所在的模式的外部引用。例如，here
文档的例子可以如此完成: 
<code class="example">  :syn region hereDoc start="&lt;&lt;\z(\I\i*\)" end="^\z1$"</code>
<code class="example"></code>
由此可见，\z 实际上有双重任务。在开始模式里，它标记 "\(\I\i*\)" 子表达式为外部
的；在结束模式里，它把 \z1 反向引用重新定义为指向开始模式里的第一个外部子表达
式的外部引用。跳过模式里也可以使用外部引用: 
<code class="example">  :syn region foo start="start \z(\I\i*\)" skip="not end \z1" end="end \z1"</code>

<code class="note">注意</code> 普通和外部子表达式是完全不相关联，它们分别索引。如果模式 "\z(..\)\(..\)"
应用于字符串 "aabb"，\1 会指向 "bb" 而 \z1 会指向 "aa"。也要 <code class="note">注意</code>，外部子表达
式不能和普通的子表达式那样，在同一个模式里作为反向引用来访问。如果你需要把一个
子表达式同时作为普通和外部子表达式来使用，可以嵌套使用这两者，形如
"\(\z(...\)\)"。

<code class="note">注意</code> 这里只能使用行内的匹配，不能从外部引用多行匹配。

</section><hr class="doubleline" /><section class=inner>
<h4>9. 语法簇                                               <b class="vimtag"> <a name=":syn-cluster">:syn-cluster</a> </b> <b class="vimtag"> <a name="E400">E400</a> </b></h4>
:sy[ntax] cluster <code class="special">{cluster-name}</code> [contains=<code class="special">{group-name}</code>..]
                                 [add=<code class="special">{group-name}</code>..]
                                 [remove=<code class="special">{group-name}</code>..]

本命令允许你把若干语法组捆绑在一起，以便使用单个名字访问。

        contains=<code class="special">{group-name}</code>..
                本簇使用此处指定的组名列表。
        add=<code class="special">{group-name}</code>..
                将指定的组加入本簇。
        remove=<code class="special">{group-name}</code>..
                将指定的组从本簇里删除。

用这种方式定义的簇可以在 contains=..、containedin=..、nextgroup=..、add=.. 或
者 remove=.. 的列表里使用，只要加上 "@" 前缀即可。用这种表示方式，你可以隐含地
在指定一个簇的内容之前先声明之。

示例: 
<code class="example">   :syntax match Thing "# [^#]\+ #" contains=@ThingMembers</code>
<code class="example">   :syntax cluster ThingMembers contains=ThingMember1,ThingMember2</code>
<code class="example"></code>
如同前例所暗示的，对簇的修改追溯既往；可以说，在最后一刻才进行簇成员身份的检
查: 
<code class="example">   :syntax keyword A aaa</code>
<code class="example">   :syntax keyword B bbb</code>
<code class="example">   :syntax cluster AandB contains=A</code>
<code class="example">   :syntax match Stuff "( aaa bbb )" contains=@AandB</code>
<code class="example">   :syntax cluster AandB add=B    " 现在两个关键字都在 Stuff 里匹配</code>
<code class="example"></code>
对嵌套的簇而言，这也有若干意含: 
<code class="example">   :syntax keyword A aaa</code>
<code class="example">   :syntax keyword B bbb</code>
<code class="example">   :syntax cluster SmallGroup contains=B</code>
<code class="example">   :syntax cluster BigGroup contains=A,@SmallGroup</code>
<code class="example">   :syntax match Stuff "( aaa bbb )" contains=@BigGroup</code>
<code class="example">   :syntax cluster BigGroup remove=B    " 没有效果，因为 B 不在 BigGroup 里</code>
<code class="example">   :syntax cluster SmallGroup remove=B  " 现在 Stuff 不再匹配 bbb</code>

                                                <b class="vimtag"> <a name="E848">E848</a> </b>
簇的最大数目是 9767。

</section><hr class="doubleline" /><section class=inner>
<h4>10. 包含语法文件                                        <b class="vimtag"> <a name=":syn-include">:syn-include</a> </b> <b class="vimtag"> <a name="E397">E397</a> </b></h4>
一个语言的语法文件经常需要包含相关语言的语法文件。取决于它们实际的关系，可以用
两种不同的方式完成:

        - 如果允许被包含的语法文件里的顶层的语法项目也出现在包含它的语法的顶层
          中，可以简单的使用  <a href="repeat.html#:runtime">:runtime</a>  命令: 
<code class="example"></code>
<code class="example">  " 在 cpp.vim 里:</code>
<code class="example">  :runtime! syntax/c.vim</code>
<code class="example">  :unlet b:current_syntax</code>
<code class="example"></code>
        - 如果被包含的语法文件里的顶层语法项目应在包含它的语法的某区域中应用，
          可以使用 ":syntax include" 命令:

:sy[ntax] include [@<code class="special">{grouplist-name}</code>] <code class="special">{file-name}</code>

          被包含文件里定义所有的语法项目会自动加上 "contained" 标志。同时，如
          果指定了组群 (簇)，被包含文件所有的顶层语法项目会加到该组群里。 
<code class="example"></code>
<code class="example">   " 在 perl.vim 里:</code>
<code class="example">   :syntax include @Pod &lt;sfile&gt;:p:h/pod.vim</code>
<code class="example">   :syntax region perlPOD start="^=head" end="^=cut" contains=@Pod</code>

          如果 <code class="special">{file-name}</code> 是绝对路径 (以 "/"、"c:"、"$VAR" 或者 "<code class="special">&lt;sfile&gt;</code>" 开
          始)，则载入该文件。如果它是是相对路径 (例如，"syntax/pod.vim")，则先
          在 <a href="options.html#'runtimepath'">'runtimepath'</a> 里搜索该文件，然后载入所有匹配的文件。建议使用相对
          路径，因为它允许用户用自己的版本替代被包含的文件，而不用修改使用
          ":syn include" 命令的文件。

                                                <b class="vimtag"> <a name="E847">E847</a> </b>
包含的最大数目是 999。

</section><hr class="doubleline" /><section class=inner>
<h4>11. 同步                                        <b class="vimtag"> <a name=":syn-sync">:syn-sync</a> </b> <b class="vimtag"> <a name="E403">E403</a> </b> <b class="vimtag"> <a name="E404">E404</a> </b></h4>
Vim 期待在文档的任何位置都能开始重画过程。为此目的，它需要知道重画开始所在的位
置相应的语法状态。

:sy[ntax] sync [ccomment [group-name] | minlines=<code class="special">{N}</code> | ...]

有四个同步方法:
1. 总是从文件头开始分析。
    <a href="syntax.html#:syn-sync-first">:syn-sync-first</a> 
2. 基于 C 风格的注释。Vim 理解 C 注释的工作方式，因而可以发现当前行是在注释里
   面还是外面。
    <a href="syntax.html#:syn-sync-second">:syn-sync-second</a> 
3. 回跳若干行，从那里开始分析。
    <a href="syntax.html#:syn-sync-third">:syn-sync-third</a> 
4. 反向搜索某模式的匹配文本，从那里开始同步。
    <a href="syntax.html#:syn-sync-fourth">:syn-sync-fourth</a> 

                                <b class="vimtag"> <a name=":syn-sync-maxlines">:syn-sync-maxlines</a> </b> <b class="vimtag"> <a name=":syn-sync-minlines">:syn-sync-minlines</a> </b>
对于后三个方法而言，开始分析所在的行范围受到 "minlines" 和 "maxlines" 的限制。

如果给出 "minlines=<code class="special">{N}</code>" 参数，分析总是至少倒退给出的行数，然后才开始。这适用于
分析过程在能判断正确之前至少需要若干行的情况、或者完全无法使用同步机制的场合。

如果给出 "maxlines=<code class="special">{N}</code>" 参数，反向搜索注释或者同步用搜索模式的行数限于 N 行之
内 (包括 "minlines" 指定的行数)。可用于同步的项目较少且机器较慢的场合。例如:

<code class="example">   :syntax sync maxlines=500 ccomment</code>

                                                <b class="vimtag"> <a name=":syn-sync-linebreaks">:syn-sync-linebreaks</a> </b>
使用可以匹配多行的模式时，某行的改变可以使得匹配不再能从上一行开始匹配。这意味
着同步必须从改变发生所在位置之前就进行。具体需要多少行可由 "linebreaks" 参数指
定。例如，如果模式包含一个换行符，可以这样: 
<code class="example">   :syntax sync linebreaks=1</code>
结果是，重画至少从改变所在之前的一行开始。缺省的 "linebreaks" 值为零。通常，
"minlines" 的值比 "linebreaks" 要大。


第一种同步方法:                         <b class="vimtag"> <a name=":syn-sync-first">:syn-sync-first</a> </b>

<code class="example">   :syntax sync fromstart</code>
<code class="example"></code>
文件从头开始分析。这使得语法高亮完全准确，但对很长的文件需时也久。Vim 预存以前
分析过的文本，所以只有第一次分析文本的时候才会缓慢。不过，如果修改了文本，其后
的部分需要重新分析 (最差情况下: 一直到文件尾)。

使用 "fromstart" 等价于把 "minlines" 指定为很大的数字。


第二种同步方法:                         <b class="vimtag"> <a name=":syn-sync-second">:syn-sync-second</a> </b> <b class="vimtag"> <a name=":syn-sync-ccomment">:syn-sync-ccomment</a> </b>

第二种方法只需指定 "ccomment" 参数。示例: 
<code class="example">   :syntax sync ccomment</code>
<code class="example"></code>
Vim 如果发现显示开始的行出现在 C 风格注释的内部，就使用组名为 "Comment" 的最后
一个区域语法项目。这需要组名为 "Comment" 的区域项目存在！也可指定替代的组名，
例如: 
<code class="example">   :syntax sync ccomment javaComment</code>
这意味着最后出现的 "syn region javaComment" 会用来检测 C 注释的区域。只有该区
域确实包含了开始模式 "\/*" 和结束模式 "*\/" 的时候才能有效。

"maxlines" 参数可以用来限制搜索的行数。"minlines" 参数用来指定至少回退若干行才
开始 (例如一些只占用若干行，但很难同步的构造)。

<code class="note">注意</code>: 如果使用跨行且包含 "*/" 的字符串，C 注释的同步方法不一定能正确工作。让字
符串跨行是一个不好的编程习惯 (许多编译器会给出<code class="note">警告</code>)，而 "*/" 出现在注释 (<code class="vim">译者</code>
注: 应为字符串) 的机率又相当小，一般很难<code class="note">注意</code>到这个限制。


第三种同步方法:                         <b class="vimtag"> <a name=":syn-sync-third">:syn-sync-third</a> </b>

第三种同步方法只要指定 "minlines=<code class="special">{N}</code>" 参数。Vim 会从行号上减去 <code class="special">{N}</code> 然后从那里
开始分析。这意味着需要额外分析 <code class="special">{N}</code> 行，该方法也因此较慢。例如: 
<code class="example">   :syntax sync minlines=50</code>
<code class="example"></code>
"lines" 等价于 "minlines" (用于较老的版本)。


第四种同步方法:                         <b class="vimtag"> <a name=":syn-sync-fourth">:syn-sync-fourth</a> </b>

本方法试图在若干指定区域的一端同步，称为同步模式。因为只有区域可以跨行。所以如
果我们能找到某区域的一端，或许就可以知道现在在哪个语法项目之中。该方法中，搜索
从重画开始所在的上一行开始，然后在文件中反向进行。

和非同步的语法项目类似，同步项目也可以使用 contained、matches、nextgroup 等。
但有如下区别:
- 不能使用关键字项目。
- 使用 "sync" 关键字的语法项目构成完全独立的语法项目组。你不能混合同步组和非同
  步组。
- 匹配在缓冲区里 (逐行) 反向进行，而不是正向。
- 可以给出续行模式，用于决定哪些行的组合可以在搜索时当成单行。这意味着搜索指定
  项目的匹配从包含续行模式的连续多行的第一行开始。
- "nextgroup" 或 "contains" 只适用于一行 (或者连续行构成的组合) 之内。
- 使用区域项目时，必须在同一行上 (或者连续行构成的组合) 开始和结束。否则，假定
  行尾 (或者连续行构成的组合的尾部) 会结束此项目。
- 如果找到同步模式的匹配，该行 (或者连续行构成的组合) 的其余部分会搜索其它匹
  配。最后发现的匹配被使用。这可以用于同时包括区域开始和结束的行 (例如，C 注释
  /* this */，使用最后找到的 "*/")。

有两个使用同步模式的匹配方法:
1. 高亮分析从重画开始处开始 (也就是同步模式的搜索起点)。必须指定在那里出现的合
   法语法组。如果跨行的区域不会包含别的区域时，这很有效。
2. 高亮分析从匹配之后立即开始。必须指定匹配之后立即出现的合法语法组。可
   用于上述方法不适用的情形。它慢得多，因为需要分析更多的文本。
可以同时使用两种类型的同步模式。

除了同步模式以外，还可以指定另外的匹配和区域项目，以跳过不需要的匹配。

[之所以单独给出同步模式，是因为多数情况下，同步点的搜索比高亮部分的确定要简单
得多。而模式的减少意味着速度的 (大大) 加快。]

                                            <b class="vimtag"> <a name="syn-sync-grouphere">syn-sync-grouphere</a> </b> <b class="vimtag"> <a name="E393">E393</a> </b> <b class="vimtag"> <a name="E394">E394</a> </b>
    :syntax sync match <code class="special">{sync-group-name}</code> grouphere <code class="special">{group-name}</code> "pattern" ..

        "这里的组"，定义用于同步的匹配。<code class="special">{group-name}</code> 为匹配之后立刻出现的语法
        组名 (<code class="vim">译者注</code>: 但不一定从那里开始，尤其是同步模式本身就可以属于该组)。
        文本的高亮分析在匹配之后立刻进行。<code class="special">{group-name}</code> 至少应包含一个区域项
        目，并使用其中的第一个这样的定义。"NONE" 用来指示匹配之后不存在语法
        组。

                                                <b class="vimtag"> <a name="syn-sync-groupthere">syn-sync-groupthere</a> </b>
    :syntax sync match <code class="special">{sync-group-name}</code> groupthere <code class="special">{group-name}</code> "pattern" ..

        "那里的组"，类似于 "grouphere"，但 <code class="special">{group-name}</code> 是在同步点的搜索起点所
        在行的行首使用的语法组名。匹配和同步点的搜索起点之间的文本假定不会改变
        语法的高亮。例如，在 C 里，你可以反向搜索 "/*" 和 "*/"。如果先找到
        "/*"，你知道在注释内部，所以 "那里的组" 是 "cComment"。如果先找到
        "*/" ，你知道不在注释里，所以 "那里的组" 是 "NONE"。(实际应用中更复
        杂，因为 "/*" 和 "*/" 可以出现在字符串中。留给读者作为练习吧……)。

    :syntax sync match ..
    :syntax sync region ..

        没有 "groupthere" 参数。定义区域或匹配项目，在同步点搜索过程中跳过这些
        项目 (<code class="vim">译者注</code>: <code class="note">注意</code> 同步模式只能使用匹配项目，但在这里定义的同步过程的
        "跳过" 模式可以指定区域或匹配项目。区域项目的限制上面已有叙述)。

                                                <b class="vimtag"> <a name="syn-sync-linecont">syn-sync-linecont</a> </b>
    :syntax sync linecont <code class="special">{pattern}</code>

        如果 <code class="special">{pattern}</code> 在行内匹配，本行被认为会在下一行继续。这意味着同步点的
        搜索会把这些行当作连接在一起的一行处理。

如果同时给出 "maxlines=<code class="special">{N}</code>" 参数，寻找匹配的搜索行数限于 N 行之内。可以用于同
步项目很少且机器速度较慢的场合。例如: 
<code class="example">   :syntax sync maxlines=100</code>
<code class="example"></code>
你可以这样清除所有的同步设置: 
<code class="example">   :syntax sync clear</code>
<code class="example"></code>
你也可以清除特定的同步模式: 
<code class="example">   :syntax sync clear {sync-group-name} ..</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>12. 列出语法项目                        <b class="vimtag"> <a name=":syntax">:syntax</a> </b> <b class="vimtag"> <a name=":sy">:sy</a> </b> <b class="vimtag"> <a name=":syn">:syn</a> </b> <b class="vimtag"> <a name=":syn-list">:syn-list</a> </b></h4>
本命令列出所有的语法项目: 
<code class="example"></code>
<code class="example">    :sy[ntax] [list]</code>
<code class="example"></code>
要显示单个语法组的所有语法项目: 
<code class="example"></code>
<code class="example">    :sy[ntax] list {group-name}</code>
<code class="example"></code>
要列出单个簇的所有语法组:                                       <b class="vimtag"> <a name="E392">E392</a> </b>  
<code class="example"></code>
<code class="example">    :sy[ntax] list @{cluster-name}</code>
<code class="example"></code>
":syntax" 命令的其它参数见上。

<code class="note">注意</code> ":syntax" 命令可以简化成 ":sy"，不过 ":syn" 更常用，因为看起来更舒服点。

</section><hr class="doubleline" /><section class=inner>
<h4>13. Colorschemes                                <b class="vimtag"> <a name="color-schemes">color-schemes</a> </b></h4>
下一小节介绍如何为个别高亮组找到相关信息以及指定颜色。其实你更有可能只想用
 <a href="syntax.html#:colorscheme">:colorscheme</a>  命令选择一组颜色，例如: 
<code class="example"></code>
<code class="example">            colorscheme pablo</code>

                                                <b class="vimtag"> <a name=":colo">:colo</a> </b> <b class="vimtag"> <a name=":colorscheme">:colorscheme</a> </b> <b class="vimtag"> <a name="E185">E185</a> </b>
:colo[rscheme]          输出当前激活的色彩方案名。基本上等同 
<code class="example">                                :echo g:colors_name</code>
                        如果 g:colors_name 没有定义 :colo 会输出 "default"。如
                        果编译时没有带  <a href="various.html#+eval">+eval</a>  特性，输出 "unknown"。

:colo[rscheme] <code class="special">{name}</code>   载入色彩方案 <code class="special">{name}</code>。它会在 <a href="options.html#'runtimepath'">'runtimepath'</a> 里搜索
                        "colors/<code class="special">{name}</code>.vim"，载入第一个找到的文件。
                        也在 <a href="options.html#'packpath'">'packpath'</a> 中的所有插件里寻找，先在 "start" 下，
                        然后在 "opt" 下查找。

                        它不能递归调用，所以你不能在色彩方案脚本里使用
                        ":colorscheme"。

要定制色彩方案，你有两个选项。要修改特定色彩的外观，可在载入方案前重新定义某色
彩名。dsert 方案中光标用 khaki 色。要使用同一色彩的更深版本: 
<code class="example"></code>
<code class="example">        let v:colornames['khaki'] = '#bdb76b'</code>
<code class="example">        colorscheme desert</code>

要进一步定制，如修改   <a href="syntax.html#:highlight-link">:highlight-link</a>  关联，用新名，如
"~/.vim/colors/mine.vim"，并用  <a href="repeat.html#:runtime">:runtime</a>  载入原来的色彩方案: 
<code class="example">        runtime colors/evening.vim</code>
<code class="example">        hi Statement ctermfg=Blue guifg=Blue</code>
<code class="example"></code>
色彩方案载入前，先执行所有的缺省色彩列表脚本 ( <code class="badlink">colors/lists/default.vim</code> ) 然后
激活  <a href="autocmd.html#ColorSchemePre">ColorSchemePre</a>  自动命令事件。色彩方案载入后，激活  <a href="autocmd.html#ColorScheme">ColorScheme</a>  自动命
令事件。

                                                <b class="vimtag"> <a name="colorscheme-override">colorscheme-override</a> </b>
如果色彩方案基本满意，可用  <a href="autocmd.html#ColorScheme">ColorScheme</a>  自动命令在其上做少量修改。例如，要删
除背景色 (在某些终端中这可使之透明): 
<code class="example">        augroup my_colorschemes</code>
<code class="example">          au!</code>
<code class="example">          au Colorscheme pablo hi Normal ctermbg=NONE</code>
<code class="example">        augroup END</code>
<code class="example"></code>
多修改一些色彩: 
<code class="example">        augroup my_colorschemes</code>
<code class="example">          au!</code>
<code class="example">          au Colorscheme pablo hi Normal ctermbg=NONE</code>
<code class="example">                      \ | highlight Special ctermfg=63</code>
<code class="example">                      \ | highlight Identifier ctermfg=44</code>
<code class="example">        augroup END</code>
<code class="example"></code>
如果要做大量修改，最好把发布的色彩方案复制到你自己的主目录并作修改: 
<code class="example">        :!cp $VIMRUNTIME/colors/pablo.vim ~/.vim/colors</code>
<code class="example">        :edit ~/.vim/colors/pablo.vim</code>
<code class="example"></code>
Vim 9.0 更新了色彩方案的列表，使之能在许多不同的终端上工作。一个修改常常是定义
Normal 高亮组以确保色彩完美。如果你还是喜欢旧版本，可以在这里找到:
<a href="https://github.com/vim/colorschemes/blob/master/legacy_colors/">https://github.com/vim/colorschemes/blob/master/legacy_colors/</a>

关于如何编写色彩方案文件的信息: 
<code class="example">        :edit $VIMRUNTIME/colors/README.txt</code>
<code class="example"></code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>14. Highlight 命令                      <b class="vimtag"> <a name=":highlight">:highlight</a> </b> <b class="vimtag"> <a name=":hi">:hi</a> </b> <b class="vimtag"> <a name="E28">E28</a> </b> <b class="vimtag"> <a name="E411">E411</a> </b> <b class="vimtag"> <a name="E415">E415</a> </b></h4>
有三种类型的高亮组:
- 用于特定语言的。这些组的名字以该语言的名字开始。它们中很多没有属性，而是链接
  到第二种类型的组。
- 用于所有语法语言的。
- 用于 <a href="options.html#'highlight'">'highlight'</a> 选项的。
                                                        <b class="vimtag"> <a name="hitest.vim">hitest.vim</a> </b>
用这个命令，你可以看到当前激活的所有组: 
<code class="example">    :so $VIMRUNTIME/syntax/hitest.vim</code>
它会打开一个新窗口，其中包含所有的高亮组名，以它们本身的颜色显示。

:hi[ghlight]            列出当前所有的有属性设置的高亮组。

:hi[ghlight] <code class="special">{group-name}</code>
                        列出一个高亮组。

                                                <b class="vimtag"> <a name="highlight-clear">highlight-clear</a> </b> <b class="vimtag"> <a name=":hi-clear">:hi-clear</a> </b>
:hi[ghlight] clear      复位高亮设置为缺省值。删除用户增加的所有组的高亮属性。
                        用当前的 <a href="options.html#'background'">'background'</a> 的值来决定所使用的缺省颜色。
                        如果有缺省链接，恢复之。 <a href="syntax.html#:hi-link">:hi-link</a> 

:hi[ghlight] clear <code class="special">{group-name}</code>
:hi[ghlight] <code class="special">{group-name}</code> NONE
                        屏蔽一个高亮组的所有高亮设置。并 <code class="emphasis">不</code> 复原缺省的颜色。

:hi[ghlight] <code class="special">[default]</code> <code class="special">{group-name}</code> <code class="special">{key}</code>=<code class="special">{arg}</code> ..
                        增加高亮组，或者更改已有的组高亮设置。如果给出的色彩名
                        不能识别，载入每个  <a href="options.html#'runtimepath'">'runtimepath'</a>  里找到的
                         <code class="badlink">colors/lists/default.vim</code> 。
                         <a href="syntax.html#highlight-args">highlight-args</a>  说明 <code class="special">{key}</code>=<code class="special">{arg}</code> 的参数。
                         <a href="syntax.html#:highlight-default">:highlight-default</a>  说明可选的 <code class="special">[default]</code> 参数。

通常，在启动时加入高亮组。它设置高亮的缺省值。在这之后，你可以使用附加的
highlight 命令来修改你希望设置为非缺省值的参数。也可以用 "NONE" 来撤销某个值并
恢复缺省的值。

修改颜色的简单方式是  <a href="syntax.html#:colorscheme">:colorscheme</a>  命令。它载入一个文件，里面包含了这样的
":highlight" 命令: 
<code class="example"></code>
<code class="example">   :hi Comment  gui=bold</code>

<code class="note">注意</code> 所有没有包含在内的设置都保持原样，只使用指定的字段，从而和以前的设置进行
了合并。所以实际结果就像用了下面这样的一条命令: 
<code class="example">   :hi Comment  term=bold ctermfg=Cyan guifg=#80a0ff gui=bold</code>

                                                        <b class="vimtag"> <a name=":highlight-verbose">:highlight-verbose</a> </b>
如果列出高亮组时 <a href="options.html#'verbose'">'verbose'</a> 非零，同时列出高亮组最近在哪里设置。例如: 
<code class="example">        :verbose hi Comment</code>
<code class="section">        Comment        xxx term=bold ctermfg=4 guifg=Blue </code>
<code class="section">           Last set from /home/mool/vim/vim7/runtime/syntax/syncolor.vim </code>

如果使用了 ":hi clear"，那么列出缺省值的同时提到使用该命令的脚本。详见
 <a href="various.html#:verbose-cmd">:verbose-cmd</a> 。

                                        <b class="vimtag"> <a name="highlight-args">highlight-args</a> </b> <b class="vimtag"> <a name="E416">E416</a> </b> <b class="vimtag"> <a name="E417">E417</a> </b> <b class="vimtag"> <a name="E423">E423</a> </b>
用于高亮，有三种类型的终端:
term    普通的终端 (vt100、xterm)
cterm   色彩终端 (MS-Windows 控制台、color-xterm，带有 "Co" termcap 项目的终
        端)
gui     GUI

每种类型可以分别设置高亮属性。这样，单个语法文件就可用于所有的终端，并使用每个
终端最优的高亮设置。

1. 普通终端的高亮参数

                                        <b class="vimtag"> <a name="bold">bold</a> </b> <b class="vimtag"> <a name="underline">underline</a> </b> <b class="vimtag"> <a name="undercurl">undercurl</a> </b>
                                        <b class="vimtag"> <a name="underdouble">underdouble</a> </b> <b class="vimtag"> <a name="underdotted">underdotted</a> </b>
                                        <b class="vimtag"> <a name="underdashed">underdashed</a> </b> <b class="vimtag"> <a name="inverse">inverse</a> </b> <b class="vimtag"> <a name="italic">italic</a> </b>
                                        <b class="vimtag"> <a name="standout">standout</a> </b> <b class="vimtag"> <a name="nocombine">nocombine</a> </b> <b class="vimtag"> <a name="strikethrough">strikethrough</a> </b>
term=<code class="special">{attr-list}</code>                        <b class="vimtag"> <a name="attr-list">attr-list</a> </b> <b class="vimtag"> <a name="highlight-term">highlight-term</a> </b> <b class="vimtag"> <a name="E418">E418</a> </b>
        attr-list 是逗号分隔的下述项目 (不能有空格) 的列表 (任何顺序都可以):
                bold
                underline
                undercurl       不一定总是可用
                underdouble     不一定总是可用
                underdotted     不一定总是可用
                underdashed     不一定总是可用
                strikethrough   不一定总是可用
                reverse
                inverse         同 reverse
                italic
                standout
                nocombine       覆盖属性而不是混合属性
                NONE            不使用属性 (用于复位)

        <code class="note">注意</code> 这里使用 "bold" 和使用粗体字体都可以，效果相同。
                                                        <b class="vimtag"> <a name="underline-codes">underline-codes</a> </b>
        "undercurl" 是波浪状的下划线。如果 "undercurl" 不可用，用 "underline"
        代替。一般而言，只有 GUI 和部分终端才能使用 "undercurl" 和
        "strikethrough"。其颜色可用  <a href="syntax.html#highlight-guisp">highlight-guisp</a>  或  <a href="syntax.html#highlight-ctermul">highlight-ctermul</a> 
        设置。终端中，可以尝试以下 termcap 项目来使用波浪下划线: 
<code class="example">            let &amp;t_Cs = "\e[4:3m"</code>
<code class="example">            let &amp;t_Ce = "\e[4:0m"</code>
<code class="example"></code>
        "underdouble" 是双下划线，"underdotted" 是点状的下划线，而
        "underdashed" 是虚线的下划线。它们只有部分终端支持。如果你的终端支持，
        可以如此指定代码: 
<code class="example">            let &amp;t_Us = "\e[4:2m"</code>
<code class="example">            let &amp;t_ds = "\e[4:4m"</code>
<code class="example">            let &amp;t_Ds = "\e[4:5m"</code>
         <a href="term.html#t_Ce">t_Ce</a>  重设所有这些，这和波浪状的下划线 (undercurl) 用的一样。
        如果 t_Us、t_ds 或 t_Ds 没有设置，underline 用作后备。



start=<code class="special">{term-list}</code>                               <b class="vimtag"> <a name="highlight-start">highlight-start</a> </b> <b class="vimtag"> <a name="E422">E422</a> </b>
stop=<code class="special">{term-list}</code>                                <b class="vimtag"> <a name="term-list">term-list</a> </b> <b class="vimtag"> <a name="highlight-stop">highlight-stop</a> </b>
        可以得到终端上的非标准的属性的终端代码的列表。

        "start" 参数指定的转义码序列在高亮区域的字符之前被写入，它可以是你希望
        给终端发送的用于高亮区域的任何内容。"stop" 参数指定的转义码序列在高亮
        区域之后被写入，它可以撤销 "start" 参数的效果。否则屏幕会被弄乱。

        <code class="special">{term-list}</code> 可有两种形式:

        1. 转义序列的字符串。
           可以是任何字符的序列，除了不能以 "t_" 开始而且不能有空格之外。这里
           识别 <code class="special">&lt;&gt;</code> 记法。所以你可使用 "<code class="special">&lt;Esc&gt;</code>" 和 "<code class="special">&lt;Space&gt;</code>"。例如:
                start=<code class="special">&lt;Esc&gt;</code>[27h;<code class="special">&lt;Esc&gt;</code>[<code class="special">&lt;Space&gt;</code>r;

        2. 终端代码的列表。
           终端代码的形式是 "t_xx" ，其中 "xx" 是 termcap 项目的名字。这些代码
           必须以逗号分隔，而且不允许有空格。例如:
                start=t_C1,t_BL
           要使之工作，这些终端代码必须存在。


2. 色彩终端的高亮参数

cterm=<code class="special">{attr-list}</code>                                       <b class="vimtag"> <a name="highlight-cterm">highlight-cterm</a> </b>
        <code class="special">{attr-list}</code>  <a href="syntax.html#attr-list">attr-list</a>  的描述见上。"cterm" 参数可以和 "term" 不同，比
        如可以使用颜色。例如，在普通的终端上注释可以用下划线表示，在色彩终端上
        可以用蓝色显示。
        <code class="note">注意</code>: 有些终端 (例如，DOS 控制台) 不能混合使用颜色和这些属性。为可移植
        性，只用 "cterm=" 或者 "ctermfg=" 与 "ctermbg=" 两者之一。

ctermfg=<code class="special">{color-nr}</code>                              <b class="vimtag"> <a name="highlight-ctermfg">highlight-ctermfg</a> </b> <b class="vimtag"> <a name="E421">E421</a> </b>
ctermbg=<code class="special">{color-nr}</code>                              <b class="vimtag"> <a name="highlight-ctermbg">highlight-ctermbg</a> </b>
ctermul=<code class="special">{color-nr}</code>                              <b class="vimtag"> <a name="highlight-ctermul">highlight-ctermul</a> </b>
        这些参数指定给终端使用的前景 (ctermfg)、背景 (ctermbg) 和下划线
        (ctermul) 颜色。

        <code class="special">{color-nr}</code> 参数指定颜色号。其范围从零到 termcap 项目 "Co" 给出的数字
        (不含)。实际的颜色取决于终端的类型和设置。有时，颜色也取决于 "cterm"
        的值。例如，有的系统上 "cterm=bold ctermfg=3" 给出另外一个颜色，别的系
        统上你只会得到颜色 3。

        xterm 上，它取决于你的资源，这并不容易预测。你的 xterm 文档会说明缺省
        值。color-xterm 的颜色可以通过 .Xdefaults 文件修改。不幸的是，这意味着
        每个用户未必会得到完全相同的颜色。 <a href="syntax.html#xterm-color">xterm-color</a>  提供带色彩的 xterm 的
        信息。
                                                        <b class="vimtag"> <a name="tmux">tmux</a> </b>
        用 tmux 时可在 tmux config 里: 
<code class="example">            # tmux colors</code>
<code class="example">            set -s default-terminal "tmux-256color"</code>
<code class="example">            set -as terminal-overrides ",*-256color:Tc"</code>
        详情可见:
        <a href="https://github.com/tmux/tmux/wiki/FAQ#how-do-i-use-a-256-colour-terminal">https://github.com/tmux/tmux/wiki/FAQ#how-do-i-use-a-256-colour-terminal</a>
        <a href="https://github.com/tmux/tmux/wiki/FAQ#how-do-i-use-rgb-colour">https://github.com/tmux/tmux/wiki/FAQ#how-do-i-use-rgb-colour</a>

        MS-Windows 的标准颜色是固定的 (在控制窗口上)，所以我们用这些名字。在
        X11 上，颜色名字的含义是固定的，所以我们用这些颜色设置，以使高亮设置可
        移植 (是不是很复杂？)。下面列出这些被识别的名字和所使用的颜色号:

                                                        <b class="vimtag"> <a name="cterm-colors">cterm-colors</a> </b>
<code class="section">            NR-16   NR-8    颜色名 </code>
            0       0       Black (黑)
            1       4       DarkBlue (深蓝)
            2       2       DarkGreen (深绿)
            3       6       DarkCyan (深青)
            4       1       DarkRed (深红)
            5       5       DarkMagenta (深品红)
            6       3       Brown，DarkYellow (褐、深黄)
            7       7       LightGray、LightGrey，Gray，Grey (浅灰)
            8       0*      DarkGray，DarkGrey (深灰)
            9       4*      Blue，LightBlue (浅蓝)
            10      2*      Green，LightGreen (浅绿)
            11      6*      Cyan，LightCyan (浅青)
            12      1*      Red，LightRed (浅品红)
            13      5*      Magenta，LightMagenta (浅红)
            14      3*      Yellow，LightYellow (浅黄)
            15      7*      White (白)

        "NR-16" 下的数字用于 16 色的终端 (<a href="term.html#'t_Co'">'t_Co'</a> 大于等于 16)。"NR-8" 下的数字
        用于 8 色终端 (<a href="term.html#'t_Co'">'t_Co'</a> 小于 16)。'*' 表明 ctermfg 使用的时候设置 bold
        属性。在许多 8 色终端上 (比如，"linux")，它会显示增亮的颜色。但这不适
        用于背景色。如果没有 '*'，则不包含 bold 属性。如果你想用不同的方式设置
        bold 属性，在 "ctermfg=" 或 "ctermbg=" 参数 <code class="emphasis">之后</code> 设置 "cterm=" 参数。
        或者使用数字，而不是颜色名。

        忽略颜色名的大小写。
        <code class="note">注意</code> 16 色 ansi 风格的终端 (包括 xterm) 使用 NR-8 一列的数字。这里，
        '*' 意味着 '加 8'，所以 Blue 成了 12，DarkGray 是 8，依此类推。

        <code class="note">注意</code> 有些色彩终端下，这些名字可能会产生错误的颜色！

        也可用 "NONE" 来删除颜色。

                                                        <b class="vimtag"> <a name=":hi-normal-cterm">:hi-normal-cterm</a> </b>
        Normal 组设置的 "ctermfg" 或 "ctermbg" 颜色成为非高亮文本使用的颜色。
        例如: 
<code class="example">                :highlight Normal ctermfg=grey ctermbg=darkblue</code>
        设置 Normal 组的 "ctermbg" 颜色时，假定此颜色能识别而 <a href="options.html#'background'">'background'</a> 还
        未显式设置过，会自动设置 <a href="options.html#'background'">'background'</a> 选项。这使得依赖于 <a href="options.html#'background'">'background'</a>
        的高亮组会发生改变！这意味着，你应该先设置 Normal 的颜色，然后再设置其
        它的。
        已经使用色彩方案的时候，修改 <a href="options.html#'background'">'background'</a> 使之被重新载入，这会复位所有
        颜色 (包括 Normal)。如果你不希望如此，先删除 "g:colors_name" 变量。

        如果你给 Normal 组设置了 "ctermfg" 或 "ctermbg"，Vim 退出时需要复位颜
        色，这通过 "op" termcap 项目  <a href="term.html#t_op">t_op</a>  完成。如果不能正确工作，尝试在你的
        .vimrc 里设置 <a href="term.html#'t_op'">'t_op'</a> 选项。
                                                        <b class="vimtag"> <a name="E419">E419</a> </b> <b class="vimtag"> <a name="E420">E420</a> </b> <b class="vimtag"> <a name="E453">E453</a> </b>
        如果 Vim 知道 Normal 的前景、背景和下划线色，"fg"、"bg" 和 "ul" 可以用
        作色彩名。这只有在 Normal 组的颜色设置以后和 (<code class="vim">译者注</code>: 或？) 在
        MS-Windows 控制台上才可以。比如，要设置反显视频: 
<code class="example">            :highlight Visual ctermfg=bg ctermbg=fg</code>
        <code class="note">注意</code> 使用的颜色是在给出命令时的合法颜色。如果之后 Normal 组的颜色发生
        改变，"fg" 和 "bg" 颜色不会被调整。


3. GUI 的高亮参数

gui=<code class="special">{attr-list}</code>                                         <b class="vimtag"> <a name="highlight-gui">highlight-gui</a> </b>
        给出 GUI 模式适用的属性。具体描述见  <a href="syntax.html#attr-list">attr-list</a> 。
        <code class="note">注意</code> 这里可以使用 "bold"，也可以使用粗体字体。效果相同。
        <code class="note">注意</code> "Normal" 组的属性被忽略。

font=<code class="special">{font-name}</code>                                        <b class="vimtag"> <a name="highlight-font">highlight-font</a> </b>
        font-name 是字体的名字，根据 Vim 运行所在的系统而定。X11 而言，它是一
        个复杂的名字。比如: 
<code class="example">   font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1</code>

        字体名 "NONE" 可以用来恢复到缺省字体。如果为 "Normal" 组设置字体，该字
        体成为缺省字体 (直到改变了 <a href="options.html#'guifont'">'guifont'</a> 选项为止；使用最后设置的那个)。
        以下说明只适用于 Motif，不包括其它 GUI:
        设置 "Menu" 组的字体会改变菜单。设置 "Tooltip" 组的字体会改变工具提
        示。除了 Menu 和 Tooltip 的所有使用的字体必须和缺省字体的字符大小相
        同。否则，重画时会有问题。
        要用含有内嵌空格或其它特殊字符的字体名，把名字放在单引号内。因而，不能
        使用单引号本身。
        例如: 
<code class="example">            :hi comment font='Monospace 10'</code>
<code class="example"></code>
guifg=<code class="special">{color-name}</code>                                      <b class="vimtag"> <a name="highlight-guifg">highlight-guifg</a> </b>
guibg=<code class="special">{color-name}</code>                                      <b class="vimtag"> <a name="highlight-guibg">highlight-guibg</a> </b>
guisp=<code class="special">{color-name}</code>                                      <b class="vimtag"> <a name="highlight-guisp">highlight-guisp</a> </b>
        给出 GUI 使用的前景色 (guifg)、背景色 (guibg) 和特殊颜色 (guisp)。
        "guisp" 用于 undercurl 和 strikethrough。
        可用一些特殊的名字:
                NONE            没有颜色 (透明)         <b class="vimtag"> <a name="E1361">E1361</a> </b>
                bg              使用 Normal 的背景色
                background      使用 Normal 的背景色
                fg              使用 Normal 的前景色
                foreground      使用 Normal 的前景色
        要使用有内嵌空格或者其它特殊字符的颜色名，把它放在单引号里面。这时，不
        能使用单引号。例如: 
<code class="example">            :hi comment guifg='salmon pink'</code>

                                                        <b class="vimtag"> <a name="gui-colors">gui-colors</a> </b>
        建议的颜色名 (可用于多数系统):
            Red         LightRed        DarkRed
            Green       LightGreen      DarkGreen       SeaGreen
            Blue        LightBlue       DarkBlue        SlateBlue
            Cyan        LightCyan       DarkCyan
            Magenta     LightMagenta    DarkMagenta
            Yellow      LightYellow     Brown           DarkYellow
            Gray        LightGray       DarkGray
            Black       White
            Orange      Purple          Violet

        Win32 GUI 版本可以使用更多的系统颜色。见  <a href="gui_w32.html#win32-colors">win32-colors</a> 。

        你可以用红、绿、蓝的色值指定颜色。格式为 "#rrggbb"，其中
                "rr"    为红色值
                "bb"    为蓝色值
                "gg"    为绿色值
        所有的值都以十六进制表示，范围是 "00" 到 "ff"。例如: 
<code class="example">            :highlight Comment guifg=#11f0c3 guibg=#ff00ff</code>

        如果你是色彩方案的作者而且频繁使用相同的十六进制颜色，可为此在
         <a href="eval.html#v:colornames">v:colornames</a>  里定义一个名字。例如: 
<code class="example"></code>
<code class="example">            # 提供此色彩的缺省值，但允许用户覆盖之。</code>
<code class="example">            :call extend(v:colornames, {'alt_turquoise': '#11f0c3'}, 'keep')</code>
<code class="example">            :highlight Comment guifg=alt_turquoise guibg=magenta</code>

        如果使用依赖于命名色彩的色彩方案，而你又想调节那些颜色的具体外观，可在
        载入方案前覆盖  <a href="eval.html#v:colornames">v:colornames</a>  里的值: 
<code class="example"></code>
<code class="example">            let v:colornames['alt_turquoise'] = '#22f0d3'</code>
<code class="example">            colorscheme alt</code>

        如果你要开发被他人依赖的色彩列表，最好给你的色彩名加上前缀。惯例是把这
        些色彩列表放在 colors/lists 目录里。具体例子可见
        '$VIMRUNTIME/colors/lists/csscolors.vim'。色彩方案里可载入此列表: 
<code class="example"></code>
<code class="example">            :runtime colors/lists/csscolors.vim</code>
<code class="example">            :highlight Comment guifg=css_turquoise</code>


                                        <b class="vimtag"> <a name="highlight-groups">highlight-groups</a> </b> <b class="vimtag"> <a name="highlight-default">highlight-default</a> </b>
有一些缺省的高亮组。<a href="options.html#'highlight'">'highlight'</a> 选项缺省使用这些组。<code class="note">注意</code> 高亮取决于
<a href="options.html#'background'">'background'</a> 的值。你可以用 ":highlight" 命令看到当前的设置。
下表中色彩使用其本身高亮。如果不可读的话，试试可视选择。

                                                        <b class="vimtag"> <a name="hl-ColorColumn">hl-ColorColumn</a> </b>
ColorColumn     用于 <a href="options.html#'colorcolumn'">'colorcolumn'</a> 设置的列。
                                                        <b class="vimtag"> <a name="hl-Conceal">hl-Conceal</a> </b>
Conceal         代替隐藏文本的填充字符 (见 <a href="options.html#'conceallevel'">'conceallevel'</a>)。
                                                <b class="vimtag"> <a name="hl-Cursor">hl-Cursor</a> </b> <b class="vimtag"> <a name="hl-lCursor">hl-lCursor</a> </b>
Cursor          光标所在的字符。
lCursor         使用  <a href="map.html#language-mapping">language-mapping</a>  时光标所在的字符 (见 <a href="options.html#'guicursor'">'guicursor'</a>)。
                                                        <b class="vimtag"> <a name="hl-CursorIM">hl-CursorIM</a> </b>
CursorIM        类似于 Cursor，但用于 IME 模式。 <a href="mbyte.html#CursorIM">CursorIM</a> 
                                                        <b class="vimtag"> <a name="hl-CursorColumn">hl-CursorColumn</a> </b>
CursorColumn    置位 <a href="options.html#'cursorcolumn'">'cursorcolumn'</a> 时，光标所在的屏幕列。
                                                        <b class="vimtag"> <a name="hl-CursorLine">hl-CursorLine</a> </b>
CursorLine      置位 <a href="options.html#'cursorline'">'cursorline'</a> 时，光标所在的屏幕行。
                                                        <b class="vimtag"> <a name="hl-Directory">hl-Directory</a> </b>
Directory       目录名 (还有列表里的其它特殊名字)。
                                                        <b class="vimtag"> <a name="hl-DiffAdd">hl-DiffAdd</a> </b>
DiffAdd         比较模式: 增加的行。 <a href="diff.html#diff.txt">diff.txt</a> 
                                                        <b class="vimtag"> <a name="hl-DiffChange">hl-DiffChange</a> </b>
DiffChange      比较模式: 改变的行。 <a href="diff.html#diff.txt">diff.txt</a> 
                                                        <b class="vimtag"> <a name="hl-DiffDelete">hl-DiffDelete</a> </b>
DiffDelete      比较模式: 删除的行。 <a href="diff.html#diff.txt">diff.txt</a> 
                                                        <b class="vimtag"> <a name="hl-DiffText">hl-DiffText</a> </b>
DiffText        比较模式: 改变行里的改动文本。 <a href="diff.html#diff.txt">diff.txt</a> 
                                                        <b class="vimtag"> <a name="hl-EndOfBuffer">hl-EndOfBuffer</a> </b>
EndOfBuffer     缓冲区的末行之后的填充行 (~)。缺省用  <a href="syntax.html#hl-NonText">hl-NonText</a>  类似的高亮。
                                                        <b class="vimtag"> <a name="hl-ErrorMsg">hl-ErrorMsg</a> </b>
ErrorMsg        命令行上的错误信息。
                                                        <b class="vimtag"> <a name="hl-VertSplit">hl-VertSplit</a> </b>
VertSplit       分离垂直分割窗口的列。
                                                        <b class="vimtag"> <a name="hl-Folded">hl-Folded</a> </b>
Folded          用于关闭的折叠的行。
                                                        <b class="vimtag"> <a name="hl-FoldColumn">hl-FoldColumn</a> </b>
FoldColumn      <a href="options.html#'foldcolumn'">'foldcolumn'</a>
                                                        <b class="vimtag"> <a name="hl-SignColumn">hl-SignColumn</a> </b>
SignColumn      显示  <a href="sign.html#signs">signs</a>  的列。
                                                        <b class="vimtag"> <a name="hl-IncSearch">hl-IncSearch</a> </b>
IncSearch       <a href="options.html#'incsearch'">'incsearch'</a> 高亮；也用于被 ":s///c" 替换的文本。
                                                        <b class="vimtag"> <a name="hl-LineNr">hl-LineNr</a> </b>
LineNr          ":number" 和 ":#" 命令与置位 <a href="options.html#'number'">'number'</a> 或 <a href="options.html#'relativenumber'">'relativenumber'</a> 选项
                时的行号。
                                                        <b class="vimtag"> <a name="hl-LineNrAbove">hl-LineNrAbove</a> </b>
LineNrAbove     置位 <a href="options.html#'relativenumber'">'relativenumber'</a> 选项时，光标上方的行号。
                                                        <b class="vimtag"> <a name="hl-LineNrBelow">hl-LineNrBelow</a> </b>
LineNrBelow     置位 <a href="options.html#'relativenumber'">'relativenumber'</a> 选项时，光标下方的行号。
                                                        <b class="vimtag"> <a name="hl-CursorLineNr">hl-CursorLineNr</a> </b>
CursorLineNr    和 LineNr 类似，置位 <a href="options.html#'cursorline'">'cursorline'</a> 且 <a href="options.html#'cursorlineopt'">'cursorlineopt'</a> 设为
                "number" 或 "both" 时，用于光标行。
                                                        <b class="vimtag"> <a name="hl-CursorLineFold">hl-CursorLineFold</a> </b>
CursorLineFold  和 FoldColumn 类似，置位  <a href="options.html#'cursorline'">'cursorline'</a> 时用于光标行。
                                                        <b class="vimtag"> <a name="hl-CursorLineSign">hl-CursorLineSign</a> </b>
CursorLineSign  和 SignColumn 类似，置位  <a href="options.html#'cursorline'">'cursorline'</a> 时用于光标行。
                                                        <b class="vimtag"> <a name="hl-MatchParen">hl-MatchParen</a> </b>
MatchParen      如果光标所在或刚刚在它之前的字符是配对的括号一部分的话，它和它
                的配对。 <a href="pi_paren.html#pi_paren.txt">pi_paren.txt</a> 

                                                        <b class="vimtag"> <a name="hl-MessageWindow">hl-MessageWindow</a> </b>
MessageWindow    <a href="eval.html#:echowindow">:echowindow</a>  使用的信息弹出窗口。如无定义，使用
                 <a href="syntax.html#hl-WarningMsg">hl-WarningMsg</a> 。
                                                        <b class="vimtag"> <a name="hl-ModeMsg">hl-ModeMsg</a> </b>
ModeMsg         <a href="options.html#'showmode'">'showmode'</a> 消息 (例如，"-- INSERT --")。
                                                        <b class="vimtag"> <a name="hl-MoreMsg">hl-MoreMsg</a> </b>
MoreMsg          <a href="message.html#more-prompt">more-prompt</a> 
                                                        <b class="vimtag"> <a name="hl-NonText">hl-NonText</a> </b>
NonText         窗口尾部的 '@'、用于 <a href="options.html#'smoothscroll'">'smoothscroll'</a> 在窗口开始处的 "&lt;&lt;&lt;"、
                <a href="options.html#'showbreak'">'showbreak'</a> 的字符和其它在文本里实际不存在的字符，如代替行尾放
                不下的双宽字符而显示的 "&gt;"。
                                                        <b class="vimtag"> <a name="hl-Normal">hl-Normal</a> </b>
Normal          普通文本。
                                                        <b class="vimtag"> <a name="hl-Pmenu">hl-Pmenu</a> </b>
Pmenu           弹出菜单: 普通项目。
                                                        <b class="vimtag"> <a name="hl-PmenuSel">hl-PmenuSel</a> </b>
PmenuSel        弹出菜单: 选中项目。
                                                        <b class="vimtag"> <a name="hl-PmenuKind">hl-PmenuKind</a> </b>
PmenuKind       弹出菜单: 普通项目 "kind"。
                                                        <b class="vimtag"> <a name="hl-PmenuKindSel">hl-PmenuKindSel</a> </b>
PmenuKindSel    弹出菜单: 选中项目 "kind"。
                                                        <b class="vimtag"> <a name="hl-PmenuExtra">hl-PmenuExtra</a> </b>
PmenuExtra      弹出菜单: 普通项目 "extra text"。
                                                        <b class="vimtag"> <a name="hl-PmenuExtraSel">hl-PmenuExtraSel</a> </b>
PmenuExtraSel   弹出菜单: 选中项目 "extra text"。
                                                        <b class="vimtag"> <a name="hl-PmenuSbar">hl-PmenuSbar</a> </b>
PmenuSbar       弹出菜单: 滚动条。
                                                        <b class="vimtag"> <a name="hl-PmenuThumb">hl-PmenuThumb</a> </b>
PmenuThumb      弹出菜单: 滚动条的拇指 (thumb)。
                                                        <b class="vimtag"> <a name="hl-PopupNotification">hl-PopupNotification</a> </b>
PopupNotification
                  <a href="popup.html#popup_notification()">popup_notification()</a>  创建的弹出窗口。如无定义，使用
                 <a href="syntax.html#hl-WarningMsg">hl-WarningMsg</a> 。
                                                        <b class="vimtag"> <a name="hl-Question">hl-Question</a> </b>
Question         <a href="message.html#hit-enter">hit-enter</a>  提示和 yes/no 问题。
                                                        <b class="vimtag"> <a name="hl-QuickFixLine">hl-QuickFixLine</a> </b>
QuickFixLine    快速修复窗口的当前  <a href="quickfix.html#quickfix">quickfix</a>  项目。
                                                        <b class="vimtag"> <a name="hl-Search">hl-Search</a> </b>
Search          最近搜索模式的高亮 (见 <a href="options.html#'hlsearch'">'hlsearch'</a>)。
                也用于类似的要突出显示的项目。
                                                        <b class="vimtag"> <a name="hl-CurSearch">hl-CurSearch</a> </b>
CurSearch       最近搜索模式的当前匹配 (见 <a href="options.html#'hlsearch'">'hlsearch'</a>)。
                <code class="note">备注</code>: 只在刚搜索后才正确，内容作了修改或屏幕重画后可能会过时。
                                                        <b class="vimtag"> <a name="hl-SpecialKey">hl-SpecialKey</a> </b>
SpecialKey      ":map" 列出的 Meta 和特殊键，也包括文本里不可显示字符的显示和
                <a href="options.html#'listchars'">'listchars'</a>。
                一般的: 和实际内容显示上有差异的文本。
                                                        <b class="vimtag"> <a name="hl-SpellBad">hl-SpellBad</a> </b>
SpellBad        拼写检查器不能识别的单词。 <a href="spell.html#spell">spell</a> 
                它会和本来应该使用的高亮进行组合。
                                                        <b class="vimtag"> <a name="hl-SpellCap">hl-SpellCap</a> </b>
SpellCap        应该大写字母开头的单词。 <a href="spell.html#spell">spell</a> 
                它会和本来应该使用的高亮进行组合。
                                                        <b class="vimtag"> <a name="hl-SpellLocal">hl-SpellLocal</a> </b>
SpellLocal      拼写检查器能识别但只在其它区域使用的单词。 <a href="spell.html#spell">spell</a> 
                它会和本来应该使用的高亮进行组合。
                                                        <b class="vimtag"> <a name="hl-SpellRare">hl-SpellRare</a> </b>
SpellRare       拼写检查器能识别但很少使用的单词。 <a href="spell.html#spell">spell</a> 
                它会和本来应该使用的高亮进行组合。
                                                        <b class="vimtag"> <a name="hl-StatusLine">hl-StatusLine</a> </b>
StatusLine      当前窗口的状态行。
                                                        <b class="vimtag"> <a name="hl-StatusLineNC">hl-StatusLineNC</a> </b>
StatusLineNC    非当前窗口的状态行
                <code class="note">注意</code>: 如果等于 "StatusLine"，Vim 会使用 "^^^" 指示当前窗口的状
                态行。
                                                        <b class="vimtag"> <a name="hl-StatusLineTerm">hl-StatusLineTerm</a> </b>
StatusLineTerm   <a href="terminal.html#terminal">terminal</a>  窗口为当前窗口时的状态行。
                                                        <b class="vimtag"> <a name="hl-StatusLineTermNC">hl-StatusLineTermNC</a> </b>
StatusLineTermNC    <a href="terminal.html#terminal">terminal</a>  窗口不为当前窗口时的状态行。
                                                        <b class="vimtag"> <a name="hl-TabLine">hl-TabLine</a> </b>
TabLine         标签页行，非活动标签页标签。
                                                        <b class="vimtag"> <a name="hl-TabLineFill">hl-TabLineFill</a> </b>
TabLineFill     标签页行，没有标签的地方。
                                                        <b class="vimtag"> <a name="hl-TabLineSel">hl-TabLineSel</a> </b>
TabLineSel      标签页行，活动标签页标签。
                                                        <b class="vimtag"> <a name="hl-Terminal">hl-Terminal</a> </b>
Terminal         <a href="terminal.html#terminal">terminal</a>  窗口 (见  <a href="terminal.html#terminal-size-color">terminal-size-color</a> )。
                                                        <b class="vimtag"> <a name="hl-Title">hl-Title</a> </b>
Title           ":set all"、":autocmd" 等输出的标题。
                                                        <b class="vimtag"> <a name="hl-Visual">hl-Visual</a> </b>
Visual          可视模式的选择区。
                                                        <b class="vimtag"> <a name="hl-VisualNOS">hl-VisualNOS</a> </b>
VisualNOS       Vim 是 "选择区的非拥有者" 时，可视模式的选择区。只有 X11 GUI
                的  <a href="gui_x11.html#gui-x11">gui-x11</a>  和  <a href="term.html#xterm-clipboard">xterm-clipboard</a>  才提供此支持。
                                                        <b class="vimtag"> <a name="hl-WarningMsg">hl-WarningMsg</a> </b>
WarningMsg      <code class="note">警告</code>消息。
                                                        <b class="vimtag"> <a name="hl-WildMenu">hl-WildMenu</a> </b>
WildMenu        <a href="options.html#'wildmenu'">'wildmenu'</a> 补全的当前匹配。

                                        <b class="vimtag"> <a name="hl-User1">hl-User1</a> </b> <b class="vimtag"> <a name="hl-User1..9">hl-User1..9</a> </b> <b class="vimtag"> <a name="hl-User9">hl-User9</a> </b>
<a href="options.html#'statusline'">'statusline'</a> 语法允许在状态行和标尺 (通过 <a href="options.html#'rulerformat'">'rulerformat'</a>) 上使用 9 种不同的高
亮。这些高亮组的名字是 User1 到 User9。

GUI 里，你可以使用以下这些组来设置菜单、滚动条和工具提示的色彩。它们没有缺省
值。这不适用于 Win32 GUI。这里，只有三种高亮参数有效: font、guibg 和 guifg。

                                                        <b class="vimtag"> <a name="hl-Menu">hl-Menu</a> </b>
Menu            当前菜单的字体、背景色和前景色。也包括工具栏。
                可用的高亮参数: font、guibg、guifg。

                <code class="note">注意</code>: Motif 里，font 参数在所有情况下实际上指定字体集
                (fontset)，不管 <a href="options.html#'guifontset'">'guifontset'</a> 是否为空。所以，它和当前的
                 <a href="mlang.html#:language">:language</a>  有关系。

                                                        <b class="vimtag"> <a name="hl-Scrollbar">hl-Scrollbar</a> </b>
Scrollbar       主窗口滚动条的当前背景和前景色。
                可用的高亮参数: guibg、guifg。

                                                        <b class="vimtag"> <a name="hl-Tooltip">hl-Tooltip</a> </b>
Tooltip         当前工具提示的字体、背景色和前景色。也包括工具栏。
                可用的高亮参数: font、guibg、guifg。

                <code class="note">注意</code>: Motif 里，font 参数在所有情况下都指定字体集 (fontset)，
                不管 <a href="options.html#'guifontset'">'guifontset'</a> 是否为空，从而在设置的时候和当前  <a href="mlang.html#:language">:language</a> 
                相联系。

</section><hr class="doubleline" /><section class=inner>
<h4>15. 链接组                      <b class="vimtag"> <a name=":hi-link">:hi-link</a> </b> <b class="vimtag"> <a name=":highlight-link">:highlight-link</a> </b> <b class="vimtag"> <a name="E412">E412</a> </b> <b class="vimtag"> <a name="E413">E413</a> </b></h4>
如果如果你想为几个语法组使用相同的高亮设置，更简单的方法是把这些组链接到一个共
同的高亮组，并且只为该组指定颜色属性。

要设置链接:

    :hi[ghlight][!] <code class="special">[default]</code> link <code class="special">{from-group}</code> <code class="special">{to-group}</code>

要删除链接:

    :hi[ghlight][!] <code class="special">[default]</code> link <code class="special">{from-group}</code> NONE

<code class="note">注意</code>:                                                   <b class="vimtag"> <a name="E414">E414</a> </b>
- 如果 <code class="special">{from-group}</code> 和/或 <code class="special">{to-group}</code> 不存在，先建立之。不存在的组不会给你错误
  信息。
- 一旦你为被链接的组使用 ":highlight" 命令，该链接关系就不存在了。
- 如果已经有 <code class="special">{from-group}</code> 的高亮设置，链接不会建立，除非你给出了 '!'。如果在载
  入的文件里执行 ":highlight link" 命令，你不会得到错误信息。这可以用来跳过已
  有设置的组的链接。

                                        <b class="vimtag"> <a name=":hi-default">:hi-default</a> </b> <b class="vimtag"> <a name=":highlight-default">:highlight-default</a> </b>
用 <code class="special">[default]</code> 参数可以设置组的缺省高亮。如果该组已经设置了高亮，或者已经存在链
接，忽略该命令。

这里， <code class="special">[default]</code> 对否决特定语法文件的高亮特别有用。例如，C 语法文件包含: 
<code class="example">        :highlight default link cComment Comment</code>
如果你喜欢 C 注释像 Question 一样高亮，在你的 vimrc 文件里放入此行: 
<code class="example">        :highlight link cComment Question</code>
如果没有 "default"，执行 C 语法文件后会覆盖你的高亮设置。

部分链接可以不受 `:highlight clear` 影响，这可用于为特定文件类型指定高亮，而选
择不同色彩方案时要保留那些设置。为此，在 "after/syntax/<code class="special">{filetype}</code>.vim" 文件中
放入命令: 
<code class="example">    highlight! default link cComment Question</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>16. 清理                                                <b class="vimtag"> <a name=":syn-clear">:syn-clear</a> </b> <b class="vimtag"> <a name="E391">E391</a> </b></h4>
如果你想为当前缓冲区清除所有的语法设置，可以使用如下命令: 
<code class="example">  :syntax clear</code>
<code class="example"></code>
该命令应该在你想关闭语法高亮或者切换到别的语法时使用。通常，语法文件本身不需要
它。因为载入语法文件的自动命令会清理语法。
该命令也删除 "b:current_syntax" 变量，因为该命令之后没有载入的语法了。

要为当前缓冲区清理特定的语法组: 
<code class="example">  :syntax clear {group-name} ..</code>
它删除了 <code class="special">{group-name}</code> 里所有的模式和关键字。

要为当前缓冲区清理特定的语法组群 (簇): 
<code class="example">  :syntax clear @{grouplist-name} ..</code>
它把 <code class="special">{grouplist-name}</code> 的内容设为空表。

                                                <b class="vimtag"> <a name=":syntax-off">:syntax-off</a> </b> <b class="vimtag"> <a name=":syn-off">:syn-off</a> </b>
如果想为所有的缓冲区关闭语法高亮，你需要删除载入语法文件的自动命令: 
<code class="example">  :syntax off</code>
<code class="example"></code>
该命令实际执行的是命令 
<code class="example">  :source $VIMRUNTIME/syntax/nosyntax.vim</code>
详情见 "nosyntax.vim" 文件。<code class="note">注意</code> 要使它工作，$VIMRUNTIME 必须合法。见
 <a href="starting.html#$VIMRUNTIME">$VIMRUNTIME</a> 。

                                                <b class="vimtag"> <a name=":syntax-reset">:syntax-reset</a> </b> <b class="vimtag"> <a name=":syn-reset">:syn-reset</a> </b>
如果你修改了颜色并且把颜色弄乱了，使用这个命令取回缺省值: 
<code class="example"></code>
<code class="example">  :syntax reset</code>
<code class="example"></code>
这个名字起的不太好，因为它并不复位任何语法项目，而只对高亮有影响。

它不会改变 <a href="options.html#'highlight'">'highlight'</a> 选项的颜色值。

<code class="note">注意</code> 你在 vimrc 文件里设定的语法颜色也会复位成其 Vim 的缺省值。
<code class="note">注意</code> 如果你使用了色彩方案，色彩方案定义的语法高亮的色彩会丢失。

实际上，它做的是: 
<code class="example"></code>
<code class="example">        let g:syntax_cmd = "reset"</code>
<code class="example">        runtime! syntax/syncolor.vim</code>

<code class="note">注意</code> 这里使用了 <a href="options.html#'runtimepath'">'runtimepath'</a> 选项。

                                                        <b class="vimtag"> <a name="syncolor">syncolor</a> </b>
如果想为语法高亮使用不同的色彩，你可以增加一个 Vim 脚本来设置这些颜色。把该文
件放在 <a href="options.html#'runtimepath'">'runtimepath'</a> 里 $VIMRUNTIME 之后的一个目录里，以使你的设置覆盖缺省颜色
值。这样，这些颜色会在 ":syntax reset" 命令之后被使用。

Unix 上你可以使用文件 ~/.vim/after/syntax/syncolor.vim。例如: 
<code class="example"></code>
<code class="example">        if &amp;background == "light"</code>
<code class="example">          highlight comment ctermfg=darkgreen guifg=darkgreen</code>
<code class="example">        else</code>
<code class="example">          highlight comment ctermfg=green guifg=green</code>
<code class="example">        endif</code>

                                                                <b class="vimtag"> <a name="E679">E679</a> </b>
要确信这个 syncolor.vim 脚本不使用 "syntax on" 命令，设置 <a href="options.html#'background'">'background'</a> 选项或
者使用 "colorscheme" 命令，不然会导致死循环。

<code class="note">注意</code> 如果使用了色彩方案，可能会比较混淆: 到底使用的是你自己定义的颜色还是方案
里的颜色。这取决于色彩方案文件，见  <a href="syntax.html#:colorscheme">:colorscheme</a> 。

                                                        <b class="vimtag"> <a name="syntax_cmd">syntax_cmd</a> </b>
载入 syntax/syncolor.vim 文件时，"syntax_cmd" 变量设为以下这些值之一:
   "on"         `:syntax on` 命令。高亮颜色被覆盖，但是链接被保持
   "enable"     `:syntax enable` 命令。只为没有设置过高亮的组定义颜色。使用
                `:highlight default`。
   "reset"      `:syntax reset` 命令或者载入色彩方案。定义所有的颜色。
   "skip"       不定义颜色。用来跳过 <a href="options.html#'runtimepath'">'runtimepath'</a> 里较早出现的 syncolor.vim
                已经设置过的缺省设置。

</section><hr class="doubleline" /><section class=inner>
<h4>17. 高亮标签                                            <b class="vimtag"> <a name="tag-highlight">tag-highlight</a> </b></h4>
如果你想高亮文件里的所有标签，可以使用如下映射。

        <code class="special">&lt;F11&gt;</code>   -- 生成 tags.vim 文件，并高亮标签。
        <code class="special">&lt;F12&gt;</code>   -- 只根据已有的 tags.vim 文件高亮标签。

<code class="example">  :map &lt;F11&gt;  :sp tags&lt;CR&gt;:%s/^\([^     :]*:\)\=\([^    ]*\).*/syntax keyword Tag \2/&lt;CR&gt;:wq! tags.vim&lt;CR&gt;/^&lt;CR&gt;&lt;F12&gt;</code>
<code class="example">  :map &lt;F12&gt;  :so tags.vim&lt;CR&gt;</code>
<code class="example"></code>
警 告: 标签文件越长，这会越慢，而 Vim 消耗的内存也越多。

这里只高亮 typedef，也可以针对 union 和 struct 进行设置。为此，你需要
Universal Ctags (可在 <a href="https://ctags.io">https://ctags.io</a> 找到) 或 Exuberant ctags (可在
<a href="http://ctags.sf.net">http://ctags.sf.net</a> 找到)。

在你的 Makefile 里放入以下的行:

# 建立 types 的高亮文件。需要 Universal/Exuberant ctags 和 awk
types: types.vim
types.vim: *.[ch]
        ctags --c-kinds=gstu -o- *.[ch] |\
                awk 'BEGIN{printf("syntax keyword Type\t")}\
                        {printf("%s ", $$1)}END{print ""}' &gt; $@

在你的 .vimrc 里放入以下的行: 
<code class="example"></code>
<code class="example">   " 载入 types.vim 高亮文件，如果存在的话</code>
<code class="example">   autocmd BufRead,BufNewFile *.[ch] let fname = expand('&lt;afile&gt;:p:h') .. '/types.vim'</code>
<code class="example">   autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)</code>
<code class="example">   autocmd BufRead,BufNewFile *.[ch]   exe 'so ' .. fname</code>
<code class="example">   autocmd BufRead,BufNewFile *.[ch] endif</code>
<code class="example"></code>
</section><hr class="doubleline" /><section class=inner>
<h4>18. 窗口局部语法                                <b class="vimtag"> <a name=":ownsyntax">:ownsyntax</a> </b></h4>
通常，同一个缓冲区对应的所有窗口共用相同的语法设置。不过，可以为某个文件的某个
窗口设置单独的语法设置。一个可能的例子，在一个窗口中使用普通的高亮方式编辑
LaTeX 源代码，另一个窗口用不同的高亮方式访问相同的代码 (例如隐藏控制序列，实际
对文本加粗，加斜体等等)。<a href="options.html#'scrollbind'">'scrollbind'</a> 选项可用于此。

要使当前窗口使用语法 "foo"，而不影响缓冲区的其它窗口: 
<code class="example">   :ownsyntax foo</code>
                                                <b class="vimtag"> <a name="w:current_syntax">w:current_syntax</a> </b>
这样做，"w:current_syntax" 变量会设为 "foo"。"b:current_syntax" 的值不变。实际
上，这是通过保存和恢复 "b:current_syntax" 来实现的，因为语法文件会设置
"b:current_syntax"。但语法文件设置的值会被转赋到 "w:current_syntax" 上。
<code class="note">备注</code>: 这会复位 <a href="options.html#'spell'">'spell'</a>、<a href="options.html#'spellcapcheck'">'spellcapcheck'</a> 和 <a href="options.html#'spellfile'">'spellfile'</a> 选项。

一旦窗口有自己的语法，同一缓冲区其它窗口执行的语法命令 (包括 :syntax clear) 就
不会有效果。相反地，此窗口执行的语法命令对同一缓冲区其它窗口也没有效果。

带有自己语法的窗口当载入其它缓冲区或重载文件时，会恢复到正常行为。
分割窗口时，新窗口使用原有的语法。

</section><hr class="doubleline" /><section class=inner>
<h4>19. 彩色 xterm                                  <b class="vimtag"> <a name="xterm-color">xterm-color</a> </b> <b class="vimtag"> <a name="color-xterm">color-xterm</a> </b></h4>
多数彩色 xterm 只有八色。如果你得不到缺省设置的颜色，在 .vimrc 里使用这些行应
该就可以了: 
<code class="example">   :if &amp;term =~ "xterm"</code>
<code class="example">   :  if has("terminfo")</code>
<code class="example">   :    set t_Co=8</code>
<code class="example">   :    set t_Sf=&lt;Esc&gt;[3%p1%dm</code>
<code class="example">   :    set t_Sb=&lt;Esc&gt;[4%p1%dm</code>
<code class="example">   :  else</code>
<code class="example">   :    set t_Co=8</code>
<code class="example">   :    set t_Sf=&lt;Esc&gt;[3%dm</code>
<code class="example">   :    set t_Sb=&lt;Esc&gt;[4%dm</code>
<code class="example">   :  endif</code>
<code class="example">   :endif</code>
        [<code class="special">&lt;Esc&gt;</code> 是真正的 escape，输入 <code class="keystroke">CTRL-V</code> <code class="special">&lt;Esc&gt;</code>]

你可能需要修改第一个 "if" 来匹配你的终端的名字。比如，"dtterm" 取代 "xterm"。

<code class="note">注意</code>: 在 ":syntax on" 执行 <code class="emphasis">之前</code> 这些设置。否则颜色可能不正确。
                                                        <b class="vimtag"> <a name="xiterm">xiterm</a> </b> <b class="vimtag"> <a name="rxvt">rxvt</a> </b>

上面提到的设置也适用于 xiterm 和 rxvt。但要在 rxvt 里使用 16 色，可以使用
terminfo 并执行如下命令: 
<code class="example">        :set t_AB=&lt;Esc&gt;[%?%p1%{8}%&lt;%t25;%p1%{40}%+%e5;%p1%{32}%+%;%dm</code>
<code class="example">        :set t_AF=&lt;Esc&gt;[%?%p1%{8}%&lt;%t22;%p1%{30}%+%e1;%p1%{22}%+%;%dm</code>

                                                        <b class="vimtag"> <a name="colortest.vim">colortest.vim</a> </b>
要测试你的色彩设置，Vim 发布版本里包含了一个文件。要使用它，执行如下命令: 
<code class="example">   :runtime syntax/colortest.vim</code>
<code class="example"></code>
即使颜色数定义为 8，一些版本的 xterm (还有其他终端，比如 linux 控制台) 可以输
出更亮的前景色。因此如果 <a href="term.html#'t_Co'">'t_Co'</a> 为 8，Vim 为浅色的前景色设置 "cterm=bold" 属
性。

                                                        <b class="vimtag"> <a name="xfree-xterm">xfree-xterm</a> </b>
要得到 16 色或更多，需要最新的 xterm 版本 (应该包含在 Xfree86 3.3 或更新的版本
里)。你可以在这里得到最新的版本: 
<code class="example">        http://invisible-island.net/xterm/xterm.html</code>
下面是 configure 的好方法。它使用 88 色，并打开 termcap-query 特性。这使得 Vim
能够询问 xterm 可以支持多少颜色。 
<code class="example">        ./configure --disable-bold-color --enable-88-color --enable-tcap-query</code>
如果你只有 8 色，检查 xterm 的编译设置。
(另见  <a href="mbyte.html#UTF8-xterm">UTF8-xterm</a> ，了解如何在该 xterm 里使用 UTF-8 字符编码)。

在你的 .vimrc 放入以下几行，该 xterm 应该工作 (16 色): 
<code class="example">   :if has("terminfo")</code>
<code class="example">   :  set t_Co=16</code>
<code class="example">   :  set t_AB=&lt;Esc&gt;[%?%p1%{8}%&lt;%t%p1%{40}%+%e%p1%{92}%+%;%dm</code>
<code class="example">   :  set t_AF=&lt;Esc&gt;[%?%p1%{8}%&lt;%t%p1%{30}%+%e%p1%{82}%+%;%dm</code>
<code class="example">   :else</code>
<code class="example">   :  set t_Co=16</code>
<code class="example">   :  set t_Sf=&lt;Esc&gt;[3%dm</code>
<code class="example">   :  set t_Sb=&lt;Esc&gt;[4%dm</code>
<code class="example">   :endif</code>
        [<code class="special">&lt;Esc&gt;</code> 是真正的 escape，输入 <code class="keystroke">CTRL-V</code> <code class="special">&lt;Esc&gt;</code>]

没有  <a href="various.html#+terminfo">+terminfo</a>  的话，Vim 会识别这些设置，并自动把 cterm 的第 8 色或更高的颜
色翻译成 "<code class="special">&lt;Esc&gt;</code>[9%dm" 和 "<code class="special">&lt;Esc&gt;</code>[10%dm"。第 16 色以上也自动进行翻译。

有报告说这样可以用于 256 色: 
<code class="example"></code>
<code class="example">   :set t_AB=&lt;Esc&gt;[48;5;%dm</code>
<code class="example">   :set t_AF=&lt;Esc&gt;[38;5;%dm</code>
<code class="example"></code>
或者只设置 TERM 环境变量为 "xterm-color" 或 "xterm-16color"，然后试试行不行。

你也许想使用如下 X 资源 (在你的 ~/.Xdefaults 文件里):
        XTerm*color0:                   #000000
        XTerm*color1:                   #c00000
        XTerm*color2:                   #008000
        XTerm*color3:                   #808000
        XTerm*color4:                   #0000c0
        XTerm*color5:                   #c000c0
        XTerm*color6:                   #008080
        XTerm*color7:                   #c0c0c0
        XTerm*color8:                   #808080
        XTerm*color9:                   #ff6060
        XTerm*color10:                  #00ff00
        XTerm*color11:                  #ffff00
        XTerm*color12:                  #8080ff
        XTerm*color13:                  #ff40ff
        XTerm*color14:                  #00ffff
        XTerm*color15:                  #ffffff
        Xterm*cursorColor:              Black

[<code class="note">注意</code>: 需要 cursorColor 来绕过一个漏洞。该漏洞把光标颜色设为最后显示的文本的颜
色。在较新的版本里该问题被修正，但还不是所有人都使用新版本。]

要立刻使用，在 X 选项数据库管理器里重新载入 .Xdefaults 文件 (你只须在改变
.Xdefaults 文件的时候这么做就可以了): 
<code class="example">  xrdb -merge ~/.Xdefaults</code>

                                        <b class="vimtag"> <a name="xterm-blink">xterm-blink</a> </b> <b class="vimtag"> <a name="xterm-blinking-cursor">xterm-blinking-cursor</a> </b>
要使光标在 xterm 上闪烁，见 tools/blink.c。或者使用 Thomas Dickey 的 xterm 补
丁号 107 以上的版本 (取得的方法见上)，使用这些资源:
        XTerm*cursorBlink:      on
        XTerm*cursorOnTime:     400
        XTerm*cursorOffTime:    250
        XTerm*cursorColor:      White

                                                        <b class="vimtag"> <a name="hpterm-color">hpterm-color</a> </b>
下面的设置 (或多或少) 在 hpterm 里工作，它只支持 8 种前景色: 
<code class="example">   :if has("terminfo")</code>
<code class="example">   :  set t_Co=8</code>
<code class="example">   :  set t_Sf=&lt;Esc&gt;[&amp;v%p1%dS</code>
<code class="example">   :  set t_Sb=&lt;Esc&gt;[&amp;v7S</code>
<code class="example">   :else</code>
<code class="example">   :  set t_Co=8</code>
<code class="example">   :  set t_Sf=&lt;Esc&gt;[&amp;v%dS</code>
<code class="example">   :  set t_Sb=&lt;Esc&gt;[&amp;v7S</code>
<code class="example">   :endif</code>
        [<code class="special">&lt;Esc&gt;</code> 是真正的 escape，输入 <code class="keystroke">CTRL-V</code> <code class="special">&lt;Esc&gt;</code>]

                                                <b class="vimtag"> <a name="Eterm">Eterm</a> </b> <b class="vimtag"> <a name="enlightened-terminal">enlightened-terminal</a> </b>
有报告称下面的设置可以使得 Enlightened terminal emulator，或 Eterm，工作。它们
可能适用于所有的和 xterm 类似并使用 bold 属性来取得亮色的终端。有必要的话，增
加类似于上面那样的 ":if"。 
<code class="example">       :set t_Co=16</code>
<code class="example">       :set t_AF=^[[%?%p1%{8}%&lt;%t3%p1%d%e%p1%{22}%+%d;1%;m</code>
<code class="example">       :set t_AB=^[[%?%p1%{8}%&lt;%t4%p1%d%e%p1%{32}%+%d;1%;m</code>

                                                <b class="vimtag"> <a name="TTpro-telnet">TTpro-telnet</a> </b>
下面的设置应该适用于 TTpro telnet。Tera Term Pro 是 MS-Windows 上一个自由软件
/ 开源程序。 
<code class="example">        set t_Co=16</code>
<code class="example">        set t_AB=^[[%?%p1%{8}%&lt;%t%p1%{40}%+%e%p1%{32}%+5;%;%dm</code>
<code class="example">        set t_AF=^[[%?%p1%{8}%&lt;%t%p1%{30}%+%e%p1%{22}%+1;%;%dm</code>
要确信打开了 TTpro 的 Setup / Window / Full Color，并确信 <code class="emphasis">没有</code> 打开 Setup /
Font / Enable Bold。
(由 John Love-Jensen &lt;eljay@Adobe.COM&gt; 提供信息)


</section><hr class="doubleline" /><section class=inner>
<h4>20. 语 法 太 慢 了                                              <b class="vimtag"> <a name=":syntime">:syntime</a> </b></h4>
本节主要针对语法文件的作者。

如果语法导致重画变慢，有一些小窍门。打开一些通常会有干扰的特性，比如
<a href="options.html#'relativenumber'">'relativenumber'</a> 和  <a href="fold.html#folding">folding</a> ，会看到是否变慢。

<code class="note">注意</code>: 仅当编译时带  <a href="various.html#+profile">+profile</a>  特性才可用。可能需要编译 Vim 时带 "huge" 特性
包。

要知道哪些模式花了最多时间，下面的命令序列会给出概要: 
<code class="example">        :syntime on</code>
<code class="example">        [ 至少用 CTRL-L 重画文本一次 ]</code>
<code class="example">        :syntime report</code>
<code class="example"></code>
此时会显示使用到的语法模式的列表，按匹配文本使用的时间排序。

:syntime on             开始测量语法时间。会增加若干开销，用来计算语法模式匹配
                        的时间。

:syntime off            停止测量语法时间。

:syntime clear          把所有的计数清零，重新开始测量。

:syntime report         在当前窗口显示 ":syntime on" 开始使用的语法项目。使用
                        更宽的显示可以看到更多输出。

                        列表按总时间排序。显示以下诸列:
                        TOTAL           用于匹配本模式的总时间，按秒计。
                        COUNT           本模式使用的次数。
                        MATCH           本模式实际匹配的次数。
                        SLOWEST         单次匹配最长的时间。
                        AVERAGE         单次匹配平均时间。
                        NAME            语法项目名。<code class="note">注意</code> 这未必唯一。
                        PATTERN         使用的模式。

模式的匹配如果要尝试不同的分支时会变慢。尽量包括更多的直义文本，以减少模式 <code class="emphasis">不</code> 
匹配的可能性。

如果用 "\@&lt;=" 和 "\@&lt;!" 项目，加入最大范围来避免匹配本行和前行的所有可能位置。
例如，如要项目是直义文本，指明文本的长度 (以字节计):

"&lt;\@&lt;=span"     匹配 "&lt;span" 中的 "span"。会试图在很多位置匹配 "&lt;"。
"&lt;\@1&lt;=span"    相同匹配，但仅尝试 "span" 之前的一个字节。


 vim:tw=78:sw=4:ts=8:noet:ft=help:norl:
</section>
</article>
<footer>
Generated by vim2html
</footer>
</body>
</html>
